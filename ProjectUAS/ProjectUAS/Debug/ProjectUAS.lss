
ProjectUAS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000056f0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000120  00802000  000056f0  00005784  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003a7  00802120  00802120  000058a4  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000058a4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  00005900  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000008c0  00000000  00000000  00005948  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00018187  00000000  00000000  00006208  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006211  00000000  00000000  0001e38f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00007174  00000000  00000000  000245a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000025b4  00000000  00000000  0002b714  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000071b8  00000000  00000000  0002dcc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000d1ca  00000000  00000000  00034e80  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000af8  00000000  00000000  00042050  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	56 c2       	rjmp	.+1196   	; 0x4ae <__ctors_end>
       2:	00 00       	nop
       4:	75 c2       	rjmp	.+1258   	; 0x4f0 <__bad_interrupt>
       6:	00 00       	nop
       8:	73 c2       	rjmp	.+1254   	; 0x4f0 <__bad_interrupt>
       a:	00 00       	nop
       c:	71 c2       	rjmp	.+1250   	; 0x4f0 <__bad_interrupt>
       e:	00 00       	nop
      10:	6f c2       	rjmp	.+1246   	; 0x4f0 <__bad_interrupt>
      12:	00 00       	nop
      14:	6d c2       	rjmp	.+1242   	; 0x4f0 <__bad_interrupt>
      16:	00 00       	nop
      18:	6b c2       	rjmp	.+1238   	; 0x4f0 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	69 c2       	rjmp	.+1234   	; 0x4f0 <__bad_interrupt>
      1e:	00 00       	nop
      20:	67 c2       	rjmp	.+1230   	; 0x4f0 <__bad_interrupt>
      22:	00 00       	nop
      24:	65 c2       	rjmp	.+1226   	; 0x4f0 <__bad_interrupt>
      26:	00 00       	nop
      28:	63 c2       	rjmp	.+1222   	; 0x4f0 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	61 c2       	rjmp	.+1218   	; 0x4f0 <__bad_interrupt>
      2e:	00 00       	nop
      30:	5f c2       	rjmp	.+1214   	; 0x4f0 <__bad_interrupt>
      32:	00 00       	nop
      34:	5d c2       	rjmp	.+1210   	; 0x4f0 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 b1 13 	jmp	0x2762	; 0x2762 <__vector_14>
      3c:	0c 94 ea 08 	jmp	0x11d4	; 0x11d4 <__vector_15>
      40:	0c 94 17 09 	jmp	0x122e	; 0x122e <__vector_16>
      44:	0c 94 44 09 	jmp	0x1288	; 0x1288 <__vector_17>
      48:	0c 94 71 09 	jmp	0x12e2	; 0x12e2 <__vector_18>
      4c:	0c 94 9e 09 	jmp	0x133c	; 0x133c <__vector_19>
      50:	0c 94 cb 09 	jmp	0x1396	; 0x1396 <__vector_20>
      54:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__vector_21>
      58:	0c 94 25 0a 	jmp	0x144a	; 0x144a <__vector_22>
      5c:	0c 94 52 0a 	jmp	0x14a4	; 0x14a4 <__vector_23>
      60:	47 c2       	rjmp	.+1166   	; 0x4f0 <__bad_interrupt>
      62:	00 00       	nop
      64:	45 c2       	rjmp	.+1162   	; 0x4f0 <__bad_interrupt>
      66:	00 00       	nop
      68:	43 c2       	rjmp	.+1158   	; 0x4f0 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	41 c2       	rjmp	.+1154   	; 0x4f0 <__bad_interrupt>
      6e:	00 00       	nop
      70:	3f c2       	rjmp	.+1150   	; 0x4f0 <__bad_interrupt>
      72:	00 00       	nop
      74:	3d c2       	rjmp	.+1146   	; 0x4f0 <__bad_interrupt>
      76:	00 00       	nop
      78:	3b c2       	rjmp	.+1142   	; 0x4f0 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	39 c2       	rjmp	.+1138   	; 0x4f0 <__bad_interrupt>
      7e:	00 00       	nop
      80:	37 c2       	rjmp	.+1134   	; 0x4f0 <__bad_interrupt>
      82:	00 00       	nop
      84:	35 c2       	rjmp	.+1130   	; 0x4f0 <__bad_interrupt>
      86:	00 00       	nop
      88:	33 c2       	rjmp	.+1126   	; 0x4f0 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	31 c2       	rjmp	.+1122   	; 0x4f0 <__bad_interrupt>
      8e:	00 00       	nop
      90:	2f c2       	rjmp	.+1118   	; 0x4f0 <__bad_interrupt>
      92:	00 00       	nop
      94:	2d c2       	rjmp	.+1114   	; 0x4f0 <__bad_interrupt>
      96:	00 00       	nop
      98:	2b c2       	rjmp	.+1110   	; 0x4f0 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	9a c6       	rjmp	.+3380   	; 0xdd2 <__vector_39>
      9e:	00 00       	nop
      a0:	ca c6       	rjmp	.+3476   	; 0xe36 <__vector_40>
      a2:	00 00       	nop
      a4:	fa c6       	rjmp	.+3572   	; 0xe9a <__vector_41>
      a6:	00 00       	nop
      a8:	2a c7       	rjmp	.+3668   	; 0xefe <__vector_42>
      aa:	00 00       	nop
      ac:	21 c2       	rjmp	.+1090   	; 0x4f0 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	1f c2       	rjmp	.+1086   	; 0x4f0 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	1d c2       	rjmp	.+1082   	; 0x4f0 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	1b c2       	rjmp	.+1078   	; 0x4f0 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 41 0c 	jmp	0x1882	; 0x1882 <__vector_47>
      c0:	0c 94 6e 0c 	jmp	0x18dc	; 0x18dc <__vector_48>
      c4:	0c 94 9b 0c 	jmp	0x1936	; 0x1936 <__vector_49>
      c8:	0c 94 c8 0c 	jmp	0x1990	; 0x1990 <__vector_50>
      cc:	0c 94 f5 0c 	jmp	0x19ea	; 0x19ea <__vector_51>
      d0:	0c 94 22 0d 	jmp	0x1a44	; 0x1a44 <__vector_52>
      d4:	0c 94 4f 0d 	jmp	0x1a9e	; 0x1a9e <__vector_53>
      d8:	0c 94 7c 0d 	jmp	0x1af8	; 0x1af8 <__vector_54>
      dc:	0c 94 a9 0d 	jmp	0x1b52	; 0x1b52 <__vector_55>
      e0:	0c 94 d6 0d 	jmp	0x1bac	; 0x1bac <__vector_56>
      e4:	05 c2       	rjmp	.+1034   	; 0x4f0 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	03 c2       	rjmp	.+1030   	; 0x4f0 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	01 c2       	rjmp	.+1026   	; 0x4f0 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	ff c1       	rjmp	.+1022   	; 0x4f0 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	fd c1       	rjmp	.+1018   	; 0x4f0 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	fb c1       	rjmp	.+1014   	; 0x4f0 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f9 c1       	rjmp	.+1010   	; 0x4f0 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f7 c1       	rjmp	.+1006   	; 0x4f0 <__bad_interrupt>
     102:	00 00       	nop
     104:	f5 c1       	rjmp	.+1002   	; 0x4f0 <__bad_interrupt>
     106:	00 00       	nop
     108:	f3 c1       	rjmp	.+998    	; 0x4f0 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	f1 c1       	rjmp	.+994    	; 0x4f0 <__bad_interrupt>
     10e:	00 00       	nop
     110:	ef c1       	rjmp	.+990    	; 0x4f0 <__bad_interrupt>
     112:	00 00       	nop
     114:	ed c1       	rjmp	.+986    	; 0x4f0 <__bad_interrupt>
     116:	00 00       	nop
     118:	eb c1       	rjmp	.+982    	; 0x4f0 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	92 c5       	rjmp	.+2852   	; 0xc42 <__vector_71>
     11e:	00 00       	nop
     120:	c2 c5       	rjmp	.+2948   	; 0xca6 <__vector_72>
     122:	00 00       	nop
     124:	f2 c5       	rjmp	.+3044   	; 0xd0a <__vector_73>
     126:	00 00       	nop
     128:	22 c6       	rjmp	.+3140   	; 0xd6e <__vector_74>
     12a:	00 00       	nop
     12c:	e1 c1       	rjmp	.+962    	; 0x4f0 <__bad_interrupt>
     12e:	00 00       	nop
     130:	df c1       	rjmp	.+958    	; 0x4f0 <__bad_interrupt>
     132:	00 00       	nop
     134:	0c 94 7f 0a 	jmp	0x14fe	; 0x14fe <__vector_77>
     138:	0c 94 ac 0a 	jmp	0x1558	; 0x1558 <__vector_78>
     13c:	0c 94 d9 0a 	jmp	0x15b2	; 0x15b2 <__vector_79>
     140:	0c 94 06 0b 	jmp	0x160c	; 0x160c <__vector_80>
     144:	0c 94 33 0b 	jmp	0x1666	; 0x1666 <__vector_81>
     148:	0c 94 60 0b 	jmp	0x16c0	; 0x16c0 <__vector_82>
     14c:	0c 94 8d 0b 	jmp	0x171a	; 0x171a <__vector_83>
     150:	0c 94 ba 0b 	jmp	0x1774	; 0x1774 <__vector_84>
     154:	0c 94 e7 0b 	jmp	0x17ce	; 0x17ce <__vector_85>
     158:	0c 94 14 0c 	jmp	0x1828	; 0x1828 <__vector_86>
     15c:	c9 c1       	rjmp	.+914    	; 0x4f0 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c7 c1       	rjmp	.+910    	; 0x4f0 <__bad_interrupt>
     162:	00 00       	nop
     164:	c5 c1       	rjmp	.+906    	; 0x4f0 <__bad_interrupt>
     166:	00 00       	nop
     168:	c3 c1       	rjmp	.+902    	; 0x4f0 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	c1 c1       	rjmp	.+898    	; 0x4f0 <__bad_interrupt>
     16e:	00 00       	nop
     170:	bf c1       	rjmp	.+894    	; 0x4f0 <__bad_interrupt>
     172:	00 00       	nop
     174:	bd c1       	rjmp	.+890    	; 0x4f0 <__bad_interrupt>
     176:	00 00       	nop
     178:	bb c1       	rjmp	.+886    	; 0x4f0 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b9 c1       	rjmp	.+882    	; 0x4f0 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b7 c1       	rjmp	.+878    	; 0x4f0 <__bad_interrupt>
     182:	00 00       	nop
     184:	b5 c1       	rjmp	.+874    	; 0x4f0 <__bad_interrupt>
     186:	00 00       	nop
     188:	b3 c1       	rjmp	.+870    	; 0x4f0 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	b1 c1       	rjmp	.+866    	; 0x4f0 <__bad_interrupt>
     18e:	00 00       	nop
     190:	af c1       	rjmp	.+862    	; 0x4f0 <__bad_interrupt>
     192:	00 00       	nop
     194:	ad c1       	rjmp	.+858    	; 0x4f0 <__bad_interrupt>
     196:	00 00       	nop
     198:	ab c1       	rjmp	.+854    	; 0x4f0 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a9 c1       	rjmp	.+850    	; 0x4f0 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a7 c1       	rjmp	.+846    	; 0x4f0 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	a5 c1       	rjmp	.+842    	; 0x4f0 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	a3 c1       	rjmp	.+838    	; 0x4f0 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	a1 c1       	rjmp	.+834    	; 0x4f0 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	0c 94 03 0e 	jmp	0x1c06	; 0x1c06 <__vector_108>
     1b4:	0c 94 30 0e 	jmp	0x1c60	; 0x1c60 <__vector_109>
     1b8:	0c 94 5d 0e 	jmp	0x1cba	; 0x1cba <__vector_110>
     1bc:	0c 94 8a 0e 	jmp	0x1d14	; 0x1d14 <__vector_111>
     1c0:	0c 94 b7 0e 	jmp	0x1d6e	; 0x1d6e <__vector_112>
     1c4:	0c 94 e4 0e 	jmp	0x1dc8	; 0x1dc8 <__vector_113>
     1c8:	93 c1       	rjmp	.+806    	; 0x4f0 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	91 c1       	rjmp	.+802    	; 0x4f0 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	8f c1       	rjmp	.+798    	; 0x4f0 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	8d c1       	rjmp	.+794    	; 0x4f0 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	8b c1       	rjmp	.+790    	; 0x4f0 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	89 c1       	rjmp	.+786    	; 0x4f0 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	87 c1       	rjmp	.+782    	; 0x4f0 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	85 c1       	rjmp	.+778    	; 0x4f0 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	83 c1       	rjmp	.+774    	; 0x4f0 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	81 c1       	rjmp	.+770    	; 0x4f0 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	7f c1       	rjmp	.+766    	; 0x4f0 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	7d c1       	rjmp	.+762    	; 0x4f0 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	7b c1       	rjmp	.+758    	; 0x4f0 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	d1 1c       	adc	r13, r1
     1fe:	d1 1c       	adc	r13, r1
     200:	d1 1c       	adc	r13, r1
     202:	fe 1c       	adc	r15, r14
     204:	06 1d       	adc	r16, r6
     206:	14 1d       	adc	r17, r4
     208:	d1 1c       	adc	r13, r1
     20a:	d1 1c       	adc	r13, r1
     20c:	fe 1c       	adc	r15, r14
     20e:	06 1d       	adc	r16, r6

00000210 <__trampolines_end>:
     210:	63 64       	ori	r22, 0x43	; 67
     212:	69 6e       	ori	r22, 0xE9	; 233
     214:	6f 70       	andi	r22, 0x0F	; 15
     216:	73 75       	andi	r23, 0x53	; 83
     218:	78 58       	subi	r23, 0x88	; 136
     21a:	5b 00       	.word	0x005b	; ????

0000021c <sysfont_glyphs>:
     21c:	00 00 00 00 00 00 00 20 20 20 20 20 00 20 50 50     .......     . PP
     22c:	50 00 00 00 00 50 50 f8 50 f8 50 50 20 78 a0 70     P....PP.P.PP x.p
     23c:	28 f0 20 c0 c8 10 20 40 98 18 60 90 a0 40 a8 90     (. ... @..`..@..
     24c:	68 60 20 40 00 00 00 00 10 20 40 40 40 20 10 40     h` @..... @@@ .@
     25c:	20 10 10 10 20 40 00 50 20 f8 20 50 00 00 20 20      ... @.P . P..  
     26c:	f8 20 20 00 00 00 00 00 60 20 40 00 00 00 f8 00     .  .....` @.....
     27c:	00 00 00 00 00 00 00 60 60 00 08 10 20 40 80 00     .......``... @..
     28c:	70 88 98 a8 c8 88 70 20 60 20 20 20 20 70 70 88     p.....p `    pp.
     29c:	08 10 20 40 f8 f8 10 20 10 08 88 70 10 30 50 90     .. @... ...p.0P.
     2ac:	f8 10 10 f8 80 f0 08 08 88 70 30 40 80 f0 88 88     .........p0@....
     2bc:	70 f8 08 10 20 40 40 40 70 88 88 70 88 88 70 70     p... @@@p..p..pp
     2cc:	88 88 78 08 10 60 00 60 60 00 60 60 00 00 60 60     ..x..`.``.``..``
     2dc:	00 60 20 40 08 10 20 40 20 10 08 00 00 f8 00 f8     .` @.. @ .......
     2ec:	00 00 80 40 20 10 20 40 80 70 88 08 10 20 00 20     ...@ . @.p... . 
     2fc:	70 88 08 68 a8 a8 70 70 88 88 88 f8 88 88 f0 88     p..h..pp........
     30c:	88 f0 88 88 f0 70 88 80 80 80 88 70 e0 90 88 88     .....p.....p....
     31c:	88 90 e0 f8 80 80 f0 80 80 f8 f8 80 80 e0 80 80     ................
     32c:	80 70 88 80 80 98 88 70 88 88 88 f8 88 88 88 70     .p.....p.......p
     33c:	20 20 20 20 20 70 38 10 10 10 10 90 60 88 90 a0          p8.....`...
     34c:	c0 a0 90 88 80 80 80 80 80 80 f8 88 d8 a8 88 88     ................
     35c:	88 88 88 88 c8 a8 98 88 88 70 88 88 88 88 88 70     .........p.....p
     36c:	f0 88 88 f0 80 80 80 70 88 88 88 a8 90 68 f0 88     .......p.....h..
     37c:	88 f0 a0 90 88 78 80 80 70 08 08 f0 f8 20 20 20     .....x..p....   
     38c:	20 20 20 88 88 88 88 88 88 70 88 88 88 88 88 50        ......p.....P
     39c:	20 88 88 88 a8 a8 d8 88 88 88 50 20 50 88 88 88      .........P P...
     3ac:	88 50 20 20 20 20 f8 08 10 20 40 80 f8 38 20 20     .P    ... @..8  
     3bc:	20 20 20 38 00 80 40 20 10 08 00 e0 20 20 20 20        8..@ ....    
     3cc:	20 e0 20 50 88 00 00 00 00 00 00 00 00 00 00 f8      . P............
     3dc:	40 20 10 00 00 00 00 00 00 70 08 78 88 78 80 80     @ .......p.x.x..
     3ec:	b0 c8 88 88 f0 00 00 70 80 80 88 70 08 08 68 98     .......p...p..h.
     3fc:	88 88 78 00 00 70 88 f8 80 70 30 48 40 e0 40 40     ..x..p...p0H@.@@
     40c:	40 00 00 78 88 78 08 30 80 80 b0 c8 88 88 88 20     @..x.x.0....... 
     41c:	00 60 20 20 20 70 10 00 30 10 10 90 60 40 40 48     .`   p..0...`@@H
     42c:	50 60 50 48 60 20 20 20 20 20 70 00 00 d0 a8 a8     P`PH`     p.....
     43c:	88 88 00 00 b0 c8 88 88 88 00 00 70 88 88 88 70     ...........p...p
     44c:	00 00 f0 88 f0 80 80 00 00 68 98 78 08 08 00 00     .........h.x....
     45c:	b0 c8 80 80 80 00 00 70 80 70 08 f0 40 40 e0 40     .......p.p..@@.@
     46c:	40 48 30 00 00 88 88 88 98 68 00 00 88 88 88 50     @H0......h.....P
     47c:	20 00 00 88 88 a8 a8 50 00 00 88 50 20 50 88 00      ......P...P P..
     48c:	00 88 88 78 08 70 00 00 f8 10 20 40 f8 10 20 20     ...x.p.... @..  
     49c:	40 20 20 10 20 20 20 20 20 20 20 40 20 20 10 20     @  .       @  . 
     4ac:	20 40                                                @

000004ae <__ctors_end>:
     4ae:	11 24       	eor	r1, r1
     4b0:	1f be       	out	0x3f, r1	; 63
     4b2:	cf ef       	ldi	r28, 0xFF	; 255
     4b4:	cd bf       	out	0x3d, r28	; 61
     4b6:	df e5       	ldi	r29, 0x5F	; 95
     4b8:	de bf       	out	0x3e, r29	; 62
     4ba:	00 e0       	ldi	r16, 0x00	; 0
     4bc:	0c bf       	out	0x3c, r16	; 60

000004be <__do_copy_data>:
     4be:	11 e2       	ldi	r17, 0x21	; 33
     4c0:	a0 e0       	ldi	r26, 0x00	; 0
     4c2:	b0 e2       	ldi	r27, 0x20	; 32
     4c4:	e0 ef       	ldi	r30, 0xF0	; 240
     4c6:	f6 e5       	ldi	r31, 0x56	; 86
     4c8:	00 e0       	ldi	r16, 0x00	; 0
     4ca:	0b bf       	out	0x3b, r16	; 59
     4cc:	02 c0       	rjmp	.+4      	; 0x4d2 <__do_copy_data+0x14>
     4ce:	07 90       	elpm	r0, Z+
     4d0:	0d 92       	st	X+, r0
     4d2:	a0 32       	cpi	r26, 0x20	; 32
     4d4:	b1 07       	cpc	r27, r17
     4d6:	d9 f7       	brne	.-10     	; 0x4ce <__do_copy_data+0x10>

000004d8 <__do_clear_bss>:
     4d8:	24 e2       	ldi	r18, 0x24	; 36
     4da:	a0 e2       	ldi	r26, 0x20	; 32
     4dc:	b1 e2       	ldi	r27, 0x21	; 33
     4de:	01 c0       	rjmp	.+2      	; 0x4e2 <.do_clear_bss_start>

000004e0 <.do_clear_bss_loop>:
     4e0:	1d 92       	st	X+, r1

000004e2 <.do_clear_bss_start>:
     4e2:	a7 3c       	cpi	r26, 0xC7	; 199
     4e4:	b2 07       	cpc	r27, r18
     4e6:	e1 f7       	brne	.-8      	; 0x4e0 <.do_clear_bss_loop>
     4e8:	0e 94 30 23 	call	0x4660	; 0x4660 <main>
     4ec:	0c 94 76 2b 	jmp	0x56ec	; 0x56ec <_exit>

000004f0 <__bad_interrupt>:
     4f0:	87 cd       	rjmp	.-1266   	; 0x0 <__vectors>

000004f2 <__portable_avr_delay_cycles>:
 *
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
     4f2:	04 c0       	rjmp	.+8      	; 0x4fc <__portable_avr_delay_cycles+0xa>
	while (n) {
		barrier();
		n--;
     4f4:	61 50       	subi	r22, 0x01	; 1
     4f6:	71 09       	sbc	r23, r1
     4f8:	81 09       	sbc	r24, r1
     4fa:	91 09       	sbc	r25, r1
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	while (n) {
     4fc:	61 15       	cp	r22, r1
     4fe:	71 05       	cpc	r23, r1
     500:	81 05       	cpc	r24, r1
     502:	91 05       	cpc	r25, r1
     504:	b9 f7       	brne	.-18     	; 0x4f4 <__portable_avr_delay_cycles+0x2>
     506:	08 95       	ret

00000508 <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     508:	bf 92       	push	r11
     50a:	cf 92       	push	r12
     50c:	df 92       	push	r13
     50e:	ef 92       	push	r14
     510:	ff 92       	push	r15
     512:	0f 93       	push	r16
     514:	1f 93       	push	r17
     516:	cf 93       	push	r28
     518:	df 93       	push	r29
     51a:	1f 92       	push	r1
     51c:	cd b7       	in	r28, 0x3d	; 61
     51e:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     520:	00 e0       	ldi	r16, 0x00	; 0
     522:	16 e0       	ldi	r17, 0x06	; 6
     524:	68 94       	set
     526:	ff 24       	eor	r15, r15
     528:	f3 f8       	bld	r15, 3
     52a:	f8 01       	movw	r30, r16
     52c:	f6 82       	std	Z+6, r15	; 0x06
 * function, this command will control the RST pin.
 */
static inline void st7565r_hard_reset(void)
{
	ioport_set_pin_low(ST7565R_RESET_PIN);
	delay_us(10);
     52e:	64 e0       	ldi	r22, 0x04	; 4
     530:	70 e0       	ldi	r23, 0x00	; 0
     532:	80 e0       	ldi	r24, 0x00	; 0
     534:	90 e0       	ldi	r25, 0x00	; 0
     536:	dd df       	rcall	.-70     	; 0x4f2 <__portable_avr_delay_cycles>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     538:	f8 01       	movw	r30, r16
     53a:	f5 82       	std	Z+5, r15	; 0x05
	ioport_set_pin_high(ST7565R_RESET_PIN);
	delay_us(10);
     53c:	64 e0       	ldi	r22, 0x04	; 4
     53e:	70 e0       	ldi	r23, 0x00	; 0
     540:	80 e0       	ldi	r24, 0x00	; 0
     542:	90 e0       	ldi	r25, 0x00	; 0
     544:	d6 df       	rcall	.-84     	; 0x4f2 <__portable_avr_delay_cycles>
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     546:	0f 2e       	mov	r0, r31
     548:	fb e2       	ldi	r31, 0x2B	; 43
     54a:	bf 2e       	mov	r11, r31
     54c:	f0 2d       	mov	r31, r0
     54e:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     550:	80 ea       	ldi	r24, 0xA0	; 160
     552:	99 e0       	ldi	r25, 0x09	; 9
     554:	0e 94 3e 1d 	call	0x3a7c	; 0x3a7c <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     558:	c1 2c       	mov	r12, r1
     55a:	d1 2c       	mov	r13, r1
     55c:	76 01       	movw	r14, r12
     55e:	00 e4       	ldi	r16, 0x40	; 64
     560:	12 e4       	ldi	r17, 0x42	; 66
     562:	2f e0       	ldi	r18, 0x0F	; 15
     564:	30 e0       	ldi	r19, 0x00	; 0
     566:	43 e0       	ldi	r20, 0x03	; 3
     568:	be 01       	movw	r22, r28
     56a:	6f 5f       	subi	r22, 0xFF	; 255
     56c:	7f 4f       	sbci	r23, 0xFF	; 255
     56e:	80 ea       	ldi	r24, 0xA0	; 160
     570:	99 e0       	ldi	r25, 0x09	; 9
     572:	0e 94 6d 1d 	call	0x3ada	; 0x3ada <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     576:	00 e6       	ldi	r16, 0x60	; 96
     578:	16 e0       	ldi	r17, 0x06	; 6
     57a:	ff 24       	eor	r15, r15
     57c:	f3 94       	inc	r15
     57e:	f8 01       	movw	r30, r16
     580:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     582:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     584:	be 01       	movw	r22, r28
     586:	6f 5f       	subi	r22, 0xFF	; 255
     588:	7f 4f       	sbci	r23, 0xFF	; 255
     58a:	80 ea       	ldi	r24, 0xA0	; 160
     58c:	99 e0       	ldi	r25, 0x09	; 9
     58e:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     592:	f8 01       	movw	r30, r16
     594:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     596:	e0 ea       	ldi	r30, 0xA0	; 160
     598:	f9 e0       	ldi	r31, 0x09	; 9
     59a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     59c:	85 ff       	sbrs	r24, 5
     59e:	fd cf       	rjmp	.-6      	; 0x59a <st7565r_init+0x92>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5a0:	80 ea       	ldi	r24, 0xA0	; 160
     5a2:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5a6:	e0 ea       	ldi	r30, 0xA0	; 160
     5a8:	f9 e0       	ldi	r31, 0x09	; 9
     5aa:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5ac:	86 ff       	sbrs	r24, 6
     5ae:	fd cf       	rjmp	.-6      	; 0x5aa <st7565r_init+0xa2>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5b0:	e0 ea       	ldi	r30, 0xA0	; 160
     5b2:	f9 e0       	ldi	r31, 0x09	; 9
     5b4:	80 e4       	ldi	r24, 0x40	; 64
     5b6:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5b8:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5ba:	be 01       	movw	r22, r28
     5bc:	6f 5f       	subi	r22, 0xFF	; 255
     5be:	7f 4f       	sbci	r23, 0xFF	; 255
     5c0:	80 ea       	ldi	r24, 0xA0	; 160
     5c2:	99 e0       	ldi	r25, 0x09	; 9
     5c4:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5c8:	8b e2       	ldi	r24, 0x2B	; 43
     5ca:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5cc:	be 01       	movw	r22, r28
     5ce:	6f 5f       	subi	r22, 0xFF	; 255
     5d0:	7f 4f       	sbci	r23, 0xFF	; 255
     5d2:	80 ea       	ldi	r24, 0xA0	; 160
     5d4:	99 e0       	ldi	r25, 0x09	; 9
     5d6:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     5da:	81 e0       	ldi	r24, 0x01	; 1
     5dc:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     5e0:	e0 ea       	ldi	r30, 0xA0	; 160
     5e2:	f9 e0       	ldi	r31, 0x09	; 9
     5e4:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5e6:	85 ff       	sbrs	r24, 5
     5e8:	fd cf       	rjmp	.-6      	; 0x5e4 <st7565r_init+0xdc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5ea:	86 ea       	ldi	r24, 0xA6	; 166
     5ec:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5f0:	e0 ea       	ldi	r30, 0xA0	; 160
     5f2:	f9 e0       	ldi	r31, 0x09	; 9
     5f4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5f6:	86 ff       	sbrs	r24, 6
     5f8:	fd cf       	rjmp	.-6      	; 0x5f4 <st7565r_init+0xec>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5fa:	e0 ea       	ldi	r30, 0xA0	; 160
     5fc:	f9 e0       	ldi	r31, 0x09	; 9
     5fe:	80 e4       	ldi	r24, 0x40	; 64
     600:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     602:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     604:	be 01       	movw	r22, r28
     606:	6f 5f       	subi	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	80 ea       	ldi	r24, 0xA0	; 160
     60c:	99 e0       	ldi	r25, 0x09	; 9
     60e:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     612:	8b e2       	ldi	r24, 0x2B	; 43
     614:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     616:	be 01       	movw	r22, r28
     618:	6f 5f       	subi	r22, 0xFF	; 255
     61a:	7f 4f       	sbci	r23, 0xFF	; 255
     61c:	80 ea       	ldi	r24, 0xA0	; 160
     61e:	99 e0       	ldi	r25, 0x09	; 9
     620:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     624:	81 e0       	ldi	r24, 0x01	; 1
     626:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     62a:	e0 ea       	ldi	r30, 0xA0	; 160
     62c:	f9 e0       	ldi	r31, 0x09	; 9
     62e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     630:	85 ff       	sbrs	r24, 5
     632:	fd cf       	rjmp	.-6      	; 0x62e <st7565r_init+0x126>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     634:	88 ec       	ldi	r24, 0xC8	; 200
     636:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     63a:	e0 ea       	ldi	r30, 0xA0	; 160
     63c:	f9 e0       	ldi	r31, 0x09	; 9
     63e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     640:	86 ff       	sbrs	r24, 6
     642:	fd cf       	rjmp	.-6      	; 0x63e <st7565r_init+0x136>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     644:	e0 ea       	ldi	r30, 0xA0	; 160
     646:	f9 e0       	ldi	r31, 0x09	; 9
     648:	80 e4       	ldi	r24, 0x40	; 64
     64a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     64c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     64e:	be 01       	movw	r22, r28
     650:	6f 5f       	subi	r22, 0xFF	; 255
     652:	7f 4f       	sbci	r23, 0xFF	; 255
     654:	80 ea       	ldi	r24, 0xA0	; 160
     656:	99 e0       	ldi	r25, 0x09	; 9
     658:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     65c:	8b e2       	ldi	r24, 0x2B	; 43
     65e:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     660:	be 01       	movw	r22, r28
     662:	6f 5f       	subi	r22, 0xFF	; 255
     664:	7f 4f       	sbci	r23, 0xFF	; 255
     666:	80 ea       	ldi	r24, 0xA0	; 160
     668:	99 e0       	ldi	r25, 0x09	; 9
     66a:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     66e:	81 e0       	ldi	r24, 0x01	; 1
     670:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     674:	e0 ea       	ldi	r30, 0xA0	; 160
     676:	f9 e0       	ldi	r31, 0x09	; 9
     678:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     67a:	85 ff       	sbrs	r24, 5
     67c:	fd cf       	rjmp	.-6      	; 0x678 <st7565r_init+0x170>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     67e:	82 ea       	ldi	r24, 0xA2	; 162
     680:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     684:	e0 ea       	ldi	r30, 0xA0	; 160
     686:	f9 e0       	ldi	r31, 0x09	; 9
     688:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     68a:	86 ff       	sbrs	r24, 6
     68c:	fd cf       	rjmp	.-6      	; 0x688 <st7565r_init+0x180>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     68e:	e0 ea       	ldi	r30, 0xA0	; 160
     690:	f9 e0       	ldi	r31, 0x09	; 9
     692:	80 e4       	ldi	r24, 0x40	; 64
     694:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     696:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     698:	be 01       	movw	r22, r28
     69a:	6f 5f       	subi	r22, 0xFF	; 255
     69c:	7f 4f       	sbci	r23, 0xFF	; 255
     69e:	80 ea       	ldi	r24, 0xA0	; 160
     6a0:	99 e0       	ldi	r25, 0x09	; 9
     6a2:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6a6:	8b e2       	ldi	r24, 0x2B	; 43
     6a8:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6aa:	be 01       	movw	r22, r28
     6ac:	6f 5f       	subi	r22, 0xFF	; 255
     6ae:	7f 4f       	sbci	r23, 0xFF	; 255
     6b0:	80 ea       	ldi	r24, 0xA0	; 160
     6b2:	99 e0       	ldi	r25, 0x09	; 9
     6b4:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     6b8:	81 e0       	ldi	r24, 0x01	; 1
     6ba:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6be:	e0 ea       	ldi	r30, 0xA0	; 160
     6c0:	f9 e0       	ldi	r31, 0x09	; 9
     6c2:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6c4:	85 ff       	sbrs	r24, 5
     6c6:	fd cf       	rjmp	.-6      	; 0x6c2 <st7565r_init+0x1ba>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6c8:	8f e2       	ldi	r24, 0x2F	; 47
     6ca:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6ce:	e0 ea       	ldi	r30, 0xA0	; 160
     6d0:	f9 e0       	ldi	r31, 0x09	; 9
     6d2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6d4:	86 ff       	sbrs	r24, 6
     6d6:	fd cf       	rjmp	.-6      	; 0x6d2 <st7565r_init+0x1ca>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6d8:	e0 ea       	ldi	r30, 0xA0	; 160
     6da:	f9 e0       	ldi	r31, 0x09	; 9
     6dc:	80 e4       	ldi	r24, 0x40	; 64
     6de:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6e0:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6e2:	be 01       	movw	r22, r28
     6e4:	6f 5f       	subi	r22, 0xFF	; 255
     6e6:	7f 4f       	sbci	r23, 0xFF	; 255
     6e8:	80 ea       	ldi	r24, 0xA0	; 160
     6ea:	99 e0       	ldi	r25, 0x09	; 9
     6ec:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6f0:	8b e2       	ldi	r24, 0x2B	; 43
     6f2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6f4:	be 01       	movw	r22, r28
     6f6:	6f 5f       	subi	r22, 0xFF	; 255
     6f8:	7f 4f       	sbci	r23, 0xFF	; 255
     6fa:	80 ea       	ldi	r24, 0xA0	; 160
     6fc:	99 e0       	ldi	r25, 0x09	; 9
     6fe:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     702:	81 e0       	ldi	r24, 0x01	; 1
     704:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     708:	e0 ea       	ldi	r30, 0xA0	; 160
     70a:	f9 e0       	ldi	r31, 0x09	; 9
     70c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     70e:	85 ff       	sbrs	r24, 5
     710:	fd cf       	rjmp	.-6      	; 0x70c <st7565r_init+0x204>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     712:	88 ef       	ldi	r24, 0xF8	; 248
     714:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     718:	e0 ea       	ldi	r30, 0xA0	; 160
     71a:	f9 e0       	ldi	r31, 0x09	; 9
     71c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     71e:	86 ff       	sbrs	r24, 6
     720:	fd cf       	rjmp	.-6      	; 0x71c <st7565r_init+0x214>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     722:	e0 ea       	ldi	r30, 0xA0	; 160
     724:	f9 e0       	ldi	r31, 0x09	; 9
     726:	80 e4       	ldi	r24, 0x40	; 64
     728:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     72a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     72c:	be 01       	movw	r22, r28
     72e:	6f 5f       	subi	r22, 0xFF	; 255
     730:	7f 4f       	sbci	r23, 0xFF	; 255
     732:	80 ea       	ldi	r24, 0xA0	; 160
     734:	99 e0       	ldi	r25, 0x09	; 9
     736:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     73a:	8b e2       	ldi	r24, 0x2B	; 43
     73c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     73e:	be 01       	movw	r22, r28
     740:	6f 5f       	subi	r22, 0xFF	; 255
     742:	7f 4f       	sbci	r23, 0xFF	; 255
     744:	80 ea       	ldi	r24, 0xA0	; 160
     746:	99 e0       	ldi	r25, 0x09	; 9
     748:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     74c:	81 e0       	ldi	r24, 0x01	; 1
     74e:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     752:	e0 ea       	ldi	r30, 0xA0	; 160
     754:	f9 e0       	ldi	r31, 0x09	; 9
     756:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     758:	85 ff       	sbrs	r24, 5
     75a:	fd cf       	rjmp	.-6      	; 0x756 <st7565r_init+0x24e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     75c:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     760:	e0 ea       	ldi	r30, 0xA0	; 160
     762:	f9 e0       	ldi	r31, 0x09	; 9
     764:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     766:	86 ff       	sbrs	r24, 6
     768:	fd cf       	rjmp	.-6      	; 0x764 <st7565r_init+0x25c>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     76a:	e0 ea       	ldi	r30, 0xA0	; 160
     76c:	f9 e0       	ldi	r31, 0x09	; 9
     76e:	80 e4       	ldi	r24, 0x40	; 64
     770:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     772:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     774:	be 01       	movw	r22, r28
     776:	6f 5f       	subi	r22, 0xFF	; 255
     778:	7f 4f       	sbci	r23, 0xFF	; 255
     77a:	80 ea       	ldi	r24, 0xA0	; 160
     77c:	99 e0       	ldi	r25, 0x09	; 9
     77e:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     782:	8b e2       	ldi	r24, 0x2B	; 43
     784:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     786:	be 01       	movw	r22, r28
     788:	6f 5f       	subi	r22, 0xFF	; 255
     78a:	7f 4f       	sbci	r23, 0xFF	; 255
     78c:	80 ea       	ldi	r24, 0xA0	; 160
     78e:	99 e0       	ldi	r25, 0x09	; 9
     790:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     794:	81 e0       	ldi	r24, 0x01	; 1
     796:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     79a:	e0 ea       	ldi	r30, 0xA0	; 160
     79c:	f9 e0       	ldi	r31, 0x09	; 9
     79e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7a0:	85 ff       	sbrs	r24, 5
     7a2:	fd cf       	rjmp	.-6      	; 0x79e <st7565r_init+0x296>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7a4:	81 e2       	ldi	r24, 0x21	; 33
     7a6:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7aa:	e0 ea       	ldi	r30, 0xA0	; 160
     7ac:	f9 e0       	ldi	r31, 0x09	; 9
     7ae:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7b0:	86 ff       	sbrs	r24, 6
     7b2:	fd cf       	rjmp	.-6      	; 0x7ae <st7565r_init+0x2a6>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7b4:	e0 ea       	ldi	r30, 0xA0	; 160
     7b6:	f9 e0       	ldi	r31, 0x09	; 9
     7b8:	80 e4       	ldi	r24, 0x40	; 64
     7ba:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7bc:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7be:	be 01       	movw	r22, r28
     7c0:	6f 5f       	subi	r22, 0xFF	; 255
     7c2:	7f 4f       	sbci	r23, 0xFF	; 255
     7c4:	80 ea       	ldi	r24, 0xA0	; 160
     7c6:	99 e0       	ldi	r25, 0x09	; 9
     7c8:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7cc:	8b e2       	ldi	r24, 0x2B	; 43
     7ce:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7d0:	be 01       	movw	r22, r28
     7d2:	6f 5f       	subi	r22, 0xFF	; 255
     7d4:	7f 4f       	sbci	r23, 0xFF	; 255
     7d6:	80 ea       	ldi	r24, 0xA0	; 160
     7d8:	99 e0       	ldi	r25, 0x09	; 9
     7da:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     7de:	81 e0       	ldi	r24, 0x01	; 1
     7e0:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7e4:	e0 ea       	ldi	r30, 0xA0	; 160
     7e6:	f9 e0       	ldi	r31, 0x09	; 9
     7e8:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7ea:	85 ff       	sbrs	r24, 5
     7ec:	fd cf       	rjmp	.-6      	; 0x7e8 <st7565r_init+0x2e0>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7ee:	81 e8       	ldi	r24, 0x81	; 129
     7f0:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7f4:	e0 ea       	ldi	r30, 0xA0	; 160
     7f6:	f9 e0       	ldi	r31, 0x09	; 9
     7f8:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7fa:	86 ff       	sbrs	r24, 6
     7fc:	fd cf       	rjmp	.-6      	; 0x7f8 <st7565r_init+0x2f0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7fe:	e0 ea       	ldi	r30, 0xA0	; 160
     800:	f9 e0       	ldi	r31, 0x09	; 9
     802:	80 e4       	ldi	r24, 0x40	; 64
     804:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     806:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     808:	be 01       	movw	r22, r28
     80a:	6f 5f       	subi	r22, 0xFF	; 255
     80c:	7f 4f       	sbci	r23, 0xFF	; 255
     80e:	80 ea       	ldi	r24, 0xA0	; 160
     810:	99 e0       	ldi	r25, 0x09	; 9
     812:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     816:	8b e2       	ldi	r24, 0x2B	; 43
     818:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     81a:	be 01       	movw	r22, r28
     81c:	6f 5f       	subi	r22, 0xFF	; 255
     81e:	7f 4f       	sbci	r23, 0xFF	; 255
     820:	80 ea       	ldi	r24, 0xA0	; 160
     822:	99 e0       	ldi	r25, 0x09	; 9
     824:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     828:	81 e0       	ldi	r24, 0x01	; 1
     82a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     82e:	e0 ea       	ldi	r30, 0xA0	; 160
     830:	f9 e0       	ldi	r31, 0x09	; 9
     832:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     834:	85 ff       	sbrs	r24, 5
     836:	fd cf       	rjmp	.-6      	; 0x832 <st7565r_init+0x32a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     838:	81 e2       	ldi	r24, 0x21	; 33
     83a:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     83e:	e0 ea       	ldi	r30, 0xA0	; 160
     840:	f9 e0       	ldi	r31, 0x09	; 9
     842:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     844:	86 ff       	sbrs	r24, 6
     846:	fd cf       	rjmp	.-6      	; 0x842 <st7565r_init+0x33a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     848:	e0 ea       	ldi	r30, 0xA0	; 160
     84a:	f9 e0       	ldi	r31, 0x09	; 9
     84c:	80 e4       	ldi	r24, 0x40	; 64
     84e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     850:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     852:	be 01       	movw	r22, r28
     854:	6f 5f       	subi	r22, 0xFF	; 255
     856:	7f 4f       	sbci	r23, 0xFF	; 255
     858:	80 ea       	ldi	r24, 0xA0	; 160
     85a:	99 e0       	ldi	r25, 0x09	; 9
     85c:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     860:	8b e2       	ldi	r24, 0x2B	; 43
     862:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     864:	be 01       	movw	r22, r28
     866:	6f 5f       	subi	r22, 0xFF	; 255
     868:	7f 4f       	sbci	r23, 0xFF	; 255
     86a:	80 ea       	ldi	r24, 0xA0	; 160
     86c:	99 e0       	ldi	r25, 0x09	; 9
     86e:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     872:	81 e0       	ldi	r24, 0x01	; 1
     874:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     878:	e0 ea       	ldi	r30, 0xA0	; 160
     87a:	f9 e0       	ldi	r31, 0x09	; 9
     87c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     87e:	85 ff       	sbrs	r24, 5
     880:	fd cf       	rjmp	.-6      	; 0x87c <st7565r_init+0x374>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     882:	8f ea       	ldi	r24, 0xAF	; 175
     884:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     888:	e0 ea       	ldi	r30, 0xA0	; 160
     88a:	f9 e0       	ldi	r31, 0x09	; 9
     88c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     88e:	86 ff       	sbrs	r24, 6
     890:	fd cf       	rjmp	.-6      	; 0x88c <st7565r_init+0x384>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     892:	e0 ea       	ldi	r30, 0xA0	; 160
     894:	f9 e0       	ldi	r31, 0x09	; 9
     896:	80 e4       	ldi	r24, 0x40	; 64
     898:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     89a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     89c:	be 01       	movw	r22, r28
     89e:	6f 5f       	subi	r22, 0xFF	; 255
     8a0:	7f 4f       	sbci	r23, 0xFF	; 255
     8a2:	80 ea       	ldi	r24, 0xA0	; 160
     8a4:	99 e0       	ldi	r25, 0x09	; 9
     8a6:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     8aa:	0f 90       	pop	r0
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	1f 91       	pop	r17
     8b2:	0f 91       	pop	r16
     8b4:	ff 90       	pop	r15
     8b6:	ef 90       	pop	r14
     8b8:	df 90       	pop	r13
     8ba:	cf 90       	pop	r12
     8bc:	bf 90       	pop	r11
     8be:	08 95       	ret

000008c0 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     8c0:	ff 92       	push	r15
     8c2:	0f 93       	push	r16
     8c4:	1f 93       	push	r17
     8c6:	cf 93       	push	r28
     8c8:	df 93       	push	r29
     8ca:	1f 92       	push	r1
     8cc:	cd b7       	in	r28, 0x3d	; 61
     8ce:	de b7       	in	r29, 0x3e	; 62
     8d0:	08 2f       	mov	r16, r24
     8d2:	f6 2e       	mov	r15, r22
     8d4:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     8d6:	0e 94 b9 1d 	call	0x3b72	; 0x3b72 <gfx_mono_framebuffer_put_byte>
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     8da:	0f 70       	andi	r16, 0x0F	; 15
     8dc:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     8de:	8b e2       	ldi	r24, 0x2B	; 43
     8e0:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8e2:	be 01       	movw	r22, r28
     8e4:	6f 5f       	subi	r22, 0xFF	; 255
     8e6:	7f 4f       	sbci	r23, 0xFF	; 255
     8e8:	80 ea       	ldi	r24, 0xA0	; 160
     8ea:	99 e0       	ldi	r25, 0x09	; 9
     8ec:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     8f0:	81 e0       	ldi	r24, 0x01	; 1
     8f2:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     8f6:	e0 ea       	ldi	r30, 0xA0	; 160
     8f8:	f9 e0       	ldi	r31, 0x09	; 9
     8fa:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     8fc:	95 ff       	sbrs	r25, 5
     8fe:	fd cf       	rjmp	.-6      	; 0x8fa <gfx_mono_st7565r_put_byte+0x3a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     900:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     904:	e0 ea       	ldi	r30, 0xA0	; 160
     906:	f9 e0       	ldi	r31, 0x09	; 9
     908:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     90a:	86 ff       	sbrs	r24, 6
     90c:	fd cf       	rjmp	.-6      	; 0x908 <gfx_mono_st7565r_put_byte+0x48>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     90e:	e0 ea       	ldi	r30, 0xA0	; 160
     910:	f9 e0       	ldi	r31, 0x09	; 9
     912:	80 e4       	ldi	r24, 0x40	; 64
     914:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     916:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     918:	be 01       	movw	r22, r28
     91a:	6f 5f       	subi	r22, 0xFF	; 255
     91c:	7f 4f       	sbci	r23, 0xFF	; 255
     91e:	80 ea       	ldi	r24, 0xA0	; 160
     920:	99 e0       	ldi	r25, 0x09	; 9
     922:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     926:	0f 2d       	mov	r16, r15
     928:	0f 77       	andi	r16, 0x7F	; 127
     92a:	02 95       	swap	r16
     92c:	0f 70       	andi	r16, 0x0F	; 15
     92e:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     930:	8b e2       	ldi	r24, 0x2B	; 43
     932:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     934:	be 01       	movw	r22, r28
     936:	6f 5f       	subi	r22, 0xFF	; 255
     938:	7f 4f       	sbci	r23, 0xFF	; 255
     93a:	80 ea       	ldi	r24, 0xA0	; 160
     93c:	99 e0       	ldi	r25, 0x09	; 9
     93e:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     942:	81 e0       	ldi	r24, 0x01	; 1
     944:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     948:	e0 ea       	ldi	r30, 0xA0	; 160
     94a:	f9 e0       	ldi	r31, 0x09	; 9
     94c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     94e:	85 ff       	sbrs	r24, 5
     950:	fd cf       	rjmp	.-6      	; 0x94c <gfx_mono_st7565r_put_byte+0x8c>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     952:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     956:	e0 ea       	ldi	r30, 0xA0	; 160
     958:	f9 e0       	ldi	r31, 0x09	; 9
     95a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     95c:	86 ff       	sbrs	r24, 6
     95e:	fd cf       	rjmp	.-6      	; 0x95a <gfx_mono_st7565r_put_byte+0x9a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     960:	e0 ea       	ldi	r30, 0xA0	; 160
     962:	f9 e0       	ldi	r31, 0x09	; 9
     964:	80 e4       	ldi	r24, 0x40	; 64
     966:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     968:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     96a:	be 01       	movw	r22, r28
     96c:	6f 5f       	subi	r22, 0xFF	; 255
     96e:	7f 4f       	sbci	r23, 0xFF	; 255
     970:	80 ea       	ldi	r24, 0xA0	; 160
     972:	99 e0       	ldi	r25, 0x09	; 9
     974:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     978:	0f 2d       	mov	r16, r15
     97a:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     97c:	8b e2       	ldi	r24, 0x2B	; 43
     97e:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     980:	be 01       	movw	r22, r28
     982:	6f 5f       	subi	r22, 0xFF	; 255
     984:	7f 4f       	sbci	r23, 0xFF	; 255
     986:	80 ea       	ldi	r24, 0xA0	; 160
     988:	99 e0       	ldi	r25, 0x09	; 9
     98a:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     98e:	81 e0       	ldi	r24, 0x01	; 1
     990:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     994:	e0 ea       	ldi	r30, 0xA0	; 160
     996:	f9 e0       	ldi	r31, 0x09	; 9
     998:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     99a:	85 ff       	sbrs	r24, 5
     99c:	fd cf       	rjmp	.-6      	; 0x998 <gfx_mono_st7565r_put_byte+0xd8>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     99e:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     9a2:	e0 ea       	ldi	r30, 0xA0	; 160
     9a4:	f9 e0       	ldi	r31, 0x09	; 9
     9a6:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9a8:	86 ff       	sbrs	r24, 6
     9aa:	fd cf       	rjmp	.-6      	; 0x9a6 <gfx_mono_st7565r_put_byte+0xe6>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9ac:	e0 ea       	ldi	r30, 0xA0	; 160
     9ae:	f9 e0       	ldi	r31, 0x09	; 9
     9b0:	80 e4       	ldi	r24, 0x40	; 64
     9b2:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9b4:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9b6:	be 01       	movw	r22, r28
     9b8:	6f 5f       	subi	r22, 0xFF	; 255
     9ba:	7f 4f       	sbci	r23, 0xFF	; 255
     9bc:	80 ea       	ldi	r24, 0xA0	; 160
     9be:	99 e0       	ldi	r25, 0x09	; 9
     9c0:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9c4:	8b e2       	ldi	r24, 0x2B	; 43
     9c6:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9c8:	be 01       	movw	r22, r28
     9ca:	6f 5f       	subi	r22, 0xFF	; 255
     9cc:	7f 4f       	sbci	r23, 0xFF	; 255
     9ce:	80 ea       	ldi	r24, 0xA0	; 160
     9d0:	99 e0       	ldi	r25, 0x09	; 9
     9d2:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     9d6:	81 e0       	ldi	r24, 0x01	; 1
     9d8:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9dc:	e0 ea       	ldi	r30, 0xA0	; 160
     9de:	f9 e0       	ldi	r31, 0x09	; 9
     9e0:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     9e2:	85 ff       	sbrs	r24, 5
     9e4:	fd cf       	rjmp	.-6      	; 0x9e0 <gfx_mono_st7565r_put_byte+0x120>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     9e6:	10 93 a0 09 	sts	0x09A0, r17	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     9ea:	e0 ea       	ldi	r30, 0xA0	; 160
     9ec:	f9 e0       	ldi	r31, 0x09	; 9
     9ee:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9f0:	86 ff       	sbrs	r24, 6
     9f2:	fd cf       	rjmp	.-6      	; 0x9ee <gfx_mono_st7565r_put_byte+0x12e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9f4:	e0 ea       	ldi	r30, 0xA0	; 160
     9f6:	f9 e0       	ldi	r31, 0x09	; 9
     9f8:	80 e4       	ldi	r24, 0x40	; 64
     9fa:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9fc:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     9fe:	81 e0       	ldi	r24, 0x01	; 1
     a00:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a04:	be 01       	movw	r22, r28
     a06:	6f 5f       	subi	r22, 0xFF	; 255
     a08:	7f 4f       	sbci	r23, 0xFF	; 255
     a0a:	80 ea       	ldi	r24, 0xA0	; 160
     a0c:	99 e0       	ldi	r25, 0x09	; 9
     a0e:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     a12:	0f 90       	pop	r0
     a14:	df 91       	pop	r29
     a16:	cf 91       	pop	r28
     a18:	1f 91       	pop	r17
     a1a:	0f 91       	pop	r16
     a1c:	ff 90       	pop	r15
     a1e:	08 95       	ret

00000a20 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a20:	0f 93       	push	r16
     a22:	1f 93       	push	r17
     a24:	cf 93       	push	r28
     a26:	df 93       	push	r29
     a28:	1f 92       	push	r1
     a2a:	cd b7       	in	r28, 0x3d	; 61
     a2c:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     a2e:	80 e2       	ldi	r24, 0x20	; 32
     a30:	91 e2       	ldi	r25, 0x21	; 33
     a32:	0e 94 b4 1d 	call	0x3b68	; 0x3b68 <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     a36:	68 dd       	rcall	.-1328   	; 0x508 <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     a38:	8b e2       	ldi	r24, 0x2B	; 43
     a3a:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     a3c:	be 01       	movw	r22, r28
     a3e:	6f 5f       	subi	r22, 0xFF	; 255
     a40:	7f 4f       	sbci	r23, 0xFF	; 255
     a42:	80 ea       	ldi	r24, 0xA0	; 160
     a44:	99 e0       	ldi	r25, 0x09	; 9
     a46:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <usart_spi_select_device>
     a4a:	81 e0       	ldi	r24, 0x01	; 1
     a4c:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     a50:	e0 ea       	ldi	r30, 0xA0	; 160
     a52:	f9 e0       	ldi	r31, 0x09	; 9
     a54:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a56:	85 ff       	sbrs	r24, 5
     a58:	fd cf       	rjmp	.-6      	; 0xa54 <gfx_mono_st7565r_init+0x34>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a5a:	80 e4       	ldi	r24, 0x40	; 64
     a5c:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a60:	e0 ea       	ldi	r30, 0xA0	; 160
     a62:	f9 e0       	ldi	r31, 0x09	; 9
     a64:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a66:	86 ff       	sbrs	r24, 6
     a68:	fd cf       	rjmp	.-6      	; 0xa64 <gfx_mono_st7565r_init+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a6a:	e0 ea       	ldi	r30, 0xA0	; 160
     a6c:	f9 e0       	ldi	r31, 0x09	; 9
     a6e:	80 e4       	ldi	r24, 0x40	; 64
     a70:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a72:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a74:	be 01       	movw	r22, r28
     a76:	6f 5f       	subi	r22, 0xFF	; 255
     a78:	7f 4f       	sbci	r23, 0xFF	; 255
     a7a:	80 ea       	ldi	r24, 0xA0	; 160
     a7c:	99 e0       	ldi	r25, 0x09	; 9
     a7e:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a82:	00 e0       	ldi	r16, 0x00	; 0
     a84:	0a c0       	rjmp	.+20     	; 0xa9a <gfx_mono_st7565r_init+0x7a>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     a86:	40 e0       	ldi	r20, 0x00	; 0
     a88:	61 2f       	mov	r22, r17
     a8a:	80 2f       	mov	r24, r16
     a8c:	19 df       	rcall	.-462    	; 0x8c0 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     a8e:	1f 5f       	subi	r17, 0xFF	; 255
     a90:	10 38       	cpi	r17, 0x80	; 128
     a92:	c9 f7       	brne	.-14     	; 0xa86 <gfx_mono_st7565r_init+0x66>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a94:	0f 5f       	subi	r16, 0xFF	; 255
     a96:	04 30       	cpi	r16, 0x04	; 4
     a98:	11 f0       	breq	.+4      	; 0xa9e <gfx_mono_st7565r_init+0x7e>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a9a:	10 e0       	ldi	r17, 0x00	; 0
     a9c:	f4 cf       	rjmp	.-24     	; 0xa86 <gfx_mono_st7565r_init+0x66>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     a9e:	0f 90       	pop	r0
     aa0:	df 91       	pop	r29
     aa2:	cf 91       	pop	r28
     aa4:	1f 91       	pop	r17
     aa6:	0f 91       	pop	r16
     aa8:	08 95       	ret

00000aaa <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     aaa:	ff 92       	push	r15
     aac:	0f 93       	push	r16
     aae:	1f 93       	push	r17
     ab0:	cf 93       	push	r28
     ab2:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     ab4:	88 23       	and	r24, r24
     ab6:	54 f1       	brlt	.+84     	; 0xb0c <gfx_mono_st7565r_draw_pixel+0x62>
     ab8:	60 32       	cpi	r22, 0x20	; 32
     aba:	40 f5       	brcc	.+80     	; 0xb0c <gfx_mono_st7565r_draw_pixel+0x62>
     abc:	d4 2f       	mov	r29, r20
     abe:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     ac0:	f6 2e       	mov	r15, r22
     ac2:	f6 94       	lsr	r15
     ac4:	f6 94       	lsr	r15
     ac6:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     ac8:	70 e0       	ldi	r23, 0x00	; 0
     aca:	88 e0       	ldi	r24, 0x08	; 8
     acc:	f8 9e       	mul	r15, r24
     ace:	60 19       	sub	r22, r0
     ad0:	71 09       	sbc	r23, r1
     ad2:	11 24       	eor	r1, r1
     ad4:	81 e0       	ldi	r24, 0x01	; 1
     ad6:	90 e0       	ldi	r25, 0x00	; 0
     ad8:	8c 01       	movw	r16, r24
     ada:	02 c0       	rjmp	.+4      	; 0xae0 <gfx_mono_st7565r_draw_pixel+0x36>
     adc:	00 0f       	add	r16, r16
     ade:	11 1f       	adc	r17, r17
     ae0:	6a 95       	dec	r22
     ae2:	e2 f7       	brpl	.-8      	; 0xadc <gfx_mono_st7565r_draw_pixel+0x32>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     ae4:	6c 2f       	mov	r22, r28
     ae6:	8f 2d       	mov	r24, r15
     ae8:	0e 94 c7 1d 	call	0x3b8e	; 0x3b8e <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     aec:	d1 30       	cpi	r29, 0x01	; 1
     aee:	21 f0       	breq	.+8      	; 0xaf8 <gfx_mono_st7565r_draw_pixel+0x4e>
     af0:	28 f0       	brcs	.+10     	; 0xafc <gfx_mono_st7565r_draw_pixel+0x52>
     af2:	d2 30       	cpi	r29, 0x02	; 2
     af4:	31 f0       	breq	.+12     	; 0xb02 <gfx_mono_st7565r_draw_pixel+0x58>
     af6:	06 c0       	rjmp	.+12     	; 0xb04 <gfx_mono_st7565r_draw_pixel+0x5a>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     af8:	80 2b       	or	r24, r16
		break;
     afa:	04 c0       	rjmp	.+8      	; 0xb04 <gfx_mono_st7565r_draw_pixel+0x5a>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     afc:	00 95       	com	r16
     afe:	80 23       	and	r24, r16
		break;
     b00:	01 c0       	rjmp	.+2      	; 0xb04 <gfx_mono_st7565r_draw_pixel+0x5a>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     b02:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     b04:	48 2f       	mov	r20, r24
     b06:	6c 2f       	mov	r22, r28
     b08:	8f 2d       	mov	r24, r15
     b0a:	da de       	rcall	.-588    	; 0x8c0 <gfx_mono_st7565r_put_byte>
}
     b0c:	df 91       	pop	r29
     b0e:	cf 91       	pop	r28
     b10:	1f 91       	pop	r17
     b12:	0f 91       	pop	r16
     b14:	ff 90       	pop	r15
     b16:	08 95       	ret

00000b18 <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     b18:	0c 94 c7 1d 	jmp	0x3b8e	; 0x3b8e <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
     b1c:	08 95       	ret

00000b1e <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     b1e:	81 15       	cp	r24, r1
     b20:	22 e0       	ldi	r18, 0x02	; 2
     b22:	92 07       	cpc	r25, r18
     b24:	69 f4       	brne	.+26     	; 0xb40 <adc_enable_clock+0x22>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
     b26:	80 91 21 23 	lds	r24, 0x2321	; 0x802321 <adca_enable_count>
     b2a:	91 e0       	ldi	r25, 0x01	; 1
     b2c:	98 0f       	add	r25, r24
     b2e:	90 93 21 23 	sts	0x2321, r25	; 0x802321 <adca_enable_count>
     b32:	81 11       	cpse	r24, r1
     b34:	14 c0       	rjmp	.+40     	; 0xb5e <adc_enable_clock+0x40>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     b36:	62 e0       	ldi	r22, 0x02	; 2
     b38:	81 e0       	ldi	r24, 0x01	; 1
     b3a:	0c 94 67 1e 	jmp	0x3cce	; 0x3cce <sysclk_enable_module>
     b3e:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     b40:	80 34       	cpi	r24, 0x40	; 64
     b42:	92 40       	sbci	r25, 0x02	; 2
     b44:	61 f4       	brne	.+24     	; 0xb5e <adc_enable_clock+0x40>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
     b46:	80 91 20 23 	lds	r24, 0x2320	; 0x802320 <adcb_enable_count>
     b4a:	91 e0       	ldi	r25, 0x01	; 1
     b4c:	98 0f       	add	r25, r24
     b4e:	90 93 20 23 	sts	0x2320, r25	; 0x802320 <adcb_enable_count>
     b52:	81 11       	cpse	r24, r1
     b54:	04 c0       	rjmp	.+8      	; 0xb5e <adc_enable_clock+0x40>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     b56:	62 e0       	ldi	r22, 0x02	; 2
     b58:	82 e0       	ldi	r24, 0x02	; 2
     b5a:	0c 94 67 1e 	jmp	0x3cce	; 0x3cce <sysclk_enable_module>
     b5e:	08 95       	ret

00000b60 <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     b60:	81 15       	cp	r24, r1
     b62:	22 e0       	ldi	r18, 0x02	; 2
     b64:	92 07       	cpc	r25, r18
     b66:	61 f4       	brne	.+24     	; 0xb80 <adc_disable_clock+0x20>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
     b68:	80 91 21 23 	lds	r24, 0x2321	; 0x802321 <adca_enable_count>
     b6c:	81 50       	subi	r24, 0x01	; 1
     b6e:	80 93 21 23 	sts	0x2321, r24	; 0x802321 <adca_enable_count>
     b72:	81 11       	cpse	r24, r1
     b74:	13 c0       	rjmp	.+38     	; 0xb9c <adc_disable_clock+0x3c>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     b76:	62 e0       	ldi	r22, 0x02	; 2
     b78:	81 e0       	ldi	r24, 0x01	; 1
     b7a:	0c 94 7d 1e 	jmp	0x3cfa	; 0x3cfa <sysclk_disable_module>
     b7e:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     b80:	80 34       	cpi	r24, 0x40	; 64
     b82:	92 40       	sbci	r25, 0x02	; 2
     b84:	59 f4       	brne	.+22     	; 0xb9c <adc_disable_clock+0x3c>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
     b86:	80 91 20 23 	lds	r24, 0x2320	; 0x802320 <adcb_enable_count>
     b8a:	81 50       	subi	r24, 0x01	; 1
     b8c:	80 93 20 23 	sts	0x2320, r24	; 0x802320 <adcb_enable_count>
     b90:	81 11       	cpse	r24, r1
     b92:	04 c0       	rjmp	.+8      	; 0xb9c <adc_disable_clock+0x3c>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     b94:	62 e0       	ldi	r22, 0x02	; 2
     b96:	82 e0       	ldi	r24, 0x02	; 2
     b98:	0c 94 7d 1e 	jmp	0x3cfa	; 0x3cfa <sysclk_disable_module>
     b9c:	08 95       	ret

00000b9e <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
     b9e:	ef 92       	push	r14
     ba0:	ff 92       	push	r15
     ba2:	1f 93       	push	r17
     ba4:	cf 93       	push	r28
     ba6:	df 93       	push	r29
     ba8:	1f 92       	push	r1
     baa:	1f 92       	push	r1
     bac:	cd b7       	in	r28, 0x3d	; 61
     bae:	de b7       	in	r29, 0x3e	; 62
     bb0:	7c 01       	movw	r14, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     bb2:	8f b7       	in	r24, 0x3f	; 63
     bb4:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
     bb6:	f8 94       	cli
	return flags;
     bb8:	19 81       	ldd	r17, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
     bba:	c7 01       	movw	r24, r14
     bbc:	b0 df       	rcall	.-160    	; 0xb1e <adc_enable_clock>
	adc->CTRLA |= ADC_ENABLE_bm;
     bbe:	f7 01       	movw	r30, r14
     bc0:	80 81       	ld	r24, Z
     bc2:	81 60       	ori	r24, 0x01	; 1
     bc4:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     bc6:	1f bf       	out	0x3f, r17	; 63
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
     bc8:	80 91 b8 24 	lds	r24, 0x24B8	; 0x8024b8 <sleepmgr_locks+0x1>
     bcc:	8f 3f       	cpi	r24, 0xFF	; 255
     bce:	09 f4       	brne	.+2      	; 0xbd2 <adc_enable+0x34>
     bd0:	ff cf       	rjmp	.-2      	; 0xbd0 <adc_enable+0x32>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     bd2:	8f b7       	in	r24, 0x3f	; 63
     bd4:	8a 83       	std	Y+2, r24	; 0x02
	cpu_irq_disable();
     bd6:	f8 94       	cli
	return flags;
     bd8:	9a 81       	ldd	r25, Y+2	; 0x02
	}

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
     bda:	e7 eb       	ldi	r30, 0xB7	; 183
     bdc:	f4 e2       	ldi	r31, 0x24	; 36
     bde:	81 81       	ldd	r24, Z+1	; 0x01
     be0:	8f 5f       	subi	r24, 0xFF	; 255
     be2:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     be4:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
     be6:	0f 90       	pop	r0
     be8:	0f 90       	pop	r0
     bea:	df 91       	pop	r29
     bec:	cf 91       	pop	r28
     bee:	1f 91       	pop	r17
     bf0:	ff 90       	pop	r15
     bf2:	ef 90       	pop	r14
     bf4:	08 95       	ret

00000bf6 <adc_disable>:
 * Disables the ADC and unlocks IDLE mode for the sleep manager.
 *
 * \param adc Pointer to ADC module
 */
void adc_disable(ADC_t *adc)
{
     bf6:	1f 93       	push	r17
     bf8:	cf 93       	push	r28
     bfa:	df 93       	push	r29
     bfc:	1f 92       	push	r1
     bfe:	1f 92       	push	r1
     c00:	cd b7       	in	r28, 0x3d	; 61
     c02:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     c04:	2f b7       	in	r18, 0x3f	; 63
     c06:	29 83       	std	Y+1, r18	; 0x01
	cpu_irq_disable();
     c08:	f8 94       	cli
	return flags;
     c0a:	19 81       	ldd	r17, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();
	adc->CTRLA &= ~ADC_ENABLE_bm;
     c0c:	fc 01       	movw	r30, r24
     c0e:	20 81       	ld	r18, Z
     c10:	2e 7f       	andi	r18, 0xFE	; 254
     c12:	20 83       	st	Z, r18
	adc_disable_clock(adc);
     c14:	a5 df       	rcall	.-182    	; 0xb60 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     c16:	1f bf       	out	0x3f, r17	; 63
static inline void sleepmgr_unlock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] == 0) {
     c18:	80 91 b8 24 	lds	r24, 0x24B8	; 0x8024b8 <sleepmgr_locks+0x1>
     c1c:	81 11       	cpse	r24, r1
     c1e:	01 c0       	rjmp	.+2      	; 0xc22 <adc_disable+0x2c>
     c20:	ff cf       	rjmp	.-2      	; 0xc20 <adc_disable+0x2a>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     c22:	8f b7       	in	r24, 0x3f	; 63
     c24:	8a 83       	std	Y+2, r24	; 0x02
	cpu_irq_disable();
     c26:	f8 94       	cli
	return flags;
     c28:	9a 81       	ldd	r25, Y+2	; 0x02
	}

	// Enter a critical section
	flags = cpu_irq_save();

	--sleepmgr_locks[mode];
     c2a:	e7 eb       	ldi	r30, 0xB7	; 183
     c2c:	f4 e2       	ldi	r31, 0x24	; 36
     c2e:	81 81       	ldd	r24, Z+1	; 0x01
     c30:	81 50       	subi	r24, 0x01	; 1
     c32:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     c34:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_unlock_mode(SLEEPMGR_IDLE);
}
     c36:	0f 90       	pop	r0
     c38:	0f 90       	pop	r0
     c3a:	df 91       	pop	r29
     c3c:	cf 91       	pop	r28
     c3e:	1f 91       	pop	r17
     c40:	08 95       	ret

00000c42 <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
     c42:	1f 92       	push	r1
     c44:	0f 92       	push	r0
     c46:	0f b6       	in	r0, 0x3f	; 63
     c48:	0f 92       	push	r0
     c4a:	11 24       	eor	r1, r1
     c4c:	0b b6       	in	r0, 0x3b	; 59
     c4e:	0f 92       	push	r0
     c50:	2f 93       	push	r18
     c52:	3f 93       	push	r19
     c54:	4f 93       	push	r20
     c56:	5f 93       	push	r21
     c58:	6f 93       	push	r22
     c5a:	7f 93       	push	r23
     c5c:	8f 93       	push	r24
     c5e:	9f 93       	push	r25
     c60:	af 93       	push	r26
     c62:	bf 93       	push	r27
     c64:	ef 93       	push	r30
     c66:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
     c68:	40 91 24 02 	lds	r20, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
     c6c:	50 91 25 02 	lds	r21, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
     c70:	e0 91 bf 24 	lds	r30, 0x24BF	; 0x8024bf <adca_callback>
     c74:	f0 91 c0 24 	lds	r31, 0x24C0	; 0x8024c0 <adca_callback+0x1>
     c78:	61 e0       	ldi	r22, 0x01	; 1
     c7a:	80 e0       	ldi	r24, 0x00	; 0
     c7c:	92 e0       	ldi	r25, 0x02	; 2
     c7e:	19 95       	eicall
}
     c80:	ff 91       	pop	r31
     c82:	ef 91       	pop	r30
     c84:	bf 91       	pop	r27
     c86:	af 91       	pop	r26
     c88:	9f 91       	pop	r25
     c8a:	8f 91       	pop	r24
     c8c:	7f 91       	pop	r23
     c8e:	6f 91       	pop	r22
     c90:	5f 91       	pop	r21
     c92:	4f 91       	pop	r20
     c94:	3f 91       	pop	r19
     c96:	2f 91       	pop	r18
     c98:	0f 90       	pop	r0
     c9a:	0b be       	out	0x3b, r0	; 59
     c9c:	0f 90       	pop	r0
     c9e:	0f be       	out	0x3f, r0	; 63
     ca0:	0f 90       	pop	r0
     ca2:	1f 90       	pop	r1
     ca4:	18 95       	reti

00000ca6 <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
     ca6:	1f 92       	push	r1
     ca8:	0f 92       	push	r0
     caa:	0f b6       	in	r0, 0x3f	; 63
     cac:	0f 92       	push	r0
     cae:	11 24       	eor	r1, r1
     cb0:	0b b6       	in	r0, 0x3b	; 59
     cb2:	0f 92       	push	r0
     cb4:	2f 93       	push	r18
     cb6:	3f 93       	push	r19
     cb8:	4f 93       	push	r20
     cba:	5f 93       	push	r21
     cbc:	6f 93       	push	r22
     cbe:	7f 93       	push	r23
     cc0:	8f 93       	push	r24
     cc2:	9f 93       	push	r25
     cc4:	af 93       	push	r26
     cc6:	bf 93       	push	r27
     cc8:	ef 93       	push	r30
     cca:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
     ccc:	40 91 2c 02 	lds	r20, 0x022C	; 0x80022c <__TEXT_REGION_LENGTH__+0x70022c>
     cd0:	50 91 2d 02 	lds	r21, 0x022D	; 0x80022d <__TEXT_REGION_LENGTH__+0x70022d>
     cd4:	e0 91 bf 24 	lds	r30, 0x24BF	; 0x8024bf <adca_callback>
     cd8:	f0 91 c0 24 	lds	r31, 0x24C0	; 0x8024c0 <adca_callback+0x1>
     cdc:	62 e0       	ldi	r22, 0x02	; 2
     cde:	80 e0       	ldi	r24, 0x00	; 0
     ce0:	92 e0       	ldi	r25, 0x02	; 2
     ce2:	19 95       	eicall
}
     ce4:	ff 91       	pop	r31
     ce6:	ef 91       	pop	r30
     ce8:	bf 91       	pop	r27
     cea:	af 91       	pop	r26
     cec:	9f 91       	pop	r25
     cee:	8f 91       	pop	r24
     cf0:	7f 91       	pop	r23
     cf2:	6f 91       	pop	r22
     cf4:	5f 91       	pop	r21
     cf6:	4f 91       	pop	r20
     cf8:	3f 91       	pop	r19
     cfa:	2f 91       	pop	r18
     cfc:	0f 90       	pop	r0
     cfe:	0b be       	out	0x3b, r0	; 59
     d00:	0f 90       	pop	r0
     d02:	0f be       	out	0x3f, r0	; 63
     d04:	0f 90       	pop	r0
     d06:	1f 90       	pop	r1
     d08:	18 95       	reti

00000d0a <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
     d0a:	1f 92       	push	r1
     d0c:	0f 92       	push	r0
     d0e:	0f b6       	in	r0, 0x3f	; 63
     d10:	0f 92       	push	r0
     d12:	11 24       	eor	r1, r1
     d14:	0b b6       	in	r0, 0x3b	; 59
     d16:	0f 92       	push	r0
     d18:	2f 93       	push	r18
     d1a:	3f 93       	push	r19
     d1c:	4f 93       	push	r20
     d1e:	5f 93       	push	r21
     d20:	6f 93       	push	r22
     d22:	7f 93       	push	r23
     d24:	8f 93       	push	r24
     d26:	9f 93       	push	r25
     d28:	af 93       	push	r26
     d2a:	bf 93       	push	r27
     d2c:	ef 93       	push	r30
     d2e:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
     d30:	40 91 34 02 	lds	r20, 0x0234	; 0x800234 <__TEXT_REGION_LENGTH__+0x700234>
     d34:	50 91 35 02 	lds	r21, 0x0235	; 0x800235 <__TEXT_REGION_LENGTH__+0x700235>
     d38:	e0 91 bf 24 	lds	r30, 0x24BF	; 0x8024bf <adca_callback>
     d3c:	f0 91 c0 24 	lds	r31, 0x24C0	; 0x8024c0 <adca_callback+0x1>
     d40:	64 e0       	ldi	r22, 0x04	; 4
     d42:	80 e0       	ldi	r24, 0x00	; 0
     d44:	92 e0       	ldi	r25, 0x02	; 2
     d46:	19 95       	eicall
}
     d48:	ff 91       	pop	r31
     d4a:	ef 91       	pop	r30
     d4c:	bf 91       	pop	r27
     d4e:	af 91       	pop	r26
     d50:	9f 91       	pop	r25
     d52:	8f 91       	pop	r24
     d54:	7f 91       	pop	r23
     d56:	6f 91       	pop	r22
     d58:	5f 91       	pop	r21
     d5a:	4f 91       	pop	r20
     d5c:	3f 91       	pop	r19
     d5e:	2f 91       	pop	r18
     d60:	0f 90       	pop	r0
     d62:	0b be       	out	0x3b, r0	; 59
     d64:	0f 90       	pop	r0
     d66:	0f be       	out	0x3f, r0	; 63
     d68:	0f 90       	pop	r0
     d6a:	1f 90       	pop	r1
     d6c:	18 95       	reti

00000d6e <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
     d6e:	1f 92       	push	r1
     d70:	0f 92       	push	r0
     d72:	0f b6       	in	r0, 0x3f	; 63
     d74:	0f 92       	push	r0
     d76:	11 24       	eor	r1, r1
     d78:	0b b6       	in	r0, 0x3b	; 59
     d7a:	0f 92       	push	r0
     d7c:	2f 93       	push	r18
     d7e:	3f 93       	push	r19
     d80:	4f 93       	push	r20
     d82:	5f 93       	push	r21
     d84:	6f 93       	push	r22
     d86:	7f 93       	push	r23
     d88:	8f 93       	push	r24
     d8a:	9f 93       	push	r25
     d8c:	af 93       	push	r26
     d8e:	bf 93       	push	r27
     d90:	ef 93       	push	r30
     d92:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
     d94:	40 91 3c 02 	lds	r20, 0x023C	; 0x80023c <__TEXT_REGION_LENGTH__+0x70023c>
     d98:	50 91 3d 02 	lds	r21, 0x023D	; 0x80023d <__TEXT_REGION_LENGTH__+0x70023d>
     d9c:	e0 91 bf 24 	lds	r30, 0x24BF	; 0x8024bf <adca_callback>
     da0:	f0 91 c0 24 	lds	r31, 0x24C0	; 0x8024c0 <adca_callback+0x1>
     da4:	68 e0       	ldi	r22, 0x08	; 8
     da6:	80 e0       	ldi	r24, 0x00	; 0
     da8:	92 e0       	ldi	r25, 0x02	; 2
     daa:	19 95       	eicall
}
     dac:	ff 91       	pop	r31
     dae:	ef 91       	pop	r30
     db0:	bf 91       	pop	r27
     db2:	af 91       	pop	r26
     db4:	9f 91       	pop	r25
     db6:	8f 91       	pop	r24
     db8:	7f 91       	pop	r23
     dba:	6f 91       	pop	r22
     dbc:	5f 91       	pop	r21
     dbe:	4f 91       	pop	r20
     dc0:	3f 91       	pop	r19
     dc2:	2f 91       	pop	r18
     dc4:	0f 90       	pop	r0
     dc6:	0b be       	out	0x3b, r0	; 59
     dc8:	0f 90       	pop	r0
     dca:	0f be       	out	0x3f, r0	; 63
     dcc:	0f 90       	pop	r0
     dce:	1f 90       	pop	r1
     dd0:	18 95       	reti

00000dd2 <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
     dd2:	1f 92       	push	r1
     dd4:	0f 92       	push	r0
     dd6:	0f b6       	in	r0, 0x3f	; 63
     dd8:	0f 92       	push	r0
     dda:	11 24       	eor	r1, r1
     ddc:	0b b6       	in	r0, 0x3b	; 59
     dde:	0f 92       	push	r0
     de0:	2f 93       	push	r18
     de2:	3f 93       	push	r19
     de4:	4f 93       	push	r20
     de6:	5f 93       	push	r21
     de8:	6f 93       	push	r22
     dea:	7f 93       	push	r23
     dec:	8f 93       	push	r24
     dee:	9f 93       	push	r25
     df0:	af 93       	push	r26
     df2:	bf 93       	push	r27
     df4:	ef 93       	push	r30
     df6:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
     df8:	40 91 64 02 	lds	r20, 0x0264	; 0x800264 <__TEXT_REGION_LENGTH__+0x700264>
     dfc:	50 91 65 02 	lds	r21, 0x0265	; 0x800265 <__TEXT_REGION_LENGTH__+0x700265>
     e00:	e0 91 bd 24 	lds	r30, 0x24BD	; 0x8024bd <adcb_callback>
     e04:	f0 91 be 24 	lds	r31, 0x24BE	; 0x8024be <adcb_callback+0x1>
     e08:	61 e0       	ldi	r22, 0x01	; 1
     e0a:	80 e4       	ldi	r24, 0x40	; 64
     e0c:	92 e0       	ldi	r25, 0x02	; 2
     e0e:	19 95       	eicall
}
     e10:	ff 91       	pop	r31
     e12:	ef 91       	pop	r30
     e14:	bf 91       	pop	r27
     e16:	af 91       	pop	r26
     e18:	9f 91       	pop	r25
     e1a:	8f 91       	pop	r24
     e1c:	7f 91       	pop	r23
     e1e:	6f 91       	pop	r22
     e20:	5f 91       	pop	r21
     e22:	4f 91       	pop	r20
     e24:	3f 91       	pop	r19
     e26:	2f 91       	pop	r18
     e28:	0f 90       	pop	r0
     e2a:	0b be       	out	0x3b, r0	; 59
     e2c:	0f 90       	pop	r0
     e2e:	0f be       	out	0x3f, r0	; 63
     e30:	0f 90       	pop	r0
     e32:	1f 90       	pop	r1
     e34:	18 95       	reti

00000e36 <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
     e36:	1f 92       	push	r1
     e38:	0f 92       	push	r0
     e3a:	0f b6       	in	r0, 0x3f	; 63
     e3c:	0f 92       	push	r0
     e3e:	11 24       	eor	r1, r1
     e40:	0b b6       	in	r0, 0x3b	; 59
     e42:	0f 92       	push	r0
     e44:	2f 93       	push	r18
     e46:	3f 93       	push	r19
     e48:	4f 93       	push	r20
     e4a:	5f 93       	push	r21
     e4c:	6f 93       	push	r22
     e4e:	7f 93       	push	r23
     e50:	8f 93       	push	r24
     e52:	9f 93       	push	r25
     e54:	af 93       	push	r26
     e56:	bf 93       	push	r27
     e58:	ef 93       	push	r30
     e5a:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
     e5c:	40 91 6c 02 	lds	r20, 0x026C	; 0x80026c <__TEXT_REGION_LENGTH__+0x70026c>
     e60:	50 91 6d 02 	lds	r21, 0x026D	; 0x80026d <__TEXT_REGION_LENGTH__+0x70026d>
     e64:	e0 91 bd 24 	lds	r30, 0x24BD	; 0x8024bd <adcb_callback>
     e68:	f0 91 be 24 	lds	r31, 0x24BE	; 0x8024be <adcb_callback+0x1>
     e6c:	62 e0       	ldi	r22, 0x02	; 2
     e6e:	80 e4       	ldi	r24, 0x40	; 64
     e70:	92 e0       	ldi	r25, 0x02	; 2
     e72:	19 95       	eicall
}
     e74:	ff 91       	pop	r31
     e76:	ef 91       	pop	r30
     e78:	bf 91       	pop	r27
     e7a:	af 91       	pop	r26
     e7c:	9f 91       	pop	r25
     e7e:	8f 91       	pop	r24
     e80:	7f 91       	pop	r23
     e82:	6f 91       	pop	r22
     e84:	5f 91       	pop	r21
     e86:	4f 91       	pop	r20
     e88:	3f 91       	pop	r19
     e8a:	2f 91       	pop	r18
     e8c:	0f 90       	pop	r0
     e8e:	0b be       	out	0x3b, r0	; 59
     e90:	0f 90       	pop	r0
     e92:	0f be       	out	0x3f, r0	; 63
     e94:	0f 90       	pop	r0
     e96:	1f 90       	pop	r1
     e98:	18 95       	reti

00000e9a <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
     e9a:	1f 92       	push	r1
     e9c:	0f 92       	push	r0
     e9e:	0f b6       	in	r0, 0x3f	; 63
     ea0:	0f 92       	push	r0
     ea2:	11 24       	eor	r1, r1
     ea4:	0b b6       	in	r0, 0x3b	; 59
     ea6:	0f 92       	push	r0
     ea8:	2f 93       	push	r18
     eaa:	3f 93       	push	r19
     eac:	4f 93       	push	r20
     eae:	5f 93       	push	r21
     eb0:	6f 93       	push	r22
     eb2:	7f 93       	push	r23
     eb4:	8f 93       	push	r24
     eb6:	9f 93       	push	r25
     eb8:	af 93       	push	r26
     eba:	bf 93       	push	r27
     ebc:	ef 93       	push	r30
     ebe:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
     ec0:	40 91 74 02 	lds	r20, 0x0274	; 0x800274 <__TEXT_REGION_LENGTH__+0x700274>
     ec4:	50 91 75 02 	lds	r21, 0x0275	; 0x800275 <__TEXT_REGION_LENGTH__+0x700275>
     ec8:	e0 91 bd 24 	lds	r30, 0x24BD	; 0x8024bd <adcb_callback>
     ecc:	f0 91 be 24 	lds	r31, 0x24BE	; 0x8024be <adcb_callback+0x1>
     ed0:	64 e0       	ldi	r22, 0x04	; 4
     ed2:	80 e4       	ldi	r24, 0x40	; 64
     ed4:	92 e0       	ldi	r25, 0x02	; 2
     ed6:	19 95       	eicall
}
     ed8:	ff 91       	pop	r31
     eda:	ef 91       	pop	r30
     edc:	bf 91       	pop	r27
     ede:	af 91       	pop	r26
     ee0:	9f 91       	pop	r25
     ee2:	8f 91       	pop	r24
     ee4:	7f 91       	pop	r23
     ee6:	6f 91       	pop	r22
     ee8:	5f 91       	pop	r21
     eea:	4f 91       	pop	r20
     eec:	3f 91       	pop	r19
     eee:	2f 91       	pop	r18
     ef0:	0f 90       	pop	r0
     ef2:	0b be       	out	0x3b, r0	; 59
     ef4:	0f 90       	pop	r0
     ef6:	0f be       	out	0x3f, r0	; 63
     ef8:	0f 90       	pop	r0
     efa:	1f 90       	pop	r1
     efc:	18 95       	reti

00000efe <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
     efe:	1f 92       	push	r1
     f00:	0f 92       	push	r0
     f02:	0f b6       	in	r0, 0x3f	; 63
     f04:	0f 92       	push	r0
     f06:	11 24       	eor	r1, r1
     f08:	0b b6       	in	r0, 0x3b	; 59
     f0a:	0f 92       	push	r0
     f0c:	2f 93       	push	r18
     f0e:	3f 93       	push	r19
     f10:	4f 93       	push	r20
     f12:	5f 93       	push	r21
     f14:	6f 93       	push	r22
     f16:	7f 93       	push	r23
     f18:	8f 93       	push	r24
     f1a:	9f 93       	push	r25
     f1c:	af 93       	push	r26
     f1e:	bf 93       	push	r27
     f20:	ef 93       	push	r30
     f22:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
     f24:	40 91 7c 02 	lds	r20, 0x027C	; 0x80027c <__TEXT_REGION_LENGTH__+0x70027c>
     f28:	50 91 7d 02 	lds	r21, 0x027D	; 0x80027d <__TEXT_REGION_LENGTH__+0x70027d>
     f2c:	e0 91 bd 24 	lds	r30, 0x24BD	; 0x8024bd <adcb_callback>
     f30:	f0 91 be 24 	lds	r31, 0x24BE	; 0x8024be <adcb_callback+0x1>
     f34:	68 e0       	ldi	r22, 0x08	; 8
     f36:	80 e4       	ldi	r24, 0x40	; 64
     f38:	92 e0       	ldi	r25, 0x02	; 2
     f3a:	19 95       	eicall
}
     f3c:	ff 91       	pop	r31
     f3e:	ef 91       	pop	r30
     f40:	bf 91       	pop	r27
     f42:	af 91       	pop	r26
     f44:	9f 91       	pop	r25
     f46:	8f 91       	pop	r24
     f48:	7f 91       	pop	r23
     f4a:	6f 91       	pop	r22
     f4c:	5f 91       	pop	r21
     f4e:	4f 91       	pop	r20
     f50:	3f 91       	pop	r19
     f52:	2f 91       	pop	r18
     f54:	0f 90       	pop	r0
     f56:	0b be       	out	0x3b, r0	; 59
     f58:	0f 90       	pop	r0
     f5a:	0f be       	out	0x3f, r0	; 63
     f5c:	0f 90       	pop	r0
     f5e:	1f 90       	pop	r1
     f60:	18 95       	reti

00000f62 <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
     f62:	bf 92       	push	r11
     f64:	cf 92       	push	r12
     f66:	df 92       	push	r13
     f68:	ef 92       	push	r14
     f6a:	ff 92       	push	r15
     f6c:	0f 93       	push	r16
     f6e:	1f 93       	push	r17
     f70:	cf 93       	push	r28
     f72:	df 93       	push	r29
     f74:	1f 92       	push	r1
     f76:	cd b7       	in	r28, 0x3d	; 61
     f78:	de b7       	in	r29, 0x3e	; 62
     f7a:	8c 01       	movw	r16, r24
     f7c:	7b 01       	movw	r14, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
     f7e:	81 15       	cp	r24, r1
     f80:	22 e0       	ldi	r18, 0x02	; 2
     f82:	92 07       	cpc	r25, r18
     f84:	81 f4       	brne	.+32     	; 0xfa6 <adc_write_configuration+0x44>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
     f86:	61 e2       	ldi	r22, 0x21	; 33
     f88:	70 e0       	ldi	r23, 0x00	; 0
     f8a:	82 e0       	ldi	r24, 0x02	; 2
     f8c:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
     f90:	c8 2e       	mov	r12, r24
     f92:	d1 2c       	mov	r13, r1
     f94:	60 e2       	ldi	r22, 0x20	; 32
     f96:	70 e0       	ldi	r23, 0x00	; 0
     f98:	82 e0       	ldi	r24, 0x02	; 2
     f9a:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <nvm_read_byte>
		data <<= 8;
		data |= nvm_read_production_signature_row(ADCACAL0);
     f9e:	dc 2c       	mov	r13, r12
     fa0:	cc 24       	eor	r12, r12
     fa2:	c8 2a       	or	r12, r24
     fa4:	12 c0       	rjmp	.+36     	; 0xfca <adc_write_configuration+0x68>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
     fa6:	80 34       	cpi	r24, 0x40	; 64
     fa8:	92 40       	sbci	r25, 0x02	; 2
     faa:	d1 f5       	brne	.+116    	; 0x1020 <adc_write_configuration+0xbe>
     fac:	65 e2       	ldi	r22, 0x25	; 37
     fae:	70 e0       	ldi	r23, 0x00	; 0
     fb0:	82 e0       	ldi	r24, 0x02	; 2
     fb2:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
     fb6:	c8 2e       	mov	r12, r24
     fb8:	d1 2c       	mov	r13, r1
     fba:	64 e2       	ldi	r22, 0x24	; 36
     fbc:	70 e0       	ldi	r23, 0x00	; 0
     fbe:	82 e0       	ldi	r24, 0x02	; 2
     fc0:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <nvm_read_byte>
		data <<= 8;
		data |= nvm_read_production_signature_row(ADCBCAL0);
     fc4:	dc 2c       	mov	r13, r12
     fc6:	cc 24       	eor	r12, r12
     fc8:	c8 2a       	or	r12, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     fca:	8f b7       	in	r24, 0x3f	; 63
     fcc:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
     fce:	f8 94       	cli
	return flags;
     fd0:	b9 80       	ldd	r11, Y+1	; 0x01
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
     fd2:	c8 01       	movw	r24, r16
     fd4:	a4 dd       	rcall	.-1208   	; 0xb1e <adc_enable_clock>
	enable = adc->CTRLA & ADC_ENABLE_bm;
     fd6:	f8 01       	movw	r30, r16
     fd8:	80 81       	ld	r24, Z

	adc->CTRLA = ADC_FLUSH_bm;
     fda:	92 e0       	ldi	r25, 0x02	; 2
     fdc:	90 83       	st	Z, r25
	adc->CAL = cal;
     fde:	c4 86       	std	Z+12, r12	; 0x0c
     fe0:	d5 86       	std	Z+13, r13	; 0x0d
	adc->CMP = conf->cmp;
     fe2:	f7 01       	movw	r30, r14
     fe4:	25 81       	ldd	r18, Z+5	; 0x05
     fe6:	36 81       	ldd	r19, Z+6	; 0x06
     fe8:	f8 01       	movw	r30, r16
     fea:	20 8f       	std	Z+24, r18	; 0x18
     fec:	31 8f       	std	Z+25, r19	; 0x19
	adc->REFCTRL = conf->refctrl;
     fee:	f7 01       	movw	r30, r14
     ff0:	92 81       	ldd	r25, Z+2	; 0x02
     ff2:	f8 01       	movw	r30, r16
     ff4:	92 83       	std	Z+2, r25	; 0x02
	adc->PRESCALER = conf->prescaler;
     ff6:	f7 01       	movw	r30, r14
     ff8:	94 81       	ldd	r25, Z+4	; 0x04
     ffa:	f8 01       	movw	r30, r16
     ffc:	94 83       	std	Z+4, r25	; 0x04
	adc->EVCTRL = conf->evctrl;
     ffe:	f7 01       	movw	r30, r14
    1000:	93 81       	ldd	r25, Z+3	; 0x03
    1002:	f8 01       	movw	r30, r16
    1004:	93 83       	std	Z+3, r25	; 0x03
	adc->CTRLB = conf->ctrlb;
    1006:	f7 01       	movw	r30, r14
    1008:	91 81       	ldd	r25, Z+1	; 0x01
    100a:	f8 01       	movw	r30, r16
    100c:	91 83       	std	Z+1, r25	; 0x01

	adc->CTRLA = enable | conf->ctrla;
    100e:	81 70       	andi	r24, 0x01	; 1
    1010:	f7 01       	movw	r30, r14
    1012:	90 81       	ld	r25, Z
    1014:	89 2b       	or	r24, r25
    1016:	f8 01       	movw	r30, r16
    1018:	80 83       	st	Z, r24

	adc_disable_clock(adc);
    101a:	c8 01       	movw	r24, r16
    101c:	a1 dd       	rcall	.-1214   	; 0xb60 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    101e:	bf be       	out	0x3f, r11	; 63

	cpu_irq_restore(flags);
}
    1020:	0f 90       	pop	r0
    1022:	df 91       	pop	r29
    1024:	cf 91       	pop	r28
    1026:	1f 91       	pop	r17
    1028:	0f 91       	pop	r16
    102a:	ff 90       	pop	r15
    102c:	ef 90       	pop	r14
    102e:	df 90       	pop	r13
    1030:	cf 90       	pop	r12
    1032:	bf 90       	pop	r11
    1034:	08 95       	ret

00001036 <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    1036:	df 92       	push	r13
    1038:	ef 92       	push	r14
    103a:	ff 92       	push	r15
    103c:	0f 93       	push	r16
    103e:	1f 93       	push	r17
    1040:	cf 93       	push	r28
    1042:	df 93       	push	r29
    1044:	1f 92       	push	r1
    1046:	cd b7       	in	r28, 0x3d	; 61
    1048:	de b7       	in	r29, 0x3e	; 62
    104a:	8c 01       	movw	r16, r24
    104c:	7b 01       	movw	r14, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    104e:	8f b7       	in	r24, 0x3f	; 63
    1050:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    1052:	f8 94       	cli
	return flags;
    1054:	d9 80       	ldd	r13, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    1056:	c8 01       	movw	r24, r16
    1058:	62 dd       	rcall	.-1340   	; 0xb1e <adc_enable_clock>

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    105a:	f8 01       	movw	r30, r16
    105c:	80 81       	ld	r24, Z
    105e:	80 7c       	andi	r24, 0xC0	; 192
    1060:	f7 01       	movw	r30, r14
    1062:	80 83       	st	Z, r24

	conf->cmp = adc->CMP;
    1064:	f8 01       	movw	r30, r16
    1066:	80 8d       	ldd	r24, Z+24	; 0x18
    1068:	91 8d       	ldd	r25, Z+25	; 0x19
    106a:	f7 01       	movw	r30, r14
    106c:	85 83       	std	Z+5, r24	; 0x05
    106e:	96 83       	std	Z+6, r25	; 0x06
	conf->refctrl = adc->REFCTRL;
    1070:	f8 01       	movw	r30, r16
    1072:	82 81       	ldd	r24, Z+2	; 0x02
    1074:	f7 01       	movw	r30, r14
    1076:	82 83       	std	Z+2, r24	; 0x02
	conf->prescaler = adc->PRESCALER;
    1078:	f8 01       	movw	r30, r16
    107a:	84 81       	ldd	r24, Z+4	; 0x04
    107c:	f7 01       	movw	r30, r14
    107e:	84 83       	std	Z+4, r24	; 0x04
	conf->evctrl = adc->EVCTRL;
    1080:	f8 01       	movw	r30, r16
    1082:	83 81       	ldd	r24, Z+3	; 0x03
    1084:	f7 01       	movw	r30, r14
    1086:	83 83       	std	Z+3, r24	; 0x03
	conf->ctrlb = adc->CTRLB;
    1088:	f8 01       	movw	r30, r16
    108a:	81 81       	ldd	r24, Z+1	; 0x01
    108c:	f7 01       	movw	r30, r14
    108e:	81 83       	std	Z+1, r24	; 0x01

	adc_disable_clock(adc);
    1090:	c8 01       	movw	r24, r16
    1092:	66 dd       	rcall	.-1332   	; 0xb60 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1094:	df be       	out	0x3f, r13	; 63

	cpu_irq_restore(flags);
}
    1096:	0f 90       	pop	r0
    1098:	df 91       	pop	r29
    109a:	cf 91       	pop	r28
    109c:	1f 91       	pop	r17
    109e:	0f 91       	pop	r16
    10a0:	ff 90       	pop	r15
    10a2:	ef 90       	pop	r14
    10a4:	df 90       	pop	r13
    10a6:	08 95       	ret

000010a8 <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    10a8:	af 92       	push	r10
    10aa:	bf 92       	push	r11
    10ac:	cf 92       	push	r12
    10ae:	df 92       	push	r13
    10b0:	ef 92       	push	r14
    10b2:	ff 92       	push	r15
    10b4:	0f 93       	push	r16
    10b6:	1f 93       	push	r17
    10b8:	cf 93       	push	r28
    10ba:	df 93       	push	r29
    10bc:	1f 92       	push	r1
    10be:	cd b7       	in	r28, 0x3d	; 61
    10c0:	de b7       	in	r29, 0x3e	; 62
    10c2:	6c 01       	movw	r12, r24
    10c4:	b6 2e       	mov	r11, r22
    10c6:	7a 01       	movw	r14, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    10c8:	86 2f       	mov	r24, r22
    10ca:	83 70       	andi	r24, 0x03	; 3
    10cc:	29 f4       	brne	.+10     	; 0x10d8 <adcch_write_configuration+0x30>
		index += 2;
		ch_mask >>= 2;
    10ce:	96 2f       	mov	r25, r22
    10d0:	96 95       	lsr	r25
    10d2:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    10d4:	82 e0       	ldi	r24, 0x02	; 2
    10d6:	02 c0       	rjmp	.+4      	; 0x10dc <adcch_write_configuration+0x34>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    10d8:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
__always_inline static  ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    10da:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    10dc:	90 ff       	sbrs	r25, 0
		index++;
    10de:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    10e0:	86 01       	movw	r16, r12
    10e2:	00 5e       	subi	r16, 0xE0	; 224
    10e4:	1f 4f       	sbci	r17, 0xFF	; 255
    10e6:	98 e0       	ldi	r25, 0x08	; 8
    10e8:	89 9f       	mul	r24, r25
    10ea:	00 0d       	add	r16, r0
    10ec:	11 1d       	adc	r17, r1
    10ee:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    10f0:	8f b7       	in	r24, 0x3f	; 63
    10f2:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    10f4:	f8 94       	cli
	return flags;
    10f6:	a9 80       	ldd	r10, Y+1	; 0x01
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    10f8:	c6 01       	movw	r24, r12
    10fa:	11 dd       	rcall	.-1502   	; 0xb1e <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    10fc:	f7 01       	movw	r30, r14
    10fe:	80 81       	ld	r24, Z
    1100:	f8 01       	movw	r30, r16
    1102:	80 83       	st	Z, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    1104:	f7 01       	movw	r30, r14
    1106:	82 81       	ldd	r24, Z+2	; 0x02
    1108:	f8 01       	movw	r30, r16
    110a:	82 83       	std	Z+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    110c:	f7 01       	movw	r30, r14
    110e:	81 81       	ldd	r24, Z+1	; 0x01
    1110:	f8 01       	movw	r30, r16
    1112:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1114:	b0 fe       	sbrs	r11, 0
    1116:	04 c0       	rjmp	.+8      	; 0x1120 <adcch_write_configuration+0x78>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    1118:	f7 01       	movw	r30, r14
    111a:	83 81       	ldd	r24, Z+3	; 0x03
    111c:	f8 01       	movw	r30, r16
    111e:	86 83       	std	Z+6, r24	; 0x06
	}
	adc_disable_clock(adc);
    1120:	c6 01       	movw	r24, r12
    1122:	1e dd       	rcall	.-1476   	; 0xb60 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1124:	af be       	out	0x3f, r10	; 63

	cpu_irq_restore(flags);
}
    1126:	0f 90       	pop	r0
    1128:	df 91       	pop	r29
    112a:	cf 91       	pop	r28
    112c:	1f 91       	pop	r17
    112e:	0f 91       	pop	r16
    1130:	ff 90       	pop	r15
    1132:	ef 90       	pop	r14
    1134:	df 90       	pop	r13
    1136:	cf 90       	pop	r12
    1138:	bf 90       	pop	r11
    113a:	af 90       	pop	r10
    113c:	08 95       	ret

0000113e <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    113e:	af 92       	push	r10
    1140:	bf 92       	push	r11
    1142:	cf 92       	push	r12
    1144:	df 92       	push	r13
    1146:	ef 92       	push	r14
    1148:	ff 92       	push	r15
    114a:	0f 93       	push	r16
    114c:	1f 93       	push	r17
    114e:	cf 93       	push	r28
    1150:	df 93       	push	r29
    1152:	1f 92       	push	r1
    1154:	cd b7       	in	r28, 0x3d	; 61
    1156:	de b7       	in	r29, 0x3e	; 62
    1158:	6c 01       	movw	r12, r24
    115a:	b6 2e       	mov	r11, r22
    115c:	7a 01       	movw	r14, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    115e:	86 2f       	mov	r24, r22
    1160:	83 70       	andi	r24, 0x03	; 3
    1162:	29 f4       	brne	.+10     	; 0x116e <adcch_read_configuration+0x30>
		index += 2;
		ch_mask >>= 2;
    1164:	96 2f       	mov	r25, r22
    1166:	96 95       	lsr	r25
    1168:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    116a:	82 e0       	ldi	r24, 0x02	; 2
    116c:	02 c0       	rjmp	.+4      	; 0x1172 <adcch_read_configuration+0x34>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    116e:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
__always_inline static  ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    1170:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    1172:	90 ff       	sbrs	r25, 0
		index++;
    1174:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1176:	86 01       	movw	r16, r12
    1178:	00 5e       	subi	r16, 0xE0	; 224
    117a:	1f 4f       	sbci	r17, 0xFF	; 255
    117c:	98 e0       	ldi	r25, 0x08	; 8
    117e:	89 9f       	mul	r24, r25
    1180:	00 0d       	add	r16, r0
    1182:	11 1d       	adc	r17, r1
    1184:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    1186:	8f b7       	in	r24, 0x3f	; 63
    1188:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    118a:	f8 94       	cli
	return flags;
    118c:	a9 80       	ldd	r10, Y+1	; 0x01

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    118e:	c6 01       	movw	r24, r12
    1190:	c6 dc       	rcall	.-1652   	; 0xb1e <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    1192:	f8 01       	movw	r30, r16
    1194:	80 81       	ld	r24, Z
    1196:	f7 01       	movw	r30, r14
    1198:	80 83       	st	Z, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    119a:	f8 01       	movw	r30, r16
    119c:	82 81       	ldd	r24, Z+2	; 0x02
    119e:	f7 01       	movw	r30, r14
    11a0:	82 83       	std	Z+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    11a2:	f8 01       	movw	r30, r16
    11a4:	81 81       	ldd	r24, Z+1	; 0x01
    11a6:	f7 01       	movw	r30, r14
    11a8:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    11aa:	b0 fe       	sbrs	r11, 0
    11ac:	04 c0       	rjmp	.+8      	; 0x11b6 <adcch_read_configuration+0x78>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    11ae:	f8 01       	movw	r30, r16
    11b0:	86 81       	ldd	r24, Z+6	; 0x06
    11b2:	f7 01       	movw	r30, r14
    11b4:	83 83       	std	Z+3, r24	; 0x03
	}
	adc_disable_clock(adc);
    11b6:	c6 01       	movw	r24, r12
    11b8:	d3 dc       	rcall	.-1626   	; 0xb60 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    11ba:	af be       	out	0x3f, r10	; 63

	cpu_irq_restore(flags);
}
    11bc:	0f 90       	pop	r0
    11be:	df 91       	pop	r29
    11c0:	cf 91       	pop	r28
    11c2:	1f 91       	pop	r17
    11c4:	0f 91       	pop	r16
    11c6:	ff 90       	pop	r15
    11c8:	ef 90       	pop	r14
    11ca:	df 90       	pop	r13
    11cc:	cf 90       	pop	r12
    11ce:	bf 90       	pop	r11
    11d0:	af 90       	pop	r10
    11d2:	08 95       	ret

000011d4 <__vector_15>:
	{
		cpu_irq_restore(iflags);
		return;
	}
	cpu_irq_restore(iflags);
}
    11d4:	1f 92       	push	r1
    11d6:	0f 92       	push	r0
    11d8:	0f b6       	in	r0, 0x3f	; 63
    11da:	0f 92       	push	r0
    11dc:	11 24       	eor	r1, r1
    11de:	0b b6       	in	r0, 0x3b	; 59
    11e0:	0f 92       	push	r0
    11e2:	2f 93       	push	r18
    11e4:	3f 93       	push	r19
    11e6:	4f 93       	push	r20
    11e8:	5f 93       	push	r21
    11ea:	6f 93       	push	r22
    11ec:	7f 93       	push	r23
    11ee:	8f 93       	push	r24
    11f0:	9f 93       	push	r25
    11f2:	af 93       	push	r26
    11f4:	bf 93       	push	r27
    11f6:	ef 93       	push	r30
    11f8:	ff 93       	push	r31
    11fa:	e0 91 66 23 	lds	r30, 0x2366	; 0x802366 <tc_tcc0_err_callback>
    11fe:	f0 91 67 23 	lds	r31, 0x2367	; 0x802367 <tc_tcc0_err_callback+0x1>
    1202:	30 97       	sbiw	r30, 0x00	; 0
    1204:	09 f0       	breq	.+2      	; 0x1208 <__vector_15+0x34>
    1206:	19 95       	eicall
    1208:	ff 91       	pop	r31
    120a:	ef 91       	pop	r30
    120c:	bf 91       	pop	r27
    120e:	af 91       	pop	r26
    1210:	9f 91       	pop	r25
    1212:	8f 91       	pop	r24
    1214:	7f 91       	pop	r23
    1216:	6f 91       	pop	r22
    1218:	5f 91       	pop	r21
    121a:	4f 91       	pop	r20
    121c:	3f 91       	pop	r19
    121e:	2f 91       	pop	r18
    1220:	0f 90       	pop	r0
    1222:	0b be       	out	0x3b, r0	; 59
    1224:	0f 90       	pop	r0
    1226:	0f be       	out	0x3f, r0	; 63
    1228:	0f 90       	pop	r0
    122a:	1f 90       	pop	r1
    122c:	18 95       	reti

0000122e <__vector_16>:
    122e:	1f 92       	push	r1
    1230:	0f 92       	push	r0
    1232:	0f b6       	in	r0, 0x3f	; 63
    1234:	0f 92       	push	r0
    1236:	11 24       	eor	r1, r1
    1238:	0b b6       	in	r0, 0x3b	; 59
    123a:	0f 92       	push	r0
    123c:	2f 93       	push	r18
    123e:	3f 93       	push	r19
    1240:	4f 93       	push	r20
    1242:	5f 93       	push	r21
    1244:	6f 93       	push	r22
    1246:	7f 93       	push	r23
    1248:	8f 93       	push	r24
    124a:	9f 93       	push	r25
    124c:	af 93       	push	r26
    124e:	bf 93       	push	r27
    1250:	ef 93       	push	r30
    1252:	ff 93       	push	r31
    1254:	e0 91 64 23 	lds	r30, 0x2364	; 0x802364 <tc_tcc0_cca_callback>
    1258:	f0 91 65 23 	lds	r31, 0x2365	; 0x802365 <tc_tcc0_cca_callback+0x1>
    125c:	30 97       	sbiw	r30, 0x00	; 0
    125e:	09 f0       	breq	.+2      	; 0x1262 <__vector_16+0x34>
    1260:	19 95       	eicall
    1262:	ff 91       	pop	r31
    1264:	ef 91       	pop	r30
    1266:	bf 91       	pop	r27
    1268:	af 91       	pop	r26
    126a:	9f 91       	pop	r25
    126c:	8f 91       	pop	r24
    126e:	7f 91       	pop	r23
    1270:	6f 91       	pop	r22
    1272:	5f 91       	pop	r21
    1274:	4f 91       	pop	r20
    1276:	3f 91       	pop	r19
    1278:	2f 91       	pop	r18
    127a:	0f 90       	pop	r0
    127c:	0b be       	out	0x3b, r0	; 59
    127e:	0f 90       	pop	r0
    1280:	0f be       	out	0x3f, r0	; 63
    1282:	0f 90       	pop	r0
    1284:	1f 90       	pop	r1
    1286:	18 95       	reti

00001288 <__vector_17>:
    1288:	1f 92       	push	r1
    128a:	0f 92       	push	r0
    128c:	0f b6       	in	r0, 0x3f	; 63
    128e:	0f 92       	push	r0
    1290:	11 24       	eor	r1, r1
    1292:	0b b6       	in	r0, 0x3b	; 59
    1294:	0f 92       	push	r0
    1296:	2f 93       	push	r18
    1298:	3f 93       	push	r19
    129a:	4f 93       	push	r20
    129c:	5f 93       	push	r21
    129e:	6f 93       	push	r22
    12a0:	7f 93       	push	r23
    12a2:	8f 93       	push	r24
    12a4:	9f 93       	push	r25
    12a6:	af 93       	push	r26
    12a8:	bf 93       	push	r27
    12aa:	ef 93       	push	r30
    12ac:	ff 93       	push	r31
    12ae:	e0 91 62 23 	lds	r30, 0x2362	; 0x802362 <tc_tcc0_ccb_callback>
    12b2:	f0 91 63 23 	lds	r31, 0x2363	; 0x802363 <tc_tcc0_ccb_callback+0x1>
    12b6:	30 97       	sbiw	r30, 0x00	; 0
    12b8:	09 f0       	breq	.+2      	; 0x12bc <__vector_17+0x34>
    12ba:	19 95       	eicall
    12bc:	ff 91       	pop	r31
    12be:	ef 91       	pop	r30
    12c0:	bf 91       	pop	r27
    12c2:	af 91       	pop	r26
    12c4:	9f 91       	pop	r25
    12c6:	8f 91       	pop	r24
    12c8:	7f 91       	pop	r23
    12ca:	6f 91       	pop	r22
    12cc:	5f 91       	pop	r21
    12ce:	4f 91       	pop	r20
    12d0:	3f 91       	pop	r19
    12d2:	2f 91       	pop	r18
    12d4:	0f 90       	pop	r0
    12d6:	0b be       	out	0x3b, r0	; 59
    12d8:	0f 90       	pop	r0
    12da:	0f be       	out	0x3f, r0	; 63
    12dc:	0f 90       	pop	r0
    12de:	1f 90       	pop	r1
    12e0:	18 95       	reti

000012e2 <__vector_18>:
    12e2:	1f 92       	push	r1
    12e4:	0f 92       	push	r0
    12e6:	0f b6       	in	r0, 0x3f	; 63
    12e8:	0f 92       	push	r0
    12ea:	11 24       	eor	r1, r1
    12ec:	0b b6       	in	r0, 0x3b	; 59
    12ee:	0f 92       	push	r0
    12f0:	2f 93       	push	r18
    12f2:	3f 93       	push	r19
    12f4:	4f 93       	push	r20
    12f6:	5f 93       	push	r21
    12f8:	6f 93       	push	r22
    12fa:	7f 93       	push	r23
    12fc:	8f 93       	push	r24
    12fe:	9f 93       	push	r25
    1300:	af 93       	push	r26
    1302:	bf 93       	push	r27
    1304:	ef 93       	push	r30
    1306:	ff 93       	push	r31
    1308:	e0 91 60 23 	lds	r30, 0x2360	; 0x802360 <tc_tcc0_ccc_callback>
    130c:	f0 91 61 23 	lds	r31, 0x2361	; 0x802361 <tc_tcc0_ccc_callback+0x1>
    1310:	30 97       	sbiw	r30, 0x00	; 0
    1312:	09 f0       	breq	.+2      	; 0x1316 <__vector_18+0x34>
    1314:	19 95       	eicall
    1316:	ff 91       	pop	r31
    1318:	ef 91       	pop	r30
    131a:	bf 91       	pop	r27
    131c:	af 91       	pop	r26
    131e:	9f 91       	pop	r25
    1320:	8f 91       	pop	r24
    1322:	7f 91       	pop	r23
    1324:	6f 91       	pop	r22
    1326:	5f 91       	pop	r21
    1328:	4f 91       	pop	r20
    132a:	3f 91       	pop	r19
    132c:	2f 91       	pop	r18
    132e:	0f 90       	pop	r0
    1330:	0b be       	out	0x3b, r0	; 59
    1332:	0f 90       	pop	r0
    1334:	0f be       	out	0x3f, r0	; 63
    1336:	0f 90       	pop	r0
    1338:	1f 90       	pop	r1
    133a:	18 95       	reti

0000133c <__vector_19>:
    133c:	1f 92       	push	r1
    133e:	0f 92       	push	r0
    1340:	0f b6       	in	r0, 0x3f	; 63
    1342:	0f 92       	push	r0
    1344:	11 24       	eor	r1, r1
    1346:	0b b6       	in	r0, 0x3b	; 59
    1348:	0f 92       	push	r0
    134a:	2f 93       	push	r18
    134c:	3f 93       	push	r19
    134e:	4f 93       	push	r20
    1350:	5f 93       	push	r21
    1352:	6f 93       	push	r22
    1354:	7f 93       	push	r23
    1356:	8f 93       	push	r24
    1358:	9f 93       	push	r25
    135a:	af 93       	push	r26
    135c:	bf 93       	push	r27
    135e:	ef 93       	push	r30
    1360:	ff 93       	push	r31
    1362:	e0 91 5e 23 	lds	r30, 0x235E	; 0x80235e <tc_tcc0_ccd_callback>
    1366:	f0 91 5f 23 	lds	r31, 0x235F	; 0x80235f <tc_tcc0_ccd_callback+0x1>
    136a:	30 97       	sbiw	r30, 0x00	; 0
    136c:	09 f0       	breq	.+2      	; 0x1370 <__vector_19+0x34>
    136e:	19 95       	eicall
    1370:	ff 91       	pop	r31
    1372:	ef 91       	pop	r30
    1374:	bf 91       	pop	r27
    1376:	af 91       	pop	r26
    1378:	9f 91       	pop	r25
    137a:	8f 91       	pop	r24
    137c:	7f 91       	pop	r23
    137e:	6f 91       	pop	r22
    1380:	5f 91       	pop	r21
    1382:	4f 91       	pop	r20
    1384:	3f 91       	pop	r19
    1386:	2f 91       	pop	r18
    1388:	0f 90       	pop	r0
    138a:	0b be       	out	0x3b, r0	; 59
    138c:	0f 90       	pop	r0
    138e:	0f be       	out	0x3f, r0	; 63
    1390:	0f 90       	pop	r0
    1392:	1f 90       	pop	r1
    1394:	18 95       	reti

00001396 <__vector_20>:
    1396:	1f 92       	push	r1
    1398:	0f 92       	push	r0
    139a:	0f b6       	in	r0, 0x3f	; 63
    139c:	0f 92       	push	r0
    139e:	11 24       	eor	r1, r1
    13a0:	0b b6       	in	r0, 0x3b	; 59
    13a2:	0f 92       	push	r0
    13a4:	2f 93       	push	r18
    13a6:	3f 93       	push	r19
    13a8:	4f 93       	push	r20
    13aa:	5f 93       	push	r21
    13ac:	6f 93       	push	r22
    13ae:	7f 93       	push	r23
    13b0:	8f 93       	push	r24
    13b2:	9f 93       	push	r25
    13b4:	af 93       	push	r26
    13b6:	bf 93       	push	r27
    13b8:	ef 93       	push	r30
    13ba:	ff 93       	push	r31
    13bc:	e0 91 5c 23 	lds	r30, 0x235C	; 0x80235c <tc_tcc1_ovf_callback>
    13c0:	f0 91 5d 23 	lds	r31, 0x235D	; 0x80235d <tc_tcc1_ovf_callback+0x1>
    13c4:	30 97       	sbiw	r30, 0x00	; 0
    13c6:	09 f0       	breq	.+2      	; 0x13ca <__vector_20+0x34>
    13c8:	19 95       	eicall
    13ca:	ff 91       	pop	r31
    13cc:	ef 91       	pop	r30
    13ce:	bf 91       	pop	r27
    13d0:	af 91       	pop	r26
    13d2:	9f 91       	pop	r25
    13d4:	8f 91       	pop	r24
    13d6:	7f 91       	pop	r23
    13d8:	6f 91       	pop	r22
    13da:	5f 91       	pop	r21
    13dc:	4f 91       	pop	r20
    13de:	3f 91       	pop	r19
    13e0:	2f 91       	pop	r18
    13e2:	0f 90       	pop	r0
    13e4:	0b be       	out	0x3b, r0	; 59
    13e6:	0f 90       	pop	r0
    13e8:	0f be       	out	0x3f, r0	; 63
    13ea:	0f 90       	pop	r0
    13ec:	1f 90       	pop	r1
    13ee:	18 95       	reti

000013f0 <__vector_21>:
    13f0:	1f 92       	push	r1
    13f2:	0f 92       	push	r0
    13f4:	0f b6       	in	r0, 0x3f	; 63
    13f6:	0f 92       	push	r0
    13f8:	11 24       	eor	r1, r1
    13fa:	0b b6       	in	r0, 0x3b	; 59
    13fc:	0f 92       	push	r0
    13fe:	2f 93       	push	r18
    1400:	3f 93       	push	r19
    1402:	4f 93       	push	r20
    1404:	5f 93       	push	r21
    1406:	6f 93       	push	r22
    1408:	7f 93       	push	r23
    140a:	8f 93       	push	r24
    140c:	9f 93       	push	r25
    140e:	af 93       	push	r26
    1410:	bf 93       	push	r27
    1412:	ef 93       	push	r30
    1414:	ff 93       	push	r31
    1416:	e0 91 5a 23 	lds	r30, 0x235A	; 0x80235a <tc_tcc1_err_callback>
    141a:	f0 91 5b 23 	lds	r31, 0x235B	; 0x80235b <tc_tcc1_err_callback+0x1>
    141e:	30 97       	sbiw	r30, 0x00	; 0
    1420:	09 f0       	breq	.+2      	; 0x1424 <__vector_21+0x34>
    1422:	19 95       	eicall
    1424:	ff 91       	pop	r31
    1426:	ef 91       	pop	r30
    1428:	bf 91       	pop	r27
    142a:	af 91       	pop	r26
    142c:	9f 91       	pop	r25
    142e:	8f 91       	pop	r24
    1430:	7f 91       	pop	r23
    1432:	6f 91       	pop	r22
    1434:	5f 91       	pop	r21
    1436:	4f 91       	pop	r20
    1438:	3f 91       	pop	r19
    143a:	2f 91       	pop	r18
    143c:	0f 90       	pop	r0
    143e:	0b be       	out	0x3b, r0	; 59
    1440:	0f 90       	pop	r0
    1442:	0f be       	out	0x3f, r0	; 63
    1444:	0f 90       	pop	r0
    1446:	1f 90       	pop	r1
    1448:	18 95       	reti

0000144a <__vector_22>:
    144a:	1f 92       	push	r1
    144c:	0f 92       	push	r0
    144e:	0f b6       	in	r0, 0x3f	; 63
    1450:	0f 92       	push	r0
    1452:	11 24       	eor	r1, r1
    1454:	0b b6       	in	r0, 0x3b	; 59
    1456:	0f 92       	push	r0
    1458:	2f 93       	push	r18
    145a:	3f 93       	push	r19
    145c:	4f 93       	push	r20
    145e:	5f 93       	push	r21
    1460:	6f 93       	push	r22
    1462:	7f 93       	push	r23
    1464:	8f 93       	push	r24
    1466:	9f 93       	push	r25
    1468:	af 93       	push	r26
    146a:	bf 93       	push	r27
    146c:	ef 93       	push	r30
    146e:	ff 93       	push	r31
    1470:	e0 91 58 23 	lds	r30, 0x2358	; 0x802358 <tc_tcc1_cca_callback>
    1474:	f0 91 59 23 	lds	r31, 0x2359	; 0x802359 <tc_tcc1_cca_callback+0x1>
    1478:	30 97       	sbiw	r30, 0x00	; 0
    147a:	09 f0       	breq	.+2      	; 0x147e <__vector_22+0x34>
    147c:	19 95       	eicall
    147e:	ff 91       	pop	r31
    1480:	ef 91       	pop	r30
    1482:	bf 91       	pop	r27
    1484:	af 91       	pop	r26
    1486:	9f 91       	pop	r25
    1488:	8f 91       	pop	r24
    148a:	7f 91       	pop	r23
    148c:	6f 91       	pop	r22
    148e:	5f 91       	pop	r21
    1490:	4f 91       	pop	r20
    1492:	3f 91       	pop	r19
    1494:	2f 91       	pop	r18
    1496:	0f 90       	pop	r0
    1498:	0b be       	out	0x3b, r0	; 59
    149a:	0f 90       	pop	r0
    149c:	0f be       	out	0x3f, r0	; 63
    149e:	0f 90       	pop	r0
    14a0:	1f 90       	pop	r1
    14a2:	18 95       	reti

000014a4 <__vector_23>:
    14a4:	1f 92       	push	r1
    14a6:	0f 92       	push	r0
    14a8:	0f b6       	in	r0, 0x3f	; 63
    14aa:	0f 92       	push	r0
    14ac:	11 24       	eor	r1, r1
    14ae:	0b b6       	in	r0, 0x3b	; 59
    14b0:	0f 92       	push	r0
    14b2:	2f 93       	push	r18
    14b4:	3f 93       	push	r19
    14b6:	4f 93       	push	r20
    14b8:	5f 93       	push	r21
    14ba:	6f 93       	push	r22
    14bc:	7f 93       	push	r23
    14be:	8f 93       	push	r24
    14c0:	9f 93       	push	r25
    14c2:	af 93       	push	r26
    14c4:	bf 93       	push	r27
    14c6:	ef 93       	push	r30
    14c8:	ff 93       	push	r31
    14ca:	e0 91 56 23 	lds	r30, 0x2356	; 0x802356 <tc_tcc1_ccb_callback>
    14ce:	f0 91 57 23 	lds	r31, 0x2357	; 0x802357 <tc_tcc1_ccb_callback+0x1>
    14d2:	30 97       	sbiw	r30, 0x00	; 0
    14d4:	09 f0       	breq	.+2      	; 0x14d8 <__vector_23+0x34>
    14d6:	19 95       	eicall
    14d8:	ff 91       	pop	r31
    14da:	ef 91       	pop	r30
    14dc:	bf 91       	pop	r27
    14de:	af 91       	pop	r26
    14e0:	9f 91       	pop	r25
    14e2:	8f 91       	pop	r24
    14e4:	7f 91       	pop	r23
    14e6:	6f 91       	pop	r22
    14e8:	5f 91       	pop	r21
    14ea:	4f 91       	pop	r20
    14ec:	3f 91       	pop	r19
    14ee:	2f 91       	pop	r18
    14f0:	0f 90       	pop	r0
    14f2:	0b be       	out	0x3b, r0	; 59
    14f4:	0f 90       	pop	r0
    14f6:	0f be       	out	0x3f, r0	; 63
    14f8:	0f 90       	pop	r0
    14fa:	1f 90       	pop	r1
    14fc:	18 95       	reti

000014fe <__vector_77>:
    14fe:	1f 92       	push	r1
    1500:	0f 92       	push	r0
    1502:	0f b6       	in	r0, 0x3f	; 63
    1504:	0f 92       	push	r0
    1506:	11 24       	eor	r1, r1
    1508:	0b b6       	in	r0, 0x3b	; 59
    150a:	0f 92       	push	r0
    150c:	2f 93       	push	r18
    150e:	3f 93       	push	r19
    1510:	4f 93       	push	r20
    1512:	5f 93       	push	r21
    1514:	6f 93       	push	r22
    1516:	7f 93       	push	r23
    1518:	8f 93       	push	r24
    151a:	9f 93       	push	r25
    151c:	af 93       	push	r26
    151e:	bf 93       	push	r27
    1520:	ef 93       	push	r30
    1522:	ff 93       	push	r31
    1524:	e0 91 54 23 	lds	r30, 0x2354	; 0x802354 <tc_tcd0_ovf_callback>
    1528:	f0 91 55 23 	lds	r31, 0x2355	; 0x802355 <tc_tcd0_ovf_callback+0x1>
    152c:	30 97       	sbiw	r30, 0x00	; 0
    152e:	09 f0       	breq	.+2      	; 0x1532 <__vector_77+0x34>
    1530:	19 95       	eicall
    1532:	ff 91       	pop	r31
    1534:	ef 91       	pop	r30
    1536:	bf 91       	pop	r27
    1538:	af 91       	pop	r26
    153a:	9f 91       	pop	r25
    153c:	8f 91       	pop	r24
    153e:	7f 91       	pop	r23
    1540:	6f 91       	pop	r22
    1542:	5f 91       	pop	r21
    1544:	4f 91       	pop	r20
    1546:	3f 91       	pop	r19
    1548:	2f 91       	pop	r18
    154a:	0f 90       	pop	r0
    154c:	0b be       	out	0x3b, r0	; 59
    154e:	0f 90       	pop	r0
    1550:	0f be       	out	0x3f, r0	; 63
    1552:	0f 90       	pop	r0
    1554:	1f 90       	pop	r1
    1556:	18 95       	reti

00001558 <__vector_78>:
    1558:	1f 92       	push	r1
    155a:	0f 92       	push	r0
    155c:	0f b6       	in	r0, 0x3f	; 63
    155e:	0f 92       	push	r0
    1560:	11 24       	eor	r1, r1
    1562:	0b b6       	in	r0, 0x3b	; 59
    1564:	0f 92       	push	r0
    1566:	2f 93       	push	r18
    1568:	3f 93       	push	r19
    156a:	4f 93       	push	r20
    156c:	5f 93       	push	r21
    156e:	6f 93       	push	r22
    1570:	7f 93       	push	r23
    1572:	8f 93       	push	r24
    1574:	9f 93       	push	r25
    1576:	af 93       	push	r26
    1578:	bf 93       	push	r27
    157a:	ef 93       	push	r30
    157c:	ff 93       	push	r31
    157e:	e0 91 52 23 	lds	r30, 0x2352	; 0x802352 <tc_tcd0_err_callback>
    1582:	f0 91 53 23 	lds	r31, 0x2353	; 0x802353 <tc_tcd0_err_callback+0x1>
    1586:	30 97       	sbiw	r30, 0x00	; 0
    1588:	09 f0       	breq	.+2      	; 0x158c <__vector_78+0x34>
    158a:	19 95       	eicall
    158c:	ff 91       	pop	r31
    158e:	ef 91       	pop	r30
    1590:	bf 91       	pop	r27
    1592:	af 91       	pop	r26
    1594:	9f 91       	pop	r25
    1596:	8f 91       	pop	r24
    1598:	7f 91       	pop	r23
    159a:	6f 91       	pop	r22
    159c:	5f 91       	pop	r21
    159e:	4f 91       	pop	r20
    15a0:	3f 91       	pop	r19
    15a2:	2f 91       	pop	r18
    15a4:	0f 90       	pop	r0
    15a6:	0b be       	out	0x3b, r0	; 59
    15a8:	0f 90       	pop	r0
    15aa:	0f be       	out	0x3f, r0	; 63
    15ac:	0f 90       	pop	r0
    15ae:	1f 90       	pop	r1
    15b0:	18 95       	reti

000015b2 <__vector_79>:
    15b2:	1f 92       	push	r1
    15b4:	0f 92       	push	r0
    15b6:	0f b6       	in	r0, 0x3f	; 63
    15b8:	0f 92       	push	r0
    15ba:	11 24       	eor	r1, r1
    15bc:	0b b6       	in	r0, 0x3b	; 59
    15be:	0f 92       	push	r0
    15c0:	2f 93       	push	r18
    15c2:	3f 93       	push	r19
    15c4:	4f 93       	push	r20
    15c6:	5f 93       	push	r21
    15c8:	6f 93       	push	r22
    15ca:	7f 93       	push	r23
    15cc:	8f 93       	push	r24
    15ce:	9f 93       	push	r25
    15d0:	af 93       	push	r26
    15d2:	bf 93       	push	r27
    15d4:	ef 93       	push	r30
    15d6:	ff 93       	push	r31
    15d8:	e0 91 50 23 	lds	r30, 0x2350	; 0x802350 <tc_tcd0_cca_callback>
    15dc:	f0 91 51 23 	lds	r31, 0x2351	; 0x802351 <tc_tcd0_cca_callback+0x1>
    15e0:	30 97       	sbiw	r30, 0x00	; 0
    15e2:	09 f0       	breq	.+2      	; 0x15e6 <__vector_79+0x34>
    15e4:	19 95       	eicall
    15e6:	ff 91       	pop	r31
    15e8:	ef 91       	pop	r30
    15ea:	bf 91       	pop	r27
    15ec:	af 91       	pop	r26
    15ee:	9f 91       	pop	r25
    15f0:	8f 91       	pop	r24
    15f2:	7f 91       	pop	r23
    15f4:	6f 91       	pop	r22
    15f6:	5f 91       	pop	r21
    15f8:	4f 91       	pop	r20
    15fa:	3f 91       	pop	r19
    15fc:	2f 91       	pop	r18
    15fe:	0f 90       	pop	r0
    1600:	0b be       	out	0x3b, r0	; 59
    1602:	0f 90       	pop	r0
    1604:	0f be       	out	0x3f, r0	; 63
    1606:	0f 90       	pop	r0
    1608:	1f 90       	pop	r1
    160a:	18 95       	reti

0000160c <__vector_80>:
    160c:	1f 92       	push	r1
    160e:	0f 92       	push	r0
    1610:	0f b6       	in	r0, 0x3f	; 63
    1612:	0f 92       	push	r0
    1614:	11 24       	eor	r1, r1
    1616:	0b b6       	in	r0, 0x3b	; 59
    1618:	0f 92       	push	r0
    161a:	2f 93       	push	r18
    161c:	3f 93       	push	r19
    161e:	4f 93       	push	r20
    1620:	5f 93       	push	r21
    1622:	6f 93       	push	r22
    1624:	7f 93       	push	r23
    1626:	8f 93       	push	r24
    1628:	9f 93       	push	r25
    162a:	af 93       	push	r26
    162c:	bf 93       	push	r27
    162e:	ef 93       	push	r30
    1630:	ff 93       	push	r31
    1632:	e0 91 4e 23 	lds	r30, 0x234E	; 0x80234e <tc_tcd0_ccb_callback>
    1636:	f0 91 4f 23 	lds	r31, 0x234F	; 0x80234f <tc_tcd0_ccb_callback+0x1>
    163a:	30 97       	sbiw	r30, 0x00	; 0
    163c:	09 f0       	breq	.+2      	; 0x1640 <__vector_80+0x34>
    163e:	19 95       	eicall
    1640:	ff 91       	pop	r31
    1642:	ef 91       	pop	r30
    1644:	bf 91       	pop	r27
    1646:	af 91       	pop	r26
    1648:	9f 91       	pop	r25
    164a:	8f 91       	pop	r24
    164c:	7f 91       	pop	r23
    164e:	6f 91       	pop	r22
    1650:	5f 91       	pop	r21
    1652:	4f 91       	pop	r20
    1654:	3f 91       	pop	r19
    1656:	2f 91       	pop	r18
    1658:	0f 90       	pop	r0
    165a:	0b be       	out	0x3b, r0	; 59
    165c:	0f 90       	pop	r0
    165e:	0f be       	out	0x3f, r0	; 63
    1660:	0f 90       	pop	r0
    1662:	1f 90       	pop	r1
    1664:	18 95       	reti

00001666 <__vector_81>:
    1666:	1f 92       	push	r1
    1668:	0f 92       	push	r0
    166a:	0f b6       	in	r0, 0x3f	; 63
    166c:	0f 92       	push	r0
    166e:	11 24       	eor	r1, r1
    1670:	0b b6       	in	r0, 0x3b	; 59
    1672:	0f 92       	push	r0
    1674:	2f 93       	push	r18
    1676:	3f 93       	push	r19
    1678:	4f 93       	push	r20
    167a:	5f 93       	push	r21
    167c:	6f 93       	push	r22
    167e:	7f 93       	push	r23
    1680:	8f 93       	push	r24
    1682:	9f 93       	push	r25
    1684:	af 93       	push	r26
    1686:	bf 93       	push	r27
    1688:	ef 93       	push	r30
    168a:	ff 93       	push	r31
    168c:	e0 91 4c 23 	lds	r30, 0x234C	; 0x80234c <tc_tcd0_ccc_callback>
    1690:	f0 91 4d 23 	lds	r31, 0x234D	; 0x80234d <tc_tcd0_ccc_callback+0x1>
    1694:	30 97       	sbiw	r30, 0x00	; 0
    1696:	09 f0       	breq	.+2      	; 0x169a <__vector_81+0x34>
    1698:	19 95       	eicall
    169a:	ff 91       	pop	r31
    169c:	ef 91       	pop	r30
    169e:	bf 91       	pop	r27
    16a0:	af 91       	pop	r26
    16a2:	9f 91       	pop	r25
    16a4:	8f 91       	pop	r24
    16a6:	7f 91       	pop	r23
    16a8:	6f 91       	pop	r22
    16aa:	5f 91       	pop	r21
    16ac:	4f 91       	pop	r20
    16ae:	3f 91       	pop	r19
    16b0:	2f 91       	pop	r18
    16b2:	0f 90       	pop	r0
    16b4:	0b be       	out	0x3b, r0	; 59
    16b6:	0f 90       	pop	r0
    16b8:	0f be       	out	0x3f, r0	; 63
    16ba:	0f 90       	pop	r0
    16bc:	1f 90       	pop	r1
    16be:	18 95       	reti

000016c0 <__vector_82>:
    16c0:	1f 92       	push	r1
    16c2:	0f 92       	push	r0
    16c4:	0f b6       	in	r0, 0x3f	; 63
    16c6:	0f 92       	push	r0
    16c8:	11 24       	eor	r1, r1
    16ca:	0b b6       	in	r0, 0x3b	; 59
    16cc:	0f 92       	push	r0
    16ce:	2f 93       	push	r18
    16d0:	3f 93       	push	r19
    16d2:	4f 93       	push	r20
    16d4:	5f 93       	push	r21
    16d6:	6f 93       	push	r22
    16d8:	7f 93       	push	r23
    16da:	8f 93       	push	r24
    16dc:	9f 93       	push	r25
    16de:	af 93       	push	r26
    16e0:	bf 93       	push	r27
    16e2:	ef 93       	push	r30
    16e4:	ff 93       	push	r31
    16e6:	e0 91 4a 23 	lds	r30, 0x234A	; 0x80234a <tc_tcd0_ccd_callback>
    16ea:	f0 91 4b 23 	lds	r31, 0x234B	; 0x80234b <tc_tcd0_ccd_callback+0x1>
    16ee:	30 97       	sbiw	r30, 0x00	; 0
    16f0:	09 f0       	breq	.+2      	; 0x16f4 <__vector_82+0x34>
    16f2:	19 95       	eicall
    16f4:	ff 91       	pop	r31
    16f6:	ef 91       	pop	r30
    16f8:	bf 91       	pop	r27
    16fa:	af 91       	pop	r26
    16fc:	9f 91       	pop	r25
    16fe:	8f 91       	pop	r24
    1700:	7f 91       	pop	r23
    1702:	6f 91       	pop	r22
    1704:	5f 91       	pop	r21
    1706:	4f 91       	pop	r20
    1708:	3f 91       	pop	r19
    170a:	2f 91       	pop	r18
    170c:	0f 90       	pop	r0
    170e:	0b be       	out	0x3b, r0	; 59
    1710:	0f 90       	pop	r0
    1712:	0f be       	out	0x3f, r0	; 63
    1714:	0f 90       	pop	r0
    1716:	1f 90       	pop	r1
    1718:	18 95       	reti

0000171a <__vector_83>:
    171a:	1f 92       	push	r1
    171c:	0f 92       	push	r0
    171e:	0f b6       	in	r0, 0x3f	; 63
    1720:	0f 92       	push	r0
    1722:	11 24       	eor	r1, r1
    1724:	0b b6       	in	r0, 0x3b	; 59
    1726:	0f 92       	push	r0
    1728:	2f 93       	push	r18
    172a:	3f 93       	push	r19
    172c:	4f 93       	push	r20
    172e:	5f 93       	push	r21
    1730:	6f 93       	push	r22
    1732:	7f 93       	push	r23
    1734:	8f 93       	push	r24
    1736:	9f 93       	push	r25
    1738:	af 93       	push	r26
    173a:	bf 93       	push	r27
    173c:	ef 93       	push	r30
    173e:	ff 93       	push	r31
    1740:	e0 91 48 23 	lds	r30, 0x2348	; 0x802348 <tc_tcd1_ovf_callback>
    1744:	f0 91 49 23 	lds	r31, 0x2349	; 0x802349 <tc_tcd1_ovf_callback+0x1>
    1748:	30 97       	sbiw	r30, 0x00	; 0
    174a:	09 f0       	breq	.+2      	; 0x174e <__vector_83+0x34>
    174c:	19 95       	eicall
    174e:	ff 91       	pop	r31
    1750:	ef 91       	pop	r30
    1752:	bf 91       	pop	r27
    1754:	af 91       	pop	r26
    1756:	9f 91       	pop	r25
    1758:	8f 91       	pop	r24
    175a:	7f 91       	pop	r23
    175c:	6f 91       	pop	r22
    175e:	5f 91       	pop	r21
    1760:	4f 91       	pop	r20
    1762:	3f 91       	pop	r19
    1764:	2f 91       	pop	r18
    1766:	0f 90       	pop	r0
    1768:	0b be       	out	0x3b, r0	; 59
    176a:	0f 90       	pop	r0
    176c:	0f be       	out	0x3f, r0	; 63
    176e:	0f 90       	pop	r0
    1770:	1f 90       	pop	r1
    1772:	18 95       	reti

00001774 <__vector_84>:
    1774:	1f 92       	push	r1
    1776:	0f 92       	push	r0
    1778:	0f b6       	in	r0, 0x3f	; 63
    177a:	0f 92       	push	r0
    177c:	11 24       	eor	r1, r1
    177e:	0b b6       	in	r0, 0x3b	; 59
    1780:	0f 92       	push	r0
    1782:	2f 93       	push	r18
    1784:	3f 93       	push	r19
    1786:	4f 93       	push	r20
    1788:	5f 93       	push	r21
    178a:	6f 93       	push	r22
    178c:	7f 93       	push	r23
    178e:	8f 93       	push	r24
    1790:	9f 93       	push	r25
    1792:	af 93       	push	r26
    1794:	bf 93       	push	r27
    1796:	ef 93       	push	r30
    1798:	ff 93       	push	r31
    179a:	e0 91 46 23 	lds	r30, 0x2346	; 0x802346 <tc_tcd1_err_callback>
    179e:	f0 91 47 23 	lds	r31, 0x2347	; 0x802347 <tc_tcd1_err_callback+0x1>
    17a2:	30 97       	sbiw	r30, 0x00	; 0
    17a4:	09 f0       	breq	.+2      	; 0x17a8 <__vector_84+0x34>
    17a6:	19 95       	eicall
    17a8:	ff 91       	pop	r31
    17aa:	ef 91       	pop	r30
    17ac:	bf 91       	pop	r27
    17ae:	af 91       	pop	r26
    17b0:	9f 91       	pop	r25
    17b2:	8f 91       	pop	r24
    17b4:	7f 91       	pop	r23
    17b6:	6f 91       	pop	r22
    17b8:	5f 91       	pop	r21
    17ba:	4f 91       	pop	r20
    17bc:	3f 91       	pop	r19
    17be:	2f 91       	pop	r18
    17c0:	0f 90       	pop	r0
    17c2:	0b be       	out	0x3b, r0	; 59
    17c4:	0f 90       	pop	r0
    17c6:	0f be       	out	0x3f, r0	; 63
    17c8:	0f 90       	pop	r0
    17ca:	1f 90       	pop	r1
    17cc:	18 95       	reti

000017ce <__vector_85>:
    17ce:	1f 92       	push	r1
    17d0:	0f 92       	push	r0
    17d2:	0f b6       	in	r0, 0x3f	; 63
    17d4:	0f 92       	push	r0
    17d6:	11 24       	eor	r1, r1
    17d8:	0b b6       	in	r0, 0x3b	; 59
    17da:	0f 92       	push	r0
    17dc:	2f 93       	push	r18
    17de:	3f 93       	push	r19
    17e0:	4f 93       	push	r20
    17e2:	5f 93       	push	r21
    17e4:	6f 93       	push	r22
    17e6:	7f 93       	push	r23
    17e8:	8f 93       	push	r24
    17ea:	9f 93       	push	r25
    17ec:	af 93       	push	r26
    17ee:	bf 93       	push	r27
    17f0:	ef 93       	push	r30
    17f2:	ff 93       	push	r31
    17f4:	e0 91 44 23 	lds	r30, 0x2344	; 0x802344 <tc_tcd1_cca_callback>
    17f8:	f0 91 45 23 	lds	r31, 0x2345	; 0x802345 <tc_tcd1_cca_callback+0x1>
    17fc:	30 97       	sbiw	r30, 0x00	; 0
    17fe:	09 f0       	breq	.+2      	; 0x1802 <__vector_85+0x34>
    1800:	19 95       	eicall
    1802:	ff 91       	pop	r31
    1804:	ef 91       	pop	r30
    1806:	bf 91       	pop	r27
    1808:	af 91       	pop	r26
    180a:	9f 91       	pop	r25
    180c:	8f 91       	pop	r24
    180e:	7f 91       	pop	r23
    1810:	6f 91       	pop	r22
    1812:	5f 91       	pop	r21
    1814:	4f 91       	pop	r20
    1816:	3f 91       	pop	r19
    1818:	2f 91       	pop	r18
    181a:	0f 90       	pop	r0
    181c:	0b be       	out	0x3b, r0	; 59
    181e:	0f 90       	pop	r0
    1820:	0f be       	out	0x3f, r0	; 63
    1822:	0f 90       	pop	r0
    1824:	1f 90       	pop	r1
    1826:	18 95       	reti

00001828 <__vector_86>:
    1828:	1f 92       	push	r1
    182a:	0f 92       	push	r0
    182c:	0f b6       	in	r0, 0x3f	; 63
    182e:	0f 92       	push	r0
    1830:	11 24       	eor	r1, r1
    1832:	0b b6       	in	r0, 0x3b	; 59
    1834:	0f 92       	push	r0
    1836:	2f 93       	push	r18
    1838:	3f 93       	push	r19
    183a:	4f 93       	push	r20
    183c:	5f 93       	push	r21
    183e:	6f 93       	push	r22
    1840:	7f 93       	push	r23
    1842:	8f 93       	push	r24
    1844:	9f 93       	push	r25
    1846:	af 93       	push	r26
    1848:	bf 93       	push	r27
    184a:	ef 93       	push	r30
    184c:	ff 93       	push	r31
    184e:	e0 91 42 23 	lds	r30, 0x2342	; 0x802342 <tc_tcd1_ccb_callback>
    1852:	f0 91 43 23 	lds	r31, 0x2343	; 0x802343 <tc_tcd1_ccb_callback+0x1>
    1856:	30 97       	sbiw	r30, 0x00	; 0
    1858:	09 f0       	breq	.+2      	; 0x185c <__vector_86+0x34>
    185a:	19 95       	eicall
    185c:	ff 91       	pop	r31
    185e:	ef 91       	pop	r30
    1860:	bf 91       	pop	r27
    1862:	af 91       	pop	r26
    1864:	9f 91       	pop	r25
    1866:	8f 91       	pop	r24
    1868:	7f 91       	pop	r23
    186a:	6f 91       	pop	r22
    186c:	5f 91       	pop	r21
    186e:	4f 91       	pop	r20
    1870:	3f 91       	pop	r19
    1872:	2f 91       	pop	r18
    1874:	0f 90       	pop	r0
    1876:	0b be       	out	0x3b, r0	; 59
    1878:	0f 90       	pop	r0
    187a:	0f be       	out	0x3f, r0	; 63
    187c:	0f 90       	pop	r0
    187e:	1f 90       	pop	r1
    1880:	18 95       	reti

00001882 <__vector_47>:
    1882:	1f 92       	push	r1
    1884:	0f 92       	push	r0
    1886:	0f b6       	in	r0, 0x3f	; 63
    1888:	0f 92       	push	r0
    188a:	11 24       	eor	r1, r1
    188c:	0b b6       	in	r0, 0x3b	; 59
    188e:	0f 92       	push	r0
    1890:	2f 93       	push	r18
    1892:	3f 93       	push	r19
    1894:	4f 93       	push	r20
    1896:	5f 93       	push	r21
    1898:	6f 93       	push	r22
    189a:	7f 93       	push	r23
    189c:	8f 93       	push	r24
    189e:	9f 93       	push	r25
    18a0:	af 93       	push	r26
    18a2:	bf 93       	push	r27
    18a4:	ef 93       	push	r30
    18a6:	ff 93       	push	r31
    18a8:	e0 91 40 23 	lds	r30, 0x2340	; 0x802340 <tc_tce0_ovf_callback>
    18ac:	f0 91 41 23 	lds	r31, 0x2341	; 0x802341 <tc_tce0_ovf_callback+0x1>
    18b0:	30 97       	sbiw	r30, 0x00	; 0
    18b2:	09 f0       	breq	.+2      	; 0x18b6 <__vector_47+0x34>
    18b4:	19 95       	eicall
    18b6:	ff 91       	pop	r31
    18b8:	ef 91       	pop	r30
    18ba:	bf 91       	pop	r27
    18bc:	af 91       	pop	r26
    18be:	9f 91       	pop	r25
    18c0:	8f 91       	pop	r24
    18c2:	7f 91       	pop	r23
    18c4:	6f 91       	pop	r22
    18c6:	5f 91       	pop	r21
    18c8:	4f 91       	pop	r20
    18ca:	3f 91       	pop	r19
    18cc:	2f 91       	pop	r18
    18ce:	0f 90       	pop	r0
    18d0:	0b be       	out	0x3b, r0	; 59
    18d2:	0f 90       	pop	r0
    18d4:	0f be       	out	0x3f, r0	; 63
    18d6:	0f 90       	pop	r0
    18d8:	1f 90       	pop	r1
    18da:	18 95       	reti

000018dc <__vector_48>:
    18dc:	1f 92       	push	r1
    18de:	0f 92       	push	r0
    18e0:	0f b6       	in	r0, 0x3f	; 63
    18e2:	0f 92       	push	r0
    18e4:	11 24       	eor	r1, r1
    18e6:	0b b6       	in	r0, 0x3b	; 59
    18e8:	0f 92       	push	r0
    18ea:	2f 93       	push	r18
    18ec:	3f 93       	push	r19
    18ee:	4f 93       	push	r20
    18f0:	5f 93       	push	r21
    18f2:	6f 93       	push	r22
    18f4:	7f 93       	push	r23
    18f6:	8f 93       	push	r24
    18f8:	9f 93       	push	r25
    18fa:	af 93       	push	r26
    18fc:	bf 93       	push	r27
    18fe:	ef 93       	push	r30
    1900:	ff 93       	push	r31
    1902:	e0 91 3e 23 	lds	r30, 0x233E	; 0x80233e <tc_tce0_err_callback>
    1906:	f0 91 3f 23 	lds	r31, 0x233F	; 0x80233f <tc_tce0_err_callback+0x1>
    190a:	30 97       	sbiw	r30, 0x00	; 0
    190c:	09 f0       	breq	.+2      	; 0x1910 <__vector_48+0x34>
    190e:	19 95       	eicall
    1910:	ff 91       	pop	r31
    1912:	ef 91       	pop	r30
    1914:	bf 91       	pop	r27
    1916:	af 91       	pop	r26
    1918:	9f 91       	pop	r25
    191a:	8f 91       	pop	r24
    191c:	7f 91       	pop	r23
    191e:	6f 91       	pop	r22
    1920:	5f 91       	pop	r21
    1922:	4f 91       	pop	r20
    1924:	3f 91       	pop	r19
    1926:	2f 91       	pop	r18
    1928:	0f 90       	pop	r0
    192a:	0b be       	out	0x3b, r0	; 59
    192c:	0f 90       	pop	r0
    192e:	0f be       	out	0x3f, r0	; 63
    1930:	0f 90       	pop	r0
    1932:	1f 90       	pop	r1
    1934:	18 95       	reti

00001936 <__vector_49>:
    1936:	1f 92       	push	r1
    1938:	0f 92       	push	r0
    193a:	0f b6       	in	r0, 0x3f	; 63
    193c:	0f 92       	push	r0
    193e:	11 24       	eor	r1, r1
    1940:	0b b6       	in	r0, 0x3b	; 59
    1942:	0f 92       	push	r0
    1944:	2f 93       	push	r18
    1946:	3f 93       	push	r19
    1948:	4f 93       	push	r20
    194a:	5f 93       	push	r21
    194c:	6f 93       	push	r22
    194e:	7f 93       	push	r23
    1950:	8f 93       	push	r24
    1952:	9f 93       	push	r25
    1954:	af 93       	push	r26
    1956:	bf 93       	push	r27
    1958:	ef 93       	push	r30
    195a:	ff 93       	push	r31
    195c:	e0 91 3c 23 	lds	r30, 0x233C	; 0x80233c <tc_tce0_cca_callback>
    1960:	f0 91 3d 23 	lds	r31, 0x233D	; 0x80233d <tc_tce0_cca_callback+0x1>
    1964:	30 97       	sbiw	r30, 0x00	; 0
    1966:	09 f0       	breq	.+2      	; 0x196a <__vector_49+0x34>
    1968:	19 95       	eicall
    196a:	ff 91       	pop	r31
    196c:	ef 91       	pop	r30
    196e:	bf 91       	pop	r27
    1970:	af 91       	pop	r26
    1972:	9f 91       	pop	r25
    1974:	8f 91       	pop	r24
    1976:	7f 91       	pop	r23
    1978:	6f 91       	pop	r22
    197a:	5f 91       	pop	r21
    197c:	4f 91       	pop	r20
    197e:	3f 91       	pop	r19
    1980:	2f 91       	pop	r18
    1982:	0f 90       	pop	r0
    1984:	0b be       	out	0x3b, r0	; 59
    1986:	0f 90       	pop	r0
    1988:	0f be       	out	0x3f, r0	; 63
    198a:	0f 90       	pop	r0
    198c:	1f 90       	pop	r1
    198e:	18 95       	reti

00001990 <__vector_50>:
    1990:	1f 92       	push	r1
    1992:	0f 92       	push	r0
    1994:	0f b6       	in	r0, 0x3f	; 63
    1996:	0f 92       	push	r0
    1998:	11 24       	eor	r1, r1
    199a:	0b b6       	in	r0, 0x3b	; 59
    199c:	0f 92       	push	r0
    199e:	2f 93       	push	r18
    19a0:	3f 93       	push	r19
    19a2:	4f 93       	push	r20
    19a4:	5f 93       	push	r21
    19a6:	6f 93       	push	r22
    19a8:	7f 93       	push	r23
    19aa:	8f 93       	push	r24
    19ac:	9f 93       	push	r25
    19ae:	af 93       	push	r26
    19b0:	bf 93       	push	r27
    19b2:	ef 93       	push	r30
    19b4:	ff 93       	push	r31
    19b6:	e0 91 3a 23 	lds	r30, 0x233A	; 0x80233a <tc_tce0_ccb_callback>
    19ba:	f0 91 3b 23 	lds	r31, 0x233B	; 0x80233b <tc_tce0_ccb_callback+0x1>
    19be:	30 97       	sbiw	r30, 0x00	; 0
    19c0:	09 f0       	breq	.+2      	; 0x19c4 <__vector_50+0x34>
    19c2:	19 95       	eicall
    19c4:	ff 91       	pop	r31
    19c6:	ef 91       	pop	r30
    19c8:	bf 91       	pop	r27
    19ca:	af 91       	pop	r26
    19cc:	9f 91       	pop	r25
    19ce:	8f 91       	pop	r24
    19d0:	7f 91       	pop	r23
    19d2:	6f 91       	pop	r22
    19d4:	5f 91       	pop	r21
    19d6:	4f 91       	pop	r20
    19d8:	3f 91       	pop	r19
    19da:	2f 91       	pop	r18
    19dc:	0f 90       	pop	r0
    19de:	0b be       	out	0x3b, r0	; 59
    19e0:	0f 90       	pop	r0
    19e2:	0f be       	out	0x3f, r0	; 63
    19e4:	0f 90       	pop	r0
    19e6:	1f 90       	pop	r1
    19e8:	18 95       	reti

000019ea <__vector_51>:
    19ea:	1f 92       	push	r1
    19ec:	0f 92       	push	r0
    19ee:	0f b6       	in	r0, 0x3f	; 63
    19f0:	0f 92       	push	r0
    19f2:	11 24       	eor	r1, r1
    19f4:	0b b6       	in	r0, 0x3b	; 59
    19f6:	0f 92       	push	r0
    19f8:	2f 93       	push	r18
    19fa:	3f 93       	push	r19
    19fc:	4f 93       	push	r20
    19fe:	5f 93       	push	r21
    1a00:	6f 93       	push	r22
    1a02:	7f 93       	push	r23
    1a04:	8f 93       	push	r24
    1a06:	9f 93       	push	r25
    1a08:	af 93       	push	r26
    1a0a:	bf 93       	push	r27
    1a0c:	ef 93       	push	r30
    1a0e:	ff 93       	push	r31
    1a10:	e0 91 38 23 	lds	r30, 0x2338	; 0x802338 <tc_tce0_ccc_callback>
    1a14:	f0 91 39 23 	lds	r31, 0x2339	; 0x802339 <tc_tce0_ccc_callback+0x1>
    1a18:	30 97       	sbiw	r30, 0x00	; 0
    1a1a:	09 f0       	breq	.+2      	; 0x1a1e <__vector_51+0x34>
    1a1c:	19 95       	eicall
    1a1e:	ff 91       	pop	r31
    1a20:	ef 91       	pop	r30
    1a22:	bf 91       	pop	r27
    1a24:	af 91       	pop	r26
    1a26:	9f 91       	pop	r25
    1a28:	8f 91       	pop	r24
    1a2a:	7f 91       	pop	r23
    1a2c:	6f 91       	pop	r22
    1a2e:	5f 91       	pop	r21
    1a30:	4f 91       	pop	r20
    1a32:	3f 91       	pop	r19
    1a34:	2f 91       	pop	r18
    1a36:	0f 90       	pop	r0
    1a38:	0b be       	out	0x3b, r0	; 59
    1a3a:	0f 90       	pop	r0
    1a3c:	0f be       	out	0x3f, r0	; 63
    1a3e:	0f 90       	pop	r0
    1a40:	1f 90       	pop	r1
    1a42:	18 95       	reti

00001a44 <__vector_52>:
    1a44:	1f 92       	push	r1
    1a46:	0f 92       	push	r0
    1a48:	0f b6       	in	r0, 0x3f	; 63
    1a4a:	0f 92       	push	r0
    1a4c:	11 24       	eor	r1, r1
    1a4e:	0b b6       	in	r0, 0x3b	; 59
    1a50:	0f 92       	push	r0
    1a52:	2f 93       	push	r18
    1a54:	3f 93       	push	r19
    1a56:	4f 93       	push	r20
    1a58:	5f 93       	push	r21
    1a5a:	6f 93       	push	r22
    1a5c:	7f 93       	push	r23
    1a5e:	8f 93       	push	r24
    1a60:	9f 93       	push	r25
    1a62:	af 93       	push	r26
    1a64:	bf 93       	push	r27
    1a66:	ef 93       	push	r30
    1a68:	ff 93       	push	r31
    1a6a:	e0 91 36 23 	lds	r30, 0x2336	; 0x802336 <tc_tce0_ccd_callback>
    1a6e:	f0 91 37 23 	lds	r31, 0x2337	; 0x802337 <tc_tce0_ccd_callback+0x1>
    1a72:	30 97       	sbiw	r30, 0x00	; 0
    1a74:	09 f0       	breq	.+2      	; 0x1a78 <__vector_52+0x34>
    1a76:	19 95       	eicall
    1a78:	ff 91       	pop	r31
    1a7a:	ef 91       	pop	r30
    1a7c:	bf 91       	pop	r27
    1a7e:	af 91       	pop	r26
    1a80:	9f 91       	pop	r25
    1a82:	8f 91       	pop	r24
    1a84:	7f 91       	pop	r23
    1a86:	6f 91       	pop	r22
    1a88:	5f 91       	pop	r21
    1a8a:	4f 91       	pop	r20
    1a8c:	3f 91       	pop	r19
    1a8e:	2f 91       	pop	r18
    1a90:	0f 90       	pop	r0
    1a92:	0b be       	out	0x3b, r0	; 59
    1a94:	0f 90       	pop	r0
    1a96:	0f be       	out	0x3f, r0	; 63
    1a98:	0f 90       	pop	r0
    1a9a:	1f 90       	pop	r1
    1a9c:	18 95       	reti

00001a9e <__vector_53>:
    1a9e:	1f 92       	push	r1
    1aa0:	0f 92       	push	r0
    1aa2:	0f b6       	in	r0, 0x3f	; 63
    1aa4:	0f 92       	push	r0
    1aa6:	11 24       	eor	r1, r1
    1aa8:	0b b6       	in	r0, 0x3b	; 59
    1aaa:	0f 92       	push	r0
    1aac:	2f 93       	push	r18
    1aae:	3f 93       	push	r19
    1ab0:	4f 93       	push	r20
    1ab2:	5f 93       	push	r21
    1ab4:	6f 93       	push	r22
    1ab6:	7f 93       	push	r23
    1ab8:	8f 93       	push	r24
    1aba:	9f 93       	push	r25
    1abc:	af 93       	push	r26
    1abe:	bf 93       	push	r27
    1ac0:	ef 93       	push	r30
    1ac2:	ff 93       	push	r31
    1ac4:	e0 91 34 23 	lds	r30, 0x2334	; 0x802334 <tc_tce1_ovf_callback>
    1ac8:	f0 91 35 23 	lds	r31, 0x2335	; 0x802335 <tc_tce1_ovf_callback+0x1>
    1acc:	30 97       	sbiw	r30, 0x00	; 0
    1ace:	09 f0       	breq	.+2      	; 0x1ad2 <__vector_53+0x34>
    1ad0:	19 95       	eicall
    1ad2:	ff 91       	pop	r31
    1ad4:	ef 91       	pop	r30
    1ad6:	bf 91       	pop	r27
    1ad8:	af 91       	pop	r26
    1ada:	9f 91       	pop	r25
    1adc:	8f 91       	pop	r24
    1ade:	7f 91       	pop	r23
    1ae0:	6f 91       	pop	r22
    1ae2:	5f 91       	pop	r21
    1ae4:	4f 91       	pop	r20
    1ae6:	3f 91       	pop	r19
    1ae8:	2f 91       	pop	r18
    1aea:	0f 90       	pop	r0
    1aec:	0b be       	out	0x3b, r0	; 59
    1aee:	0f 90       	pop	r0
    1af0:	0f be       	out	0x3f, r0	; 63
    1af2:	0f 90       	pop	r0
    1af4:	1f 90       	pop	r1
    1af6:	18 95       	reti

00001af8 <__vector_54>:
    1af8:	1f 92       	push	r1
    1afa:	0f 92       	push	r0
    1afc:	0f b6       	in	r0, 0x3f	; 63
    1afe:	0f 92       	push	r0
    1b00:	11 24       	eor	r1, r1
    1b02:	0b b6       	in	r0, 0x3b	; 59
    1b04:	0f 92       	push	r0
    1b06:	2f 93       	push	r18
    1b08:	3f 93       	push	r19
    1b0a:	4f 93       	push	r20
    1b0c:	5f 93       	push	r21
    1b0e:	6f 93       	push	r22
    1b10:	7f 93       	push	r23
    1b12:	8f 93       	push	r24
    1b14:	9f 93       	push	r25
    1b16:	af 93       	push	r26
    1b18:	bf 93       	push	r27
    1b1a:	ef 93       	push	r30
    1b1c:	ff 93       	push	r31
    1b1e:	e0 91 32 23 	lds	r30, 0x2332	; 0x802332 <tc_tce1_err_callback>
    1b22:	f0 91 33 23 	lds	r31, 0x2333	; 0x802333 <tc_tce1_err_callback+0x1>
    1b26:	30 97       	sbiw	r30, 0x00	; 0
    1b28:	09 f0       	breq	.+2      	; 0x1b2c <__vector_54+0x34>
    1b2a:	19 95       	eicall
    1b2c:	ff 91       	pop	r31
    1b2e:	ef 91       	pop	r30
    1b30:	bf 91       	pop	r27
    1b32:	af 91       	pop	r26
    1b34:	9f 91       	pop	r25
    1b36:	8f 91       	pop	r24
    1b38:	7f 91       	pop	r23
    1b3a:	6f 91       	pop	r22
    1b3c:	5f 91       	pop	r21
    1b3e:	4f 91       	pop	r20
    1b40:	3f 91       	pop	r19
    1b42:	2f 91       	pop	r18
    1b44:	0f 90       	pop	r0
    1b46:	0b be       	out	0x3b, r0	; 59
    1b48:	0f 90       	pop	r0
    1b4a:	0f be       	out	0x3f, r0	; 63
    1b4c:	0f 90       	pop	r0
    1b4e:	1f 90       	pop	r1
    1b50:	18 95       	reti

00001b52 <__vector_55>:
    1b52:	1f 92       	push	r1
    1b54:	0f 92       	push	r0
    1b56:	0f b6       	in	r0, 0x3f	; 63
    1b58:	0f 92       	push	r0
    1b5a:	11 24       	eor	r1, r1
    1b5c:	0b b6       	in	r0, 0x3b	; 59
    1b5e:	0f 92       	push	r0
    1b60:	2f 93       	push	r18
    1b62:	3f 93       	push	r19
    1b64:	4f 93       	push	r20
    1b66:	5f 93       	push	r21
    1b68:	6f 93       	push	r22
    1b6a:	7f 93       	push	r23
    1b6c:	8f 93       	push	r24
    1b6e:	9f 93       	push	r25
    1b70:	af 93       	push	r26
    1b72:	bf 93       	push	r27
    1b74:	ef 93       	push	r30
    1b76:	ff 93       	push	r31
    1b78:	e0 91 30 23 	lds	r30, 0x2330	; 0x802330 <tc_tce1_cca_callback>
    1b7c:	f0 91 31 23 	lds	r31, 0x2331	; 0x802331 <tc_tce1_cca_callback+0x1>
    1b80:	30 97       	sbiw	r30, 0x00	; 0
    1b82:	09 f0       	breq	.+2      	; 0x1b86 <__vector_55+0x34>
    1b84:	19 95       	eicall
    1b86:	ff 91       	pop	r31
    1b88:	ef 91       	pop	r30
    1b8a:	bf 91       	pop	r27
    1b8c:	af 91       	pop	r26
    1b8e:	9f 91       	pop	r25
    1b90:	8f 91       	pop	r24
    1b92:	7f 91       	pop	r23
    1b94:	6f 91       	pop	r22
    1b96:	5f 91       	pop	r21
    1b98:	4f 91       	pop	r20
    1b9a:	3f 91       	pop	r19
    1b9c:	2f 91       	pop	r18
    1b9e:	0f 90       	pop	r0
    1ba0:	0b be       	out	0x3b, r0	; 59
    1ba2:	0f 90       	pop	r0
    1ba4:	0f be       	out	0x3f, r0	; 63
    1ba6:	0f 90       	pop	r0
    1ba8:	1f 90       	pop	r1
    1baa:	18 95       	reti

00001bac <__vector_56>:
    1bac:	1f 92       	push	r1
    1bae:	0f 92       	push	r0
    1bb0:	0f b6       	in	r0, 0x3f	; 63
    1bb2:	0f 92       	push	r0
    1bb4:	11 24       	eor	r1, r1
    1bb6:	0b b6       	in	r0, 0x3b	; 59
    1bb8:	0f 92       	push	r0
    1bba:	2f 93       	push	r18
    1bbc:	3f 93       	push	r19
    1bbe:	4f 93       	push	r20
    1bc0:	5f 93       	push	r21
    1bc2:	6f 93       	push	r22
    1bc4:	7f 93       	push	r23
    1bc6:	8f 93       	push	r24
    1bc8:	9f 93       	push	r25
    1bca:	af 93       	push	r26
    1bcc:	bf 93       	push	r27
    1bce:	ef 93       	push	r30
    1bd0:	ff 93       	push	r31
    1bd2:	e0 91 2e 23 	lds	r30, 0x232E	; 0x80232e <tc_tce1_ccb_callback>
    1bd6:	f0 91 2f 23 	lds	r31, 0x232F	; 0x80232f <tc_tce1_ccb_callback+0x1>
    1bda:	30 97       	sbiw	r30, 0x00	; 0
    1bdc:	09 f0       	breq	.+2      	; 0x1be0 <__vector_56+0x34>
    1bde:	19 95       	eicall
    1be0:	ff 91       	pop	r31
    1be2:	ef 91       	pop	r30
    1be4:	bf 91       	pop	r27
    1be6:	af 91       	pop	r26
    1be8:	9f 91       	pop	r25
    1bea:	8f 91       	pop	r24
    1bec:	7f 91       	pop	r23
    1bee:	6f 91       	pop	r22
    1bf0:	5f 91       	pop	r21
    1bf2:	4f 91       	pop	r20
    1bf4:	3f 91       	pop	r19
    1bf6:	2f 91       	pop	r18
    1bf8:	0f 90       	pop	r0
    1bfa:	0b be       	out	0x3b, r0	; 59
    1bfc:	0f 90       	pop	r0
    1bfe:	0f be       	out	0x3f, r0	; 63
    1c00:	0f 90       	pop	r0
    1c02:	1f 90       	pop	r1
    1c04:	18 95       	reti

00001c06 <__vector_108>:
    1c06:	1f 92       	push	r1
    1c08:	0f 92       	push	r0
    1c0a:	0f b6       	in	r0, 0x3f	; 63
    1c0c:	0f 92       	push	r0
    1c0e:	11 24       	eor	r1, r1
    1c10:	0b b6       	in	r0, 0x3b	; 59
    1c12:	0f 92       	push	r0
    1c14:	2f 93       	push	r18
    1c16:	3f 93       	push	r19
    1c18:	4f 93       	push	r20
    1c1a:	5f 93       	push	r21
    1c1c:	6f 93       	push	r22
    1c1e:	7f 93       	push	r23
    1c20:	8f 93       	push	r24
    1c22:	9f 93       	push	r25
    1c24:	af 93       	push	r26
    1c26:	bf 93       	push	r27
    1c28:	ef 93       	push	r30
    1c2a:	ff 93       	push	r31
    1c2c:	e0 91 2c 23 	lds	r30, 0x232C	; 0x80232c <tc_tcf0_ovf_callback>
    1c30:	f0 91 2d 23 	lds	r31, 0x232D	; 0x80232d <tc_tcf0_ovf_callback+0x1>
    1c34:	30 97       	sbiw	r30, 0x00	; 0
    1c36:	09 f0       	breq	.+2      	; 0x1c3a <__vector_108+0x34>
    1c38:	19 95       	eicall
    1c3a:	ff 91       	pop	r31
    1c3c:	ef 91       	pop	r30
    1c3e:	bf 91       	pop	r27
    1c40:	af 91       	pop	r26
    1c42:	9f 91       	pop	r25
    1c44:	8f 91       	pop	r24
    1c46:	7f 91       	pop	r23
    1c48:	6f 91       	pop	r22
    1c4a:	5f 91       	pop	r21
    1c4c:	4f 91       	pop	r20
    1c4e:	3f 91       	pop	r19
    1c50:	2f 91       	pop	r18
    1c52:	0f 90       	pop	r0
    1c54:	0b be       	out	0x3b, r0	; 59
    1c56:	0f 90       	pop	r0
    1c58:	0f be       	out	0x3f, r0	; 63
    1c5a:	0f 90       	pop	r0
    1c5c:	1f 90       	pop	r1
    1c5e:	18 95       	reti

00001c60 <__vector_109>:
    1c60:	1f 92       	push	r1
    1c62:	0f 92       	push	r0
    1c64:	0f b6       	in	r0, 0x3f	; 63
    1c66:	0f 92       	push	r0
    1c68:	11 24       	eor	r1, r1
    1c6a:	0b b6       	in	r0, 0x3b	; 59
    1c6c:	0f 92       	push	r0
    1c6e:	2f 93       	push	r18
    1c70:	3f 93       	push	r19
    1c72:	4f 93       	push	r20
    1c74:	5f 93       	push	r21
    1c76:	6f 93       	push	r22
    1c78:	7f 93       	push	r23
    1c7a:	8f 93       	push	r24
    1c7c:	9f 93       	push	r25
    1c7e:	af 93       	push	r26
    1c80:	bf 93       	push	r27
    1c82:	ef 93       	push	r30
    1c84:	ff 93       	push	r31
    1c86:	e0 91 2a 23 	lds	r30, 0x232A	; 0x80232a <tc_tcf0_err_callback>
    1c8a:	f0 91 2b 23 	lds	r31, 0x232B	; 0x80232b <tc_tcf0_err_callback+0x1>
    1c8e:	30 97       	sbiw	r30, 0x00	; 0
    1c90:	09 f0       	breq	.+2      	; 0x1c94 <__vector_109+0x34>
    1c92:	19 95       	eicall
    1c94:	ff 91       	pop	r31
    1c96:	ef 91       	pop	r30
    1c98:	bf 91       	pop	r27
    1c9a:	af 91       	pop	r26
    1c9c:	9f 91       	pop	r25
    1c9e:	8f 91       	pop	r24
    1ca0:	7f 91       	pop	r23
    1ca2:	6f 91       	pop	r22
    1ca4:	5f 91       	pop	r21
    1ca6:	4f 91       	pop	r20
    1ca8:	3f 91       	pop	r19
    1caa:	2f 91       	pop	r18
    1cac:	0f 90       	pop	r0
    1cae:	0b be       	out	0x3b, r0	; 59
    1cb0:	0f 90       	pop	r0
    1cb2:	0f be       	out	0x3f, r0	; 63
    1cb4:	0f 90       	pop	r0
    1cb6:	1f 90       	pop	r1
    1cb8:	18 95       	reti

00001cba <__vector_110>:
    1cba:	1f 92       	push	r1
    1cbc:	0f 92       	push	r0
    1cbe:	0f b6       	in	r0, 0x3f	; 63
    1cc0:	0f 92       	push	r0
    1cc2:	11 24       	eor	r1, r1
    1cc4:	0b b6       	in	r0, 0x3b	; 59
    1cc6:	0f 92       	push	r0
    1cc8:	2f 93       	push	r18
    1cca:	3f 93       	push	r19
    1ccc:	4f 93       	push	r20
    1cce:	5f 93       	push	r21
    1cd0:	6f 93       	push	r22
    1cd2:	7f 93       	push	r23
    1cd4:	8f 93       	push	r24
    1cd6:	9f 93       	push	r25
    1cd8:	af 93       	push	r26
    1cda:	bf 93       	push	r27
    1cdc:	ef 93       	push	r30
    1cde:	ff 93       	push	r31
    1ce0:	e0 91 28 23 	lds	r30, 0x2328	; 0x802328 <tc_tcf0_cca_callback>
    1ce4:	f0 91 29 23 	lds	r31, 0x2329	; 0x802329 <tc_tcf0_cca_callback+0x1>
    1ce8:	30 97       	sbiw	r30, 0x00	; 0
    1cea:	09 f0       	breq	.+2      	; 0x1cee <__vector_110+0x34>
    1cec:	19 95       	eicall
    1cee:	ff 91       	pop	r31
    1cf0:	ef 91       	pop	r30
    1cf2:	bf 91       	pop	r27
    1cf4:	af 91       	pop	r26
    1cf6:	9f 91       	pop	r25
    1cf8:	8f 91       	pop	r24
    1cfa:	7f 91       	pop	r23
    1cfc:	6f 91       	pop	r22
    1cfe:	5f 91       	pop	r21
    1d00:	4f 91       	pop	r20
    1d02:	3f 91       	pop	r19
    1d04:	2f 91       	pop	r18
    1d06:	0f 90       	pop	r0
    1d08:	0b be       	out	0x3b, r0	; 59
    1d0a:	0f 90       	pop	r0
    1d0c:	0f be       	out	0x3f, r0	; 63
    1d0e:	0f 90       	pop	r0
    1d10:	1f 90       	pop	r1
    1d12:	18 95       	reti

00001d14 <__vector_111>:
    1d14:	1f 92       	push	r1
    1d16:	0f 92       	push	r0
    1d18:	0f b6       	in	r0, 0x3f	; 63
    1d1a:	0f 92       	push	r0
    1d1c:	11 24       	eor	r1, r1
    1d1e:	0b b6       	in	r0, 0x3b	; 59
    1d20:	0f 92       	push	r0
    1d22:	2f 93       	push	r18
    1d24:	3f 93       	push	r19
    1d26:	4f 93       	push	r20
    1d28:	5f 93       	push	r21
    1d2a:	6f 93       	push	r22
    1d2c:	7f 93       	push	r23
    1d2e:	8f 93       	push	r24
    1d30:	9f 93       	push	r25
    1d32:	af 93       	push	r26
    1d34:	bf 93       	push	r27
    1d36:	ef 93       	push	r30
    1d38:	ff 93       	push	r31
    1d3a:	e0 91 26 23 	lds	r30, 0x2326	; 0x802326 <tc_tcf0_ccb_callback>
    1d3e:	f0 91 27 23 	lds	r31, 0x2327	; 0x802327 <tc_tcf0_ccb_callback+0x1>
    1d42:	30 97       	sbiw	r30, 0x00	; 0
    1d44:	09 f0       	breq	.+2      	; 0x1d48 <__vector_111+0x34>
    1d46:	19 95       	eicall
    1d48:	ff 91       	pop	r31
    1d4a:	ef 91       	pop	r30
    1d4c:	bf 91       	pop	r27
    1d4e:	af 91       	pop	r26
    1d50:	9f 91       	pop	r25
    1d52:	8f 91       	pop	r24
    1d54:	7f 91       	pop	r23
    1d56:	6f 91       	pop	r22
    1d58:	5f 91       	pop	r21
    1d5a:	4f 91       	pop	r20
    1d5c:	3f 91       	pop	r19
    1d5e:	2f 91       	pop	r18
    1d60:	0f 90       	pop	r0
    1d62:	0b be       	out	0x3b, r0	; 59
    1d64:	0f 90       	pop	r0
    1d66:	0f be       	out	0x3f, r0	; 63
    1d68:	0f 90       	pop	r0
    1d6a:	1f 90       	pop	r1
    1d6c:	18 95       	reti

00001d6e <__vector_112>:
    1d6e:	1f 92       	push	r1
    1d70:	0f 92       	push	r0
    1d72:	0f b6       	in	r0, 0x3f	; 63
    1d74:	0f 92       	push	r0
    1d76:	11 24       	eor	r1, r1
    1d78:	0b b6       	in	r0, 0x3b	; 59
    1d7a:	0f 92       	push	r0
    1d7c:	2f 93       	push	r18
    1d7e:	3f 93       	push	r19
    1d80:	4f 93       	push	r20
    1d82:	5f 93       	push	r21
    1d84:	6f 93       	push	r22
    1d86:	7f 93       	push	r23
    1d88:	8f 93       	push	r24
    1d8a:	9f 93       	push	r25
    1d8c:	af 93       	push	r26
    1d8e:	bf 93       	push	r27
    1d90:	ef 93       	push	r30
    1d92:	ff 93       	push	r31
    1d94:	e0 91 24 23 	lds	r30, 0x2324	; 0x802324 <tc_tcf0_ccc_callback>
    1d98:	f0 91 25 23 	lds	r31, 0x2325	; 0x802325 <tc_tcf0_ccc_callback+0x1>
    1d9c:	30 97       	sbiw	r30, 0x00	; 0
    1d9e:	09 f0       	breq	.+2      	; 0x1da2 <__vector_112+0x34>
    1da0:	19 95       	eicall
    1da2:	ff 91       	pop	r31
    1da4:	ef 91       	pop	r30
    1da6:	bf 91       	pop	r27
    1da8:	af 91       	pop	r26
    1daa:	9f 91       	pop	r25
    1dac:	8f 91       	pop	r24
    1dae:	7f 91       	pop	r23
    1db0:	6f 91       	pop	r22
    1db2:	5f 91       	pop	r21
    1db4:	4f 91       	pop	r20
    1db6:	3f 91       	pop	r19
    1db8:	2f 91       	pop	r18
    1dba:	0f 90       	pop	r0
    1dbc:	0b be       	out	0x3b, r0	; 59
    1dbe:	0f 90       	pop	r0
    1dc0:	0f be       	out	0x3f, r0	; 63
    1dc2:	0f 90       	pop	r0
    1dc4:	1f 90       	pop	r1
    1dc6:	18 95       	reti

00001dc8 <__vector_113>:
    1dc8:	1f 92       	push	r1
    1dca:	0f 92       	push	r0
    1dcc:	0f b6       	in	r0, 0x3f	; 63
    1dce:	0f 92       	push	r0
    1dd0:	11 24       	eor	r1, r1
    1dd2:	0b b6       	in	r0, 0x3b	; 59
    1dd4:	0f 92       	push	r0
    1dd6:	2f 93       	push	r18
    1dd8:	3f 93       	push	r19
    1dda:	4f 93       	push	r20
    1ddc:	5f 93       	push	r21
    1dde:	6f 93       	push	r22
    1de0:	7f 93       	push	r23
    1de2:	8f 93       	push	r24
    1de4:	9f 93       	push	r25
    1de6:	af 93       	push	r26
    1de8:	bf 93       	push	r27
    1dea:	ef 93       	push	r30
    1dec:	ff 93       	push	r31
    1dee:	e0 91 22 23 	lds	r30, 0x2322	; 0x802322 <tc_tcf0_ccd_callback>
    1df2:	f0 91 23 23 	lds	r31, 0x2323	; 0x802323 <tc_tcf0_ccd_callback+0x1>
    1df6:	30 97       	sbiw	r30, 0x00	; 0
    1df8:	09 f0       	breq	.+2      	; 0x1dfc <__vector_113+0x34>
    1dfa:	19 95       	eicall
    1dfc:	ff 91       	pop	r31
    1dfe:	ef 91       	pop	r30
    1e00:	bf 91       	pop	r27
    1e02:	af 91       	pop	r26
    1e04:	9f 91       	pop	r25
    1e06:	8f 91       	pop	r24
    1e08:	7f 91       	pop	r23
    1e0a:	6f 91       	pop	r22
    1e0c:	5f 91       	pop	r21
    1e0e:	4f 91       	pop	r20
    1e10:	3f 91       	pop	r19
    1e12:	2f 91       	pop	r18
    1e14:	0f 90       	pop	r0
    1e16:	0b be       	out	0x3b, r0	; 59
    1e18:	0f 90       	pop	r0
    1e1a:	0f be       	out	0x3f, r0	; 63
    1e1c:	0f 90       	pop	r0
    1e1e:	1f 90       	pop	r1
    1e20:	18 95       	reti

00001e22 <tc_enable>:
    1e22:	1f 93       	push	r17
    1e24:	cf 93       	push	r28
    1e26:	df 93       	push	r29
    1e28:	1f 92       	push	r1
    1e2a:	1f 92       	push	r1
    1e2c:	cd b7       	in	r28, 0x3d	; 61
    1e2e:	de b7       	in	r29, 0x3e	; 62
    1e30:	2f b7       	in	r18, 0x3f	; 63
    1e32:	2a 83       	std	Y+2, r18	; 0x02
    1e34:	f8 94       	cli
    1e36:	1a 81       	ldd	r17, Y+2	; 0x02
    1e38:	28 2f       	mov	r18, r24
    1e3a:	39 2f       	mov	r19, r25
    1e3c:	21 15       	cp	r18, r1
    1e3e:	88 e0       	ldi	r24, 0x08	; 8
    1e40:	38 07       	cpc	r19, r24
    1e42:	49 f4       	brne	.+18     	; 0x1e56 <tc_enable+0x34>
    1e44:	61 e0       	ldi	r22, 0x01	; 1
    1e46:	83 e0       	ldi	r24, 0x03	; 3
    1e48:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    1e4c:	64 e0       	ldi	r22, 0x04	; 4
    1e4e:	83 e0       	ldi	r24, 0x03	; 3
    1e50:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    1e54:	4f c0       	rjmp	.+158    	; 0x1ef4 <tc_enable+0xd2>
    1e56:	20 34       	cpi	r18, 0x40	; 64
    1e58:	88 e0       	ldi	r24, 0x08	; 8
    1e5a:	38 07       	cpc	r19, r24
    1e5c:	49 f4       	brne	.+18     	; 0x1e70 <tc_enable+0x4e>
    1e5e:	62 e0       	ldi	r22, 0x02	; 2
    1e60:	83 e0       	ldi	r24, 0x03	; 3
    1e62:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    1e66:	64 e0       	ldi	r22, 0x04	; 4
    1e68:	83 e0       	ldi	r24, 0x03	; 3
    1e6a:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    1e6e:	42 c0       	rjmp	.+132    	; 0x1ef4 <tc_enable+0xd2>
    1e70:	21 15       	cp	r18, r1
    1e72:	89 e0       	ldi	r24, 0x09	; 9
    1e74:	38 07       	cpc	r19, r24
    1e76:	49 f4       	brne	.+18     	; 0x1e8a <tc_enable+0x68>
    1e78:	61 e0       	ldi	r22, 0x01	; 1
    1e7a:	84 e0       	ldi	r24, 0x04	; 4
    1e7c:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    1e80:	64 e0       	ldi	r22, 0x04	; 4
    1e82:	84 e0       	ldi	r24, 0x04	; 4
    1e84:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    1e88:	35 c0       	rjmp	.+106    	; 0x1ef4 <tc_enable+0xd2>
    1e8a:	20 34       	cpi	r18, 0x40	; 64
    1e8c:	89 e0       	ldi	r24, 0x09	; 9
    1e8e:	38 07       	cpc	r19, r24
    1e90:	49 f4       	brne	.+18     	; 0x1ea4 <tc_enable+0x82>
    1e92:	62 e0       	ldi	r22, 0x02	; 2
    1e94:	84 e0       	ldi	r24, 0x04	; 4
    1e96:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    1e9a:	64 e0       	ldi	r22, 0x04	; 4
    1e9c:	84 e0       	ldi	r24, 0x04	; 4
    1e9e:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    1ea2:	28 c0       	rjmp	.+80     	; 0x1ef4 <tc_enable+0xd2>
    1ea4:	21 15       	cp	r18, r1
    1ea6:	8a e0       	ldi	r24, 0x0A	; 10
    1ea8:	38 07       	cpc	r19, r24
    1eaa:	49 f4       	brne	.+18     	; 0x1ebe <tc_enable+0x9c>
    1eac:	61 e0       	ldi	r22, 0x01	; 1
    1eae:	85 e0       	ldi	r24, 0x05	; 5
    1eb0:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    1eb4:	64 e0       	ldi	r22, 0x04	; 4
    1eb6:	85 e0       	ldi	r24, 0x05	; 5
    1eb8:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    1ebc:	1b c0       	rjmp	.+54     	; 0x1ef4 <tc_enable+0xd2>
    1ebe:	20 34       	cpi	r18, 0x40	; 64
    1ec0:	8a e0       	ldi	r24, 0x0A	; 10
    1ec2:	38 07       	cpc	r19, r24
    1ec4:	49 f4       	brne	.+18     	; 0x1ed8 <tc_enable+0xb6>
    1ec6:	62 e0       	ldi	r22, 0x02	; 2
    1ec8:	85 e0       	ldi	r24, 0x05	; 5
    1eca:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    1ece:	64 e0       	ldi	r22, 0x04	; 4
    1ed0:	85 e0       	ldi	r24, 0x05	; 5
    1ed2:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    1ed6:	0e c0       	rjmp	.+28     	; 0x1ef4 <tc_enable+0xd2>
    1ed8:	21 15       	cp	r18, r1
    1eda:	3b 40       	sbci	r19, 0x0B	; 11
    1edc:	49 f4       	brne	.+18     	; 0x1ef0 <tc_enable+0xce>
    1ede:	61 e0       	ldi	r22, 0x01	; 1
    1ee0:	86 e0       	ldi	r24, 0x06	; 6
    1ee2:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    1ee6:	64 e0       	ldi	r22, 0x04	; 4
    1ee8:	86 e0       	ldi	r24, 0x06	; 6
    1eea:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    1eee:	02 c0       	rjmp	.+4      	; 0x1ef4 <tc_enable+0xd2>
    1ef0:	1f bf       	out	0x3f, r17	; 63
    1ef2:	10 c0       	rjmp	.+32     	; 0x1f14 <tc_enable+0xf2>
    1ef4:	80 91 b8 24 	lds	r24, 0x24B8	; 0x8024b8 <sleepmgr_locks+0x1>
    1ef8:	8f 3f       	cpi	r24, 0xFF	; 255
    1efa:	09 f4       	brne	.+2      	; 0x1efe <tc_enable+0xdc>
    1efc:	ff cf       	rjmp	.-2      	; 0x1efc <tc_enable+0xda>
    1efe:	8f b7       	in	r24, 0x3f	; 63
    1f00:	89 83       	std	Y+1, r24	; 0x01
    1f02:	f8 94       	cli
    1f04:	99 81       	ldd	r25, Y+1	; 0x01
    1f06:	e7 eb       	ldi	r30, 0xB7	; 183
    1f08:	f4 e2       	ldi	r31, 0x24	; 36
    1f0a:	81 81       	ldd	r24, Z+1	; 0x01
    1f0c:	8f 5f       	subi	r24, 0xFF	; 255
    1f0e:	81 83       	std	Z+1, r24	; 0x01
    1f10:	9f bf       	out	0x3f, r25	; 63
    1f12:	1f bf       	out	0x3f, r17	; 63
    1f14:	0f 90       	pop	r0
    1f16:	0f 90       	pop	r0
    1f18:	df 91       	pop	r29
    1f1a:	cf 91       	pop	r28
    1f1c:	1f 91       	pop	r17
    1f1e:	08 95       	ret

00001f20 <tc_set_overflow_interrupt_callback>:

void tc_set_overflow_interrupt_callback(volatile void *tc,
		tc_callback_t callback)
{
#ifdef TCC0
	if ((uintptr_t) tc == (uintptr_t) & TCC0) {
    1f20:	81 15       	cp	r24, r1
    1f22:	28 e0       	ldi	r18, 0x08	; 8
    1f24:	92 07       	cpc	r25, r18
    1f26:	a1 f1       	breq	.+104    	; 0x1f90 <tc_set_overflow_interrupt_callback+0x70>
		tc_tcc0_ovf_callback = callback;
	} else
#endif
#ifdef TCC1
	if ((uintptr_t) tc == (uintptr_t) & TCC1) {
    1f28:	80 34       	cpi	r24, 0x40	; 64
    1f2a:	28 e0       	ldi	r18, 0x08	; 8
    1f2c:	92 07       	cpc	r25, r18
    1f2e:	29 f4       	brne	.+10     	; 0x1f3a <tc_set_overflow_interrupt_callback+0x1a>
		tc_tcc1_ovf_callback = callback;
    1f30:	60 93 5c 23 	sts	0x235C, r22	; 0x80235c <tc_tcc1_ovf_callback>
    1f34:	70 93 5d 23 	sts	0x235D, r23	; 0x80235d <tc_tcc1_ovf_callback+0x1>
    1f38:	08 95       	ret
	} else
#endif
#ifdef TCD0
	if ((uintptr_t) tc == (uintptr_t) & TCD0) {
    1f3a:	81 15       	cp	r24, r1
    1f3c:	29 e0       	ldi	r18, 0x09	; 9
    1f3e:	92 07       	cpc	r25, r18
    1f40:	29 f4       	brne	.+10     	; 0x1f4c <tc_set_overflow_interrupt_callback+0x2c>
		tc_tcd0_ovf_callback = callback;
    1f42:	60 93 54 23 	sts	0x2354, r22	; 0x802354 <tc_tcd0_ovf_callback>
    1f46:	70 93 55 23 	sts	0x2355, r23	; 0x802355 <tc_tcd0_ovf_callback+0x1>
    1f4a:	08 95       	ret
	} else
#endif
#ifdef TCD1
	if ((uintptr_t) tc == (uintptr_t) & TCD1) {
    1f4c:	80 34       	cpi	r24, 0x40	; 64
    1f4e:	29 e0       	ldi	r18, 0x09	; 9
    1f50:	92 07       	cpc	r25, r18
    1f52:	29 f4       	brne	.+10     	; 0x1f5e <tc_set_overflow_interrupt_callback+0x3e>
		tc_tcd1_ovf_callback = callback;
    1f54:	60 93 48 23 	sts	0x2348, r22	; 0x802348 <tc_tcd1_ovf_callback>
    1f58:	70 93 49 23 	sts	0x2349, r23	; 0x802349 <tc_tcd1_ovf_callback+0x1>
    1f5c:	08 95       	ret
	} else
#endif
#ifdef TCE0
	if ((uintptr_t) tc == (uintptr_t) & TCE0) {
    1f5e:	81 15       	cp	r24, r1
    1f60:	2a e0       	ldi	r18, 0x0A	; 10
    1f62:	92 07       	cpc	r25, r18
    1f64:	29 f4       	brne	.+10     	; 0x1f70 <tc_set_overflow_interrupt_callback+0x50>
		tc_tce0_ovf_callback = callback;
    1f66:	60 93 40 23 	sts	0x2340, r22	; 0x802340 <tc_tce0_ovf_callback>
    1f6a:	70 93 41 23 	sts	0x2341, r23	; 0x802341 <tc_tce0_ovf_callback+0x1>
    1f6e:	08 95       	ret
	} else
#endif
#ifdef TCE1
	if ((uintptr_t) tc == (uintptr_t) & TCE1) {
    1f70:	80 34       	cpi	r24, 0x40	; 64
    1f72:	2a e0       	ldi	r18, 0x0A	; 10
    1f74:	92 07       	cpc	r25, r18
    1f76:	29 f4       	brne	.+10     	; 0x1f82 <tc_set_overflow_interrupt_callback+0x62>
		tc_tce1_ovf_callback = callback;
    1f78:	60 93 34 23 	sts	0x2334, r22	; 0x802334 <tc_tce1_ovf_callback>
    1f7c:	70 93 35 23 	sts	0x2335, r23	; 0x802335 <tc_tce1_ovf_callback+0x1>
    1f80:	08 95       	ret
	} else
#endif
#ifdef TCF0
	if ((uintptr_t) tc == (uintptr_t) & TCF0) {
    1f82:	81 15       	cp	r24, r1
    1f84:	9b 40       	sbci	r25, 0x0B	; 11
    1f86:	21 f4       	brne	.+8      	; 0x1f90 <tc_set_overflow_interrupt_callback+0x70>
		tc_tcf0_ovf_callback = callback;
    1f88:	60 93 2c 23 	sts	0x232C, r22	; 0x80232c <tc_tcf0_ovf_callback>
    1f8c:	70 93 2d 23 	sts	0x232D, r23	; 0x80232d <tc_tcf0_ovf_callback+0x1>
    1f90:	08 95       	ret

00001f92 <usart_putchar>:
	result = usart_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
	
	return result;
}
    1f92:	fc 01       	movw	r30, r24
    1f94:	91 81       	ldd	r25, Z+1	; 0x01
    1f96:	95 ff       	sbrs	r25, 5
    1f98:	fd cf       	rjmp	.-6      	; 0x1f94 <usart_putchar+0x2>
    1f9a:	60 83       	st	Z, r22
    1f9c:	80 e0       	ldi	r24, 0x00	; 0
    1f9e:	90 e0       	ldi	r25, 0x00	; 0
    1fa0:	08 95       	ret

00001fa2 <usart_getchar>:
    1fa2:	fc 01       	movw	r30, r24
    1fa4:	24 e6       	ldi	r18, 0x64	; 100
    1fa6:	30 e0       	ldi	r19, 0x00	; 0
    1fa8:	03 c0       	rjmp	.+6      	; 0x1fb0 <usart_getchar+0xe>
    1faa:	21 50       	subi	r18, 0x01	; 1
    1fac:	31 09       	sbc	r19, r1
    1fae:	29 f0       	breq	.+10     	; 0x1fba <usart_getchar+0x18>
    1fb0:	91 81       	ldd	r25, Z+1	; 0x01
    1fb2:	99 23       	and	r25, r25
    1fb4:	d4 f7       	brge	.-12     	; 0x1faa <usart_getchar+0x8>
    1fb6:	80 81       	ld	r24, Z
    1fb8:	08 95       	ret
    1fba:	8f ef       	ldi	r24, 0xFF	; 255
    1fbc:	08 95       	ret

00001fbe <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    1fbe:	cf 92       	push	r12
    1fc0:	df 92       	push	r13
    1fc2:	ef 92       	push	r14
    1fc4:	ff 92       	push	r15
    1fc6:	0f 93       	push	r16
    1fc8:	1f 93       	push	r17
    1fca:	cf 93       	push	r28
    1fcc:	df 93       	push	r29
    1fce:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    1fd0:	d9 01       	movw	r26, r18
    1fd2:	c8 01       	movw	r24, r16
    1fd4:	b6 95       	lsr	r27
    1fd6:	a7 95       	ror	r26
    1fd8:	97 95       	ror	r25
    1fda:	87 95       	ror	r24
    1fdc:	48 17       	cp	r20, r24
    1fde:	59 07       	cpc	r21, r25
    1fe0:	6a 07       	cpc	r22, r26
    1fe2:	7b 07       	cpc	r23, r27
    1fe4:	78 f4       	brcc	.+30     	; 0x2004 <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    1fe6:	6a 01       	movw	r12, r20
    1fe8:	7b 01       	movw	r14, r22
    1fea:	cc 0c       	add	r12, r12
    1fec:	dd 1c       	adc	r13, r13
    1fee:	ee 1c       	adc	r14, r14
    1ff0:	ff 1c       	adc	r15, r15
    1ff2:	c9 01       	movw	r24, r18
    1ff4:	b8 01       	movw	r22, r16
    1ff6:	a7 01       	movw	r20, r14
    1ff8:	96 01       	movw	r18, r12
    1ffa:	0e 94 e0 23 	call	0x47c0	; 0x47c0 <__udivmodsi4>
    1ffe:	21 50       	subi	r18, 0x01	; 1
    2000:	31 09       	sbc	r19, r1
    2002:	02 c0       	rjmp	.+4      	; 0x2008 <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    2004:	20 e0       	ldi	r18, 0x00	; 0
    2006:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    2008:	83 2f       	mov	r24, r19
    200a:	8f 70       	andi	r24, 0x0F	; 15
    200c:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    200e:	2e 83       	std	Y+6, r18	; 0x06
}
    2010:	df 91       	pop	r29
    2012:	cf 91       	pop	r28
    2014:	1f 91       	pop	r17
    2016:	0f 91       	pop	r16
    2018:	ff 90       	pop	r15
    201a:	ef 90       	pop	r14
    201c:	df 90       	pop	r13
    201e:	cf 90       	pop	r12
    2020:	08 95       	ret

00002022 <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    2022:	df 92       	push	r13
    2024:	ef 92       	push	r14
    2026:	ff 92       	push	r15
    2028:	0f 93       	push	r16
    202a:	1f 93       	push	r17
    202c:	cf 93       	push	r28
    202e:	df 93       	push	r29
    2030:	1f 92       	push	r1
    2032:	cd b7       	in	r28, 0x3d	; 61
    2034:	de b7       	in	r29, 0x3e	; 62
    2036:	7c 01       	movw	r14, r24
    2038:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    203a:	00 97       	sbiw	r24, 0x00	; 0
    203c:	09 f4       	brne	.+2      	; 0x2040 <usart_init_spi+0x1e>
    203e:	cf c1       	rjmp	.+926    	; 0x23de <usart_init_spi+0x3bc>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    2040:	80 3c       	cpi	r24, 0xC0	; 192
    2042:	91 05       	cpc	r25, r1
    2044:	29 f4       	brne	.+10     	; 0x2050 <usart_init_spi+0x2e>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    2046:	60 e1       	ldi	r22, 0x10	; 16
    2048:	80 e0       	ldi	r24, 0x00	; 0
    204a:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    204e:	c7 c1       	rjmp	.+910    	; 0x23de <usart_init_spi+0x3bc>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    2050:	80 e8       	ldi	r24, 0x80	; 128
    2052:	e8 16       	cp	r14, r24
    2054:	81 e0       	ldi	r24, 0x01	; 1
    2056:	f8 06       	cpc	r15, r24
    2058:	29 f4       	brne	.+10     	; 0x2064 <usart_init_spi+0x42>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    205a:	62 e0       	ldi	r22, 0x02	; 2
    205c:	80 e0       	ldi	r24, 0x00	; 0
    205e:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    2062:	bd c1       	rjmp	.+890    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    2064:	e1 14       	cp	r14, r1
    2066:	e1 e0       	ldi	r30, 0x01	; 1
    2068:	fe 06       	cpc	r15, r30
    206a:	29 f4       	brne	.+10     	; 0x2076 <usart_init_spi+0x54>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    206c:	61 e0       	ldi	r22, 0x01	; 1
    206e:	80 e0       	ldi	r24, 0x00	; 0
    2070:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    2074:	b4 c1       	rjmp	.+872    	; 0x23de <usart_init_spi+0x3bc>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    2076:	f0 e8       	ldi	r31, 0x80	; 128
    2078:	ef 16       	cp	r14, r31
    207a:	f3 e0       	ldi	r31, 0x03	; 3
    207c:	ff 06       	cpc	r15, r31
    207e:	29 f4       	brne	.+10     	; 0x208a <usart_init_spi+0x68>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    2080:	61 e0       	ldi	r22, 0x01	; 1
    2082:	81 e0       	ldi	r24, 0x01	; 1
    2084:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    2088:	aa c1       	rjmp	.+852    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    208a:	30 e9       	ldi	r19, 0x90	; 144
    208c:	e3 16       	cp	r14, r19
    208e:	33 e0       	ldi	r19, 0x03	; 3
    2090:	f3 06       	cpc	r15, r19
    2092:	29 f4       	brne	.+10     	; 0x209e <usart_init_spi+0x7c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    2094:	61 e0       	ldi	r22, 0x01	; 1
    2096:	82 e0       	ldi	r24, 0x02	; 2
    2098:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    209c:	a0 c1       	rjmp	.+832    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    209e:	e1 14       	cp	r14, r1
    20a0:	82 e0       	ldi	r24, 0x02	; 2
    20a2:	f8 06       	cpc	r15, r24
    20a4:	29 f4       	brne	.+10     	; 0x20b0 <usart_init_spi+0x8e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    20a6:	62 e0       	ldi	r22, 0x02	; 2
    20a8:	81 e0       	ldi	r24, 0x01	; 1
    20aa:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    20ae:	97 c1       	rjmp	.+814    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    20b0:	e0 e4       	ldi	r30, 0x40	; 64
    20b2:	ee 16       	cp	r14, r30
    20b4:	e2 e0       	ldi	r30, 0x02	; 2
    20b6:	fe 06       	cpc	r15, r30
    20b8:	29 f4       	brne	.+10     	; 0x20c4 <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    20ba:	62 e0       	ldi	r22, 0x02	; 2
    20bc:	82 e0       	ldi	r24, 0x02	; 2
    20be:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    20c2:	8d c1       	rjmp	.+794    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    20c4:	f0 e2       	ldi	r31, 0x20	; 32
    20c6:	ef 16       	cp	r14, r31
    20c8:	f3 e0       	ldi	r31, 0x03	; 3
    20ca:	ff 06       	cpc	r15, r31
    20cc:	29 f4       	brne	.+10     	; 0x20d8 <usart_init_spi+0xb6>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    20ce:	64 e0       	ldi	r22, 0x04	; 4
    20d0:	82 e0       	ldi	r24, 0x02	; 2
    20d2:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    20d6:	83 c1       	rjmp	.+774    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    20d8:	e1 14       	cp	r14, r1
    20da:	38 e0       	ldi	r19, 0x08	; 8
    20dc:	f3 06       	cpc	r15, r19
    20de:	29 f4       	brne	.+10     	; 0x20ea <usart_init_spi+0xc8>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    20e0:	61 e0       	ldi	r22, 0x01	; 1
    20e2:	83 e0       	ldi	r24, 0x03	; 3
    20e4:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    20e8:	7a c1       	rjmp	.+756    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    20ea:	e1 14       	cp	r14, r1
    20ec:	89 e0       	ldi	r24, 0x09	; 9
    20ee:	f8 06       	cpc	r15, r24
    20f0:	29 f4       	brne	.+10     	; 0x20fc <usart_init_spi+0xda>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    20f2:	61 e0       	ldi	r22, 0x01	; 1
    20f4:	84 e0       	ldi	r24, 0x04	; 4
    20f6:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    20fa:	71 c1       	rjmp	.+738    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    20fc:	e1 14       	cp	r14, r1
    20fe:	ea e0       	ldi	r30, 0x0A	; 10
    2100:	fe 06       	cpc	r15, r30
    2102:	29 f4       	brne	.+10     	; 0x210e <usart_init_spi+0xec>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    2104:	61 e0       	ldi	r22, 0x01	; 1
    2106:	85 e0       	ldi	r24, 0x05	; 5
    2108:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    210c:	68 c1       	rjmp	.+720    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    210e:	e1 14       	cp	r14, r1
    2110:	fb e0       	ldi	r31, 0x0B	; 11
    2112:	ff 06       	cpc	r15, r31
    2114:	29 f4       	brne	.+10     	; 0x2120 <usart_init_spi+0xfe>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    2116:	61 e0       	ldi	r22, 0x01	; 1
    2118:	86 e0       	ldi	r24, 0x06	; 6
    211a:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    211e:	5f c1       	rjmp	.+702    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    2120:	30 e4       	ldi	r19, 0x40	; 64
    2122:	e3 16       	cp	r14, r19
    2124:	38 e0       	ldi	r19, 0x08	; 8
    2126:	f3 06       	cpc	r15, r19
    2128:	29 f4       	brne	.+10     	; 0x2134 <usart_init_spi+0x112>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    212a:	62 e0       	ldi	r22, 0x02	; 2
    212c:	83 e0       	ldi	r24, 0x03	; 3
    212e:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    2132:	55 c1       	rjmp	.+682    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    2134:	80 e4       	ldi	r24, 0x40	; 64
    2136:	e8 16       	cp	r14, r24
    2138:	89 e0       	ldi	r24, 0x09	; 9
    213a:	f8 06       	cpc	r15, r24
    213c:	29 f4       	brne	.+10     	; 0x2148 <usart_init_spi+0x126>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    213e:	62 e0       	ldi	r22, 0x02	; 2
    2140:	84 e0       	ldi	r24, 0x04	; 4
    2142:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    2146:	4b c1       	rjmp	.+662    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    2148:	e0 e4       	ldi	r30, 0x40	; 64
    214a:	ee 16       	cp	r14, r30
    214c:	ea e0       	ldi	r30, 0x0A	; 10
    214e:	fe 06       	cpc	r15, r30
    2150:	29 f4       	brne	.+10     	; 0x215c <usart_init_spi+0x13a>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    2152:	62 e0       	ldi	r22, 0x02	; 2
    2154:	85 e0       	ldi	r24, 0x05	; 5
    2156:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    215a:	41 c1       	rjmp	.+642    	; 0x23de <usart_init_spi+0x3bc>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    215c:	f0 e9       	ldi	r31, 0x90	; 144
    215e:	ef 16       	cp	r14, r31
    2160:	f8 e0       	ldi	r31, 0x08	; 8
    2162:	ff 06       	cpc	r15, r31
    2164:	29 f4       	brne	.+10     	; 0x2170 <usart_init_spi+0x14e>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    2166:	64 e0       	ldi	r22, 0x04	; 4
    2168:	83 e0       	ldi	r24, 0x03	; 3
    216a:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    216e:	37 c1       	rjmp	.+622    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    2170:	30 e9       	ldi	r19, 0x90	; 144
    2172:	e3 16       	cp	r14, r19
    2174:	39 e0       	ldi	r19, 0x09	; 9
    2176:	f3 06       	cpc	r15, r19
    2178:	29 f4       	brne	.+10     	; 0x2184 <usart_init_spi+0x162>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    217a:	64 e0       	ldi	r22, 0x04	; 4
    217c:	84 e0       	ldi	r24, 0x04	; 4
    217e:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    2182:	2d c1       	rjmp	.+602    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    2184:	80 e9       	ldi	r24, 0x90	; 144
    2186:	e8 16       	cp	r14, r24
    2188:	8a e0       	ldi	r24, 0x0A	; 10
    218a:	f8 06       	cpc	r15, r24
    218c:	29 f4       	brne	.+10     	; 0x2198 <usart_init_spi+0x176>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    218e:	64 e0       	ldi	r22, 0x04	; 4
    2190:	85 e0       	ldi	r24, 0x05	; 5
    2192:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    2196:	23 c1       	rjmp	.+582    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    2198:	e0 e9       	ldi	r30, 0x90	; 144
    219a:	ee 16       	cp	r14, r30
    219c:	eb e0       	ldi	r30, 0x0B	; 11
    219e:	fe 06       	cpc	r15, r30
    21a0:	29 f4       	brne	.+10     	; 0x21ac <usart_init_spi+0x18a>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    21a2:	64 e0       	ldi	r22, 0x04	; 4
    21a4:	86 e0       	ldi	r24, 0x06	; 6
    21a6:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    21aa:	19 c1       	rjmp	.+562    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    21ac:	f0 ec       	ldi	r31, 0xC0	; 192
    21ae:	ef 16       	cp	r14, r31
    21b0:	f8 e0       	ldi	r31, 0x08	; 8
    21b2:	ff 06       	cpc	r15, r31
    21b4:	29 f4       	brne	.+10     	; 0x21c0 <usart_init_spi+0x19e>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    21b6:	68 e0       	ldi	r22, 0x08	; 8
    21b8:	83 e0       	ldi	r24, 0x03	; 3
    21ba:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    21be:	0f c1       	rjmp	.+542    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    21c0:	30 ec       	ldi	r19, 0xC0	; 192
    21c2:	e3 16       	cp	r14, r19
    21c4:	39 e0       	ldi	r19, 0x09	; 9
    21c6:	f3 06       	cpc	r15, r19
    21c8:	29 f4       	brne	.+10     	; 0x21d4 <usart_init_spi+0x1b2>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    21ca:	68 e0       	ldi	r22, 0x08	; 8
    21cc:	84 e0       	ldi	r24, 0x04	; 4
    21ce:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    21d2:	05 c1       	rjmp	.+522    	; 0x23de <usart_init_spi+0x3bc>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    21d4:	80 ea       	ldi	r24, 0xA0	; 160
    21d6:	e8 16       	cp	r14, r24
    21d8:	88 e0       	ldi	r24, 0x08	; 8
    21da:	f8 06       	cpc	r15, r24
    21dc:	69 f4       	brne	.+26     	; 0x21f8 <usart_init_spi+0x1d6>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    21de:	60 e1       	ldi	r22, 0x10	; 16
    21e0:	83 e0       	ldi	r24, 0x03	; 3
    21e2:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    21e6:	e0 ea       	ldi	r30, 0xA0	; 160
    21e8:	f8 e0       	ldi	r31, 0x08	; 8
    21ea:	84 81       	ldd	r24, Z+4	; 0x04
    21ec:	8f 7e       	andi	r24, 0xEF	; 239
    21ee:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    21f0:	f8 01       	movw	r30, r16
    21f2:	24 81       	ldd	r18, Z+4	; 0x04
    21f4:	22 50       	subi	r18, 0x02	; 2
    21f6:	53 c0       	rjmp	.+166    	; 0x229e <usart_init_spi+0x27c>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    21f8:	f0 ea       	ldi	r31, 0xA0	; 160
    21fa:	ef 16       	cp	r14, r31
    21fc:	f9 e0       	ldi	r31, 0x09	; 9
    21fe:	ff 06       	cpc	r15, r31
    2200:	29 f4       	brne	.+10     	; 0x220c <usart_init_spi+0x1ea>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    2202:	60 e1       	ldi	r22, 0x10	; 16
    2204:	84 e0       	ldi	r24, 0x04	; 4
    2206:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    220a:	e9 c0       	rjmp	.+466    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    220c:	30 ea       	ldi	r19, 0xA0	; 160
    220e:	e3 16       	cp	r14, r19
    2210:	3a e0       	ldi	r19, 0x0A	; 10
    2212:	f3 06       	cpc	r15, r19
    2214:	29 f4       	brne	.+10     	; 0x2220 <usart_init_spi+0x1fe>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    2216:	60 e1       	ldi	r22, 0x10	; 16
    2218:	85 e0       	ldi	r24, 0x05	; 5
    221a:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    221e:	df c0       	rjmp	.+446    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    2220:	80 ea       	ldi	r24, 0xA0	; 160
    2222:	e8 16       	cp	r14, r24
    2224:	8b e0       	ldi	r24, 0x0B	; 11
    2226:	f8 06       	cpc	r15, r24
    2228:	29 f4       	brne	.+10     	; 0x2234 <usart_init_spi+0x212>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    222a:	60 e1       	ldi	r22, 0x10	; 16
    222c:	86 e0       	ldi	r24, 0x06	; 6
    222e:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    2232:	d5 c0       	rjmp	.+426    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    2234:	e0 eb       	ldi	r30, 0xB0	; 176
    2236:	ee 16       	cp	r14, r30
    2238:	e8 e0       	ldi	r30, 0x08	; 8
    223a:	fe 06       	cpc	r15, r30
    223c:	29 f4       	brne	.+10     	; 0x2248 <usart_init_spi+0x226>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    223e:	60 e2       	ldi	r22, 0x20	; 32
    2240:	83 e0       	ldi	r24, 0x03	; 3
    2242:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    2246:	cb c0       	rjmp	.+406    	; 0x23de <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    2248:	f0 eb       	ldi	r31, 0xB0	; 176
    224a:	ef 16       	cp	r14, r31
    224c:	f9 e0       	ldi	r31, 0x09	; 9
    224e:	ff 06       	cpc	r15, r31
    2250:	29 f4       	brne	.+10     	; 0x225c <usart_init_spi+0x23a>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    2252:	60 e2       	ldi	r22, 0x20	; 32
    2254:	84 e0       	ldi	r24, 0x04	; 4
    2256:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    225a:	c1 c0       	rjmp	.+386    	; 0x23de <usart_init_spi+0x3bc>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    225c:	30 e8       	ldi	r19, 0x80	; 128
    225e:	e3 16       	cp	r14, r19
    2260:	34 e0       	ldi	r19, 0x04	; 4
    2262:	f3 06       	cpc	r15, r19
    2264:	29 f4       	brne	.+10     	; 0x2270 <usart_init_spi+0x24e>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    2266:	60 e4       	ldi	r22, 0x40	; 64
    2268:	83 e0       	ldi	r24, 0x03	; 3
    226a:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    226e:	b7 c0       	rjmp	.+366    	; 0x23de <usart_init_spi+0x3bc>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    2270:	80 ea       	ldi	r24, 0xA0	; 160
    2272:	e8 16       	cp	r14, r24
    2274:	84 e0       	ldi	r24, 0x04	; 4
    2276:	f8 06       	cpc	r15, r24
    2278:	29 f4       	brne	.+10     	; 0x2284 <usart_init_spi+0x262>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    227a:	60 e4       	ldi	r22, 0x40	; 64
    227c:	85 e0       	ldi	r24, 0x05	; 5
    227e:	0e 94 67 1e 	call	0x3cce	; 0x3cce <sysclk_enable_module>
    2282:	ad c0       	rjmp	.+346    	; 0x23de <usart_init_spi+0x3bc>
    2284:	f7 01       	movw	r30, r14
    2286:	84 81       	ldd	r24, Z+4	; 0x04
    2288:	8f 7e       	andi	r24, 0xEF	; 239
    228a:	84 83       	std	Z+4, r24	; 0x04
    228c:	fb 01       	movw	r30, r22
    228e:	24 81       	ldd	r18, Z+4	; 0x04
    2290:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    2292:	c7 01       	movw	r24, r14
    2294:	f0 ea       	ldi	r31, 0xA0	; 160
    2296:	ef 16       	cp	r14, r31
    2298:	f8 e0       	ldi	r31, 0x08	; 8
    229a:	ff 06       	cpc	r15, r31
    229c:	49 f4       	brne	.+18     	; 0x22b0 <usart_init_spi+0x28e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    229e:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <__TEXT_REGION_LENGTH__+0x70064e>
    22a2:	84 fd       	sbrc	r24, 4
    22a4:	a5 c0       	rjmp	.+330    	; 0x23f0 <usart_init_spi+0x3ce>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    22a6:	0f 2e       	mov	r0, r31
    22a8:	f1 e1       	ldi	r31, 0x11	; 17
    22aa:	df 2e       	mov	r13, r31
    22ac:	f0 2d       	mov	r31, r0
    22ae:	a4 c0       	rjmp	.+328    	; 0x23f8 <usart_init_spi+0x3d6>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    22b0:	80 3b       	cpi	r24, 0xB0	; 176
    22b2:	38 e0       	ldi	r19, 0x08	; 8
    22b4:	93 07       	cpc	r25, r19
    22b6:	91 f0       	breq	.+36     	; 0x22dc <usart_init_spi+0x2ba>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    22b8:	80 3a       	cpi	r24, 0xA0	; 160
    22ba:	e9 e0       	ldi	r30, 0x09	; 9
    22bc:	9e 07       	cpc	r25, r30
    22be:	49 f4       	brne	.+18     	; 0x22d2 <usart_init_spi+0x2b0>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    22c0:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
    22c4:	34 fd       	sbrc	r19, 4
    22c6:	9b c0       	rjmp	.+310    	; 0x23fe <usart_init_spi+0x3dc>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    22c8:	0f 2e       	mov	r0, r31
    22ca:	f9 e1       	ldi	r31, 0x19	; 25
    22cc:	df 2e       	mov	r13, r31
    22ce:	f0 2d       	mov	r31, r0
    22d0:	16 c0       	rjmp	.+44     	; 0x22fe <usart_init_spi+0x2dc>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    22d2:	80 3b       	cpi	r24, 0xB0	; 176
    22d4:	f9 e0       	ldi	r31, 0x09	; 9
    22d6:	9f 07       	cpc	r25, r31
    22d8:	f1 f0       	breq	.+60     	; 0x2316 <usart_init_spi+0x2f4>
    22da:	04 c0       	rjmp	.+8      	; 0x22e4 <usart_init_spi+0x2c2>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    22dc:	0f 2e       	mov	r0, r31
    22de:	f5 e1       	ldi	r31, 0x15	; 21
    22e0:	df 2e       	mov	r13, r31
    22e2:	f0 2d       	mov	r31, r0
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    22e4:	80 3a       	cpi	r24, 0xA0	; 160
    22e6:	3a e0       	ldi	r19, 0x0A	; 10
    22e8:	93 07       	cpc	r25, r19
    22ea:	49 f4       	brne	.+18     	; 0x22fe <usart_init_spi+0x2dc>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    22ec:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__TEXT_REGION_LENGTH__+0x70068e>
    22f0:	84 fd       	sbrc	r24, 4
    22f2:	8a c0       	rjmp	.+276    	; 0x2408 <usart_init_spi+0x3e6>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    22f4:	0f 2e       	mov	r0, r31
    22f6:	f1 e2       	ldi	r31, 0x21	; 33
    22f8:	df 2e       	mov	r13, r31
    22fa:	f0 2d       	mov	r31, r0
    22fc:	15 c0       	rjmp	.+42     	; 0x2328 <usart_init_spi+0x306>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    22fe:	80 3a       	cpi	r24, 0xA0	; 160
    2300:	9b 40       	sbci	r25, 0x0B	; 11
    2302:	91 f4       	brne	.+36     	; 0x2328 <usart_init_spi+0x306>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    2304:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <__TEXT_REGION_LENGTH__+0x7006ae>
    2308:	84 fd       	sbrc	r24, 4
    230a:	0a c0       	rjmp	.+20     	; 0x2320 <usart_init_spi+0x2fe>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    230c:	0f 2e       	mov	r0, r31
    230e:	f9 e2       	ldi	r31, 0x29	; 41
    2310:	df 2e       	mov	r13, r31
    2312:	f0 2d       	mov	r31, r0
    2314:	09 c0       	rjmp	.+18     	; 0x2328 <usart_init_spi+0x306>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    2316:	0f 2e       	mov	r0, r31
    2318:	fd e1       	ldi	r31, 0x1D	; 29
    231a:	df 2e       	mov	r13, r31
    231c:	f0 2d       	mov	r31, r0
    231e:	04 c0       	rjmp	.+8      	; 0x2328 <usart_init_spi+0x306>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    2320:	0f 2e       	mov	r0, r31
    2322:	fd e2       	ldi	r31, 0x2D	; 45
    2324:	df 2e       	mov	r13, r31
    2326:	f0 2d       	mov	r31, r0
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    2328:	ed 2d       	mov	r30, r13
    232a:	e6 95       	lsr	r30
    232c:	e6 95       	lsr	r30
    232e:	e6 95       	lsr	r30
    2330:	30 e2       	ldi	r19, 0x20	; 32
    2332:	e3 9f       	mul	r30, r19
    2334:	f0 01       	movw	r30, r0
    2336:	11 24       	eor	r1, r1
    2338:	fa 5f       	subi	r31, 0xFA	; 250
    233a:	3d 2d       	mov	r19, r13
    233c:	37 70       	andi	r19, 0x07	; 7
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    233e:	81 e0       	ldi	r24, 0x01	; 1
    2340:	90 e0       	ldi	r25, 0x00	; 0
    2342:	03 2e       	mov	r0, r19
    2344:	02 c0       	rjmp	.+4      	; 0x234a <usart_init_spi+0x328>
    2346:	88 0f       	add	r24, r24
    2348:	99 1f       	adc	r25, r25
    234a:	0a 94       	dec	r0
    234c:	e2 f7       	brpl	.-8      	; 0x2346 <usart_init_spi+0x324>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    234e:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    2350:	22 30       	cpi	r18, 0x02	; 2
    2352:	10 f0       	brcs	.+4      	; 0x2358 <usart_init_spi+0x336>
    2354:	40 e0       	ldi	r20, 0x00	; 0
    2356:	01 c0       	rjmp	.+2      	; 0x235a <usart_init_spi+0x338>
    2358:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    235a:	df 01       	movw	r26, r30
    235c:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    235e:	a3 0f       	add	r26, r19
    2360:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    2362:	9f b7       	in	r25, 0x3f	; 63
    2364:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
    2366:	f8 94       	cli
	return flags;
    2368:	39 81       	ldd	r19, Y+1	; 0x01
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    236a:	2c 91       	ld	r18, X
    236c:	27 70       	andi	r18, 0x07	; 7
    236e:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    2370:	9c 91       	ld	r25, X
    2372:	94 2b       	or	r25, r20
    2374:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    2376:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    2378:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    237a:	f7 01       	movw	r30, r14
    237c:	85 81       	ldd	r24, Z+5	; 0x05
    237e:	80 6c       	ori	r24, 0xC0	; 192
    2380:	85 83       	std	Z+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    2382:	f8 01       	movw	r30, r16
    2384:	84 81       	ldd	r24, Z+4	; 0x04
    2386:	8d 7f       	andi	r24, 0xFD	; 253
    2388:	81 30       	cpi	r24, 0x01	; 1
    238a:	29 f4       	brne	.+10     	; 0x2396 <usart_init_spi+0x374>
		usart->CTRLC |= USART_UCPHA_bm;
    238c:	f7 01       	movw	r30, r14
    238e:	85 81       	ldd	r24, Z+5	; 0x05
    2390:	82 60       	ori	r24, 0x02	; 2
    2392:	85 83       	std	Z+5, r24	; 0x05
    2394:	04 c0       	rjmp	.+8      	; 0x239e <usart_init_spi+0x37c>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    2396:	f7 01       	movw	r30, r14
    2398:	85 81       	ldd	r24, Z+5	; 0x05
    239a:	8d 7f       	andi	r24, 0xFD	; 253
    239c:	85 83       	std	Z+5, r24	; 0x05
	}
	if (opt->data_order) {
    239e:	f8 01       	movw	r30, r16
    23a0:	85 81       	ldd	r24, Z+5	; 0x05
    23a2:	88 23       	and	r24, r24
    23a4:	29 f0       	breq	.+10     	; 0x23b0 <usart_init_spi+0x38e>
		(usart)->CTRLC |= USART_DORD_bm;
    23a6:	f7 01       	movw	r30, r14
    23a8:	85 81       	ldd	r24, Z+5	; 0x05
    23aa:	84 60       	ori	r24, 0x04	; 4
    23ac:	85 83       	std	Z+5, r24	; 0x05
    23ae:	04 c0       	rjmp	.+8      	; 0x23b8 <usart_init_spi+0x396>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    23b0:	f7 01       	movw	r30, r14
    23b2:	85 81       	ldd	r24, Z+5	; 0x05
    23b4:	8b 7f       	andi	r24, 0xFB	; 251
    23b6:	85 83       	std	Z+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    23b8:	f8 01       	movw	r30, r16
    23ba:	40 81       	ld	r20, Z
    23bc:	51 81       	ldd	r21, Z+1	; 0x01
    23be:	62 81       	ldd	r22, Z+2	; 0x02
    23c0:	73 81       	ldd	r23, Z+3	; 0x03
    23c2:	00 e8       	ldi	r16, 0x80	; 128
    23c4:	14 e8       	ldi	r17, 0x84	; 132
    23c6:	2e e1       	ldi	r18, 0x1E	; 30
    23c8:	30 e0       	ldi	r19, 0x00	; 0
    23ca:	c7 01       	movw	r24, r14
    23cc:	f8 dd       	rcall	.-1040   	; 0x1fbe <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    23ce:	f7 01       	movw	r30, r14
    23d0:	84 81       	ldd	r24, Z+4	; 0x04
    23d2:	88 60       	ori	r24, 0x08	; 8
    23d4:	84 83       	std	Z+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    23d6:	84 81       	ldd	r24, Z+4	; 0x04
    23d8:	80 61       	ori	r24, 0x10	; 16
    23da:	84 83       	std	Z+4, r24	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    23dc:	1a c0       	rjmp	.+52     	; 0x2412 <usart_init_spi+0x3f0>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    23de:	f7 01       	movw	r30, r14
    23e0:	84 81       	ldd	r24, Z+4	; 0x04
    23e2:	8f 7e       	andi	r24, 0xEF	; 239
    23e4:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    23e6:	f8 01       	movw	r30, r16
    23e8:	24 81       	ldd	r18, Z+4	; 0x04
    23ea:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    23ec:	c7 01       	movw	r24, r14
    23ee:	60 cf       	rjmp	.-320    	; 0x22b0 <usart_init_spi+0x28e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    23f0:	0f 2e       	mov	r0, r31
    23f2:	f5 e1       	ldi	r31, 0x15	; 21
    23f4:	df 2e       	mov	r13, r31
    23f6:	f0 2d       	mov	r31, r0
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    23f8:	80 ea       	ldi	r24, 0xA0	; 160
    23fa:	98 e0       	ldi	r25, 0x08	; 8
    23fc:	6a cf       	rjmp	.-300    	; 0x22d2 <usart_init_spi+0x2b0>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    23fe:	0f 2e       	mov	r0, r31
    2400:	fd e1       	ldi	r31, 0x1D	; 29
    2402:	df 2e       	mov	r13, r31
    2404:	f0 2d       	mov	r31, r0
    2406:	7b cf       	rjmp	.-266    	; 0x22fe <usart_init_spi+0x2dc>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    2408:	0f 2e       	mov	r0, r31
    240a:	f5 e2       	ldi	r31, 0x25	; 37
    240c:	df 2e       	mov	r13, r31
    240e:	f0 2d       	mov	r31, r0
    2410:	8b cf       	rjmp	.-234    	; 0x2328 <usart_init_spi+0x306>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    2412:	0f 90       	pop	r0
    2414:	df 91       	pop	r29
    2416:	cf 91       	pop	r28
    2418:	1f 91       	pop	r17
    241a:	0f 91       	pop	r16
    241c:	ff 90       	pop	r15
    241e:	ef 90       	pop	r14
    2420:	df 90       	pop	r13
    2422:	08 95       	ret

00002424 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2424:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2426:	03 96       	adiw	r24, 0x03	; 3
    2428:	81 83       	std	Z+1, r24	; 0x01
    242a:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    242c:	2f ef       	ldi	r18, 0xFF	; 255
    242e:	3f ef       	ldi	r19, 0xFF	; 255
    2430:	23 83       	std	Z+3, r18	; 0x03
    2432:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2434:	85 83       	std	Z+5, r24	; 0x05
    2436:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2438:	87 83       	std	Z+7, r24	; 0x07
    243a:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    243c:	10 82       	st	Z, r1
    243e:	08 95       	ret

00002440 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    2440:	fc 01       	movw	r30, r24
    2442:	10 86       	std	Z+8, r1	; 0x08
    2444:	11 86       	std	Z+9, r1	; 0x09
    2446:	08 95       	ret

00002448 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2448:	cf 93       	push	r28
    244a:	df 93       	push	r29
    244c:	9c 01       	movw	r18, r24
    244e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2450:	dc 01       	movw	r26, r24
    2452:	11 96       	adiw	r26, 0x01	; 1
    2454:	cd 91       	ld	r28, X+
    2456:	dc 91       	ld	r29, X
    2458:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    245a:	c2 83       	std	Z+2, r28	; 0x02
    245c:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    245e:	8c 81       	ldd	r24, Y+4	; 0x04
    2460:	9d 81       	ldd	r25, Y+5	; 0x05
    2462:	84 83       	std	Z+4, r24	; 0x04
    2464:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2466:	8c 81       	ldd	r24, Y+4	; 0x04
    2468:	9d 81       	ldd	r25, Y+5	; 0x05
    246a:	dc 01       	movw	r26, r24
    246c:	12 96       	adiw	r26, 0x02	; 2
    246e:	6d 93       	st	X+, r22
    2470:	7c 93       	st	X, r23
    2472:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    2474:	6c 83       	std	Y+4, r22	; 0x04
    2476:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    2478:	20 87       	std	Z+8, r18	; 0x08
    247a:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    247c:	f9 01       	movw	r30, r18
    247e:	80 81       	ld	r24, Z
    2480:	8f 5f       	subi	r24, 0xFF	; 255
    2482:	80 83       	st	Z, r24
}
    2484:	df 91       	pop	r29
    2486:	cf 91       	pop	r28
    2488:	08 95       	ret

0000248a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    248a:	cf 93       	push	r28
    248c:	df 93       	push	r29
    248e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2490:	48 81       	ld	r20, Y
    2492:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2494:	4f 3f       	cpi	r20, 0xFF	; 255
    2496:	2f ef       	ldi	r18, 0xFF	; 255
    2498:	52 07       	cpc	r21, r18
    249a:	21 f4       	brne	.+8      	; 0x24a4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    249c:	fc 01       	movw	r30, r24
    249e:	a7 81       	ldd	r26, Z+7	; 0x07
    24a0:	b0 85       	ldd	r27, Z+8	; 0x08
    24a2:	0d c0       	rjmp	.+26     	; 0x24be <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    24a4:	dc 01       	movw	r26, r24
    24a6:	13 96       	adiw	r26, 0x03	; 3
    24a8:	01 c0       	rjmp	.+2      	; 0x24ac <vListInsert+0x22>
    24aa:	df 01       	movw	r26, r30
    24ac:	12 96       	adiw	r26, 0x02	; 2
    24ae:	ed 91       	ld	r30, X+
    24b0:	fc 91       	ld	r31, X
    24b2:	13 97       	sbiw	r26, 0x03	; 3
    24b4:	20 81       	ld	r18, Z
    24b6:	31 81       	ldd	r19, Z+1	; 0x01
    24b8:	42 17       	cp	r20, r18
    24ba:	53 07       	cpc	r21, r19
    24bc:	b0 f7       	brcc	.-20     	; 0x24aa <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    24be:	12 96       	adiw	r26, 0x02	; 2
    24c0:	ed 91       	ld	r30, X+
    24c2:	fc 91       	ld	r31, X
    24c4:	13 97       	sbiw	r26, 0x03	; 3
    24c6:	ea 83       	std	Y+2, r30	; 0x02
    24c8:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    24ca:	c4 83       	std	Z+4, r28	; 0x04
    24cc:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    24ce:	ac 83       	std	Y+4, r26	; 0x04
    24d0:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    24d2:	12 96       	adiw	r26, 0x02	; 2
    24d4:	cd 93       	st	X+, r28
    24d6:	dc 93       	st	X, r29
    24d8:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    24da:	88 87       	std	Y+8, r24	; 0x08
    24dc:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    24de:	fc 01       	movw	r30, r24
    24e0:	20 81       	ld	r18, Z
    24e2:	2f 5f       	subi	r18, 0xFF	; 255
    24e4:	20 83       	st	Z, r18
}
    24e6:	df 91       	pop	r29
    24e8:	cf 91       	pop	r28
    24ea:	08 95       	ret

000024ec <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    24ec:	cf 93       	push	r28
    24ee:	df 93       	push	r29
    24f0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    24f2:	a0 85       	ldd	r26, Z+8	; 0x08
    24f4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    24f6:	c2 81       	ldd	r28, Z+2	; 0x02
    24f8:	d3 81       	ldd	r29, Z+3	; 0x03
    24fa:	84 81       	ldd	r24, Z+4	; 0x04
    24fc:	95 81       	ldd	r25, Z+5	; 0x05
    24fe:	8c 83       	std	Y+4, r24	; 0x04
    2500:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2502:	c4 81       	ldd	r28, Z+4	; 0x04
    2504:	d5 81       	ldd	r29, Z+5	; 0x05
    2506:	82 81       	ldd	r24, Z+2	; 0x02
    2508:	93 81       	ldd	r25, Z+3	; 0x03
    250a:	8a 83       	std	Y+2, r24	; 0x02
    250c:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    250e:	11 96       	adiw	r26, 0x01	; 1
    2510:	8d 91       	ld	r24, X+
    2512:	9c 91       	ld	r25, X
    2514:	12 97       	sbiw	r26, 0x02	; 2
    2516:	e8 17       	cp	r30, r24
    2518:	f9 07       	cpc	r31, r25
    251a:	31 f4       	brne	.+12     	; 0x2528 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    251c:	84 81       	ldd	r24, Z+4	; 0x04
    251e:	95 81       	ldd	r25, Z+5	; 0x05
    2520:	11 96       	adiw	r26, 0x01	; 1
    2522:	8d 93       	st	X+, r24
    2524:	9c 93       	st	X, r25
    2526:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    2528:	10 86       	std	Z+8, r1	; 0x08
    252a:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    252c:	8c 91       	ld	r24, X
    252e:	81 50       	subi	r24, 0x01	; 1
    2530:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    2532:	8c 91       	ld	r24, X
}
    2534:	df 91       	pop	r29
    2536:	cf 91       	pop	r28
    2538:	08 95       	ret

0000253a <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    253a:	0f 93       	push	r16
    253c:	1f 93       	push	r17
    253e:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    2540:	71 e1       	ldi	r23, 0x11	; 17
    2542:	fc 01       	movw	r30, r24
    2544:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    2546:	31 97       	sbiw	r30, 0x01	; 1
    2548:	62 e2       	ldi	r22, 0x22	; 34
    254a:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    254c:	31 97       	sbiw	r30, 0x01	; 1
    254e:	23 e3       	ldi	r18, 0x33	; 51
    2550:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    2552:	01 2e       	mov	r0, r17
    2554:	00 0c       	add	r0, r0
    2556:	22 0b       	sbc	r18, r18
    2558:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    255a:	31 97       	sbiw	r30, 0x01	; 1
    255c:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    255e:	31 97       	sbiw	r30, 0x01	; 1
    2560:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    2562:	31 97       	sbiw	r30, 0x01	; 1
    2564:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    2566:	31 97       	sbiw	r30, 0x01	; 1
    2568:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    256a:	31 97       	sbiw	r30, 0x01	; 1
    256c:	20 e8       	ldi	r18, 0x80	; 128
    256e:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    2570:	31 97       	sbiw	r30, 0x01	; 1
    2572:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    2574:	31 97       	sbiw	r30, 0x01	; 1
    2576:	22 e0       	ldi	r18, 0x02	; 2
    2578:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    257a:	31 97       	sbiw	r30, 0x01	; 1
    257c:	23 e0       	ldi	r18, 0x03	; 3
    257e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    2580:	31 97       	sbiw	r30, 0x01	; 1
    2582:	24 e0       	ldi	r18, 0x04	; 4
    2584:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    2586:	31 97       	sbiw	r30, 0x01	; 1
    2588:	25 e0       	ldi	r18, 0x05	; 5
    258a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    258c:	31 97       	sbiw	r30, 0x01	; 1
    258e:	26 e0       	ldi	r18, 0x06	; 6
    2590:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    2592:	31 97       	sbiw	r30, 0x01	; 1
    2594:	27 e0       	ldi	r18, 0x07	; 7
    2596:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    2598:	31 97       	sbiw	r30, 0x01	; 1
    259a:	28 e0       	ldi	r18, 0x08	; 8
    259c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    259e:	31 97       	sbiw	r30, 0x01	; 1
    25a0:	29 e0       	ldi	r18, 0x09	; 9
    25a2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    25a4:	31 97       	sbiw	r30, 0x01	; 1
    25a6:	20 e1       	ldi	r18, 0x10	; 16
    25a8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    25aa:	31 97       	sbiw	r30, 0x01	; 1
    25ac:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    25ae:	31 97       	sbiw	r30, 0x01	; 1
    25b0:	22 e1       	ldi	r18, 0x12	; 18
    25b2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    25b4:	31 97       	sbiw	r30, 0x01	; 1
    25b6:	23 e1       	ldi	r18, 0x13	; 19
    25b8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    25ba:	31 97       	sbiw	r30, 0x01	; 1
    25bc:	24 e1       	ldi	r18, 0x14	; 20
    25be:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    25c0:	31 97       	sbiw	r30, 0x01	; 1
    25c2:	25 e1       	ldi	r18, 0x15	; 21
    25c4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    25c6:	31 97       	sbiw	r30, 0x01	; 1
    25c8:	26 e1       	ldi	r18, 0x16	; 22
    25ca:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    25cc:	31 97       	sbiw	r30, 0x01	; 1
    25ce:	27 e1       	ldi	r18, 0x17	; 23
    25d0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    25d2:	31 97       	sbiw	r30, 0x01	; 1
    25d4:	28 e1       	ldi	r18, 0x18	; 24
    25d6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    25d8:	31 97       	sbiw	r30, 0x01	; 1
    25da:	29 e1       	ldi	r18, 0x19	; 25
    25dc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    25de:	31 97       	sbiw	r30, 0x01	; 1
    25e0:	20 e2       	ldi	r18, 0x20	; 32
    25e2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    25e4:	31 97       	sbiw	r30, 0x01	; 1
    25e6:	21 e2       	ldi	r18, 0x21	; 33
    25e8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    25ea:	31 97       	sbiw	r30, 0x01	; 1
    25ec:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    25ee:	31 97       	sbiw	r30, 0x01	; 1
    25f0:	23 e2       	ldi	r18, 0x23	; 35
    25f2:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    25f4:	31 97       	sbiw	r30, 0x01	; 1
    25f6:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    25f8:	31 97       	sbiw	r30, 0x01	; 1
    25fa:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    25fc:	31 97       	sbiw	r30, 0x01	; 1
    25fe:	26 e2       	ldi	r18, 0x26	; 38
    2600:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    2602:	31 97       	sbiw	r30, 0x01	; 1
    2604:	27 e2       	ldi	r18, 0x27	; 39
    2606:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    2608:	31 97       	sbiw	r30, 0x01	; 1
    260a:	28 e2       	ldi	r18, 0x28	; 40
    260c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    260e:	31 97       	sbiw	r30, 0x01	; 1
    2610:	29 e2       	ldi	r18, 0x29	; 41
    2612:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    2614:	31 97       	sbiw	r30, 0x01	; 1
    2616:	20 e3       	ldi	r18, 0x30	; 48
    2618:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    261a:	31 97       	sbiw	r30, 0x01	; 1
    261c:	21 e3       	ldi	r18, 0x31	; 49
    261e:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    2620:	87 97       	sbiw	r24, 0x27	; 39
    2622:	1f 91       	pop	r17
    2624:	0f 91       	pop	r16
    2626:	08 95       	ret

00002628 <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    2628:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    262a:	e0 e7       	ldi	r30, 0x70	; 112
    262c:	f0 e0       	ldi	r31, 0x00	; 0
    262e:	83 81       	ldd	r24, Z+3	; 0x03
    2630:	8a 7f       	andi	r24, 0xFA	; 250
    2632:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    2634:	e0 e0       	ldi	r30, 0x00	; 0
    2636:	f8 e0       	ldi	r31, 0x08	; 8
    2638:	80 e0       	ldi	r24, 0x00	; 0
    263a:	9a ef       	ldi	r25, 0xFA	; 250
    263c:	86 a3       	std	Z+38, r24	; 0x26
    263e:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    2640:	91 e0       	ldi	r25, 0x01	; 1
    2642:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    2644:	a0 ea       	ldi	r26, 0xA0	; 160
    2646:	b0 e0       	ldi	r27, 0x00	; 0
    2648:	12 96       	adiw	r26, 0x02	; 2
    264a:	8c 91       	ld	r24, X
    264c:	12 97       	sbiw	r26, 0x02	; 2
    264e:	81 60       	ori	r24, 0x01	; 1
    2650:	12 96       	adiw	r26, 0x02	; 2
    2652:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    2654:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    2656:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    2658:	a0 91 c3 23 	lds	r26, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    265c:	b0 91 c4 23 	lds	r27, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    2660:	0d 90       	ld	r0, X+
    2662:	0d be       	out	0x3d, r0	; 61
    2664:	0d 90       	ld	r0, X+
    2666:	0e be       	out	0x3e, r0	; 62
    2668:	ff 91       	pop	r31
    266a:	ef 91       	pop	r30
    266c:	df 91       	pop	r29
    266e:	cf 91       	pop	r28
    2670:	bf 91       	pop	r27
    2672:	af 91       	pop	r26
    2674:	9f 91       	pop	r25
    2676:	8f 91       	pop	r24
    2678:	7f 91       	pop	r23
    267a:	6f 91       	pop	r22
    267c:	5f 91       	pop	r21
    267e:	4f 91       	pop	r20
    2680:	3f 91       	pop	r19
    2682:	2f 91       	pop	r18
    2684:	1f 91       	pop	r17
    2686:	0f 91       	pop	r16
    2688:	ff 90       	pop	r15
    268a:	ef 90       	pop	r14
    268c:	df 90       	pop	r13
    268e:	cf 90       	pop	r12
    2690:	bf 90       	pop	r11
    2692:	af 90       	pop	r10
    2694:	9f 90       	pop	r9
    2696:	8f 90       	pop	r8
    2698:	7f 90       	pop	r7
    269a:	6f 90       	pop	r6
    269c:	5f 90       	pop	r5
    269e:	4f 90       	pop	r4
    26a0:	3f 90       	pop	r3
    26a2:	2f 90       	pop	r2
    26a4:	1f 90       	pop	r1
    26a6:	0f 90       	pop	r0
    26a8:	0f be       	out	0x3f, r0	; 63
    26aa:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    26ac:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    26ae:	81 e0       	ldi	r24, 0x01	; 1
    26b0:	08 95       	ret

000026b2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    26b2:	0f 92       	push	r0
    26b4:	0f b6       	in	r0, 0x3f	; 63
    26b6:	f8 94       	cli
    26b8:	0f 92       	push	r0
    26ba:	1f 92       	push	r1
    26bc:	11 24       	eor	r1, r1
    26be:	2f 92       	push	r2
    26c0:	3f 92       	push	r3
    26c2:	4f 92       	push	r4
    26c4:	5f 92       	push	r5
    26c6:	6f 92       	push	r6
    26c8:	7f 92       	push	r7
    26ca:	8f 92       	push	r8
    26cc:	9f 92       	push	r9
    26ce:	af 92       	push	r10
    26d0:	bf 92       	push	r11
    26d2:	cf 92       	push	r12
    26d4:	df 92       	push	r13
    26d6:	ef 92       	push	r14
    26d8:	ff 92       	push	r15
    26da:	0f 93       	push	r16
    26dc:	1f 93       	push	r17
    26de:	2f 93       	push	r18
    26e0:	3f 93       	push	r19
    26e2:	4f 93       	push	r20
    26e4:	5f 93       	push	r21
    26e6:	6f 93       	push	r22
    26e8:	7f 93       	push	r23
    26ea:	8f 93       	push	r24
    26ec:	9f 93       	push	r25
    26ee:	af 93       	push	r26
    26f0:	bf 93       	push	r27
    26f2:	cf 93       	push	r28
    26f4:	df 93       	push	r29
    26f6:	ef 93       	push	r30
    26f8:	ff 93       	push	r31
    26fa:	a0 91 c3 23 	lds	r26, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    26fe:	b0 91 c4 23 	lds	r27, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    2702:	0d b6       	in	r0, 0x3d	; 61
    2704:	0d 92       	st	X+, r0
    2706:	0e b6       	in	r0, 0x3e	; 62
    2708:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    270a:	7e d6       	rcall	.+3324   	; 0x3408 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    270c:	a0 91 c3 23 	lds	r26, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    2710:	b0 91 c4 23 	lds	r27, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    2714:	0d 90       	ld	r0, X+
    2716:	0d be       	out	0x3d, r0	; 61
    2718:	0d 90       	ld	r0, X+
    271a:	0e be       	out	0x3e, r0	; 62
    271c:	ff 91       	pop	r31
    271e:	ef 91       	pop	r30
    2720:	df 91       	pop	r29
    2722:	cf 91       	pop	r28
    2724:	bf 91       	pop	r27
    2726:	af 91       	pop	r26
    2728:	9f 91       	pop	r25
    272a:	8f 91       	pop	r24
    272c:	7f 91       	pop	r23
    272e:	6f 91       	pop	r22
    2730:	5f 91       	pop	r21
    2732:	4f 91       	pop	r20
    2734:	3f 91       	pop	r19
    2736:	2f 91       	pop	r18
    2738:	1f 91       	pop	r17
    273a:	0f 91       	pop	r16
    273c:	ff 90       	pop	r15
    273e:	ef 90       	pop	r14
    2740:	df 90       	pop	r13
    2742:	cf 90       	pop	r12
    2744:	bf 90       	pop	r11
    2746:	af 90       	pop	r10
    2748:	9f 90       	pop	r9
    274a:	8f 90       	pop	r8
    274c:	7f 90       	pop	r7
    274e:	6f 90       	pop	r6
    2750:	5f 90       	pop	r5
    2752:	4f 90       	pop	r4
    2754:	3f 90       	pop	r3
    2756:	2f 90       	pop	r2
    2758:	1f 90       	pop	r1
    275a:	0f 90       	pop	r0
    275c:	0f be       	out	0x3f, r0	; 63
    275e:	0f 90       	pop	r0

    asm volatile ( "ret" );
    2760:	08 95       	ret

00002762 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    2762:	0f 92       	push	r0
    2764:	0f b6       	in	r0, 0x3f	; 63
    2766:	f8 94       	cli
    2768:	0f 92       	push	r0
    276a:	1f 92       	push	r1
    276c:	11 24       	eor	r1, r1
    276e:	2f 92       	push	r2
    2770:	3f 92       	push	r3
    2772:	4f 92       	push	r4
    2774:	5f 92       	push	r5
    2776:	6f 92       	push	r6
    2778:	7f 92       	push	r7
    277a:	8f 92       	push	r8
    277c:	9f 92       	push	r9
    277e:	af 92       	push	r10
    2780:	bf 92       	push	r11
    2782:	cf 92       	push	r12
    2784:	df 92       	push	r13
    2786:	ef 92       	push	r14
    2788:	ff 92       	push	r15
    278a:	0f 93       	push	r16
    278c:	1f 93       	push	r17
    278e:	2f 93       	push	r18
    2790:	3f 93       	push	r19
    2792:	4f 93       	push	r20
    2794:	5f 93       	push	r21
    2796:	6f 93       	push	r22
    2798:	7f 93       	push	r23
    279a:	8f 93       	push	r24
    279c:	9f 93       	push	r25
    279e:	af 93       	push	r26
    27a0:	bf 93       	push	r27
    27a2:	cf 93       	push	r28
    27a4:	df 93       	push	r29
    27a6:	ef 93       	push	r30
    27a8:	ff 93       	push	r31
    27aa:	a0 91 c3 23 	lds	r26, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    27ae:	b0 91 c4 23 	lds	r27, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    27b2:	0d b6       	in	r0, 0x3d	; 61
    27b4:	0d 92       	st	X+, r0
    27b6:	0e b6       	in	r0, 0x3e	; 62
    27b8:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    27ba:	e1 d4       	rcall	.+2498   	; 0x317e <xTaskIncrementTick>
    27bc:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    27be:	24 d6       	rcall	.+3144   	; 0x3408 <vTaskSwitchContext>
    27c0:	a0 91 c3 23 	lds	r26, 0x23C3	; 0x8023c3 <pxCurrentTCB>
        }
        portRESTORE_CONTEXT();
    27c4:	b0 91 c4 23 	lds	r27, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    27c8:	0d 90       	ld	r0, X+
    27ca:	0d be       	out	0x3d, r0	; 61
    27cc:	0d 90       	ld	r0, X+
    27ce:	0e be       	out	0x3e, r0	; 62
    27d0:	ff 91       	pop	r31
    27d2:	ef 91       	pop	r30
    27d4:	df 91       	pop	r29
    27d6:	cf 91       	pop	r28
    27d8:	bf 91       	pop	r27
    27da:	af 91       	pop	r26
    27dc:	9f 91       	pop	r25
    27de:	8f 91       	pop	r24
    27e0:	7f 91       	pop	r23
    27e2:	6f 91       	pop	r22
    27e4:	5f 91       	pop	r21
    27e6:	4f 91       	pop	r20
    27e8:	3f 91       	pop	r19
    27ea:	2f 91       	pop	r18
    27ec:	1f 91       	pop	r17
    27ee:	0f 91       	pop	r16
    27f0:	ff 90       	pop	r15
    27f2:	ef 90       	pop	r14
    27f4:	df 90       	pop	r13
    27f6:	cf 90       	pop	r12
    27f8:	bf 90       	pop	r11
    27fa:	af 90       	pop	r10
    27fc:	9f 90       	pop	r9
    27fe:	8f 90       	pop	r8
    2800:	7f 90       	pop	r7
    2802:	6f 90       	pop	r6
    2804:	5f 90       	pop	r5
    2806:	4f 90       	pop	r4
    2808:	3f 90       	pop	r3
    280a:	2f 90       	pop	r2
    280c:	1f 90       	pop	r1
    280e:	0f 90       	pop	r0
    2810:	0f be       	out	0x3f, r0	; 63
    2812:	0f 90       	pop	r0
    2814:	18 95       	reti

00002816 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2816:	cf 93       	push	r28
    2818:	df 93       	push	r29
    281a:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    281c:	a0 d4       	rcall	.+2368   	; 0x315e <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    281e:	ce 01       	movw	r24, r28
    2820:	0e 94 19 24 	call	0x4832	; 0x4832 <malloc>
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2824:	ec 01       	movw	r28, r24
    2826:	63 d5       	rcall	.+2758   	; 0x32ee <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2828:	ce 01       	movw	r24, r28
    282a:	df 91       	pop	r29
    282c:	cf 91       	pop	r28
    282e:	08 95       	ret

00002830 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2830:	cf 93       	push	r28
    2832:	df 93       	push	r29
	if( pv )
    2834:	00 97       	sbiw	r24, 0x00	; 0
    2836:	31 f0       	breq	.+12     	; 0x2844 <vPortFree+0x14>
    2838:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    283a:	91 d4       	rcall	.+2338   	; 0x315e <vTaskSuspendAll>
		{
			free( pv );
    283c:	ce 01       	movw	r24, r28
    283e:	0e 94 b1 24 	call	0x4962	; 0x4962 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    2842:	55 d5       	rcall	.+2730   	; 0x32ee <xTaskResumeAll>
	}
}
    2844:	df 91       	pop	r29
    2846:	cf 91       	pop	r28
    2848:	08 95       	ret

0000284a <prvIsQueueEmpty>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    284a:	0f b6       	in	r0, 0x3f	; 63
    284c:	f8 94       	cli
    284e:	0f 92       	push	r0
    2850:	fc 01       	movw	r30, r24
    2852:	92 8d       	ldd	r25, Z+26	; 0x1a
    2854:	0f 90       	pop	r0
    2856:	0f be       	out	0x3f, r0	; 63
    2858:	81 e0       	ldi	r24, 0x01	; 1
    285a:	91 11       	cpse	r25, r1
    285c:	80 e0       	ldi	r24, 0x00	; 0
    285e:	08 95       	ret

00002860 <prvCopyDataToQueue>:
    2860:	0f 93       	push	r16
    2862:	1f 93       	push	r17
    2864:	cf 93       	push	r28
    2866:	df 93       	push	r29
    2868:	ec 01       	movw	r28, r24
    286a:	04 2f       	mov	r16, r20
    286c:	1a 8d       	ldd	r17, Y+26	; 0x1a
    286e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2870:	44 23       	and	r20, r20
    2872:	b9 f1       	breq	.+110    	; 0x28e2 <prvCopyDataToQueue+0x82>
    2874:	01 11       	cpse	r16, r1
    2876:	16 c0       	rjmp	.+44     	; 0x28a4 <prvCopyDataToQueue+0x44>
    2878:	50 e0       	ldi	r21, 0x00	; 0
    287a:	8a 81       	ldd	r24, Y+2	; 0x02
    287c:	9b 81       	ldd	r25, Y+3	; 0x03
    287e:	0e 94 3a 25 	call	0x4a74	; 0x4a74 <memcpy>
    2882:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2884:	8a 81       	ldd	r24, Y+2	; 0x02
    2886:	9b 81       	ldd	r25, Y+3	; 0x03
    2888:	82 0f       	add	r24, r18
    288a:	91 1d       	adc	r25, r1
    288c:	8a 83       	std	Y+2, r24	; 0x02
    288e:	9b 83       	std	Y+3, r25	; 0x03
    2890:	2c 81       	ldd	r18, Y+4	; 0x04
    2892:	3d 81       	ldd	r19, Y+5	; 0x05
    2894:	82 17       	cp	r24, r18
    2896:	93 07       	cpc	r25, r19
    2898:	20 f1       	brcs	.+72     	; 0x28e2 <prvCopyDataToQueue+0x82>
    289a:	88 81       	ld	r24, Y
    289c:	99 81       	ldd	r25, Y+1	; 0x01
    289e:	8a 83       	std	Y+2, r24	; 0x02
    28a0:	9b 83       	std	Y+3, r25	; 0x03
    28a2:	1f c0       	rjmp	.+62     	; 0x28e2 <prvCopyDataToQueue+0x82>
    28a4:	50 e0       	ldi	r21, 0x00	; 0
    28a6:	8e 81       	ldd	r24, Y+6	; 0x06
    28a8:	9f 81       	ldd	r25, Y+7	; 0x07
    28aa:	0e 94 3a 25 	call	0x4a74	; 0x4a74 <memcpy>
    28ae:	8c 8d       	ldd	r24, Y+28	; 0x1c
    28b0:	90 e0       	ldi	r25, 0x00	; 0
    28b2:	91 95       	neg	r25
    28b4:	81 95       	neg	r24
    28b6:	91 09       	sbc	r25, r1
    28b8:	2e 81       	ldd	r18, Y+6	; 0x06
    28ba:	3f 81       	ldd	r19, Y+7	; 0x07
    28bc:	28 0f       	add	r18, r24
    28be:	39 1f       	adc	r19, r25
    28c0:	2e 83       	std	Y+6, r18	; 0x06
    28c2:	3f 83       	std	Y+7, r19	; 0x07
    28c4:	48 81       	ld	r20, Y
    28c6:	59 81       	ldd	r21, Y+1	; 0x01
    28c8:	24 17       	cp	r18, r20
    28ca:	35 07       	cpc	r19, r21
    28cc:	30 f4       	brcc	.+12     	; 0x28da <prvCopyDataToQueue+0x7a>
    28ce:	2c 81       	ldd	r18, Y+4	; 0x04
    28d0:	3d 81       	ldd	r19, Y+5	; 0x05
    28d2:	82 0f       	add	r24, r18
    28d4:	93 1f       	adc	r25, r19
    28d6:	8e 83       	std	Y+6, r24	; 0x06
    28d8:	9f 83       	std	Y+7, r25	; 0x07
    28da:	02 30       	cpi	r16, 0x02	; 2
    28dc:	11 f4       	brne	.+4      	; 0x28e2 <prvCopyDataToQueue+0x82>
    28de:	11 11       	cpse	r17, r1
    28e0:	11 50       	subi	r17, 0x01	; 1
    28e2:	1f 5f       	subi	r17, 0xFF	; 255
    28e4:	1a 8f       	std	Y+26, r17	; 0x1a
    28e6:	80 e0       	ldi	r24, 0x00	; 0
    28e8:	df 91       	pop	r29
    28ea:	cf 91       	pop	r28
    28ec:	1f 91       	pop	r17
    28ee:	0f 91       	pop	r16
    28f0:	08 95       	ret

000028f2 <prvCopyDataFromQueue>:
    28f2:	fc 01       	movw	r30, r24
    28f4:	44 8d       	ldd	r20, Z+28	; 0x1c
    28f6:	44 23       	and	r20, r20
    28f8:	a9 f0       	breq	.+42     	; 0x2924 <prvCopyDataFromQueue+0x32>
    28fa:	50 e0       	ldi	r21, 0x00	; 0
    28fc:	26 81       	ldd	r18, Z+6	; 0x06
    28fe:	37 81       	ldd	r19, Z+7	; 0x07
    2900:	24 0f       	add	r18, r20
    2902:	35 1f       	adc	r19, r21
    2904:	26 83       	std	Z+6, r18	; 0x06
    2906:	37 83       	std	Z+7, r19	; 0x07
    2908:	84 81       	ldd	r24, Z+4	; 0x04
    290a:	95 81       	ldd	r25, Z+5	; 0x05
    290c:	28 17       	cp	r18, r24
    290e:	39 07       	cpc	r19, r25
    2910:	20 f0       	brcs	.+8      	; 0x291a <prvCopyDataFromQueue+0x28>
    2912:	80 81       	ld	r24, Z
    2914:	91 81       	ldd	r25, Z+1	; 0x01
    2916:	86 83       	std	Z+6, r24	; 0x06
    2918:	97 83       	std	Z+7, r25	; 0x07
    291a:	cb 01       	movw	r24, r22
    291c:	66 81       	ldd	r22, Z+6	; 0x06
    291e:	77 81       	ldd	r23, Z+7	; 0x07
    2920:	0c 94 3a 25 	jmp	0x4a74	; 0x4a74 <memcpy>
    2924:	08 95       	ret

00002926 <prvUnlockQueue>:
    2926:	ef 92       	push	r14
    2928:	ff 92       	push	r15
    292a:	0f 93       	push	r16
    292c:	1f 93       	push	r17
    292e:	cf 93       	push	r28
    2930:	8c 01       	movw	r16, r24
    2932:	0f b6       	in	r0, 0x3f	; 63
    2934:	f8 94       	cli
    2936:	0f 92       	push	r0
    2938:	fc 01       	movw	r30, r24
    293a:	c6 8d       	ldd	r28, Z+30	; 0x1e
    293c:	1c 16       	cp	r1, r28
    293e:	9c f4       	brge	.+38     	; 0x2966 <prvUnlockQueue+0x40>
    2940:	81 89       	ldd	r24, Z+17	; 0x11
    2942:	81 11       	cpse	r24, r1
    2944:	06 c0       	rjmp	.+12     	; 0x2952 <prvUnlockQueue+0x2c>
    2946:	0f c0       	rjmp	.+30     	; 0x2966 <prvUnlockQueue+0x40>
    2948:	f8 01       	movw	r30, r16
    294a:	81 89       	ldd	r24, Z+17	; 0x11
    294c:	81 11       	cpse	r24, r1
    294e:	05 c0       	rjmp	.+10     	; 0x295a <prvUnlockQueue+0x34>
    2950:	0a c0       	rjmp	.+20     	; 0x2966 <prvUnlockQueue+0x40>
    2952:	78 01       	movw	r14, r16
    2954:	f1 e1       	ldi	r31, 0x11	; 17
    2956:	ef 0e       	add	r14, r31
    2958:	f1 1c       	adc	r15, r1
    295a:	c7 01       	movw	r24, r14
    295c:	e4 d5       	rcall	.+3016   	; 0x3526 <xTaskRemoveFromEventList>
    295e:	81 11       	cpse	r24, r1
    2960:	60 d6       	rcall	.+3264   	; 0x3622 <vTaskMissedYield>
    2962:	c1 50       	subi	r28, 0x01	; 1
    2964:	89 f7       	brne	.-30     	; 0x2948 <prvUnlockQueue+0x22>
    2966:	8f ef       	ldi	r24, 0xFF	; 255
    2968:	f8 01       	movw	r30, r16
    296a:	86 8f       	std	Z+30, r24	; 0x1e
    296c:	0f 90       	pop	r0
    296e:	0f be       	out	0x3f, r0	; 63
    2970:	0f b6       	in	r0, 0x3f	; 63
    2972:	f8 94       	cli
    2974:	0f 92       	push	r0
    2976:	c5 8d       	ldd	r28, Z+29	; 0x1d
    2978:	1c 16       	cp	r1, r28
    297a:	9c f4       	brge	.+38     	; 0x29a2 <prvUnlockQueue+0x7c>
    297c:	80 85       	ldd	r24, Z+8	; 0x08
    297e:	81 11       	cpse	r24, r1
    2980:	06 c0       	rjmp	.+12     	; 0x298e <prvUnlockQueue+0x68>
    2982:	0f c0       	rjmp	.+30     	; 0x29a2 <prvUnlockQueue+0x7c>
    2984:	f8 01       	movw	r30, r16
    2986:	80 85       	ldd	r24, Z+8	; 0x08
    2988:	81 11       	cpse	r24, r1
    298a:	05 c0       	rjmp	.+10     	; 0x2996 <prvUnlockQueue+0x70>
    298c:	0a c0       	rjmp	.+20     	; 0x29a2 <prvUnlockQueue+0x7c>
    298e:	78 01       	movw	r14, r16
    2990:	f8 e0       	ldi	r31, 0x08	; 8
    2992:	ef 0e       	add	r14, r31
    2994:	f1 1c       	adc	r15, r1
    2996:	c7 01       	movw	r24, r14
    2998:	c6 d5       	rcall	.+2956   	; 0x3526 <xTaskRemoveFromEventList>
    299a:	81 11       	cpse	r24, r1
    299c:	42 d6       	rcall	.+3204   	; 0x3622 <vTaskMissedYield>
    299e:	c1 50       	subi	r28, 0x01	; 1
    29a0:	89 f7       	brne	.-30     	; 0x2984 <prvUnlockQueue+0x5e>
    29a2:	8f ef       	ldi	r24, 0xFF	; 255
    29a4:	f8 01       	movw	r30, r16
    29a6:	85 8f       	std	Z+29, r24	; 0x1d
    29a8:	0f 90       	pop	r0
    29aa:	0f be       	out	0x3f, r0	; 63
    29ac:	cf 91       	pop	r28
    29ae:	1f 91       	pop	r17
    29b0:	0f 91       	pop	r16
    29b2:	ff 90       	pop	r15
    29b4:	ef 90       	pop	r14
    29b6:	08 95       	ret

000029b8 <xQueueGenericReset>:
    29b8:	cf 93       	push	r28
    29ba:	df 93       	push	r29
    29bc:	ec 01       	movw	r28, r24
    29be:	0f b6       	in	r0, 0x3f	; 63
    29c0:	f8 94       	cli
    29c2:	0f 92       	push	r0
    29c4:	e8 81       	ld	r30, Y
    29c6:	f9 81       	ldd	r31, Y+1	; 0x01
    29c8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    29ca:	2c 8d       	ldd	r18, Y+28	; 0x1c
    29cc:	90 e0       	ldi	r25, 0x00	; 0
    29ce:	30 e0       	ldi	r19, 0x00	; 0
    29d0:	82 9f       	mul	r24, r18
    29d2:	a0 01       	movw	r20, r0
    29d4:	83 9f       	mul	r24, r19
    29d6:	50 0d       	add	r21, r0
    29d8:	92 9f       	mul	r25, r18
    29da:	50 0d       	add	r21, r0
    29dc:	11 24       	eor	r1, r1
    29de:	4e 0f       	add	r20, r30
    29e0:	5f 1f       	adc	r21, r31
    29e2:	4c 83       	std	Y+4, r20	; 0x04
    29e4:	5d 83       	std	Y+5, r21	; 0x05
    29e6:	1a 8e       	std	Y+26, r1	; 0x1a
    29e8:	ea 83       	std	Y+2, r30	; 0x02
    29ea:	fb 83       	std	Y+3, r31	; 0x03
    29ec:	01 97       	sbiw	r24, 0x01	; 1
    29ee:	82 9f       	mul	r24, r18
    29f0:	a0 01       	movw	r20, r0
    29f2:	83 9f       	mul	r24, r19
    29f4:	50 0d       	add	r21, r0
    29f6:	92 9f       	mul	r25, r18
    29f8:	50 0d       	add	r21, r0
    29fa:	11 24       	eor	r1, r1
    29fc:	cf 01       	movw	r24, r30
    29fe:	84 0f       	add	r24, r20
    2a00:	95 1f       	adc	r25, r21
    2a02:	8e 83       	std	Y+6, r24	; 0x06
    2a04:	9f 83       	std	Y+7, r25	; 0x07
    2a06:	8f ef       	ldi	r24, 0xFF	; 255
    2a08:	8d 8f       	std	Y+29, r24	; 0x1d
    2a0a:	8e 8f       	std	Y+30, r24	; 0x1e
    2a0c:	61 11       	cpse	r22, r1
    2a0e:	0a c0       	rjmp	.+20     	; 0x2a24 <xQueueGenericReset+0x6c>
    2a10:	88 85       	ldd	r24, Y+8	; 0x08
    2a12:	88 23       	and	r24, r24
    2a14:	69 f0       	breq	.+26     	; 0x2a30 <xQueueGenericReset+0x78>
    2a16:	ce 01       	movw	r24, r28
    2a18:	08 96       	adiw	r24, 0x08	; 8
    2a1a:	85 d5       	rcall	.+2826   	; 0x3526 <xTaskRemoveFromEventList>
    2a1c:	88 23       	and	r24, r24
    2a1e:	41 f0       	breq	.+16     	; 0x2a30 <xQueueGenericReset+0x78>
    2a20:	48 de       	rcall	.-880    	; 0x26b2 <vPortYield>
    2a22:	06 c0       	rjmp	.+12     	; 0x2a30 <xQueueGenericReset+0x78>
    2a24:	ce 01       	movw	r24, r28
    2a26:	08 96       	adiw	r24, 0x08	; 8
    2a28:	fd dc       	rcall	.-1542   	; 0x2424 <vListInitialise>
    2a2a:	ce 01       	movw	r24, r28
    2a2c:	41 96       	adiw	r24, 0x11	; 17
    2a2e:	fa dc       	rcall	.-1548   	; 0x2424 <vListInitialise>
    2a30:	0f 90       	pop	r0
    2a32:	0f be       	out	0x3f, r0	; 63
    2a34:	81 e0       	ldi	r24, 0x01	; 1
    2a36:	df 91       	pop	r29
    2a38:	cf 91       	pop	r28
    2a3a:	08 95       	ret

00002a3c <xQueueGenericCreate>:
    2a3c:	0f 93       	push	r16
    2a3e:	1f 93       	push	r17
    2a40:	cf 93       	push	r28
    2a42:	df 93       	push	r29
    2a44:	08 2f       	mov	r16, r24
    2a46:	16 2f       	mov	r17, r22
    2a48:	86 9f       	mul	r24, r22
    2a4a:	c0 01       	movw	r24, r0
    2a4c:	11 24       	eor	r1, r1
    2a4e:	4f 96       	adiw	r24, 0x1f	; 31
    2a50:	e2 de       	rcall	.-572    	; 0x2816 <pvPortMalloc>
    2a52:	ec 01       	movw	r28, r24
    2a54:	00 97       	sbiw	r24, 0x00	; 0
    2a56:	69 f0       	breq	.+26     	; 0x2a72 <xQueueGenericCreate+0x36>
    2a58:	11 11       	cpse	r17, r1
    2a5a:	03 c0       	rjmp	.+6      	; 0x2a62 <xQueueGenericCreate+0x26>
    2a5c:	88 83       	st	Y, r24
    2a5e:	99 83       	std	Y+1, r25	; 0x01
    2a60:	03 c0       	rjmp	.+6      	; 0x2a68 <xQueueGenericCreate+0x2c>
    2a62:	4f 96       	adiw	r24, 0x1f	; 31
    2a64:	88 83       	st	Y, r24
    2a66:	99 83       	std	Y+1, r25	; 0x01
    2a68:	0b 8f       	std	Y+27, r16	; 0x1b
    2a6a:	1c 8f       	std	Y+28, r17	; 0x1c
    2a6c:	61 e0       	ldi	r22, 0x01	; 1
    2a6e:	ce 01       	movw	r24, r28
    2a70:	a3 df       	rcall	.-186    	; 0x29b8 <xQueueGenericReset>
    2a72:	ce 01       	movw	r24, r28
    2a74:	df 91       	pop	r29
    2a76:	cf 91       	pop	r28
    2a78:	1f 91       	pop	r17
    2a7a:	0f 91       	pop	r16
    2a7c:	08 95       	ret

00002a7e <xQueueGenericSend>:
    2a7e:	af 92       	push	r10
    2a80:	bf 92       	push	r11
    2a82:	cf 92       	push	r12
    2a84:	df 92       	push	r13
    2a86:	ef 92       	push	r14
    2a88:	ff 92       	push	r15
    2a8a:	0f 93       	push	r16
    2a8c:	1f 93       	push	r17
    2a8e:	cf 93       	push	r28
    2a90:	df 93       	push	r29
    2a92:	cd b7       	in	r28, 0x3d	; 61
    2a94:	de b7       	in	r29, 0x3e	; 62
    2a96:	25 97       	sbiw	r28, 0x05	; 5
    2a98:	cd bf       	out	0x3d, r28	; 61
    2a9a:	de bf       	out	0x3e, r29	; 62
    2a9c:	8c 01       	movw	r16, r24
    2a9e:	6b 01       	movw	r12, r22
    2aa0:	4c 83       	std	Y+4, r20	; 0x04
    2aa2:	5d 83       	std	Y+5, r21	; 0x05
    2aa4:	a2 2e       	mov	r10, r18
    2aa6:	b1 2c       	mov	r11, r1
    2aa8:	7c 01       	movw	r14, r24
    2aaa:	88 e0       	ldi	r24, 0x08	; 8
    2aac:	e8 0e       	add	r14, r24
    2aae:	f1 1c       	adc	r15, r1
    2ab0:	0f b6       	in	r0, 0x3f	; 63
    2ab2:	f8 94       	cli
    2ab4:	0f 92       	push	r0
    2ab6:	f8 01       	movw	r30, r16
    2ab8:	92 8d       	ldd	r25, Z+26	; 0x1a
    2aba:	83 8d       	ldd	r24, Z+27	; 0x1b
    2abc:	98 17       	cp	r25, r24
    2abe:	18 f0       	brcs	.+6      	; 0x2ac6 <xQueueGenericSend+0x48>
    2ac0:	f2 e0       	ldi	r31, 0x02	; 2
    2ac2:	af 12       	cpse	r10, r31
    2ac4:	15 c0       	rjmp	.+42     	; 0x2af0 <xQueueGenericSend+0x72>
    2ac6:	4a 2d       	mov	r20, r10
    2ac8:	b6 01       	movw	r22, r12
    2aca:	c8 01       	movw	r24, r16
    2acc:	c9 de       	rcall	.-622    	; 0x2860 <prvCopyDataToQueue>
    2ace:	f8 01       	movw	r30, r16
    2ad0:	91 89       	ldd	r25, Z+17	; 0x11
    2ad2:	99 23       	and	r25, r25
    2ad4:	39 f0       	breq	.+14     	; 0x2ae4 <xQueueGenericSend+0x66>
    2ad6:	c8 01       	movw	r24, r16
    2ad8:	41 96       	adiw	r24, 0x11	; 17
    2ada:	25 d5       	rcall	.+2634   	; 0x3526 <xTaskRemoveFromEventList>
    2adc:	88 23       	and	r24, r24
    2ade:	21 f0       	breq	.+8      	; 0x2ae8 <xQueueGenericSend+0x6a>
    2ae0:	e8 dd       	rcall	.-1072   	; 0x26b2 <vPortYield>
    2ae2:	02 c0       	rjmp	.+4      	; 0x2ae8 <xQueueGenericSend+0x6a>
    2ae4:	81 11       	cpse	r24, r1
    2ae6:	e5 dd       	rcall	.-1078   	; 0x26b2 <vPortYield>
    2ae8:	0f 90       	pop	r0
    2aea:	0f be       	out	0x3f, r0	; 63
    2aec:	81 e0       	ldi	r24, 0x01	; 1
    2aee:	46 c0       	rjmp	.+140    	; 0x2b7c <xQueueGenericSend+0xfe>
    2af0:	8c 81       	ldd	r24, Y+4	; 0x04
    2af2:	9d 81       	ldd	r25, Y+5	; 0x05
    2af4:	89 2b       	or	r24, r25
    2af6:	21 f4       	brne	.+8      	; 0x2b00 <xQueueGenericSend+0x82>
    2af8:	0f 90       	pop	r0
    2afa:	0f be       	out	0x3f, r0	; 63
    2afc:	80 e0       	ldi	r24, 0x00	; 0
    2afe:	3e c0       	rjmp	.+124    	; 0x2b7c <xQueueGenericSend+0xfe>
    2b00:	b1 10       	cpse	r11, r1
    2b02:	05 c0       	rjmp	.+10     	; 0x2b0e <xQueueGenericSend+0x90>
    2b04:	ce 01       	movw	r24, r28
    2b06:	01 96       	adiw	r24, 0x01	; 1
    2b08:	56 d5       	rcall	.+2732   	; 0x35b6 <vTaskInternalSetTimeOutState>
    2b0a:	bb 24       	eor	r11, r11
    2b0c:	b3 94       	inc	r11
    2b0e:	0f 90       	pop	r0
    2b10:	0f be       	out	0x3f, r0	; 63
    2b12:	25 d3       	rcall	.+1610   	; 0x315e <vTaskSuspendAll>
    2b14:	0f b6       	in	r0, 0x3f	; 63
    2b16:	f8 94       	cli
    2b18:	0f 92       	push	r0
    2b1a:	f8 01       	movw	r30, r16
    2b1c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b1e:	8f 3f       	cpi	r24, 0xFF	; 255
    2b20:	09 f4       	brne	.+2      	; 0x2b24 <xQueueGenericSend+0xa6>
    2b22:	15 8e       	std	Z+29, r1	; 0x1d
    2b24:	f8 01       	movw	r30, r16
    2b26:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b28:	8f 3f       	cpi	r24, 0xFF	; 255
    2b2a:	09 f4       	brne	.+2      	; 0x2b2e <xQueueGenericSend+0xb0>
    2b2c:	16 8e       	std	Z+30, r1	; 0x1e
    2b2e:	0f 90       	pop	r0
    2b30:	0f be       	out	0x3f, r0	; 63
    2b32:	be 01       	movw	r22, r28
    2b34:	6c 5f       	subi	r22, 0xFC	; 252
    2b36:	7f 4f       	sbci	r23, 0xFF	; 255
    2b38:	ce 01       	movw	r24, r28
    2b3a:	01 96       	adiw	r24, 0x01	; 1
    2b3c:	47 d5       	rcall	.+2702   	; 0x35cc <xTaskCheckForTimeOut>
    2b3e:	81 11       	cpse	r24, r1
    2b40:	19 c0       	rjmp	.+50     	; 0x2b74 <xQueueGenericSend+0xf6>
    2b42:	0f b6       	in	r0, 0x3f	; 63
    2b44:	f8 94       	cli
    2b46:	0f 92       	push	r0
    2b48:	f8 01       	movw	r30, r16
    2b4a:	92 8d       	ldd	r25, Z+26	; 0x1a
    2b4c:	0f 90       	pop	r0
    2b4e:	0f be       	out	0x3f, r0	; 63
    2b50:	83 8d       	ldd	r24, Z+27	; 0x1b
    2b52:	98 13       	cpse	r25, r24
    2b54:	0b c0       	rjmp	.+22     	; 0x2b6c <xQueueGenericSend+0xee>
    2b56:	6c 81       	ldd	r22, Y+4	; 0x04
    2b58:	7d 81       	ldd	r23, Y+5	; 0x05
    2b5a:	c7 01       	movw	r24, r14
    2b5c:	bb d4       	rcall	.+2422   	; 0x34d4 <vTaskPlaceOnEventList>
    2b5e:	c8 01       	movw	r24, r16
    2b60:	e2 de       	rcall	.-572    	; 0x2926 <prvUnlockQueue>
    2b62:	c5 d3       	rcall	.+1930   	; 0x32ee <xTaskResumeAll>
    2b64:	81 11       	cpse	r24, r1
    2b66:	a4 cf       	rjmp	.-184    	; 0x2ab0 <xQueueGenericSend+0x32>
    2b68:	a4 dd       	rcall	.-1208   	; 0x26b2 <vPortYield>
    2b6a:	a2 cf       	rjmp	.-188    	; 0x2ab0 <xQueueGenericSend+0x32>
    2b6c:	c8 01       	movw	r24, r16
    2b6e:	db de       	rcall	.-586    	; 0x2926 <prvUnlockQueue>
    2b70:	be d3       	rcall	.+1916   	; 0x32ee <xTaskResumeAll>
    2b72:	9e cf       	rjmp	.-196    	; 0x2ab0 <xQueueGenericSend+0x32>
    2b74:	c8 01       	movw	r24, r16
    2b76:	d7 de       	rcall	.-594    	; 0x2926 <prvUnlockQueue>
    2b78:	ba d3       	rcall	.+1908   	; 0x32ee <xTaskResumeAll>
    2b7a:	80 e0       	ldi	r24, 0x00	; 0
    2b7c:	25 96       	adiw	r28, 0x05	; 5
    2b7e:	cd bf       	out	0x3d, r28	; 61
    2b80:	de bf       	out	0x3e, r29	; 62
    2b82:	df 91       	pop	r29
    2b84:	cf 91       	pop	r28
    2b86:	1f 91       	pop	r17
    2b88:	0f 91       	pop	r16
    2b8a:	ff 90       	pop	r15
    2b8c:	ef 90       	pop	r14
    2b8e:	df 90       	pop	r13
    2b90:	cf 90       	pop	r12
    2b92:	bf 90       	pop	r11
    2b94:	af 90       	pop	r10
    2b96:	08 95       	ret

00002b98 <xQueueGenericSendFromISR>:
    2b98:	ef 92       	push	r14
    2b9a:	ff 92       	push	r15
    2b9c:	0f 93       	push	r16
    2b9e:	1f 93       	push	r17
    2ba0:	cf 93       	push	r28
    2ba2:	df 93       	push	r29
    2ba4:	8a 01       	movw	r16, r20
    2ba6:	fc 01       	movw	r30, r24
    2ba8:	52 8d       	ldd	r21, Z+26	; 0x1a
    2baa:	33 8d       	ldd	r19, Z+27	; 0x1b
    2bac:	53 17       	cp	r21, r19
    2bae:	10 f0       	brcs	.+4      	; 0x2bb4 <xQueueGenericSendFromISR+0x1c>
    2bb0:	22 30       	cpi	r18, 0x02	; 2
    2bb2:	f1 f4       	brne	.+60     	; 0x2bf0 <xQueueGenericSendFromISR+0x58>
    2bb4:	42 2f       	mov	r20, r18
    2bb6:	78 01       	movw	r14, r16
    2bb8:	ec 01       	movw	r28, r24
    2bba:	1e 8d       	ldd	r17, Y+30	; 0x1e
    2bbc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2bbe:	ce 01       	movw	r24, r28
    2bc0:	4f de       	rcall	.-866    	; 0x2860 <prvCopyDataToQueue>
    2bc2:	1f 3f       	cpi	r17, 0xFF	; 255
    2bc4:	79 f4       	brne	.+30     	; 0x2be4 <xQueueGenericSendFromISR+0x4c>
    2bc6:	89 89       	ldd	r24, Y+17	; 0x11
    2bc8:	88 23       	and	r24, r24
    2bca:	a1 f0       	breq	.+40     	; 0x2bf4 <xQueueGenericSendFromISR+0x5c>
    2bcc:	ce 01       	movw	r24, r28
    2bce:	41 96       	adiw	r24, 0x11	; 17
    2bd0:	aa d4       	rcall	.+2388   	; 0x3526 <xTaskRemoveFromEventList>
    2bd2:	88 23       	and	r24, r24
    2bd4:	89 f0       	breq	.+34     	; 0x2bf8 <xQueueGenericSendFromISR+0x60>
    2bd6:	e1 14       	cp	r14, r1
    2bd8:	f1 04       	cpc	r15, r1
    2bda:	81 f0       	breq	.+32     	; 0x2bfc <xQueueGenericSendFromISR+0x64>
    2bdc:	81 e0       	ldi	r24, 0x01	; 1
    2bde:	f7 01       	movw	r30, r14
    2be0:	80 83       	st	Z, r24
    2be2:	0d c0       	rjmp	.+26     	; 0x2bfe <xQueueGenericSendFromISR+0x66>
    2be4:	ff 24       	eor	r15, r15
    2be6:	f3 94       	inc	r15
    2be8:	f1 0e       	add	r15, r17
    2bea:	fe 8e       	std	Y+30, r15	; 0x1e
    2bec:	81 e0       	ldi	r24, 0x01	; 1
    2bee:	07 c0       	rjmp	.+14     	; 0x2bfe <xQueueGenericSendFromISR+0x66>
    2bf0:	80 e0       	ldi	r24, 0x00	; 0
    2bf2:	05 c0       	rjmp	.+10     	; 0x2bfe <xQueueGenericSendFromISR+0x66>
    2bf4:	81 e0       	ldi	r24, 0x01	; 1
    2bf6:	03 c0       	rjmp	.+6      	; 0x2bfe <xQueueGenericSendFromISR+0x66>
    2bf8:	81 e0       	ldi	r24, 0x01	; 1
    2bfa:	01 c0       	rjmp	.+2      	; 0x2bfe <xQueueGenericSendFromISR+0x66>
    2bfc:	81 e0       	ldi	r24, 0x01	; 1
    2bfe:	df 91       	pop	r29
    2c00:	cf 91       	pop	r28
    2c02:	1f 91       	pop	r17
    2c04:	0f 91       	pop	r16
    2c06:	ff 90       	pop	r15
    2c08:	ef 90       	pop	r14
    2c0a:	08 95       	ret

00002c0c <xQueueReceive>:
    2c0c:	af 92       	push	r10
    2c0e:	bf 92       	push	r11
    2c10:	cf 92       	push	r12
    2c12:	df 92       	push	r13
    2c14:	ef 92       	push	r14
    2c16:	ff 92       	push	r15
    2c18:	0f 93       	push	r16
    2c1a:	1f 93       	push	r17
    2c1c:	cf 93       	push	r28
    2c1e:	df 93       	push	r29
    2c20:	cd b7       	in	r28, 0x3d	; 61
    2c22:	de b7       	in	r29, 0x3e	; 62
    2c24:	25 97       	sbiw	r28, 0x05	; 5
    2c26:	cd bf       	out	0x3d, r28	; 61
    2c28:	de bf       	out	0x3e, r29	; 62
    2c2a:	8c 01       	movw	r16, r24
    2c2c:	5b 01       	movw	r10, r22
    2c2e:	4c 83       	std	Y+4, r20	; 0x04
    2c30:	5d 83       	std	Y+5, r21	; 0x05
    2c32:	e1 2c       	mov	r14, r1
    2c34:	6c 01       	movw	r12, r24
    2c36:	81 e1       	ldi	r24, 0x11	; 17
    2c38:	c8 0e       	add	r12, r24
    2c3a:	d1 1c       	adc	r13, r1
    2c3c:	0f b6       	in	r0, 0x3f	; 63
    2c3e:	f8 94       	cli
    2c40:	0f 92       	push	r0
    2c42:	f8 01       	movw	r30, r16
    2c44:	f2 8c       	ldd	r15, Z+26	; 0x1a
    2c46:	ff 20       	and	r15, r15
    2c48:	91 f0       	breq	.+36     	; 0x2c6e <xQueueReceive+0x62>
    2c4a:	b5 01       	movw	r22, r10
    2c4c:	c8 01       	movw	r24, r16
    2c4e:	51 de       	rcall	.-862    	; 0x28f2 <prvCopyDataFromQueue>
    2c50:	fa 94       	dec	r15
    2c52:	f8 01       	movw	r30, r16
    2c54:	f2 8e       	std	Z+26, r15	; 0x1a
    2c56:	80 85       	ldd	r24, Z+8	; 0x08
    2c58:	88 23       	and	r24, r24
    2c5a:	29 f0       	breq	.+10     	; 0x2c66 <xQueueReceive+0x5a>
    2c5c:	c8 01       	movw	r24, r16
    2c5e:	08 96       	adiw	r24, 0x08	; 8
    2c60:	62 d4       	rcall	.+2244   	; 0x3526 <xTaskRemoveFromEventList>
    2c62:	81 11       	cpse	r24, r1
    2c64:	26 dd       	rcall	.-1460   	; 0x26b2 <vPortYield>
    2c66:	0f 90       	pop	r0
    2c68:	0f be       	out	0x3f, r0	; 63
    2c6a:	81 e0       	ldi	r24, 0x01	; 1
    2c6c:	45 c0       	rjmp	.+138    	; 0x2cf8 <xQueueReceive+0xec>
    2c6e:	8c 81       	ldd	r24, Y+4	; 0x04
    2c70:	9d 81       	ldd	r25, Y+5	; 0x05
    2c72:	89 2b       	or	r24, r25
    2c74:	21 f4       	brne	.+8      	; 0x2c7e <xQueueReceive+0x72>
    2c76:	0f 90       	pop	r0
    2c78:	0f be       	out	0x3f, r0	; 63
    2c7a:	80 e0       	ldi	r24, 0x00	; 0
    2c7c:	3d c0       	rjmp	.+122    	; 0x2cf8 <xQueueReceive+0xec>
    2c7e:	e1 10       	cpse	r14, r1
    2c80:	05 c0       	rjmp	.+10     	; 0x2c8c <xQueueReceive+0x80>
    2c82:	ce 01       	movw	r24, r28
    2c84:	01 96       	adiw	r24, 0x01	; 1
    2c86:	97 d4       	rcall	.+2350   	; 0x35b6 <vTaskInternalSetTimeOutState>
    2c88:	ee 24       	eor	r14, r14
    2c8a:	e3 94       	inc	r14
    2c8c:	0f 90       	pop	r0
    2c8e:	0f be       	out	0x3f, r0	; 63
    2c90:	66 d2       	rcall	.+1228   	; 0x315e <vTaskSuspendAll>
    2c92:	0f b6       	in	r0, 0x3f	; 63
    2c94:	f8 94       	cli
    2c96:	0f 92       	push	r0
    2c98:	f8 01       	movw	r30, r16
    2c9a:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c9c:	8f 3f       	cpi	r24, 0xFF	; 255
    2c9e:	09 f4       	brne	.+2      	; 0x2ca2 <xQueueReceive+0x96>
    2ca0:	15 8e       	std	Z+29, r1	; 0x1d
    2ca2:	f8 01       	movw	r30, r16
    2ca4:	86 8d       	ldd	r24, Z+30	; 0x1e
    2ca6:	8f 3f       	cpi	r24, 0xFF	; 255
    2ca8:	09 f4       	brne	.+2      	; 0x2cac <xQueueReceive+0xa0>
    2caa:	16 8e       	std	Z+30, r1	; 0x1e
    2cac:	0f 90       	pop	r0
    2cae:	0f be       	out	0x3f, r0	; 63
    2cb0:	be 01       	movw	r22, r28
    2cb2:	6c 5f       	subi	r22, 0xFC	; 252
    2cb4:	7f 4f       	sbci	r23, 0xFF	; 255
    2cb6:	ce 01       	movw	r24, r28
    2cb8:	01 96       	adiw	r24, 0x01	; 1
    2cba:	88 d4       	rcall	.+2320   	; 0x35cc <xTaskCheckForTimeOut>
    2cbc:	81 11       	cpse	r24, r1
    2cbe:	13 c0       	rjmp	.+38     	; 0x2ce6 <xQueueReceive+0xda>
    2cc0:	c8 01       	movw	r24, r16
    2cc2:	c3 dd       	rcall	.-1146   	; 0x284a <prvIsQueueEmpty>
    2cc4:	88 23       	and	r24, r24
    2cc6:	59 f0       	breq	.+22     	; 0x2cde <xQueueReceive+0xd2>
    2cc8:	6c 81       	ldd	r22, Y+4	; 0x04
    2cca:	7d 81       	ldd	r23, Y+5	; 0x05
    2ccc:	c6 01       	movw	r24, r12
    2cce:	02 d4       	rcall	.+2052   	; 0x34d4 <vTaskPlaceOnEventList>
    2cd0:	c8 01       	movw	r24, r16
    2cd2:	29 de       	rcall	.-942    	; 0x2926 <prvUnlockQueue>
    2cd4:	0c d3       	rcall	.+1560   	; 0x32ee <xTaskResumeAll>
    2cd6:	81 11       	cpse	r24, r1
    2cd8:	b1 cf       	rjmp	.-158    	; 0x2c3c <xQueueReceive+0x30>
    2cda:	eb dc       	rcall	.-1578   	; 0x26b2 <vPortYield>
    2cdc:	af cf       	rjmp	.-162    	; 0x2c3c <xQueueReceive+0x30>
    2cde:	c8 01       	movw	r24, r16
    2ce0:	22 de       	rcall	.-956    	; 0x2926 <prvUnlockQueue>
    2ce2:	05 d3       	rcall	.+1546   	; 0x32ee <xTaskResumeAll>
    2ce4:	ab cf       	rjmp	.-170    	; 0x2c3c <xQueueReceive+0x30>
    2ce6:	c8 01       	movw	r24, r16
    2ce8:	1e de       	rcall	.-964    	; 0x2926 <prvUnlockQueue>
    2cea:	01 d3       	rcall	.+1538   	; 0x32ee <xTaskResumeAll>
    2cec:	c8 01       	movw	r24, r16
    2cee:	ad dd       	rcall	.-1190   	; 0x284a <prvIsQueueEmpty>
    2cf0:	88 23       	and	r24, r24
    2cf2:	09 f4       	brne	.+2      	; 0x2cf6 <xQueueReceive+0xea>
    2cf4:	a3 cf       	rjmp	.-186    	; 0x2c3c <xQueueReceive+0x30>
    2cf6:	80 e0       	ldi	r24, 0x00	; 0
    2cf8:	25 96       	adiw	r28, 0x05	; 5
    2cfa:	cd bf       	out	0x3d, r28	; 61
    2cfc:	de bf       	out	0x3e, r29	; 62
    2cfe:	df 91       	pop	r29
    2d00:	cf 91       	pop	r28
    2d02:	1f 91       	pop	r17
    2d04:	0f 91       	pop	r16
    2d06:	ff 90       	pop	r15
    2d08:	ef 90       	pop	r14
    2d0a:	df 90       	pop	r13
    2d0c:	cf 90       	pop	r12
    2d0e:	bf 90       	pop	r11
    2d10:	af 90       	pop	r10
    2d12:	08 95       	ret

00002d14 <xQueueSemaphoreTake>:
    2d14:	df 92       	push	r13
    2d16:	ef 92       	push	r14
    2d18:	ff 92       	push	r15
    2d1a:	0f 93       	push	r16
    2d1c:	1f 93       	push	r17
    2d1e:	cf 93       	push	r28
    2d20:	df 93       	push	r29
    2d22:	cd b7       	in	r28, 0x3d	; 61
    2d24:	de b7       	in	r29, 0x3e	; 62
    2d26:	25 97       	sbiw	r28, 0x05	; 5
    2d28:	cd bf       	out	0x3d, r28	; 61
    2d2a:	de bf       	out	0x3e, r29	; 62
    2d2c:	8c 01       	movw	r16, r24
    2d2e:	6c 83       	std	Y+4, r22	; 0x04
    2d30:	7d 83       	std	Y+5, r23	; 0x05
    2d32:	d1 2c       	mov	r13, r1
    2d34:	7c 01       	movw	r14, r24
    2d36:	81 e1       	ldi	r24, 0x11	; 17
    2d38:	e8 0e       	add	r14, r24
    2d3a:	f1 1c       	adc	r15, r1
    2d3c:	0f b6       	in	r0, 0x3f	; 63
    2d3e:	f8 94       	cli
    2d40:	0f 92       	push	r0
    2d42:	f8 01       	movw	r30, r16
    2d44:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d46:	88 23       	and	r24, r24
    2d48:	71 f0       	breq	.+28     	; 0x2d66 <xQueueSemaphoreTake+0x52>
    2d4a:	81 50       	subi	r24, 0x01	; 1
    2d4c:	82 8f       	std	Z+26, r24	; 0x1a
    2d4e:	80 85       	ldd	r24, Z+8	; 0x08
    2d50:	88 23       	and	r24, r24
    2d52:	29 f0       	breq	.+10     	; 0x2d5e <xQueueSemaphoreTake+0x4a>
    2d54:	c8 01       	movw	r24, r16
    2d56:	08 96       	adiw	r24, 0x08	; 8
    2d58:	e6 d3       	rcall	.+1996   	; 0x3526 <xTaskRemoveFromEventList>
    2d5a:	81 11       	cpse	r24, r1
    2d5c:	aa dc       	rcall	.-1708   	; 0x26b2 <vPortYield>
    2d5e:	0f 90       	pop	r0
    2d60:	0f be       	out	0x3f, r0	; 63
    2d62:	81 e0       	ldi	r24, 0x01	; 1
    2d64:	45 c0       	rjmp	.+138    	; 0x2df0 <xQueueSemaphoreTake+0xdc>
    2d66:	8c 81       	ldd	r24, Y+4	; 0x04
    2d68:	9d 81       	ldd	r25, Y+5	; 0x05
    2d6a:	89 2b       	or	r24, r25
    2d6c:	21 f4       	brne	.+8      	; 0x2d76 <xQueueSemaphoreTake+0x62>
    2d6e:	0f 90       	pop	r0
    2d70:	0f be       	out	0x3f, r0	; 63
    2d72:	80 e0       	ldi	r24, 0x00	; 0
    2d74:	3d c0       	rjmp	.+122    	; 0x2df0 <xQueueSemaphoreTake+0xdc>
    2d76:	d1 10       	cpse	r13, r1
    2d78:	05 c0       	rjmp	.+10     	; 0x2d84 <xQueueSemaphoreTake+0x70>
    2d7a:	ce 01       	movw	r24, r28
    2d7c:	01 96       	adiw	r24, 0x01	; 1
    2d7e:	1b d4       	rcall	.+2102   	; 0x35b6 <vTaskInternalSetTimeOutState>
    2d80:	dd 24       	eor	r13, r13
    2d82:	d3 94       	inc	r13
    2d84:	0f 90       	pop	r0
    2d86:	0f be       	out	0x3f, r0	; 63
    2d88:	ea d1       	rcall	.+980    	; 0x315e <vTaskSuspendAll>
    2d8a:	0f b6       	in	r0, 0x3f	; 63
    2d8c:	f8 94       	cli
    2d8e:	0f 92       	push	r0
    2d90:	f8 01       	movw	r30, r16
    2d92:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d94:	8f 3f       	cpi	r24, 0xFF	; 255
    2d96:	09 f4       	brne	.+2      	; 0x2d9a <xQueueSemaphoreTake+0x86>
    2d98:	15 8e       	std	Z+29, r1	; 0x1d
    2d9a:	f8 01       	movw	r30, r16
    2d9c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d9e:	8f 3f       	cpi	r24, 0xFF	; 255
    2da0:	09 f4       	brne	.+2      	; 0x2da4 <xQueueSemaphoreTake+0x90>
    2da2:	16 8e       	std	Z+30, r1	; 0x1e
    2da4:	0f 90       	pop	r0
    2da6:	0f be       	out	0x3f, r0	; 63
    2da8:	be 01       	movw	r22, r28
    2daa:	6c 5f       	subi	r22, 0xFC	; 252
    2dac:	7f 4f       	sbci	r23, 0xFF	; 255
    2dae:	ce 01       	movw	r24, r28
    2db0:	01 96       	adiw	r24, 0x01	; 1
    2db2:	0c d4       	rcall	.+2072   	; 0x35cc <xTaskCheckForTimeOut>
    2db4:	81 11       	cpse	r24, r1
    2db6:	13 c0       	rjmp	.+38     	; 0x2dde <xQueueSemaphoreTake+0xca>
    2db8:	c8 01       	movw	r24, r16
    2dba:	47 dd       	rcall	.-1394   	; 0x284a <prvIsQueueEmpty>
    2dbc:	88 23       	and	r24, r24
    2dbe:	59 f0       	breq	.+22     	; 0x2dd6 <xQueueSemaphoreTake+0xc2>
    2dc0:	6c 81       	ldd	r22, Y+4	; 0x04
    2dc2:	7d 81       	ldd	r23, Y+5	; 0x05
    2dc4:	c7 01       	movw	r24, r14
    2dc6:	86 d3       	rcall	.+1804   	; 0x34d4 <vTaskPlaceOnEventList>
    2dc8:	c8 01       	movw	r24, r16
    2dca:	ad dd       	rcall	.-1190   	; 0x2926 <prvUnlockQueue>
    2dcc:	90 d2       	rcall	.+1312   	; 0x32ee <xTaskResumeAll>
    2dce:	81 11       	cpse	r24, r1
    2dd0:	b5 cf       	rjmp	.-150    	; 0x2d3c <xQueueSemaphoreTake+0x28>
    2dd2:	6f dc       	rcall	.-1826   	; 0x26b2 <vPortYield>
    2dd4:	b3 cf       	rjmp	.-154    	; 0x2d3c <xQueueSemaphoreTake+0x28>
    2dd6:	c8 01       	movw	r24, r16
    2dd8:	a6 dd       	rcall	.-1204   	; 0x2926 <prvUnlockQueue>
    2dda:	89 d2       	rcall	.+1298   	; 0x32ee <xTaskResumeAll>
    2ddc:	af cf       	rjmp	.-162    	; 0x2d3c <xQueueSemaphoreTake+0x28>
    2dde:	c8 01       	movw	r24, r16
    2de0:	a2 dd       	rcall	.-1212   	; 0x2926 <prvUnlockQueue>
    2de2:	85 d2       	rcall	.+1290   	; 0x32ee <xTaskResumeAll>
    2de4:	c8 01       	movw	r24, r16
    2de6:	31 dd       	rcall	.-1438   	; 0x284a <prvIsQueueEmpty>
    2de8:	88 23       	and	r24, r24
    2dea:	09 f4       	brne	.+2      	; 0x2dee <xQueueSemaphoreTake+0xda>
    2dec:	a7 cf       	rjmp	.-178    	; 0x2d3c <xQueueSemaphoreTake+0x28>
    2dee:	80 e0       	ldi	r24, 0x00	; 0
    2df0:	25 96       	adiw	r28, 0x05	; 5
    2df2:	cd bf       	out	0x3d, r28	; 61
    2df4:	de bf       	out	0x3e, r29	; 62
    2df6:	df 91       	pop	r29
    2df8:	cf 91       	pop	r28
    2dfa:	1f 91       	pop	r17
    2dfc:	0f 91       	pop	r16
    2dfe:	ff 90       	pop	r15
    2e00:	ef 90       	pop	r14
    2e02:	df 90       	pop	r13
    2e04:	08 95       	ret

00002e06 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    2e06:	cf 93       	push	r28
    2e08:	df 93       	push	r29
    2e0a:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    2e0c:	0f b6       	in	r0, 0x3f	; 63
    2e0e:	f8 94       	cli
    2e10:	0f 92       	push	r0
    2e12:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2e14:	8f 3f       	cpi	r24, 0xFF	; 255
    2e16:	09 f4       	brne	.+2      	; 0x2e1a <vQueueWaitForMessageRestricted+0x14>
    2e18:	1d 8e       	std	Y+29, r1	; 0x1d
    2e1a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2e1c:	8f 3f       	cpi	r24, 0xFF	; 255
    2e1e:	09 f4       	brne	.+2      	; 0x2e22 <vQueueWaitForMessageRestricted+0x1c>
    2e20:	1e 8e       	std	Y+30, r1	; 0x1e
    2e22:	0f 90       	pop	r0
    2e24:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2e26:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2e28:	81 11       	cpse	r24, r1
    2e2a:	03 c0       	rjmp	.+6      	; 0x2e32 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2e2c:	ce 01       	movw	r24, r28
    2e2e:	41 96       	adiw	r24, 0x11	; 17
    2e30:	62 d3       	rcall	.+1732   	; 0x34f6 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    2e32:	ce 01       	movw	r24, r28
    2e34:	78 dd       	rcall	.-1296   	; 0x2926 <prvUnlockQueue>
	}
    2e36:	df 91       	pop	r29
    2e38:	cf 91       	pop	r28
    2e3a:	08 95       	ret

00002e3c <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
    2e3c:	e0 91 82 23 	lds	r30, 0x2382	; 0x802382 <pxDelayedTaskList>
    2e40:	f0 91 83 23 	lds	r31, 0x2383	; 0x802383 <pxDelayedTaskList+0x1>
    2e44:	80 81       	ld	r24, Z
    2e46:	81 11       	cpse	r24, r1
    2e48:	07 c0       	rjmp	.+14     	; 0x2e58 <prvResetNextTaskUnblockTime+0x1c>
    2e4a:	8f ef       	ldi	r24, 0xFF	; 255
    2e4c:	9f ef       	ldi	r25, 0xFF	; 255
    2e4e:	80 93 6b 23 	sts	0x236B, r24	; 0x80236b <xNextTaskUnblockTime>
    2e52:	90 93 6c 23 	sts	0x236C, r25	; 0x80236c <xNextTaskUnblockTime+0x1>
    2e56:	08 95       	ret
    2e58:	e0 91 82 23 	lds	r30, 0x2382	; 0x802382 <pxDelayedTaskList>
    2e5c:	f0 91 83 23 	lds	r31, 0x2383	; 0x802383 <pxDelayedTaskList+0x1>
    2e60:	05 80       	ldd	r0, Z+5	; 0x05
    2e62:	f6 81       	ldd	r31, Z+6	; 0x06
    2e64:	e0 2d       	mov	r30, r0
    2e66:	06 80       	ldd	r0, Z+6	; 0x06
    2e68:	f7 81       	ldd	r31, Z+7	; 0x07
    2e6a:	e0 2d       	mov	r30, r0
    2e6c:	82 81       	ldd	r24, Z+2	; 0x02
    2e6e:	93 81       	ldd	r25, Z+3	; 0x03
    2e70:	80 93 6b 23 	sts	0x236B, r24	; 0x80236b <xNextTaskUnblockTime>
    2e74:	90 93 6c 23 	sts	0x236C, r25	; 0x80236c <xNextTaskUnblockTime+0x1>
    2e78:	08 95       	ret

00002e7a <prvIdleTask>:
    2e7a:	c6 e9       	ldi	r28, 0x96	; 150
    2e7c:	d3 e2       	ldi	r29, 0x23	; 35
    2e7e:	88 81       	ld	r24, Y
    2e80:	82 30       	cpi	r24, 0x02	; 2
    2e82:	e8 f3       	brcs	.-6      	; 0x2e7e <prvIdleTask+0x4>
    2e84:	16 dc       	rcall	.-2004   	; 0x26b2 <vPortYield>
    2e86:	fb cf       	rjmp	.-10     	; 0x2e7e <prvIdleTask+0x4>

00002e88 <prvAddCurrentTaskToDelayedList>:
    2e88:	0f 93       	push	r16
    2e8a:	1f 93       	push	r17
    2e8c:	cf 93       	push	r28
    2e8e:	df 93       	push	r29
    2e90:	ec 01       	movw	r28, r24
    2e92:	00 91 74 23 	lds	r16, 0x2374	; 0x802374 <xTickCount>
    2e96:	10 91 75 23 	lds	r17, 0x2375	; 0x802375 <xTickCount+0x1>
    2e9a:	80 91 c3 23 	lds	r24, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    2e9e:	90 91 c4 23 	lds	r25, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    2ea2:	02 96       	adiw	r24, 0x02	; 2
    2ea4:	23 db       	rcall	.-2490   	; 0x24ec <uxListRemove>
    2ea6:	c0 0f       	add	r28, r16
    2ea8:	d1 1f       	adc	r29, r17
    2eaa:	e0 91 c3 23 	lds	r30, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    2eae:	f0 91 c4 23 	lds	r31, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    2eb2:	c2 83       	std	Z+2, r28	; 0x02
    2eb4:	d3 83       	std	Z+3, r29	; 0x03
    2eb6:	c0 17       	cp	r28, r16
    2eb8:	d1 07       	cpc	r29, r17
    2eba:	60 f4       	brcc	.+24     	; 0x2ed4 <prvAddCurrentTaskToDelayedList+0x4c>
    2ebc:	60 91 c3 23 	lds	r22, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    2ec0:	70 91 c4 23 	lds	r23, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    2ec4:	80 91 80 23 	lds	r24, 0x2380	; 0x802380 <pxOverflowDelayedTaskList>
    2ec8:	90 91 81 23 	lds	r25, 0x2381	; 0x802381 <pxOverflowDelayedTaskList+0x1>
    2ecc:	6e 5f       	subi	r22, 0xFE	; 254
    2ece:	7f 4f       	sbci	r23, 0xFF	; 255
    2ed0:	dc da       	rcall	.-2632   	; 0x248a <vListInsert>
    2ed2:	16 c0       	rjmp	.+44     	; 0x2f00 <prvAddCurrentTaskToDelayedList+0x78>
    2ed4:	60 91 c3 23 	lds	r22, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    2ed8:	70 91 c4 23 	lds	r23, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    2edc:	80 91 82 23 	lds	r24, 0x2382	; 0x802382 <pxDelayedTaskList>
    2ee0:	90 91 83 23 	lds	r25, 0x2383	; 0x802383 <pxDelayedTaskList+0x1>
    2ee4:	6e 5f       	subi	r22, 0xFE	; 254
    2ee6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ee8:	d0 da       	rcall	.-2656   	; 0x248a <vListInsert>
    2eea:	80 91 6b 23 	lds	r24, 0x236B	; 0x80236b <xNextTaskUnblockTime>
    2eee:	90 91 6c 23 	lds	r25, 0x236C	; 0x80236c <xNextTaskUnblockTime+0x1>
    2ef2:	c8 17       	cp	r28, r24
    2ef4:	d9 07       	cpc	r29, r25
    2ef6:	20 f4       	brcc	.+8      	; 0x2f00 <prvAddCurrentTaskToDelayedList+0x78>
    2ef8:	c0 93 6b 23 	sts	0x236B, r28	; 0x80236b <xNextTaskUnblockTime>
    2efc:	d0 93 6c 23 	sts	0x236C, r29	; 0x80236c <xNextTaskUnblockTime+0x1>
    2f00:	df 91       	pop	r29
    2f02:	cf 91       	pop	r28
    2f04:	1f 91       	pop	r17
    2f06:	0f 91       	pop	r16
    2f08:	08 95       	ret

00002f0a <xTaskCreate>:
    2f0a:	4f 92       	push	r4
    2f0c:	5f 92       	push	r5
    2f0e:	6f 92       	push	r6
    2f10:	7f 92       	push	r7
    2f12:	8f 92       	push	r8
    2f14:	9f 92       	push	r9
    2f16:	af 92       	push	r10
    2f18:	bf 92       	push	r11
    2f1a:	cf 92       	push	r12
    2f1c:	df 92       	push	r13
    2f1e:	ef 92       	push	r14
    2f20:	ff 92       	push	r15
    2f22:	0f 93       	push	r16
    2f24:	1f 93       	push	r17
    2f26:	cf 93       	push	r28
    2f28:	df 93       	push	r29
    2f2a:	4c 01       	movw	r8, r24
    2f2c:	6b 01       	movw	r12, r22
    2f2e:	5a 01       	movw	r10, r20
    2f30:	29 01       	movw	r4, r18
    2f32:	ca 01       	movw	r24, r20
    2f34:	70 dc       	rcall	.-1824   	; 0x2816 <pvPortMalloc>
    2f36:	3c 01       	movw	r6, r24
    2f38:	89 2b       	or	r24, r25
    2f3a:	09 f4       	brne	.+2      	; 0x2f3e <xTaskCreate+0x34>
    2f3c:	d3 c0       	rjmp	.+422    	; 0x30e4 <xTaskCreate+0x1da>
    2f3e:	86 e2       	ldi	r24, 0x26	; 38
    2f40:	90 e0       	ldi	r25, 0x00	; 0
    2f42:	69 dc       	rcall	.-1838   	; 0x2816 <pvPortMalloc>
    2f44:	ec 01       	movw	r28, r24
    2f46:	89 2b       	or	r24, r25
    2f48:	59 f0       	breq	.+22     	; 0x2f60 <xTaskCreate+0x56>
    2f4a:	6f 8a       	std	Y+23, r6	; 0x17
    2f4c:	78 8e       	std	Y+24, r7	; 0x18
    2f4e:	81 e0       	ldi	r24, 0x01	; 1
    2f50:	a8 1a       	sub	r10, r24
    2f52:	b1 08       	sbc	r11, r1
    2f54:	a6 0c       	add	r10, r6
    2f56:	b7 1c       	adc	r11, r7
    2f58:	c1 14       	cp	r12, r1
    2f5a:	d1 04       	cpc	r13, r1
    2f5c:	21 f4       	brne	.+8      	; 0x2f66 <xTaskCreate+0x5c>
    2f5e:	1f c0       	rjmp	.+62     	; 0x2f9e <xTaskCreate+0x94>
    2f60:	c3 01       	movw	r24, r6
    2f62:	66 dc       	rcall	.-1844   	; 0x2830 <vPortFree>
    2f64:	bf c0       	rjmp	.+382    	; 0x30e4 <xTaskCreate+0x1da>
    2f66:	d6 01       	movw	r26, r12
    2f68:	8c 91       	ld	r24, X
    2f6a:	89 8f       	std	Y+25, r24	; 0x19
    2f6c:	8c 91       	ld	r24, X
    2f6e:	88 23       	and	r24, r24
    2f70:	a1 f0       	breq	.+40     	; 0x2f9a <xTaskCreate+0x90>
    2f72:	ae 01       	movw	r20, r28
    2f74:	46 5e       	subi	r20, 0xE6	; 230
    2f76:	5f 4f       	sbci	r21, 0xFF	; 255
    2f78:	f6 01       	movw	r30, r12
    2f7a:	31 96       	adiw	r30, 0x01	; 1
    2f7c:	b8 e0       	ldi	r27, 0x08	; 8
    2f7e:	cb 0e       	add	r12, r27
    2f80:	d1 1c       	adc	r13, r1
    2f82:	cf 01       	movw	r24, r30
    2f84:	21 91       	ld	r18, Z+
    2f86:	da 01       	movw	r26, r20
    2f88:	2d 93       	st	X+, r18
    2f8a:	ad 01       	movw	r20, r26
    2f8c:	dc 01       	movw	r26, r24
    2f8e:	8c 91       	ld	r24, X
    2f90:	88 23       	and	r24, r24
    2f92:	19 f0       	breq	.+6      	; 0x2f9a <xTaskCreate+0x90>
    2f94:	ce 16       	cp	r12, r30
    2f96:	df 06       	cpc	r13, r31
    2f98:	a1 f7       	brne	.-24     	; 0x2f82 <xTaskCreate+0x78>
    2f9a:	18 a2       	std	Y+32, r1	; 0x20
    2f9c:	01 c0       	rjmp	.+2      	; 0x2fa0 <xTaskCreate+0x96>
    2f9e:	19 8e       	std	Y+25, r1	; 0x19
    2fa0:	05 30       	cpi	r16, 0x05	; 5
    2fa2:	08 f0       	brcs	.+2      	; 0x2fa6 <xTaskCreate+0x9c>
    2fa4:	04 e0       	ldi	r16, 0x04	; 4
    2fa6:	0e 8b       	std	Y+22, r16	; 0x16
    2fa8:	6e 01       	movw	r12, r28
    2faa:	b2 e0       	ldi	r27, 0x02	; 2
    2fac:	cb 0e       	add	r12, r27
    2fae:	d1 1c       	adc	r13, r1
    2fb0:	c6 01       	movw	r24, r12
    2fb2:	46 da       	rcall	.-2932   	; 0x2440 <vListInitialiseItem>
    2fb4:	ce 01       	movw	r24, r28
    2fb6:	0c 96       	adiw	r24, 0x0c	; 12
    2fb8:	43 da       	rcall	.-2938   	; 0x2440 <vListInitialiseItem>
    2fba:	c8 87       	std	Y+8, r28	; 0x08
    2fbc:	d9 87       	std	Y+9, r29	; 0x09
    2fbe:	85 e0       	ldi	r24, 0x05	; 5
    2fc0:	90 e0       	ldi	r25, 0x00	; 0
    2fc2:	80 1b       	sub	r24, r16
    2fc4:	91 09       	sbc	r25, r1
    2fc6:	8c 87       	std	Y+12, r24	; 0x0c
    2fc8:	9d 87       	std	Y+13, r25	; 0x0d
    2fca:	ca 8b       	std	Y+18, r28	; 0x12
    2fcc:	db 8b       	std	Y+19, r29	; 0x13
    2fce:	19 a2       	std	Y+33, r1	; 0x21
    2fd0:	1a a2       	std	Y+34, r1	; 0x22
    2fd2:	1b a2       	std	Y+35, r1	; 0x23
    2fd4:	1c a2       	std	Y+36, r1	; 0x24
    2fd6:	1d a2       	std	Y+37, r1	; 0x25
    2fd8:	a2 01       	movw	r20, r4
    2fda:	b4 01       	movw	r22, r8
    2fdc:	c5 01       	movw	r24, r10
    2fde:	ad da       	rcall	.-2726   	; 0x253a <pxPortInitialiseStack>
    2fe0:	88 83       	st	Y, r24
    2fe2:	99 83       	std	Y+1, r25	; 0x01
    2fe4:	e1 14       	cp	r14, r1
    2fe6:	f1 04       	cpc	r15, r1
    2fe8:	19 f0       	breq	.+6      	; 0x2ff0 <xTaskCreate+0xe6>
    2fea:	f7 01       	movw	r30, r14
    2fec:	c0 83       	st	Z, r28
    2fee:	d1 83       	std	Z+1, r29	; 0x01
    2ff0:	0f b6       	in	r0, 0x3f	; 63
    2ff2:	f8 94       	cli
    2ff4:	0f 92       	push	r0
    2ff6:	80 91 76 23 	lds	r24, 0x2376	; 0x802376 <uxCurrentNumberOfTasks>
    2ffa:	8f 5f       	subi	r24, 0xFF	; 255
    2ffc:	80 93 76 23 	sts	0x2376, r24	; 0x802376 <uxCurrentNumberOfTasks>
    3000:	80 91 c3 23 	lds	r24, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    3004:	90 91 c4 23 	lds	r25, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    3008:	89 2b       	or	r24, r25
    300a:	69 f5       	brne	.+90     	; 0x3066 <xTaskCreate+0x15c>
    300c:	c0 93 c3 23 	sts	0x23C3, r28	; 0x8023c3 <pxCurrentTCB>
    3010:	d0 93 c4 23 	sts	0x23C4, r29	; 0x8023c4 <pxCurrentTCB+0x1>
    3014:	80 91 76 23 	lds	r24, 0x2376	; 0x802376 <uxCurrentNumberOfTasks>
    3018:	81 30       	cpi	r24, 0x01	; 1
    301a:	a9 f5       	brne	.+106    	; 0x3086 <xTaskCreate+0x17c>
    301c:	06 e9       	ldi	r16, 0x96	; 150
    301e:	13 e2       	ldi	r17, 0x23	; 35
    3020:	0f 2e       	mov	r0, r31
    3022:	f3 ec       	ldi	r31, 0xC3	; 195
    3024:	ef 2e       	mov	r14, r31
    3026:	f3 e2       	ldi	r31, 0x23	; 35
    3028:	ff 2e       	mov	r15, r31
    302a:	f0 2d       	mov	r31, r0
    302c:	c8 01       	movw	r24, r16
    302e:	fa d9       	rcall	.-3084   	; 0x2424 <vListInitialise>
    3030:	07 5f       	subi	r16, 0xF7	; 247
    3032:	1f 4f       	sbci	r17, 0xFF	; 255
    3034:	0e 15       	cp	r16, r14
    3036:	1f 05       	cpc	r17, r15
    3038:	c9 f7       	brne	.-14     	; 0x302c <xTaskCreate+0x122>
    303a:	8d e8       	ldi	r24, 0x8D	; 141
    303c:	93 e2       	ldi	r25, 0x23	; 35
    303e:	f2 d9       	rcall	.-3100   	; 0x2424 <vListInitialise>
    3040:	84 e8       	ldi	r24, 0x84	; 132
    3042:	93 e2       	ldi	r25, 0x23	; 35
    3044:	ef d9       	rcall	.-3106   	; 0x2424 <vListInitialise>
    3046:	87 e7       	ldi	r24, 0x77	; 119
    3048:	93 e2       	ldi	r25, 0x23	; 35
    304a:	ec d9       	rcall	.-3112   	; 0x2424 <vListInitialise>
    304c:	8d e8       	ldi	r24, 0x8D	; 141
    304e:	93 e2       	ldi	r25, 0x23	; 35
    3050:	80 93 82 23 	sts	0x2382, r24	; 0x802382 <pxDelayedTaskList>
    3054:	90 93 83 23 	sts	0x2383, r25	; 0x802383 <pxDelayedTaskList+0x1>
    3058:	84 e8       	ldi	r24, 0x84	; 132
    305a:	93 e2       	ldi	r25, 0x23	; 35
    305c:	80 93 80 23 	sts	0x2380, r24	; 0x802380 <pxOverflowDelayedTaskList>
    3060:	90 93 81 23 	sts	0x2381, r25	; 0x802381 <pxOverflowDelayedTaskList+0x1>
    3064:	10 c0       	rjmp	.+32     	; 0x3086 <xTaskCreate+0x17c>
    3066:	80 91 72 23 	lds	r24, 0x2372	; 0x802372 <xSchedulerRunning>
    306a:	81 11       	cpse	r24, r1
    306c:	0c c0       	rjmp	.+24     	; 0x3086 <xTaskCreate+0x17c>
    306e:	e0 91 c3 23 	lds	r30, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    3072:	f0 91 c4 23 	lds	r31, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    3076:	96 89       	ldd	r25, Z+22	; 0x16
    3078:	8e 89       	ldd	r24, Y+22	; 0x16
    307a:	89 17       	cp	r24, r25
    307c:	20 f0       	brcs	.+8      	; 0x3086 <xTaskCreate+0x17c>
    307e:	c0 93 c3 23 	sts	0x23C3, r28	; 0x8023c3 <pxCurrentTCB>
    3082:	d0 93 c4 23 	sts	0x23C4, r29	; 0x8023c4 <pxCurrentTCB+0x1>
    3086:	80 91 6d 23 	lds	r24, 0x236D	; 0x80236d <uxTaskNumber>
    308a:	8f 5f       	subi	r24, 0xFF	; 255
    308c:	80 93 6d 23 	sts	0x236D, r24	; 0x80236d <uxTaskNumber>
    3090:	8e 89       	ldd	r24, Y+22	; 0x16
    3092:	90 91 73 23 	lds	r25, 0x2373	; 0x802373 <uxTopReadyPriority>
    3096:	98 17       	cp	r25, r24
    3098:	10 f4       	brcc	.+4      	; 0x309e <xTaskCreate+0x194>
    309a:	80 93 73 23 	sts	0x2373, r24	; 0x802373 <uxTopReadyPriority>
    309e:	90 e0       	ldi	r25, 0x00	; 0
    30a0:	9c 01       	movw	r18, r24
    30a2:	22 0f       	add	r18, r18
    30a4:	33 1f       	adc	r19, r19
    30a6:	22 0f       	add	r18, r18
    30a8:	33 1f       	adc	r19, r19
    30aa:	22 0f       	add	r18, r18
    30ac:	33 1f       	adc	r19, r19
    30ae:	82 0f       	add	r24, r18
    30b0:	93 1f       	adc	r25, r19
    30b2:	b6 01       	movw	r22, r12
    30b4:	8a 56       	subi	r24, 0x6A	; 106
    30b6:	9c 4d       	sbci	r25, 0xDC	; 220
    30b8:	c7 d9       	rcall	.-3186   	; 0x2448 <vListInsertEnd>
    30ba:	0f 90       	pop	r0
    30bc:	0f be       	out	0x3f, r0	; 63
    30be:	80 91 72 23 	lds	r24, 0x2372	; 0x802372 <xSchedulerRunning>
    30c2:	88 23       	and	r24, r24
    30c4:	59 f0       	breq	.+22     	; 0x30dc <xTaskCreate+0x1d2>
    30c6:	e0 91 c3 23 	lds	r30, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    30ca:	f0 91 c4 23 	lds	r31, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    30ce:	96 89       	ldd	r25, Z+22	; 0x16
    30d0:	8e 89       	ldd	r24, Y+22	; 0x16
    30d2:	98 17       	cp	r25, r24
    30d4:	28 f4       	brcc	.+10     	; 0x30e0 <xTaskCreate+0x1d6>
    30d6:	ed da       	rcall	.-2598   	; 0x26b2 <vPortYield>
    30d8:	81 e0       	ldi	r24, 0x01	; 1
    30da:	05 c0       	rjmp	.+10     	; 0x30e6 <xTaskCreate+0x1dc>
    30dc:	81 e0       	ldi	r24, 0x01	; 1
    30de:	03 c0       	rjmp	.+6      	; 0x30e6 <xTaskCreate+0x1dc>
    30e0:	81 e0       	ldi	r24, 0x01	; 1
    30e2:	01 c0       	rjmp	.+2      	; 0x30e6 <xTaskCreate+0x1dc>
    30e4:	8f ef       	ldi	r24, 0xFF	; 255
    30e6:	df 91       	pop	r29
    30e8:	cf 91       	pop	r28
    30ea:	1f 91       	pop	r17
    30ec:	0f 91       	pop	r16
    30ee:	ff 90       	pop	r15
    30f0:	ef 90       	pop	r14
    30f2:	df 90       	pop	r13
    30f4:	cf 90       	pop	r12
    30f6:	bf 90       	pop	r11
    30f8:	af 90       	pop	r10
    30fa:	9f 90       	pop	r9
    30fc:	8f 90       	pop	r8
    30fe:	7f 90       	pop	r7
    3100:	6f 90       	pop	r6
    3102:	5f 90       	pop	r5
    3104:	4f 90       	pop	r4
    3106:	08 95       	ret

00003108 <vTaskStartScheduler>:
    3108:	ef 92       	push	r14
    310a:	ff 92       	push	r15
    310c:	0f 93       	push	r16
    310e:	0f 2e       	mov	r0, r31
    3110:	f9 e6       	ldi	r31, 0x69	; 105
    3112:	ef 2e       	mov	r14, r31
    3114:	f3 e2       	ldi	r31, 0x23	; 35
    3116:	ff 2e       	mov	r15, r31
    3118:	f0 2d       	mov	r31, r0
    311a:	00 e0       	ldi	r16, 0x00	; 0
    311c:	20 e0       	ldi	r18, 0x00	; 0
    311e:	30 e0       	ldi	r19, 0x00	; 0
    3120:	45 e5       	ldi	r20, 0x55	; 85
    3122:	50 e0       	ldi	r21, 0x00	; 0
    3124:	61 e1       	ldi	r22, 0x11	; 17
    3126:	70 e2       	ldi	r23, 0x20	; 32
    3128:	8d e3       	ldi	r24, 0x3D	; 61
    312a:	97 e1       	ldi	r25, 0x17	; 23
    312c:	ee de       	rcall	.-548    	; 0x2f0a <xTaskCreate>
    312e:	81 30       	cpi	r24, 0x01	; 1
    3130:	91 f4       	brne	.+36     	; 0x3156 <vTaskStartScheduler+0x4e>
    3132:	e0 d2       	rcall	.+1472   	; 0x36f4 <xTimerCreateTimerTask>
    3134:	81 30       	cpi	r24, 0x01	; 1
    3136:	79 f4       	brne	.+30     	; 0x3156 <vTaskStartScheduler+0x4e>
    3138:	f8 94       	cli
    313a:	8f ef       	ldi	r24, 0xFF	; 255
    313c:	9f ef       	ldi	r25, 0xFF	; 255
    313e:	80 93 6b 23 	sts	0x236B, r24	; 0x80236b <xNextTaskUnblockTime>
    3142:	90 93 6c 23 	sts	0x236C, r25	; 0x80236c <xNextTaskUnblockTime+0x1>
    3146:	81 e0       	ldi	r24, 0x01	; 1
    3148:	80 93 72 23 	sts	0x2372, r24	; 0x802372 <xSchedulerRunning>
    314c:	10 92 74 23 	sts	0x2374, r1	; 0x802374 <xTickCount>
    3150:	10 92 75 23 	sts	0x2375, r1	; 0x802375 <xTickCount+0x1>
    3154:	69 da       	rcall	.-2862   	; 0x2628 <xPortStartScheduler>
    3156:	0f 91       	pop	r16
    3158:	ff 90       	pop	r15
    315a:	ef 90       	pop	r14
    315c:	08 95       	ret

0000315e <vTaskSuspendAll>:
    315e:	80 91 68 23 	lds	r24, 0x2368	; 0x802368 <uxSchedulerSuspended>
    3162:	8f 5f       	subi	r24, 0xFF	; 255
    3164:	80 93 68 23 	sts	0x2368, r24	; 0x802368 <uxSchedulerSuspended>
    3168:	08 95       	ret

0000316a <xTaskGetTickCount>:
    316a:	0f b6       	in	r0, 0x3f	; 63
    316c:	f8 94       	cli
    316e:	0f 92       	push	r0
    3170:	80 91 74 23 	lds	r24, 0x2374	; 0x802374 <xTickCount>
    3174:	90 91 75 23 	lds	r25, 0x2375	; 0x802375 <xTickCount+0x1>
    3178:	0f 90       	pop	r0
    317a:	0f be       	out	0x3f, r0	; 63
    317c:	08 95       	ret

0000317e <xTaskIncrementTick>:
    317e:	df 92       	push	r13
    3180:	ef 92       	push	r14
    3182:	ff 92       	push	r15
    3184:	0f 93       	push	r16
    3186:	1f 93       	push	r17
    3188:	cf 93       	push	r28
    318a:	df 93       	push	r29
    318c:	80 91 68 23 	lds	r24, 0x2368	; 0x802368 <uxSchedulerSuspended>
    3190:	81 11       	cpse	r24, r1
    3192:	9a c0       	rjmp	.+308    	; 0x32c8 <xTaskIncrementTick+0x14a>
    3194:	e0 90 74 23 	lds	r14, 0x2374	; 0x802374 <xTickCount>
    3198:	f0 90 75 23 	lds	r15, 0x2375	; 0x802375 <xTickCount+0x1>
    319c:	8f ef       	ldi	r24, 0xFF	; 255
    319e:	e8 1a       	sub	r14, r24
    31a0:	f8 0a       	sbc	r15, r24
    31a2:	e0 92 74 23 	sts	0x2374, r14	; 0x802374 <xTickCount>
    31a6:	f0 92 75 23 	sts	0x2375, r15	; 0x802375 <xTickCount+0x1>
    31aa:	e1 14       	cp	r14, r1
    31ac:	f1 04       	cpc	r15, r1
    31ae:	b1 f4       	brne	.+44     	; 0x31dc <xTaskIncrementTick+0x5e>
    31b0:	80 91 82 23 	lds	r24, 0x2382	; 0x802382 <pxDelayedTaskList>
    31b4:	90 91 83 23 	lds	r25, 0x2383	; 0x802383 <pxDelayedTaskList+0x1>
    31b8:	20 91 80 23 	lds	r18, 0x2380	; 0x802380 <pxOverflowDelayedTaskList>
    31bc:	30 91 81 23 	lds	r19, 0x2381	; 0x802381 <pxOverflowDelayedTaskList+0x1>
    31c0:	20 93 82 23 	sts	0x2382, r18	; 0x802382 <pxDelayedTaskList>
    31c4:	30 93 83 23 	sts	0x2383, r19	; 0x802383 <pxDelayedTaskList+0x1>
    31c8:	80 93 80 23 	sts	0x2380, r24	; 0x802380 <pxOverflowDelayedTaskList>
    31cc:	90 93 81 23 	sts	0x2381, r25	; 0x802381 <pxOverflowDelayedTaskList+0x1>
    31d0:	80 91 6e 23 	lds	r24, 0x236E	; 0x80236e <xNumOfOverflows>
    31d4:	8f 5f       	subi	r24, 0xFF	; 255
    31d6:	80 93 6e 23 	sts	0x236E, r24	; 0x80236e <xNumOfOverflows>
    31da:	30 de       	rcall	.-928    	; 0x2e3c <prvResetNextTaskUnblockTime>
    31dc:	80 91 6b 23 	lds	r24, 0x236B	; 0x80236b <xNextTaskUnblockTime>
    31e0:	90 91 6c 23 	lds	r25, 0x236C	; 0x80236c <xNextTaskUnblockTime+0x1>
    31e4:	e8 16       	cp	r14, r24
    31e6:	f9 06       	cpc	r15, r25
    31e8:	10 f4       	brcc	.+4      	; 0x31ee <xTaskIncrementTick+0x70>
    31ea:	d1 2c       	mov	r13, r1
    31ec:	4f c0       	rjmp	.+158    	; 0x328c <xTaskIncrementTick+0x10e>
    31ee:	d1 2c       	mov	r13, r1
    31f0:	e0 91 82 23 	lds	r30, 0x2382	; 0x802382 <pxDelayedTaskList>
    31f4:	f0 91 83 23 	lds	r31, 0x2383	; 0x802383 <pxDelayedTaskList+0x1>
    31f8:	80 81       	ld	r24, Z
    31fa:	81 11       	cpse	r24, r1
    31fc:	07 c0       	rjmp	.+14     	; 0x320c <xTaskIncrementTick+0x8e>
    31fe:	8f ef       	ldi	r24, 0xFF	; 255
    3200:	9f ef       	ldi	r25, 0xFF	; 255
    3202:	80 93 6b 23 	sts	0x236B, r24	; 0x80236b <xNextTaskUnblockTime>
    3206:	90 93 6c 23 	sts	0x236C, r25	; 0x80236c <xNextTaskUnblockTime+0x1>
    320a:	40 c0       	rjmp	.+128    	; 0x328c <xTaskIncrementTick+0x10e>
    320c:	e0 91 82 23 	lds	r30, 0x2382	; 0x802382 <pxDelayedTaskList>
    3210:	f0 91 83 23 	lds	r31, 0x2383	; 0x802383 <pxDelayedTaskList+0x1>
    3214:	05 80       	ldd	r0, Z+5	; 0x05
    3216:	f6 81       	ldd	r31, Z+6	; 0x06
    3218:	e0 2d       	mov	r30, r0
    321a:	c6 81       	ldd	r28, Z+6	; 0x06
    321c:	d7 81       	ldd	r29, Z+7	; 0x07
    321e:	8a 81       	ldd	r24, Y+2	; 0x02
    3220:	9b 81       	ldd	r25, Y+3	; 0x03
    3222:	e8 16       	cp	r14, r24
    3224:	f9 06       	cpc	r15, r25
    3226:	28 f4       	brcc	.+10     	; 0x3232 <xTaskIncrementTick+0xb4>
    3228:	80 93 6b 23 	sts	0x236B, r24	; 0x80236b <xNextTaskUnblockTime>
    322c:	90 93 6c 23 	sts	0x236C, r25	; 0x80236c <xNextTaskUnblockTime+0x1>
    3230:	2d c0       	rjmp	.+90     	; 0x328c <xTaskIncrementTick+0x10e>
    3232:	8e 01       	movw	r16, r28
    3234:	0e 5f       	subi	r16, 0xFE	; 254
    3236:	1f 4f       	sbci	r17, 0xFF	; 255
    3238:	c8 01       	movw	r24, r16
    323a:	58 d9       	rcall	.-3408   	; 0x24ec <uxListRemove>
    323c:	8c 89       	ldd	r24, Y+20	; 0x14
    323e:	9d 89       	ldd	r25, Y+21	; 0x15
    3240:	89 2b       	or	r24, r25
    3242:	19 f0       	breq	.+6      	; 0x324a <xTaskIncrementTick+0xcc>
    3244:	ce 01       	movw	r24, r28
    3246:	0c 96       	adiw	r24, 0x0c	; 12
    3248:	51 d9       	rcall	.-3422   	; 0x24ec <uxListRemove>
    324a:	8e 89       	ldd	r24, Y+22	; 0x16
    324c:	90 91 73 23 	lds	r25, 0x2373	; 0x802373 <uxTopReadyPriority>
    3250:	98 17       	cp	r25, r24
    3252:	10 f4       	brcc	.+4      	; 0x3258 <xTaskIncrementTick+0xda>
    3254:	80 93 73 23 	sts	0x2373, r24	; 0x802373 <uxTopReadyPriority>
    3258:	90 e0       	ldi	r25, 0x00	; 0
    325a:	9c 01       	movw	r18, r24
    325c:	22 0f       	add	r18, r18
    325e:	33 1f       	adc	r19, r19
    3260:	22 0f       	add	r18, r18
    3262:	33 1f       	adc	r19, r19
    3264:	22 0f       	add	r18, r18
    3266:	33 1f       	adc	r19, r19
    3268:	82 0f       	add	r24, r18
    326a:	93 1f       	adc	r25, r19
    326c:	b8 01       	movw	r22, r16
    326e:	8a 56       	subi	r24, 0x6A	; 106
    3270:	9c 4d       	sbci	r25, 0xDC	; 220
    3272:	ea d8       	rcall	.-3628   	; 0x2448 <vListInsertEnd>
    3274:	e0 91 c3 23 	lds	r30, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    3278:	f0 91 c4 23 	lds	r31, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    327c:	9e 89       	ldd	r25, Y+22	; 0x16
    327e:	86 89       	ldd	r24, Z+22	; 0x16
    3280:	98 17       	cp	r25, r24
    3282:	08 f4       	brcc	.+2      	; 0x3286 <xTaskIncrementTick+0x108>
    3284:	b5 cf       	rjmp	.-150    	; 0x31f0 <xTaskIncrementTick+0x72>
    3286:	dd 24       	eor	r13, r13
    3288:	d3 94       	inc	r13
    328a:	b2 cf       	rjmp	.-156    	; 0x31f0 <xTaskIncrementTick+0x72>
    328c:	e0 91 c3 23 	lds	r30, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    3290:	f0 91 c4 23 	lds	r31, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    3294:	86 89       	ldd	r24, Z+22	; 0x16
    3296:	90 e0       	ldi	r25, 0x00	; 0
    3298:	fc 01       	movw	r30, r24
    329a:	ee 0f       	add	r30, r30
    329c:	ff 1f       	adc	r31, r31
    329e:	ee 0f       	add	r30, r30
    32a0:	ff 1f       	adc	r31, r31
    32a2:	ee 0f       	add	r30, r30
    32a4:	ff 1f       	adc	r31, r31
    32a6:	8e 0f       	add	r24, r30
    32a8:	9f 1f       	adc	r25, r31
    32aa:	fc 01       	movw	r30, r24
    32ac:	ea 56       	subi	r30, 0x6A	; 106
    32ae:	fc 4d       	sbci	r31, 0xDC	; 220
    32b0:	80 81       	ld	r24, Z
    32b2:	82 30       	cpi	r24, 0x02	; 2
    32b4:	10 f0       	brcs	.+4      	; 0x32ba <xTaskIncrementTick+0x13c>
    32b6:	dd 24       	eor	r13, r13
    32b8:	d3 94       	inc	r13
    32ba:	80 91 6f 23 	lds	r24, 0x236F	; 0x80236f <xYieldPending>
    32be:	88 23       	and	r24, r24
    32c0:	69 f0       	breq	.+26     	; 0x32dc <xTaskIncrementTick+0x15e>
    32c2:	dd 24       	eor	r13, r13
    32c4:	d3 94       	inc	r13
    32c6:	0a c0       	rjmp	.+20     	; 0x32dc <xTaskIncrementTick+0x15e>
    32c8:	80 91 70 23 	lds	r24, 0x2370	; 0x802370 <xPendedTicks>
    32cc:	90 91 71 23 	lds	r25, 0x2371	; 0x802371 <xPendedTicks+0x1>
    32d0:	01 96       	adiw	r24, 0x01	; 1
    32d2:	80 93 70 23 	sts	0x2370, r24	; 0x802370 <xPendedTicks>
    32d6:	90 93 71 23 	sts	0x2371, r25	; 0x802371 <xPendedTicks+0x1>
    32da:	d1 2c       	mov	r13, r1
    32dc:	8d 2d       	mov	r24, r13
    32de:	df 91       	pop	r29
    32e0:	cf 91       	pop	r28
    32e2:	1f 91       	pop	r17
    32e4:	0f 91       	pop	r16
    32e6:	ff 90       	pop	r15
    32e8:	ef 90       	pop	r14
    32ea:	df 90       	pop	r13
    32ec:	08 95       	ret

000032ee <xTaskResumeAll>:
    32ee:	df 92       	push	r13
    32f0:	ef 92       	push	r14
    32f2:	ff 92       	push	r15
    32f4:	0f 93       	push	r16
    32f6:	1f 93       	push	r17
    32f8:	cf 93       	push	r28
    32fa:	df 93       	push	r29
    32fc:	0f b6       	in	r0, 0x3f	; 63
    32fe:	f8 94       	cli
    3300:	0f 92       	push	r0
    3302:	80 91 68 23 	lds	r24, 0x2368	; 0x802368 <uxSchedulerSuspended>
    3306:	81 50       	subi	r24, 0x01	; 1
    3308:	80 93 68 23 	sts	0x2368, r24	; 0x802368 <uxSchedulerSuspended>
    330c:	80 91 68 23 	lds	r24, 0x2368	; 0x802368 <uxSchedulerSuspended>
    3310:	81 11       	cpse	r24, r1
    3312:	5d c0       	rjmp	.+186    	; 0x33ce <xTaskResumeAll+0xe0>
    3314:	80 91 76 23 	lds	r24, 0x2376	; 0x802376 <uxCurrentNumberOfTasks>
    3318:	81 11       	cpse	r24, r1
    331a:	30 c0       	rjmp	.+96     	; 0x337c <xTaskResumeAll+0x8e>
    331c:	5b c0       	rjmp	.+182    	; 0x33d4 <xTaskResumeAll+0xe6>
    331e:	d7 01       	movw	r26, r14
    3320:	15 96       	adiw	r26, 0x05	; 5
    3322:	ed 91       	ld	r30, X+
    3324:	fc 91       	ld	r31, X
    3326:	16 97       	sbiw	r26, 0x06	; 6
    3328:	c6 81       	ldd	r28, Z+6	; 0x06
    332a:	d7 81       	ldd	r29, Z+7	; 0x07
    332c:	ce 01       	movw	r24, r28
    332e:	0c 96       	adiw	r24, 0x0c	; 12
    3330:	dd d8       	rcall	.-3654   	; 0x24ec <uxListRemove>
    3332:	8e 01       	movw	r16, r28
    3334:	0e 5f       	subi	r16, 0xFE	; 254
    3336:	1f 4f       	sbci	r17, 0xFF	; 255
    3338:	c8 01       	movw	r24, r16
    333a:	d8 d8       	rcall	.-3664   	; 0x24ec <uxListRemove>
    333c:	8e 89       	ldd	r24, Y+22	; 0x16
    333e:	90 91 73 23 	lds	r25, 0x2373	; 0x802373 <uxTopReadyPriority>
    3342:	98 17       	cp	r25, r24
    3344:	10 f4       	brcc	.+4      	; 0x334a <xTaskResumeAll+0x5c>
    3346:	80 93 73 23 	sts	0x2373, r24	; 0x802373 <uxTopReadyPriority>
    334a:	90 e0       	ldi	r25, 0x00	; 0
    334c:	9c 01       	movw	r18, r24
    334e:	22 0f       	add	r18, r18
    3350:	33 1f       	adc	r19, r19
    3352:	22 0f       	add	r18, r18
    3354:	33 1f       	adc	r19, r19
    3356:	22 0f       	add	r18, r18
    3358:	33 1f       	adc	r19, r19
    335a:	82 0f       	add	r24, r18
    335c:	93 1f       	adc	r25, r19
    335e:	b8 01       	movw	r22, r16
    3360:	8a 56       	subi	r24, 0x6A	; 106
    3362:	9c 4d       	sbci	r25, 0xDC	; 220
    3364:	71 d8       	rcall	.-3870   	; 0x2448 <vListInsertEnd>
    3366:	e0 91 c3 23 	lds	r30, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    336a:	f0 91 c4 23 	lds	r31, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    336e:	9e 89       	ldd	r25, Y+22	; 0x16
    3370:	86 89       	ldd	r24, Z+22	; 0x16
    3372:	98 17       	cp	r25, r24
    3374:	68 f0       	brcs	.+26     	; 0x3390 <xTaskResumeAll+0xa2>
    3376:	d0 92 6f 23 	sts	0x236F, r13	; 0x80236f <xYieldPending>
    337a:	0a c0       	rjmp	.+20     	; 0x3390 <xTaskResumeAll+0xa2>
    337c:	c0 e0       	ldi	r28, 0x00	; 0
    337e:	d0 e0       	ldi	r29, 0x00	; 0
    3380:	0f 2e       	mov	r0, r31
    3382:	f7 e7       	ldi	r31, 0x77	; 119
    3384:	ef 2e       	mov	r14, r31
    3386:	f3 e2       	ldi	r31, 0x23	; 35
    3388:	ff 2e       	mov	r15, r31
    338a:	f0 2d       	mov	r31, r0
    338c:	dd 24       	eor	r13, r13
    338e:	d3 94       	inc	r13
    3390:	f7 01       	movw	r30, r14
    3392:	80 81       	ld	r24, Z
    3394:	81 11       	cpse	r24, r1
    3396:	c3 cf       	rjmp	.-122    	; 0x331e <xTaskResumeAll+0x30>
    3398:	cd 2b       	or	r28, r29
    339a:	09 f0       	breq	.+2      	; 0x339e <xTaskResumeAll+0xb0>
    339c:	4f dd       	rcall	.-1378   	; 0x2e3c <prvResetNextTaskUnblockTime>
    339e:	c0 91 70 23 	lds	r28, 0x2370	; 0x802370 <xPendedTicks>
    33a2:	d0 91 71 23 	lds	r29, 0x2371	; 0x802371 <xPendedTicks+0x1>
    33a6:	20 97       	sbiw	r28, 0x00	; 0
    33a8:	59 f0       	breq	.+22     	; 0x33c0 <xTaskResumeAll+0xd2>
    33aa:	11 e0       	ldi	r17, 0x01	; 1
    33ac:	e8 de       	rcall	.-560    	; 0x317e <xTaskIncrementTick>
    33ae:	81 11       	cpse	r24, r1
    33b0:	10 93 6f 23 	sts	0x236F, r17	; 0x80236f <xYieldPending>
    33b4:	21 97       	sbiw	r28, 0x01	; 1
    33b6:	d1 f7       	brne	.-12     	; 0x33ac <xTaskResumeAll+0xbe>
    33b8:	10 92 70 23 	sts	0x2370, r1	; 0x802370 <xPendedTicks>
    33bc:	10 92 71 23 	sts	0x2371, r1	; 0x802371 <xPendedTicks+0x1>
    33c0:	80 91 6f 23 	lds	r24, 0x236F	; 0x80236f <xYieldPending>
    33c4:	88 23       	and	r24, r24
    33c6:	29 f0       	breq	.+10     	; 0x33d2 <xTaskResumeAll+0xe4>
    33c8:	74 d9       	rcall	.-3352   	; 0x26b2 <vPortYield>
    33ca:	81 e0       	ldi	r24, 0x01	; 1
    33cc:	03 c0       	rjmp	.+6      	; 0x33d4 <xTaskResumeAll+0xe6>
    33ce:	80 e0       	ldi	r24, 0x00	; 0
    33d0:	01 c0       	rjmp	.+2      	; 0x33d4 <xTaskResumeAll+0xe6>
    33d2:	80 e0       	ldi	r24, 0x00	; 0
    33d4:	0f 90       	pop	r0
    33d6:	0f be       	out	0x3f, r0	; 63
    33d8:	df 91       	pop	r29
    33da:	cf 91       	pop	r28
    33dc:	1f 91       	pop	r17
    33de:	0f 91       	pop	r16
    33e0:	ff 90       	pop	r15
    33e2:	ef 90       	pop	r14
    33e4:	df 90       	pop	r13
    33e6:	08 95       	ret

000033e8 <vTaskDelay>:
    33e8:	cf 93       	push	r28
    33ea:	df 93       	push	r29
    33ec:	ec 01       	movw	r28, r24
    33ee:	89 2b       	or	r24, r25
    33f0:	39 f0       	breq	.+14     	; 0x3400 <vTaskDelay+0x18>
    33f2:	b5 de       	rcall	.-662    	; 0x315e <vTaskSuspendAll>
    33f4:	60 e0       	ldi	r22, 0x00	; 0
    33f6:	ce 01       	movw	r24, r28
    33f8:	47 dd       	rcall	.-1394   	; 0x2e88 <prvAddCurrentTaskToDelayedList>
    33fa:	79 df       	rcall	.-270    	; 0x32ee <xTaskResumeAll>
    33fc:	81 11       	cpse	r24, r1
    33fe:	01 c0       	rjmp	.+2      	; 0x3402 <vTaskDelay+0x1a>
    3400:	58 d9       	rcall	.-3408   	; 0x26b2 <vPortYield>
    3402:	df 91       	pop	r29
    3404:	cf 91       	pop	r28
    3406:	08 95       	ret

00003408 <vTaskSwitchContext>:
    3408:	80 91 68 23 	lds	r24, 0x2368	; 0x802368 <uxSchedulerSuspended>
    340c:	88 23       	and	r24, r24
    340e:	21 f0       	breq	.+8      	; 0x3418 <vTaskSwitchContext+0x10>
    3410:	81 e0       	ldi	r24, 0x01	; 1
    3412:	80 93 6f 23 	sts	0x236F, r24	; 0x80236f <xYieldPending>
    3416:	08 95       	ret
    3418:	10 92 6f 23 	sts	0x236F, r1	; 0x80236f <xYieldPending>
    341c:	20 91 73 23 	lds	r18, 0x2373	; 0x802373 <uxTopReadyPriority>
    3420:	82 2f       	mov	r24, r18
    3422:	90 e0       	ldi	r25, 0x00	; 0
    3424:	fc 01       	movw	r30, r24
    3426:	ee 0f       	add	r30, r30
    3428:	ff 1f       	adc	r31, r31
    342a:	ee 0f       	add	r30, r30
    342c:	ff 1f       	adc	r31, r31
    342e:	ee 0f       	add	r30, r30
    3430:	ff 1f       	adc	r31, r31
    3432:	e8 0f       	add	r30, r24
    3434:	f9 1f       	adc	r31, r25
    3436:	ea 56       	subi	r30, 0x6A	; 106
    3438:	fc 4d       	sbci	r31, 0xDC	; 220
    343a:	30 81       	ld	r19, Z
    343c:	31 11       	cpse	r19, r1
    343e:	11 c0       	rjmp	.+34     	; 0x3462 <vTaskSwitchContext+0x5a>
    3440:	21 50       	subi	r18, 0x01	; 1
    3442:	82 2f       	mov	r24, r18
    3444:	90 e0       	ldi	r25, 0x00	; 0
    3446:	fc 01       	movw	r30, r24
    3448:	ee 0f       	add	r30, r30
    344a:	ff 1f       	adc	r31, r31
    344c:	ee 0f       	add	r30, r30
    344e:	ff 1f       	adc	r31, r31
    3450:	ee 0f       	add	r30, r30
    3452:	ff 1f       	adc	r31, r31
    3454:	e8 0f       	add	r30, r24
    3456:	f9 1f       	adc	r31, r25
    3458:	ea 56       	subi	r30, 0x6A	; 106
    345a:	fc 4d       	sbci	r31, 0xDC	; 220
    345c:	30 81       	ld	r19, Z
    345e:	33 23       	and	r19, r19
    3460:	79 f3       	breq	.-34     	; 0x3440 <vTaskSwitchContext+0x38>
    3462:	ac 01       	movw	r20, r24
    3464:	44 0f       	add	r20, r20
    3466:	55 1f       	adc	r21, r21
    3468:	44 0f       	add	r20, r20
    346a:	55 1f       	adc	r21, r21
    346c:	44 0f       	add	r20, r20
    346e:	55 1f       	adc	r21, r21
    3470:	48 0f       	add	r20, r24
    3472:	59 1f       	adc	r21, r25
    3474:	da 01       	movw	r26, r20
    3476:	aa 56       	subi	r26, 0x6A	; 106
    3478:	bc 4d       	sbci	r27, 0xDC	; 220
    347a:	11 96       	adiw	r26, 0x01	; 1
    347c:	ed 91       	ld	r30, X+
    347e:	fc 91       	ld	r31, X
    3480:	12 97       	sbiw	r26, 0x02	; 2
    3482:	02 80       	ldd	r0, Z+2	; 0x02
    3484:	f3 81       	ldd	r31, Z+3	; 0x03
    3486:	e0 2d       	mov	r30, r0
    3488:	11 96       	adiw	r26, 0x01	; 1
    348a:	ed 93       	st	X+, r30
    348c:	fc 93       	st	X, r31
    348e:	12 97       	sbiw	r26, 0x02	; 2
    3490:	47 56       	subi	r20, 0x67	; 103
    3492:	5c 4d       	sbci	r21, 0xDC	; 220
    3494:	e4 17       	cp	r30, r20
    3496:	f5 07       	cpc	r31, r21
    3498:	29 f4       	brne	.+10     	; 0x34a4 <vTaskSwitchContext+0x9c>
    349a:	42 81       	ldd	r20, Z+2	; 0x02
    349c:	53 81       	ldd	r21, Z+3	; 0x03
    349e:	fd 01       	movw	r30, r26
    34a0:	41 83       	std	Z+1, r20	; 0x01
    34a2:	52 83       	std	Z+2, r21	; 0x02
    34a4:	fc 01       	movw	r30, r24
    34a6:	ee 0f       	add	r30, r30
    34a8:	ff 1f       	adc	r31, r31
    34aa:	ee 0f       	add	r30, r30
    34ac:	ff 1f       	adc	r31, r31
    34ae:	ee 0f       	add	r30, r30
    34b0:	ff 1f       	adc	r31, r31
    34b2:	8e 0f       	add	r24, r30
    34b4:	9f 1f       	adc	r25, r31
    34b6:	fc 01       	movw	r30, r24
    34b8:	ea 56       	subi	r30, 0x6A	; 106
    34ba:	fc 4d       	sbci	r31, 0xDC	; 220
    34bc:	01 80       	ldd	r0, Z+1	; 0x01
    34be:	f2 81       	ldd	r31, Z+2	; 0x02
    34c0:	e0 2d       	mov	r30, r0
    34c2:	86 81       	ldd	r24, Z+6	; 0x06
    34c4:	97 81       	ldd	r25, Z+7	; 0x07
    34c6:	80 93 c3 23 	sts	0x23C3, r24	; 0x8023c3 <pxCurrentTCB>
    34ca:	90 93 c4 23 	sts	0x23C4, r25	; 0x8023c4 <pxCurrentTCB+0x1>
    34ce:	20 93 73 23 	sts	0x2373, r18	; 0x802373 <uxTopReadyPriority>
    34d2:	08 95       	ret

000034d4 <vTaskPlaceOnEventList>:
    34d4:	cf 93       	push	r28
    34d6:	df 93       	push	r29
    34d8:	eb 01       	movw	r28, r22
    34da:	60 91 c3 23 	lds	r22, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    34de:	70 91 c4 23 	lds	r23, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    34e2:	64 5f       	subi	r22, 0xF4	; 244
    34e4:	7f 4f       	sbci	r23, 0xFF	; 255
    34e6:	0e 94 45 12 	call	0x248a	; 0x248a <vListInsert>
    34ea:	61 e0       	ldi	r22, 0x01	; 1
    34ec:	ce 01       	movw	r24, r28
    34ee:	cc dc       	rcall	.-1640   	; 0x2e88 <prvAddCurrentTaskToDelayedList>
    34f0:	df 91       	pop	r29
    34f2:	cf 91       	pop	r28
    34f4:	08 95       	ret

000034f6 <vTaskPlaceOnEventListRestricted>:
    34f6:	0f 93       	push	r16
    34f8:	1f 93       	push	r17
    34fa:	cf 93       	push	r28
    34fc:	8b 01       	movw	r16, r22
    34fe:	c4 2f       	mov	r28, r20
    3500:	60 91 c3 23 	lds	r22, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    3504:	70 91 c4 23 	lds	r23, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    3508:	64 5f       	subi	r22, 0xF4	; 244
    350a:	7f 4f       	sbci	r23, 0xFF	; 255
    350c:	0e 94 24 12 	call	0x2448	; 0x2448 <vListInsertEnd>
    3510:	cc 23       	and	r28, r28
    3512:	11 f0       	breq	.+4      	; 0x3518 <vTaskPlaceOnEventListRestricted+0x22>
    3514:	0f ef       	ldi	r16, 0xFF	; 255
    3516:	1f ef       	ldi	r17, 0xFF	; 255
    3518:	6c 2f       	mov	r22, r28
    351a:	c8 01       	movw	r24, r16
    351c:	b5 dc       	rcall	.-1686   	; 0x2e88 <prvAddCurrentTaskToDelayedList>
    351e:	cf 91       	pop	r28
    3520:	1f 91       	pop	r17
    3522:	0f 91       	pop	r16
    3524:	08 95       	ret

00003526 <xTaskRemoveFromEventList>:
    3526:	0f 93       	push	r16
    3528:	1f 93       	push	r17
    352a:	cf 93       	push	r28
    352c:	df 93       	push	r29
    352e:	dc 01       	movw	r26, r24
    3530:	15 96       	adiw	r26, 0x05	; 5
    3532:	ed 91       	ld	r30, X+
    3534:	fc 91       	ld	r31, X
    3536:	16 97       	sbiw	r26, 0x06	; 6
    3538:	c6 81       	ldd	r28, Z+6	; 0x06
    353a:	d7 81       	ldd	r29, Z+7	; 0x07
    353c:	8e 01       	movw	r16, r28
    353e:	04 5f       	subi	r16, 0xF4	; 244
    3540:	1f 4f       	sbci	r17, 0xFF	; 255
    3542:	c8 01       	movw	r24, r16
    3544:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxListRemove>
    3548:	80 91 68 23 	lds	r24, 0x2368	; 0x802368 <uxSchedulerSuspended>
    354c:	81 11       	cpse	r24, r1
    354e:	1c c0       	rjmp	.+56     	; 0x3588 <xTaskRemoveFromEventList+0x62>
    3550:	0a 50       	subi	r16, 0x0A	; 10
    3552:	11 09       	sbc	r17, r1
    3554:	c8 01       	movw	r24, r16
    3556:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxListRemove>
    355a:	8e 89       	ldd	r24, Y+22	; 0x16
    355c:	90 91 73 23 	lds	r25, 0x2373	; 0x802373 <uxTopReadyPriority>
    3560:	98 17       	cp	r25, r24
    3562:	10 f4       	brcc	.+4      	; 0x3568 <xTaskRemoveFromEventList+0x42>
    3564:	80 93 73 23 	sts	0x2373, r24	; 0x802373 <uxTopReadyPriority>
    3568:	90 e0       	ldi	r25, 0x00	; 0
    356a:	9c 01       	movw	r18, r24
    356c:	22 0f       	add	r18, r18
    356e:	33 1f       	adc	r19, r19
    3570:	22 0f       	add	r18, r18
    3572:	33 1f       	adc	r19, r19
    3574:	22 0f       	add	r18, r18
    3576:	33 1f       	adc	r19, r19
    3578:	82 0f       	add	r24, r18
    357a:	93 1f       	adc	r25, r19
    357c:	b8 01       	movw	r22, r16
    357e:	8a 56       	subi	r24, 0x6A	; 106
    3580:	9c 4d       	sbci	r25, 0xDC	; 220
    3582:	0e 94 24 12 	call	0x2448	; 0x2448 <vListInsertEnd>
    3586:	05 c0       	rjmp	.+10     	; 0x3592 <xTaskRemoveFromEventList+0x6c>
    3588:	b8 01       	movw	r22, r16
    358a:	87 e7       	ldi	r24, 0x77	; 119
    358c:	93 e2       	ldi	r25, 0x23	; 35
    358e:	0e 94 24 12 	call	0x2448	; 0x2448 <vListInsertEnd>
    3592:	e0 91 c3 23 	lds	r30, 0x23C3	; 0x8023c3 <pxCurrentTCB>
    3596:	f0 91 c4 23 	lds	r31, 0x23C4	; 0x8023c4 <pxCurrentTCB+0x1>
    359a:	9e 89       	ldd	r25, Y+22	; 0x16
    359c:	86 89       	ldd	r24, Z+22	; 0x16
    359e:	89 17       	cp	r24, r25
    35a0:	20 f4       	brcc	.+8      	; 0x35aa <xTaskRemoveFromEventList+0x84>
    35a2:	81 e0       	ldi	r24, 0x01	; 1
    35a4:	80 93 6f 23 	sts	0x236F, r24	; 0x80236f <xYieldPending>
    35a8:	01 c0       	rjmp	.+2      	; 0x35ac <xTaskRemoveFromEventList+0x86>
    35aa:	80 e0       	ldi	r24, 0x00	; 0
    35ac:	df 91       	pop	r29
    35ae:	cf 91       	pop	r28
    35b0:	1f 91       	pop	r17
    35b2:	0f 91       	pop	r16
    35b4:	08 95       	ret

000035b6 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    35b6:	20 91 6e 23 	lds	r18, 0x236E	; 0x80236e <xNumOfOverflows>
    35ba:	fc 01       	movw	r30, r24
    35bc:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    35be:	20 91 74 23 	lds	r18, 0x2374	; 0x802374 <xTickCount>
    35c2:	30 91 75 23 	lds	r19, 0x2375	; 0x802375 <xTickCount+0x1>
    35c6:	21 83       	std	Z+1, r18	; 0x01
    35c8:	32 83       	std	Z+2, r19	; 0x02
    35ca:	08 95       	ret

000035cc <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    35cc:	0f b6       	in	r0, 0x3f	; 63
    35ce:	f8 94       	cli
    35d0:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    35d2:	20 91 74 23 	lds	r18, 0x2374	; 0x802374 <xTickCount>
    35d6:	30 91 75 23 	lds	r19, 0x2375	; 0x802375 <xTickCount+0x1>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    35da:	dc 01       	movw	r26, r24
    35dc:	11 96       	adiw	r26, 0x01	; 1
    35de:	4d 91       	ld	r20, X+
    35e0:	5c 91       	ld	r21, X
    35e2:	12 97       	sbiw	r26, 0x02	; 2
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    35e4:	e0 91 6e 23 	lds	r30, 0x236E	; 0x80236e <xNumOfOverflows>
    35e8:	fc 91       	ld	r31, X
    35ea:	fe 17       	cp	r31, r30
    35ec:	19 f0       	breq	.+6      	; 0x35f4 <xTaskCheckForTimeOut+0x28>
    35ee:	24 17       	cp	r18, r20
    35f0:	35 07       	cpc	r19, r21
    35f2:	98 f4       	brcc	.+38     	; 0x361a <xTaskCheckForTimeOut+0x4e>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    35f4:	24 1b       	sub	r18, r20
    35f6:	35 0b       	sbc	r19, r21
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    35f8:	fb 01       	movw	r30, r22
    35fa:	40 81       	ld	r20, Z
    35fc:	51 81       	ldd	r21, Z+1	; 0x01
    35fe:	24 17       	cp	r18, r20
    3600:	35 07       	cpc	r19, r21
    3602:	38 f4       	brcc	.+14     	; 0x3612 <xTaskCheckForTimeOut+0x46>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    3604:	42 1b       	sub	r20, r18
    3606:	53 0b       	sbc	r21, r19
    3608:	40 83       	st	Z, r20
    360a:	51 83       	std	Z+1, r21	; 0x01
			vTaskInternalSetTimeOutState( pxTimeOut );
    360c:	d4 df       	rcall	.-88     	; 0x35b6 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    360e:	80 e0       	ldi	r24, 0x00	; 0
    3610:	05 c0       	rjmp	.+10     	; 0x361c <xTaskCheckForTimeOut+0x50>
		}
		else
		{
			*pxTicksToWait = 0;
    3612:	10 82       	st	Z, r1
    3614:	11 82       	std	Z+1, r1	; 0x01
			xReturn = pdTRUE;
    3616:	81 e0       	ldi	r24, 0x01	; 1
    3618:	01 c0       	rjmp	.+2      	; 0x361c <xTaskCheckForTimeOut+0x50>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    361a:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    361c:	0f 90       	pop	r0
    361e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    3620:	08 95       	ret

00003622 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    3622:	81 e0       	ldi	r24, 0x01	; 1
    3624:	80 93 6f 23 	sts	0x236F, r24	; 0x80236f <xYieldPending>
    3628:	08 95       	ret

0000362a <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    362a:	80 91 72 23 	lds	r24, 0x2372	; 0x802372 <xSchedulerRunning>
    362e:	88 23       	and	r24, r24
    3630:	31 f0       	breq	.+12     	; 0x363e <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3632:	80 91 68 23 	lds	r24, 0x2368	; 0x802368 <uxSchedulerSuspended>
    3636:	88 23       	and	r24, r24
    3638:	21 f0       	breq	.+8      	; 0x3642 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    363a:	80 e0       	ldi	r24, 0x00	; 0
    363c:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    363e:	81 e0       	ldi	r24, 0x01	; 1
    3640:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    3642:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    3644:	08 95       	ret

00003646 <prvInsertTimerInActiveList>:
			pxNewTimer->ucStatus = 0x00;
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
		}

		return pxNewTimer;
	}
    3646:	fc 01       	movw	r30, r24
    3648:	62 83       	std	Z+2, r22	; 0x02
    364a:	73 83       	std	Z+3, r23	; 0x03
    364c:	80 87       	std	Z+8, r24	; 0x08
    364e:	91 87       	std	Z+9, r25	; 0x09
    3650:	46 17       	cp	r20, r22
    3652:	57 07       	cpc	r21, r23
    3654:	90 f0       	brcs	.+36     	; 0x367a <prvInsertTimerInActiveList+0x34>
    3656:	42 1b       	sub	r20, r18
    3658:	53 0b       	sbc	r21, r19
    365a:	84 85       	ldd	r24, Z+12	; 0x0c
    365c:	95 85       	ldd	r25, Z+13	; 0x0d
    365e:	48 17       	cp	r20, r24
    3660:	59 07       	cpc	r21, r25
    3662:	e0 f4       	brcc	.+56     	; 0x369c <prvInsertTimerInActiveList+0x56>
    3664:	bf 01       	movw	r22, r30
    3666:	6e 5f       	subi	r22, 0xFE	; 254
    3668:	7f 4f       	sbci	r23, 0xFF	; 255
    366a:	80 91 cb 23 	lds	r24, 0x23CB	; 0x8023cb <pxOverflowTimerList>
    366e:	90 91 cc 23 	lds	r25, 0x23CC	; 0x8023cc <pxOverflowTimerList+0x1>
    3672:	0e 94 45 12 	call	0x248a	; 0x248a <vListInsert>
    3676:	80 e0       	ldi	r24, 0x00	; 0
    3678:	08 95       	ret
    367a:	42 17       	cp	r20, r18
    367c:	53 07       	cpc	r21, r19
    367e:	18 f4       	brcc	.+6      	; 0x3686 <prvInsertTimerInActiveList+0x40>
    3680:	62 17       	cp	r22, r18
    3682:	73 07       	cpc	r23, r19
    3684:	68 f4       	brcc	.+26     	; 0x36a0 <prvInsertTimerInActiveList+0x5a>
    3686:	bf 01       	movw	r22, r30
    3688:	6e 5f       	subi	r22, 0xFE	; 254
    368a:	7f 4f       	sbci	r23, 0xFF	; 255
    368c:	80 91 cd 23 	lds	r24, 0x23CD	; 0x8023cd <pxCurrentTimerList>
    3690:	90 91 ce 23 	lds	r25, 0x23CE	; 0x8023ce <pxCurrentTimerList+0x1>
    3694:	0e 94 45 12 	call	0x248a	; 0x248a <vListInsert>
    3698:	80 e0       	ldi	r24, 0x00	; 0
    369a:	08 95       	ret
    369c:	81 e0       	ldi	r24, 0x01	; 1
    369e:	08 95       	ret
    36a0:	81 e0       	ldi	r24, 0x01	; 1
    36a2:	08 95       	ret

000036a4 <prvCheckForValidListAndQueue>:
    36a4:	0f b6       	in	r0, 0x3f	; 63
    36a6:	f8 94       	cli
    36a8:	0f 92       	push	r0
    36aa:	80 91 c9 23 	lds	r24, 0x23C9	; 0x8023c9 <xTimerQueue>
    36ae:	90 91 ca 23 	lds	r25, 0x23CA	; 0x8023ca <xTimerQueue+0x1>
    36b2:	89 2b       	or	r24, r25
    36b4:	e1 f4       	brne	.+56     	; 0x36ee <prvCheckForValidListAndQueue+0x4a>
    36b6:	88 ed       	ldi	r24, 0xD8	; 216
    36b8:	93 e2       	ldi	r25, 0x23	; 35
    36ba:	0e 94 12 12 	call	0x2424	; 0x2424 <vListInitialise>
    36be:	8f ec       	ldi	r24, 0xCF	; 207
    36c0:	93 e2       	ldi	r25, 0x23	; 35
    36c2:	0e 94 12 12 	call	0x2424	; 0x2424 <vListInitialise>
    36c6:	88 ed       	ldi	r24, 0xD8	; 216
    36c8:	93 e2       	ldi	r25, 0x23	; 35
    36ca:	80 93 cd 23 	sts	0x23CD, r24	; 0x8023cd <pxCurrentTimerList>
    36ce:	90 93 ce 23 	sts	0x23CE, r25	; 0x8023ce <pxCurrentTimerList+0x1>
    36d2:	8f ec       	ldi	r24, 0xCF	; 207
    36d4:	93 e2       	ldi	r25, 0x23	; 35
    36d6:	80 93 cb 23 	sts	0x23CB, r24	; 0x8023cb <pxOverflowTimerList>
    36da:	90 93 cc 23 	sts	0x23CC, r25	; 0x8023cc <pxOverflowTimerList+0x1>
    36de:	40 e0       	ldi	r20, 0x00	; 0
    36e0:	65 e0       	ldi	r22, 0x05	; 5
    36e2:	8a e0       	ldi	r24, 0x0A	; 10
    36e4:	ab d9       	rcall	.-3242   	; 0x2a3c <xQueueGenericCreate>
    36e6:	80 93 c9 23 	sts	0x23C9, r24	; 0x8023c9 <xTimerQueue>
    36ea:	90 93 ca 23 	sts	0x23CA, r25	; 0x8023ca <xTimerQueue+0x1>
    36ee:	0f 90       	pop	r0
    36f0:	0f be       	out	0x3f, r0	; 63
    36f2:	08 95       	ret

000036f4 <xTimerCreateTimerTask>:
    36f4:	ef 92       	push	r14
    36f6:	ff 92       	push	r15
    36f8:	0f 93       	push	r16
    36fa:	d4 df       	rcall	.-88     	; 0x36a4 <prvCheckForValidListAndQueue>
    36fc:	80 91 c9 23 	lds	r24, 0x23C9	; 0x8023c9 <xTimerQueue>
    3700:	90 91 ca 23 	lds	r25, 0x23CA	; 0x8023ca <xTimerQueue+0x1>
    3704:	89 2b       	or	r24, r25
    3706:	89 f0       	breq	.+34     	; 0x372a <xTimerCreateTimerTask+0x36>
    3708:	0f 2e       	mov	r0, r31
    370a:	f7 ec       	ldi	r31, 0xC7	; 199
    370c:	ef 2e       	mov	r14, r31
    370e:	f3 e2       	ldi	r31, 0x23	; 35
    3710:	ff 2e       	mov	r15, r31
    3712:	f0 2d       	mov	r31, r0
    3714:	03 e0       	ldi	r16, 0x03	; 3
    3716:	20 e0       	ldi	r18, 0x00	; 0
    3718:	30 e0       	ldi	r19, 0x00	; 0
    371a:	45 e5       	ldi	r20, 0x55	; 85
    371c:	50 e0       	ldi	r21, 0x00	; 0
    371e:	66 e1       	ldi	r22, 0x16	; 22
    3720:	70 e2       	ldi	r23, 0x20	; 32
    3722:	8a e4       	ldi	r24, 0x4A	; 74
    3724:	9c e1       	ldi	r25, 0x1C	; 28
    3726:	f1 db       	rcall	.-2078   	; 0x2f0a <xTaskCreate>
    3728:	01 c0       	rjmp	.+2      	; 0x372c <xTimerCreateTimerTask+0x38>
    372a:	80 e0       	ldi	r24, 0x00	; 0
    372c:	0f 91       	pop	r16
    372e:	ff 90       	pop	r15
    3730:	ef 90       	pop	r14
    3732:	08 95       	ret

00003734 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    3734:	0f 93       	push	r16
    3736:	1f 93       	push	r17
    3738:	cf 93       	push	r28
    373a:	df 93       	push	r29
    373c:	cd b7       	in	r28, 0x3d	; 61
    373e:	de b7       	in	r29, 0x3e	; 62
    3740:	25 97       	sbiw	r28, 0x05	; 5
    3742:	cd bf       	out	0x3d, r28	; 61
    3744:	de bf       	out	0x3e, r29	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    3746:	e0 91 c9 23 	lds	r30, 0x23C9	; 0x8023c9 <xTimerQueue>
    374a:	f0 91 ca 23 	lds	r31, 0x23CA	; 0x8023ca <xTimerQueue+0x1>
    374e:	30 97       	sbiw	r30, 0x00	; 0
    3750:	51 f1       	breq	.+84     	; 0x37a6 <xTimerGenericCommand+0x72>
    3752:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    3754:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    3756:	4a 83       	std	Y+2, r20	; 0x02
    3758:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    375a:	8c 83       	std	Y+4, r24	; 0x04
    375c:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    375e:	66 30       	cpi	r22, 0x06	; 6
    3760:	d4 f4       	brge	.+52     	; 0x3796 <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    3762:	63 df       	rcall	.-314    	; 0x362a <xTaskGetSchedulerState>
    3764:	82 30       	cpi	r24, 0x02	; 2
    3766:	59 f4       	brne	.+22     	; 0x377e <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    3768:	20 e0       	ldi	r18, 0x00	; 0
    376a:	a8 01       	movw	r20, r16
    376c:	be 01       	movw	r22, r28
    376e:	6f 5f       	subi	r22, 0xFF	; 255
    3770:	7f 4f       	sbci	r23, 0xFF	; 255
    3772:	80 91 c9 23 	lds	r24, 0x23C9	; 0x8023c9 <xTimerQueue>
    3776:	90 91 ca 23 	lds	r25, 0x23CA	; 0x8023ca <xTimerQueue+0x1>
    377a:	81 d9       	rcall	.-3326   	; 0x2a7e <xQueueGenericSend>
    377c:	15 c0       	rjmp	.+42     	; 0x37a8 <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    377e:	20 e0       	ldi	r18, 0x00	; 0
    3780:	40 e0       	ldi	r20, 0x00	; 0
    3782:	50 e0       	ldi	r21, 0x00	; 0
    3784:	be 01       	movw	r22, r28
    3786:	6f 5f       	subi	r22, 0xFF	; 255
    3788:	7f 4f       	sbci	r23, 0xFF	; 255
    378a:	80 91 c9 23 	lds	r24, 0x23C9	; 0x8023c9 <xTimerQueue>
    378e:	90 91 ca 23 	lds	r25, 0x23CA	; 0x8023ca <xTimerQueue+0x1>
    3792:	75 d9       	rcall	.-3350   	; 0x2a7e <xQueueGenericSend>
    3794:	09 c0       	rjmp	.+18     	; 0x37a8 <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    3796:	20 e0       	ldi	r18, 0x00	; 0
    3798:	ad 01       	movw	r20, r26
    379a:	be 01       	movw	r22, r28
    379c:	6f 5f       	subi	r22, 0xFF	; 255
    379e:	7f 4f       	sbci	r23, 0xFF	; 255
    37a0:	cf 01       	movw	r24, r30
    37a2:	fa d9       	rcall	.-3084   	; 0x2b98 <xQueueGenericSendFromISR>
    37a4:	01 c0       	rjmp	.+2      	; 0x37a8 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    37a6:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    37a8:	25 96       	adiw	r28, 0x05	; 5
    37aa:	cd bf       	out	0x3d, r28	; 61
    37ac:	de bf       	out	0x3e, r29	; 62
    37ae:	df 91       	pop	r29
    37b0:	cf 91       	pop	r28
    37b2:	1f 91       	pop	r17
    37b4:	0f 91       	pop	r16
    37b6:	08 95       	ret

000037b8 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    37b8:	af 92       	push	r10
    37ba:	bf 92       	push	r11
    37bc:	cf 92       	push	r12
    37be:	df 92       	push	r13
    37c0:	ef 92       	push	r14
    37c2:	ff 92       	push	r15
    37c4:	0f 93       	push	r16
    37c6:	1f 93       	push	r17
    37c8:	cf 93       	push	r28
    37ca:	df 93       	push	r29
    37cc:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    37ce:	cd dc       	rcall	.-1638   	; 0x316a <xTaskGetTickCount>
    37d0:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    37d2:	80 91 c5 23 	lds	r24, 0x23C5	; 0x8023c5 <xLastTime.4598>
    37d6:	90 91 c6 23 	lds	r25, 0x23C6	; 0x8023c6 <xLastTime.4598+0x1>
    37da:	e8 16       	cp	r14, r24
    37dc:	f9 06       	cpc	r15, r25
    37de:	08 f0       	brcs	.+2      	; 0x37e2 <prvSampleTimeNow+0x2a>
    37e0:	47 c0       	rjmp	.+142    	; 0x3870 <prvSampleTimeNow+0xb8>
    37e2:	2f c0       	rjmp	.+94     	; 0x3842 <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    37e4:	05 80       	ldd	r0, Z+5	; 0x05
    37e6:	f6 81       	ldd	r31, Z+6	; 0x06
    37e8:	e0 2d       	mov	r30, r0
    37ea:	a0 80       	ld	r10, Z
    37ec:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    37ee:	c6 81       	ldd	r28, Z+6	; 0x06
    37f0:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    37f2:	8e 01       	movw	r16, r28
    37f4:	0e 5f       	subi	r16, 0xFE	; 254
    37f6:	1f 4f       	sbci	r17, 0xFF	; 255
    37f8:	c8 01       	movw	r24, r16
    37fa:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    37fe:	e8 89       	ldd	r30, Y+16	; 0x10
    3800:	f9 89       	ldd	r31, Y+17	; 0x11
    3802:	ce 01       	movw	r24, r28
    3804:	19 95       	eicall

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    3806:	8a 89       	ldd	r24, Y+18	; 0x12
    3808:	82 ff       	sbrs	r24, 2
    380a:	1b c0       	rjmp	.+54     	; 0x3842 <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    380c:	8c 85       	ldd	r24, Y+12	; 0x0c
    380e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3810:	8a 0d       	add	r24, r10
    3812:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    3814:	a8 16       	cp	r10, r24
    3816:	b9 06       	cpc	r11, r25
    3818:	60 f4       	brcc	.+24     	; 0x3832 <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    381a:	8a 83       	std	Y+2, r24	; 0x02
    381c:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    381e:	c8 87       	std	Y+8, r28	; 0x08
    3820:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3822:	b8 01       	movw	r22, r16
    3824:	80 91 cd 23 	lds	r24, 0x23CD	; 0x8023cd <pxCurrentTimerList>
    3828:	90 91 ce 23 	lds	r25, 0x23CE	; 0x8023ce <pxCurrentTimerList+0x1>
    382c:	0e 94 45 12 	call	0x248a	; 0x248a <vListInsert>
    3830:	08 c0       	rjmp	.+16     	; 0x3842 <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3832:	00 e0       	ldi	r16, 0x00	; 0
    3834:	10 e0       	ldi	r17, 0x00	; 0
    3836:	20 e0       	ldi	r18, 0x00	; 0
    3838:	30 e0       	ldi	r19, 0x00	; 0
    383a:	a5 01       	movw	r20, r10
    383c:	60 e0       	ldi	r22, 0x00	; 0
    383e:	ce 01       	movw	r24, r28
    3840:	79 df       	rcall	.-270    	; 0x3734 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3842:	e0 91 cd 23 	lds	r30, 0x23CD	; 0x8023cd <pxCurrentTimerList>
    3846:	f0 91 ce 23 	lds	r31, 0x23CE	; 0x8023ce <pxCurrentTimerList+0x1>
    384a:	80 81       	ld	r24, Z
    384c:	81 11       	cpse	r24, r1
    384e:	ca cf       	rjmp	.-108    	; 0x37e4 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    3850:	80 91 cb 23 	lds	r24, 0x23CB	; 0x8023cb <pxOverflowTimerList>
    3854:	90 91 cc 23 	lds	r25, 0x23CC	; 0x8023cc <pxOverflowTimerList+0x1>
    3858:	80 93 cd 23 	sts	0x23CD, r24	; 0x8023cd <pxCurrentTimerList>
    385c:	90 93 ce 23 	sts	0x23CE, r25	; 0x8023ce <pxCurrentTimerList+0x1>
	pxOverflowTimerList = pxTemp;
    3860:	e0 93 cb 23 	sts	0x23CB, r30	; 0x8023cb <pxOverflowTimerList>
    3864:	f0 93 cc 23 	sts	0x23CC, r31	; 0x8023cc <pxOverflowTimerList+0x1>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    3868:	81 e0       	ldi	r24, 0x01	; 1
    386a:	f6 01       	movw	r30, r12
    386c:	80 83       	st	Z, r24
    386e:	02 c0       	rjmp	.+4      	; 0x3874 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    3870:	f6 01       	movw	r30, r12
    3872:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    3874:	e0 92 c5 23 	sts	0x23C5, r14	; 0x8023c5 <xLastTime.4598>
    3878:	f0 92 c6 23 	sts	0x23C6, r15	; 0x8023c6 <xLastTime.4598+0x1>

	return xTimeNow;
}
    387c:	c7 01       	movw	r24, r14
    387e:	df 91       	pop	r29
    3880:	cf 91       	pop	r28
    3882:	1f 91       	pop	r17
    3884:	0f 91       	pop	r16
    3886:	ff 90       	pop	r15
    3888:	ef 90       	pop	r14
    388a:	df 90       	pop	r13
    388c:	cf 90       	pop	r12
    388e:	bf 90       	pop	r11
    3890:	af 90       	pop	r10
    3892:	08 95       	ret

00003894 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    3894:	cf 93       	push	r28
    3896:	df 93       	push	r29
    3898:	00 d0       	rcall	.+0      	; 0x389a <prvTimerTask+0x6>
    389a:	00 d0       	rcall	.+0      	; 0x389c <prvTimerTask+0x8>
    389c:	cd b7       	in	r28, 0x3d	; 61
    389e:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    38a0:	ce 01       	movw	r24, r28
    38a2:	01 96       	adiw	r24, 0x01	; 1
    38a4:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    38a6:	e8 2e       	mov	r14, r24
    38a8:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    38aa:	e0 91 cd 23 	lds	r30, 0x23CD	; 0x8023cd <pxCurrentTimerList>
    38ae:	f0 91 ce 23 	lds	r31, 0x23CE	; 0x8023ce <pxCurrentTimerList+0x1>
    38b2:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    38b4:	88 23       	and	r24, r24
    38b6:	09 f4       	brne	.+2      	; 0x38ba <prvTimerTask+0x26>
    38b8:	cf c0       	rjmp	.+414    	; 0x3a58 <prvTimerTask+0x1c4>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    38ba:	05 80       	ldd	r0, Z+5	; 0x05
    38bc:	f6 81       	ldd	r31, Z+6	; 0x06
    38be:	e0 2d       	mov	r30, r0
    38c0:	c0 80       	ld	r12, Z
    38c2:	d1 80       	ldd	r13, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    38c4:	4c dc       	rcall	.-1896   	; 0x315e <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    38c6:	c5 01       	movw	r24, r10
    38c8:	77 df       	rcall	.-274    	; 0x37b8 <prvSampleTimeNow>
    38ca:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    38cc:	89 81       	ldd	r24, Y+1	; 0x01
    38ce:	81 11       	cpse	r24, r1
    38d0:	46 c0       	rjmp	.+140    	; 0x395e <prvTimerTask+0xca>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    38d2:	0c 15       	cp	r16, r12
    38d4:	1d 05       	cpc	r17, r13
			{
				( void ) xTaskResumeAll();
    38d6:	a0 f1       	brcs	.+104    	; 0x3940 <prvTimerTask+0xac>
    38d8:	0a dd       	rcall	.-1516   	; 0x32ee <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    38da:	e0 91 cd 23 	lds	r30, 0x23CD	; 0x8023cd <pxCurrentTimerList>
    38de:	f0 91 ce 23 	lds	r31, 0x23CE	; 0x8023ce <pxCurrentTimerList+0x1>
    38e2:	05 80       	ldd	r0, Z+5	; 0x05
    38e4:	f6 81       	ldd	r31, Z+6	; 0x06
    38e6:	e0 2d       	mov	r30, r0
    38e8:	86 80       	ldd	r8, Z+6	; 0x06
    38ea:	97 80       	ldd	r9, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    38ec:	c4 01       	movw	r24, r8
    38ee:	02 96       	adiw	r24, 0x02	; 2
    38f0:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto-reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    38f4:	d4 01       	movw	r26, r8
    38f6:	52 96       	adiw	r26, 0x12	; 18
    38f8:	8c 91       	ld	r24, X
    38fa:	52 97       	sbiw	r26, 0x12	; 18
    38fc:	82 ff       	sbrs	r24, 2
    38fe:	15 c0       	rjmp	.+42     	; 0x392a <prvTimerTask+0x96>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    3900:	1c 96       	adiw	r26, 0x0c	; 12
    3902:	6d 91       	ld	r22, X+
    3904:	7c 91       	ld	r23, X
    3906:	1d 97       	sbiw	r26, 0x0d	; 13
    3908:	6c 0d       	add	r22, r12
    390a:	7d 1d       	adc	r23, r13
    390c:	96 01       	movw	r18, r12
    390e:	a8 01       	movw	r20, r16
    3910:	c4 01       	movw	r24, r8
    3912:	99 de       	rcall	.-718    	; 0x3646 <prvInsertTimerInActiveList>
    3914:	88 23       	and	r24, r24
    3916:	61 f0       	breq	.+24     	; 0x3930 <prvTimerTask+0x9c>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3918:	00 e0       	ldi	r16, 0x00	; 0
    391a:	10 e0       	ldi	r17, 0x00	; 0
    391c:	20 e0       	ldi	r18, 0x00	; 0
    391e:	30 e0       	ldi	r19, 0x00	; 0
    3920:	a6 01       	movw	r20, r12
    3922:	60 e0       	ldi	r22, 0x00	; 0
    3924:	c4 01       	movw	r24, r8
    3926:	06 df       	rcall	.-500    	; 0x3734 <xTimerGenericCommand>
    3928:	03 c0       	rjmp	.+6      	; 0x3930 <prvTimerTask+0x9c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    392a:	8e 7f       	andi	r24, 0xFE	; 254
    392c:	f4 01       	movw	r30, r8
    392e:	82 8b       	std	Z+18, r24	; 0x12
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3930:	d4 01       	movw	r26, r8
    3932:	50 96       	adiw	r26, 0x10	; 16
    3934:	ed 91       	ld	r30, X+
    3936:	fc 91       	ld	r31, X
    3938:	51 97       	sbiw	r26, 0x11	; 17
    393a:	c4 01       	movw	r24, r8
    393c:	19 95       	eicall
    393e:	80 c0       	rjmp	.+256    	; 0x3a40 <prvTimerTask+0x1ac>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3940:	40 e0       	ldi	r20, 0x00	; 0
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    3942:	b6 01       	movw	r22, r12
    3944:	60 1b       	sub	r22, r16
    3946:	71 0b       	sbc	r23, r17
    3948:	80 91 c9 23 	lds	r24, 0x23C9	; 0x8023c9 <xTimerQueue>
    394c:	90 91 ca 23 	lds	r25, 0x23CA	; 0x8023ca <xTimerQueue+0x1>

				if( xTaskResumeAll() == pdFALSE )
    3950:	5a da       	rcall	.-2892   	; 0x2e06 <vQueueWaitForMessageRestricted>
    3952:	cd dc       	rcall	.-1638   	; 0x32ee <xTaskResumeAll>
    3954:	81 11       	cpse	r24, r1
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    3956:	74 c0       	rjmp	.+232    	; 0x3a40 <prvTimerTask+0x1ac>
    3958:	0e 94 59 13 	call	0x26b2	; 0x26b2 <vPortYield>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    395c:	71 c0       	rjmp	.+226    	; 0x3a40 <prvTimerTask+0x1ac>
    395e:	c7 dc       	rcall	.-1650   	; 0x32ee <xTaskResumeAll>
    3960:	6f c0       	rjmp	.+222    	; 0x3a40 <prvTimerTask+0x1ac>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3962:	89 81       	ldd	r24, Y+1	; 0x01
    3964:	88 23       	and	r24, r24
    3966:	0c f4       	brge	.+2      	; 0x396a <prvTimerTask+0xd6>
    3968:	6b c0       	rjmp	.+214    	; 0x3a40 <prvTimerTask+0x1ac>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    396a:	cc 80       	ldd	r12, Y+4	; 0x04
    396c:	dd 80       	ldd	r13, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    396e:	f6 01       	movw	r30, r12
    3970:	82 85       	ldd	r24, Z+10	; 0x0a
    3972:	93 85       	ldd	r25, Z+11	; 0x0b
    3974:	89 2b       	or	r24, r25
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3976:	21 f0       	breq	.+8      	; 0x3980 <prvTimerTask+0xec>
    3978:	c6 01       	movw	r24, r12
    397a:	02 96       	adiw	r24, 0x02	; 2
    397c:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3980:	ce 01       	movw	r24, r28
    3982:	06 96       	adiw	r24, 0x06	; 6
    3984:	19 df       	rcall	.-462    	; 0x37b8 <prvSampleTimeNow>
    3986:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    3988:	e9 81       	ldd	r30, Y+1	; 0x01
    398a:	0e 2e       	mov	r0, r30
    398c:	00 0c       	add	r0, r0
    398e:	ff 0b       	sbc	r31, r31
    3990:	ea 30       	cpi	r30, 0x0A	; 10
    3992:	f1 05       	cpc	r31, r1
    3994:	08 f0       	brcs	.+2      	; 0x3998 <prvTimerTask+0x104>
    3996:	54 c0       	rjmp	.+168    	; 0x3a40 <prvTimerTask+0x1ac>
    3998:	88 27       	eor	r24, r24
    399a:	e2 50       	subi	r30, 0x02	; 2
    399c:	ff 4f       	sbci	r31, 0xFF	; 255
    399e:	8f 4f       	sbci	r24, 0xFF	; 255
    39a0:	31 c7       	rjmp	.+3682   	; 0x4804 <__tablejump2__>
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    39a2:	d6 01       	movw	r26, r12
    39a4:	52 96       	adiw	r26, 0x12	; 18
    39a6:	8c 91       	ld	r24, X
    39a8:	52 97       	sbiw	r26, 0x12	; 18
    39aa:	81 60       	ori	r24, 0x01	; 1
    39ac:	52 96       	adiw	r26, 0x12	; 18
    39ae:	8c 93       	st	X, r24
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    39b0:	52 97       	sbiw	r26, 0x12	; 18
    39b2:	2a 81       	ldd	r18, Y+2	; 0x02
    39b4:	3b 81       	ldd	r19, Y+3	; 0x03
    39b6:	1c 96       	adiw	r26, 0x0c	; 12
    39b8:	6d 91       	ld	r22, X+
    39ba:	7c 91       	ld	r23, X
    39bc:	1d 97       	sbiw	r26, 0x0d	; 13
    39be:	62 0f       	add	r22, r18
    39c0:	73 1f       	adc	r23, r19
    39c2:	c6 01       	movw	r24, r12
    39c4:	40 de       	rcall	.-896    	; 0x3646 <prvInsertTimerInActiveList>
    39c6:	88 23       	and	r24, r24
    39c8:	d9 f1       	breq	.+118    	; 0x3a40 <prvTimerTask+0x1ac>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    39ca:	d6 01       	movw	r26, r12
    39cc:	50 96       	adiw	r26, 0x10	; 16
    39ce:	ed 91       	ld	r30, X+
    39d0:	fc 91       	ld	r31, X
    39d2:	51 97       	sbiw	r26, 0x11	; 17
    39d4:	c6 01       	movw	r24, r12
    39d6:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    39d8:	f6 01       	movw	r30, r12
    39da:	82 89       	ldd	r24, Z+18	; 0x12
    39dc:	82 ff       	sbrs	r24, 2
    39de:	30 c0       	rjmp	.+96     	; 0x3a40 <prvTimerTask+0x1ac>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    39e0:	4a 81       	ldd	r20, Y+2	; 0x02
    39e2:	5b 81       	ldd	r21, Y+3	; 0x03
    39e4:	84 85       	ldd	r24, Z+12	; 0x0c
    39e6:	95 85       	ldd	r25, Z+13	; 0x0d
    39e8:	48 0f       	add	r20, r24
    39ea:	59 1f       	adc	r21, r25
    39ec:	00 e0       	ldi	r16, 0x00	; 0
    39ee:	10 e0       	ldi	r17, 0x00	; 0
    39f0:	20 e0       	ldi	r18, 0x00	; 0
    39f2:	30 e0       	ldi	r19, 0x00	; 0
    39f4:	60 e0       	ldi	r22, 0x00	; 0
    39f6:	c6 01       	movw	r24, r12
    39f8:	9d de       	rcall	.-710    	; 0x3734 <xTimerGenericCommand>
    39fa:	22 c0       	rjmp	.+68     	; 0x3a40 <prvTimerTask+0x1ac>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    39fc:	d6 01       	movw	r26, r12
    39fe:	52 96       	adiw	r26, 0x12	; 18
    3a00:	8c 91       	ld	r24, X
    3a02:	52 97       	sbiw	r26, 0x12	; 18
    3a04:	8e 7f       	andi	r24, 0xFE	; 254
    3a06:	52 96       	adiw	r26, 0x12	; 18
    3a08:	8c 93       	st	X, r24
    3a0a:	1a c0       	rjmp	.+52     	; 0x3a40 <prvTimerTask+0x1ac>
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    3a0c:	f6 01       	movw	r30, r12
    3a0e:	82 89       	ldd	r24, Z+18	; 0x12
    3a10:	81 60       	ori	r24, 0x01	; 1
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    3a12:	82 8b       	std	Z+18, r24	; 0x12
    3a14:	6a 81       	ldd	r22, Y+2	; 0x02
    3a16:	7b 81       	ldd	r23, Y+3	; 0x03
    3a18:	64 87       	std	Z+12, r22	; 0x0c
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    3a1a:	75 87       	std	Z+13, r23	; 0x0d
    3a1c:	64 0f       	add	r22, r20
    3a1e:	75 1f       	adc	r23, r21
    3a20:	9a 01       	movw	r18, r20
    3a22:	c6 01       	movw	r24, r12
    3a24:	10 de       	rcall	.-992    	; 0x3646 <prvInsertTimerInActiveList>
    3a26:	0c c0       	rjmp	.+24     	; 0x3a40 <prvTimerTask+0x1ac>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    3a28:	d6 01       	movw	r26, r12
    3a2a:	52 96       	adiw	r26, 0x12	; 18
    3a2c:	8c 91       	ld	r24, X
    3a2e:	81 fd       	sbrc	r24, 1
    3a30:	04 c0       	rjmp	.+8      	; 0x3a3a <prvTimerTask+0x1a6>
						{
							vPortFree( pxTimer );
    3a32:	c6 01       	movw	r24, r12
    3a34:	0e 94 18 14 	call	0x2830	; 0x2830 <vPortFree>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    3a38:	03 c0       	rjmp	.+6      	; 0x3a40 <prvTimerTask+0x1ac>
    3a3a:	8e 7f       	andi	r24, 0xFE	; 254
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3a3c:	f6 01       	movw	r30, r12
    3a3e:	82 8b       	std	Z+18, r24	; 0x12
    3a40:	40 e0       	ldi	r20, 0x00	; 0
    3a42:	50 e0       	ldi	r21, 0x00	; 0
    3a44:	6e 2d       	mov	r22, r14
    3a46:	7f 2d       	mov	r23, r15
    3a48:	80 91 c9 23 	lds	r24, 0x23C9	; 0x8023c9 <xTimerQueue>
    3a4c:	90 91 ca 23 	lds	r25, 0x23CA	; 0x8023ca <xTimerQueue+0x1>
    3a50:	dd d8       	rcall	.-3654   	; 0x2c0c <xQueueReceive>
    3a52:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    3a54:	86 cf       	rjmp	.-244    	; 0x3962 <prvTimerTask+0xce>
    3a56:	29 cf       	rjmp	.-430    	; 0x38aa <prvTimerTask+0x16>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3a58:	82 db       	rcall	.-2300   	; 0x315e <vTaskSuspendAll>
    3a5a:	c5 01       	movw	r24, r10
    3a5c:	ad de       	rcall	.-678    	; 0x37b8 <prvSampleTimeNow>
    3a5e:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    3a60:	89 81       	ldd	r24, Y+1	; 0x01
    3a62:	81 11       	cpse	r24, r1
    3a64:	7c cf       	rjmp	.-264    	; 0x395e <prvTimerTask+0xca>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3a66:	e0 91 cb 23 	lds	r30, 0x23CB	; 0x8023cb <pxOverflowTimerList>
    3a6a:	f0 91 cc 23 	lds	r31, 0x23CC	; 0x8023cc <pxOverflowTimerList+0x1>
    3a6e:	80 81       	ld	r24, Z
    3a70:	41 e0       	ldi	r20, 0x01	; 1
    3a72:	81 11       	cpse	r24, r1
    3a74:	40 e0       	ldi	r20, 0x00	; 0
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    3a76:	c1 2c       	mov	r12, r1
    3a78:	d1 2c       	mov	r13, r1
    3a7a:	63 cf       	rjmp	.-314    	; 0x3942 <prvTimerTask+0xae>

00003a7c <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
    3a7c:	80 3a       	cpi	r24, 0xA0	; 160
    3a7e:	28 e0       	ldi	r18, 0x08	; 8
    3a80:	92 07       	cpc	r25, r18
    3a82:	21 f4       	brne	.+8      	; 0x3a8c <usart_spi_init+0x10>
    3a84:	60 e1       	ldi	r22, 0x10	; 16
    3a86:	83 e0       	ldi	r24, 0x03	; 3
    3a88:	22 c1       	rjmp	.+580    	; 0x3cce <sysclk_enable_module>
    3a8a:	08 95       	ret
    3a8c:	80 3b       	cpi	r24, 0xB0	; 176
    3a8e:	28 e0       	ldi	r18, 0x08	; 8
    3a90:	92 07       	cpc	r25, r18
    3a92:	21 f4       	brne	.+8      	; 0x3a9c <usart_spi_init+0x20>
    3a94:	60 e2       	ldi	r22, 0x20	; 32
    3a96:	83 e0       	ldi	r24, 0x03	; 3
    3a98:	1a c1       	rjmp	.+564    	; 0x3cce <sysclk_enable_module>
    3a9a:	08 95       	ret
    3a9c:	80 3a       	cpi	r24, 0xA0	; 160
    3a9e:	29 e0       	ldi	r18, 0x09	; 9
    3aa0:	92 07       	cpc	r25, r18
    3aa2:	21 f4       	brne	.+8      	; 0x3aac <usart_spi_init+0x30>
    3aa4:	60 e1       	ldi	r22, 0x10	; 16
    3aa6:	84 e0       	ldi	r24, 0x04	; 4
    3aa8:	12 c1       	rjmp	.+548    	; 0x3cce <sysclk_enable_module>
    3aaa:	08 95       	ret
    3aac:	80 3b       	cpi	r24, 0xB0	; 176
    3aae:	29 e0       	ldi	r18, 0x09	; 9
    3ab0:	92 07       	cpc	r25, r18
    3ab2:	21 f4       	brne	.+8      	; 0x3abc <usart_spi_init+0x40>
    3ab4:	60 e2       	ldi	r22, 0x20	; 32
    3ab6:	84 e0       	ldi	r24, 0x04	; 4
    3ab8:	0a c1       	rjmp	.+532    	; 0x3cce <sysclk_enable_module>
    3aba:	08 95       	ret
    3abc:	80 3a       	cpi	r24, 0xA0	; 160
    3abe:	2a e0       	ldi	r18, 0x0A	; 10
    3ac0:	92 07       	cpc	r25, r18
    3ac2:	21 f4       	brne	.+8      	; 0x3acc <usart_spi_init+0x50>
    3ac4:	60 e1       	ldi	r22, 0x10	; 16
    3ac6:	85 e0       	ldi	r24, 0x05	; 5
    3ac8:	02 c1       	rjmp	.+516    	; 0x3cce <sysclk_enable_module>
    3aca:	08 95       	ret
    3acc:	80 3a       	cpi	r24, 0xA0	; 160
    3ace:	9b 40       	sbci	r25, 0x0B	; 11
    3ad0:	19 f4       	brne	.+6      	; 0x3ad8 <usart_spi_init+0x5c>
    3ad2:	60 e1       	ldi	r22, 0x10	; 16
    3ad4:	86 e0       	ldi	r24, 0x06	; 6
    3ad6:	fb c0       	rjmp	.+502    	; 0x3cce <sysclk_enable_module>
    3ad8:	08 95       	ret

00003ada <usart_spi_setup_device>:
    3ada:	0f 93       	push	r16
    3adc:	1f 93       	push	r17
    3ade:	cf 93       	push	r28
    3ae0:	df 93       	push	r29
    3ae2:	00 d0       	rcall	.+0      	; 0x3ae4 <usart_spi_setup_device+0xa>
    3ae4:	00 d0       	rcall	.+0      	; 0x3ae6 <usart_spi_setup_device+0xc>
    3ae6:	cd b7       	in	r28, 0x3d	; 61
    3ae8:	de b7       	in	r29, 0x3e	; 62
    3aea:	09 83       	std	Y+1, r16	; 0x01
    3aec:	1a 83       	std	Y+2, r17	; 0x02
    3aee:	2b 83       	std	Y+3, r18	; 0x03
    3af0:	3c 83       	std	Y+4, r19	; 0x04
    3af2:	4d 83       	std	Y+5, r20	; 0x05
    3af4:	1e 82       	std	Y+6, r1	; 0x06
    3af6:	be 01       	movw	r22, r28
    3af8:	6f 5f       	subi	r22, 0xFF	; 255
    3afa:	7f 4f       	sbci	r23, 0xFF	; 255
    3afc:	0e 94 11 10 	call	0x2022	; 0x2022 <usart_init_spi>
    3b00:	26 96       	adiw	r28, 0x06	; 6
    3b02:	cd bf       	out	0x3d, r28	; 61
    3b04:	de bf       	out	0x3e, r29	; 62
    3b06:	df 91       	pop	r29
    3b08:	cf 91       	pop	r28
    3b0a:	1f 91       	pop	r17
    3b0c:	0f 91       	pop	r16
    3b0e:	08 95       	ret

00003b10 <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
    3b10:	fb 01       	movw	r30, r22
    3b12:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    3b14:	e8 2f       	mov	r30, r24
    3b16:	e6 95       	lsr	r30
    3b18:	e6 95       	lsr	r30
    3b1a:	e6 95       	lsr	r30
    3b1c:	40 e2       	ldi	r20, 0x20	; 32
    3b1e:	e4 9f       	mul	r30, r20
    3b20:	f0 01       	movw	r30, r0
    3b22:	11 24       	eor	r1, r1
    3b24:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    3b26:	87 70       	andi	r24, 0x07	; 7
    3b28:	21 e0       	ldi	r18, 0x01	; 1
    3b2a:	30 e0       	ldi	r19, 0x00	; 0
    3b2c:	a9 01       	movw	r20, r18
    3b2e:	02 c0       	rjmp	.+4      	; 0x3b34 <usart_spi_select_device+0x24>
    3b30:	44 0f       	add	r20, r20
    3b32:	55 1f       	adc	r21, r21
    3b34:	8a 95       	dec	r24
    3b36:	e2 f7       	brpl	.-8      	; 0x3b30 <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    3b38:	46 83       	std	Z+6, r20	; 0x06
    3b3a:	08 95       	ret

00003b3c <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
    3b3c:	fb 01       	movw	r30, r22
    3b3e:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    3b40:	e8 2f       	mov	r30, r24
    3b42:	e6 95       	lsr	r30
    3b44:	e6 95       	lsr	r30
    3b46:	e6 95       	lsr	r30
    3b48:	40 e2       	ldi	r20, 0x20	; 32
    3b4a:	e4 9f       	mul	r30, r20
    3b4c:	f0 01       	movw	r30, r0
    3b4e:	11 24       	eor	r1, r1
    3b50:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    3b52:	87 70       	andi	r24, 0x07	; 7
    3b54:	21 e0       	ldi	r18, 0x01	; 1
    3b56:	30 e0       	ldi	r19, 0x00	; 0
    3b58:	a9 01       	movw	r20, r18
    3b5a:	02 c0       	rjmp	.+4      	; 0x3b60 <usart_spi_deselect_device+0x24>
    3b5c:	44 0f       	add	r20, r20
    3b5e:	55 1f       	adc	r21, r21
    3b60:	8a 95       	dec	r24
    3b62:	e2 f7       	brpl	.-8      	; 0x3b5c <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3b64:	45 83       	std	Z+5, r20	; 0x05
    3b66:	08 95       	ret

00003b68 <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
    3b68:	80 93 e1 23 	sts	0x23E1, r24	; 0x8023e1 <fbpointer>
    3b6c:	90 93 e2 23 	sts	0x23E2, r25	; 0x8023e2 <fbpointer+0x1>
    3b70:	08 95       	ret

00003b72 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
    3b72:	20 91 e1 23 	lds	r18, 0x23E1	; 0x8023e1 <fbpointer>
    3b76:	30 91 e2 23 	lds	r19, 0x23E2	; 0x8023e2 <fbpointer+0x1>
    3b7a:	90 e8       	ldi	r25, 0x80	; 128
    3b7c:	89 9f       	mul	r24, r25
    3b7e:	20 0d       	add	r18, r0
    3b80:	31 1d       	adc	r19, r1
    3b82:	11 24       	eor	r1, r1
    3b84:	f9 01       	movw	r30, r18
    3b86:	e6 0f       	add	r30, r22
    3b88:	f1 1d       	adc	r31, r1
    3b8a:	40 83       	st	Z, r20
    3b8c:	08 95       	ret

00003b8e <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
    3b8e:	20 91 e1 23 	lds	r18, 0x23E1	; 0x8023e1 <fbpointer>
    3b92:	30 91 e2 23 	lds	r19, 0x23E2	; 0x8023e2 <fbpointer+0x1>
    3b96:	90 e8       	ldi	r25, 0x80	; 128
    3b98:	89 9f       	mul	r24, r25
    3b9a:	20 0d       	add	r18, r0
    3b9c:	31 1d       	adc	r19, r1
    3b9e:	11 24       	eor	r1, r1
    3ba0:	f9 01       	movw	r30, r18
    3ba2:	e6 0f       	add	r30, r22
    3ba4:	f1 1d       	adc	r31, r1
}
    3ba6:	80 81       	ld	r24, Z
    3ba8:	08 95       	ret

00003baa <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
    3baa:	ff 92       	push	r15
    3bac:	0f 93       	push	r16
    3bae:	1f 93       	push	r17
    3bb0:	cf 93       	push	r28
    3bb2:	df 93       	push	r29
    3bb4:	e4 2f       	mov	r30, r20
    3bb6:	f0 e0       	ldi	r31, 0x00	; 0
    3bb8:	e8 0f       	add	r30, r24
    3bba:	f1 1d       	adc	r31, r1
    3bbc:	e1 38       	cpi	r30, 0x81	; 129
    3bbe:	f1 05       	cpc	r31, r1
    3bc0:	1c f0       	brlt	.+6      	; 0x3bc8 <gfx_mono_generic_draw_horizontal_line+0x1e>
    3bc2:	c0 e8       	ldi	r28, 0x80	; 128
    3bc4:	4c 2f       	mov	r20, r28
    3bc6:	48 1b       	sub	r20, r24
    3bc8:	44 23       	and	r20, r20
    3bca:	09 f4       	brne	.+2      	; 0x3bce <gfx_mono_generic_draw_horizontal_line+0x24>
    3bcc:	50 c0       	rjmp	.+160    	; 0x3c6e <gfx_mono_generic_draw_horizontal_line+0xc4>
    3bce:	d6 2f       	mov	r29, r22
    3bd0:	d6 95       	lsr	r29
    3bd2:	d6 95       	lsr	r29
    3bd4:	d6 95       	lsr	r29
    3bd6:	70 e0       	ldi	r23, 0x00	; 0
    3bd8:	98 e0       	ldi	r25, 0x08	; 8
    3bda:	d9 9f       	mul	r29, r25
    3bdc:	60 19       	sub	r22, r0
    3bde:	71 09       	sbc	r23, r1
    3be0:	11 24       	eor	r1, r1
    3be2:	e1 e0       	ldi	r30, 0x01	; 1
    3be4:	f0 e0       	ldi	r31, 0x00	; 0
    3be6:	df 01       	movw	r26, r30
    3be8:	02 c0       	rjmp	.+4      	; 0x3bee <gfx_mono_generic_draw_horizontal_line+0x44>
    3bea:	aa 0f       	add	r26, r26
    3bec:	bb 1f       	adc	r27, r27
    3bee:	6a 95       	dec	r22
    3bf0:	e2 f7       	brpl	.-8      	; 0x3bea <gfx_mono_generic_draw_horizontal_line+0x40>
    3bf2:	fa 2e       	mov	r15, r26
    3bf4:	21 30       	cpi	r18, 0x01	; 1
    3bf6:	21 f0       	breq	.+8      	; 0x3c00 <gfx_mono_generic_draw_horizontal_line+0x56>
    3bf8:	a8 f0       	brcs	.+42     	; 0x3c24 <gfx_mono_generic_draw_horizontal_line+0x7a>
    3bfa:	22 30       	cpi	r18, 0x02	; 2
    3bfc:	39 f1       	breq	.+78     	; 0x3c4c <gfx_mono_generic_draw_horizontal_line+0xa2>
    3bfe:	37 c0       	rjmp	.+110    	; 0x3c6e <gfx_mono_generic_draw_horizontal_line+0xc4>
    3c00:	c4 2f       	mov	r28, r20
    3c02:	1f ef       	ldi	r17, 0xFF	; 255
    3c04:	18 0f       	add	r17, r24
    3c06:	01 2f       	mov	r16, r17
    3c08:	0c 0f       	add	r16, r28
    3c0a:	60 2f       	mov	r22, r16
    3c0c:	8d 2f       	mov	r24, r29
    3c0e:	0e 94 8c 05 	call	0xb18	; 0xb18 <gfx_mono_st7565r_get_byte>
    3c12:	4f 2d       	mov	r20, r15
    3c14:	48 2b       	or	r20, r24
    3c16:	60 2f       	mov	r22, r16
    3c18:	8d 2f       	mov	r24, r29
    3c1a:	0e 94 60 04 	call	0x8c0	; 0x8c0 <gfx_mono_st7565r_put_byte>
    3c1e:	c1 50       	subi	r28, 0x01	; 1
    3c20:	91 f7       	brne	.-28     	; 0x3c06 <gfx_mono_generic_draw_horizontal_line+0x5c>
    3c22:	25 c0       	rjmp	.+74     	; 0x3c6e <gfx_mono_generic_draw_horizontal_line+0xc4>
    3c24:	c4 2f       	mov	r28, r20
    3c26:	1f ef       	ldi	r17, 0xFF	; 255
    3c28:	18 0f       	add	r17, r24
    3c2a:	fa 2e       	mov	r15, r26
    3c2c:	f0 94       	com	r15
    3c2e:	01 2f       	mov	r16, r17
    3c30:	0c 0f       	add	r16, r28
    3c32:	60 2f       	mov	r22, r16
    3c34:	8d 2f       	mov	r24, r29
    3c36:	0e 94 8c 05 	call	0xb18	; 0xb18 <gfx_mono_st7565r_get_byte>
    3c3a:	4f 2d       	mov	r20, r15
    3c3c:	48 23       	and	r20, r24
    3c3e:	60 2f       	mov	r22, r16
    3c40:	8d 2f       	mov	r24, r29
    3c42:	0e 94 60 04 	call	0x8c0	; 0x8c0 <gfx_mono_st7565r_put_byte>
    3c46:	c1 50       	subi	r28, 0x01	; 1
    3c48:	91 f7       	brne	.-28     	; 0x3c2e <gfx_mono_generic_draw_horizontal_line+0x84>
    3c4a:	11 c0       	rjmp	.+34     	; 0x3c6e <gfx_mono_generic_draw_horizontal_line+0xc4>
    3c4c:	c4 2f       	mov	r28, r20
    3c4e:	1f ef       	ldi	r17, 0xFF	; 255
    3c50:	18 0f       	add	r17, r24
    3c52:	01 2f       	mov	r16, r17
    3c54:	0c 0f       	add	r16, r28
    3c56:	60 2f       	mov	r22, r16
    3c58:	8d 2f       	mov	r24, r29
    3c5a:	0e 94 8c 05 	call	0xb18	; 0xb18 <gfx_mono_st7565r_get_byte>
    3c5e:	4f 2d       	mov	r20, r15
    3c60:	48 27       	eor	r20, r24
    3c62:	60 2f       	mov	r22, r16
    3c64:	8d 2f       	mov	r24, r29
    3c66:	0e 94 60 04 	call	0x8c0	; 0x8c0 <gfx_mono_st7565r_put_byte>
    3c6a:	c1 50       	subi	r28, 0x01	; 1
    3c6c:	91 f7       	brne	.-28     	; 0x3c52 <gfx_mono_generic_draw_horizontal_line+0xa8>
    3c6e:	df 91       	pop	r29
    3c70:	cf 91       	pop	r28
    3c72:	1f 91       	pop	r17
    3c74:	0f 91       	pop	r16
    3c76:	ff 90       	pop	r15
    3c78:	08 95       	ret

00003c7a <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
    3c7a:	ff 92       	push	r15
    3c7c:	0f 93       	push	r16
    3c7e:	1f 93       	push	r17
    3c80:	cf 93       	push	r28
    3c82:	df 93       	push	r29
	if (height == 0) {
    3c84:	22 23       	and	r18, r18
    3c86:	69 f0       	breq	.+26     	; 0x3ca2 <gfx_mono_generic_draw_filled_rect+0x28>
    3c88:	f4 2e       	mov	r15, r20
    3c8a:	18 2f       	mov	r17, r24
    3c8c:	c2 2f       	mov	r28, r18
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
    3c8e:	df ef       	ldi	r29, 0xFF	; 255
    3c90:	d6 0f       	add	r29, r22
    3c92:	6d 2f       	mov	r22, r29
    3c94:	6c 0f       	add	r22, r28
    3c96:	20 2f       	mov	r18, r16
    3c98:	4f 2d       	mov	r20, r15
    3c9a:	81 2f       	mov	r24, r17
    3c9c:	86 df       	rcall	.-244    	; 0x3baa <gfx_mono_generic_draw_horizontal_line>
    3c9e:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
    3ca0:	c1 f7       	brne	.-16     	; 0x3c92 <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
    3ca2:	df 91       	pop	r29
    3ca4:	cf 91       	pop	r28
    3ca6:	1f 91       	pop	r17
    3ca8:	0f 91       	pop	r16
    3caa:	ff 90       	pop	r15
    3cac:	08 95       	ret

00003cae <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
    3cae:	8f ef       	ldi	r24, 0xFF	; 255
    3cb0:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x700070>
    3cb4:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
    3cb8:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
    3cbc:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x700073>
    3cc0:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x700074>
    3cc4:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <__TEXT_REGION_LENGTH__+0x700075>
    3cc8:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <__TEXT_REGION_LENGTH__+0x700076>
    3ccc:	08 95       	ret

00003cce <sysclk_enable_module>:
	sysclk_rtcsrc_enable(CONFIG_RTC_SOURCE);
#endif
}

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
    3cce:	cf 93       	push	r28
    3cd0:	df 93       	push	r29
    3cd2:	1f 92       	push	r1
    3cd4:	cd b7       	in	r28, 0x3d	; 61
    3cd6:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    3cd8:	9f b7       	in	r25, 0x3f	; 63
    3cda:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
    3cdc:	f8 94       	cli
	return flags;
    3cde:	99 81       	ldd	r25, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
    3ce0:	e8 2f       	mov	r30, r24
    3ce2:	f0 e0       	ldi	r31, 0x00	; 0
    3ce4:	e0 59       	subi	r30, 0x90	; 144
    3ce6:	ff 4f       	sbci	r31, 0xFF	; 255
    3ce8:	60 95       	com	r22
    3cea:	80 81       	ld	r24, Z
    3cec:	68 23       	and	r22, r24
    3cee:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    3cf0:	9f bf       	out	0x3f, r25	; 63

	cpu_irq_restore(flags);
}
    3cf2:	0f 90       	pop	r0
    3cf4:	df 91       	pop	r29
    3cf6:	cf 91       	pop	r28
    3cf8:	08 95       	ret

00003cfa <sysclk_disable_module>:

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
    3cfa:	cf 93       	push	r28
    3cfc:	df 93       	push	r29
    3cfe:	1f 92       	push	r1
    3d00:	cd b7       	in	r28, 0x3d	; 61
    3d02:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    3d04:	9f b7       	in	r25, 0x3f	; 63
    3d06:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
    3d08:	f8 94       	cli
	return flags;
    3d0a:	99 81       	ldd	r25, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
    3d0c:	e8 2f       	mov	r30, r24
    3d0e:	f0 e0       	ldi	r31, 0x00	; 0
    3d10:	e0 59       	subi	r30, 0x90	; 144
    3d12:	ff 4f       	sbci	r31, 0xFF	; 255
    3d14:	80 81       	ld	r24, Z
    3d16:	68 2b       	or	r22, r24
    3d18:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    3d1a:	9f bf       	out	0x3f, r25	; 63

	cpu_irq_restore(flags);
}
    3d1c:	0f 90       	pop	r0
    3d1e:	df 91       	pop	r29
    3d20:	cf 91       	pop	r28
    3d22:	08 95       	ret

00003d24 <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    3d24:	40 91 ca 01 	lds	r20, 0x01CA	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	mov ZL, r22               ; Load byte index into low byte of Z.
    3d28:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    3d2a:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    3d2c:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm r24, Z                ; Perform an LPM to read out byte
    3d30:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    3d32:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    3d36:	08 95       	ret

00003d38 <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
    3d38:	af 92       	push	r10
    3d3a:	bf 92       	push	r11
    3d3c:	cf 92       	push	r12
    3d3e:	df 92       	push	r13
    3d40:	ef 92       	push	r14
    3d42:	ff 92       	push	r15
    3d44:	0f 93       	push	r16
    3d46:	1f 93       	push	r17
    3d48:	cf 93       	push	r28
    3d4a:	df 93       	push	r29
    3d4c:	c8 2f       	mov	r28, r24
    3d4e:	e6 2e       	mov	r14, r22
    3d50:	b4 2e       	mov	r11, r20
    3d52:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
    3d54:	00 e0       	ldi	r16, 0x00	; 0
    3d56:	f9 01       	movw	r30, r18
    3d58:	24 81       	ldd	r18, Z+4	; 0x04
    3d5a:	43 81       	ldd	r20, Z+3	; 0x03
    3d5c:	6b 2d       	mov	r22, r11
    3d5e:	8e 2d       	mov	r24, r14
    3d60:	8c df       	rcall	.-232    	; 0x3c7a <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
    3d62:	f6 01       	movw	r30, r12
    3d64:	80 81       	ld	r24, Z
    3d66:	81 11       	cpse	r24, r1
    3d68:	3a c0       	rjmp	.+116    	; 0x3dde <gfx_mono_draw_char+0xa6>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
    3d6a:	83 81       	ldd	r24, Z+3	; 0x03
    3d6c:	28 2f       	mov	r18, r24
    3d6e:	26 95       	lsr	r18
    3d70:	26 95       	lsr	r18
    3d72:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
    3d74:	87 70       	andi	r24, 0x07	; 7
    3d76:	09 f0       	breq	.+2      	; 0x3d7a <gfx_mono_draw_char+0x42>
		char_row_size++;
    3d78:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
    3d7a:	f6 01       	movw	r30, r12
    3d7c:	a4 80       	ldd	r10, Z+4	; 0x04
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
    3d7e:	8c 2f       	mov	r24, r28
    3d80:	90 e0       	ldi	r25, 0x00	; 0
    3d82:	35 81       	ldd	r19, Z+5	; 0x05
    3d84:	83 1b       	sub	r24, r19
    3d86:	91 09       	sbc	r25, r1
    3d88:	2a 9d       	mul	r18, r10
    3d8a:	90 01       	movw	r18, r0
    3d8c:	11 24       	eor	r1, r1
    3d8e:	82 9f       	mul	r24, r18
    3d90:	a0 01       	movw	r20, r0
    3d92:	83 9f       	mul	r24, r19
    3d94:	50 0d       	add	r21, r0
    3d96:	92 9f       	mul	r25, r18
    3d98:	50 0d       	add	r21, r0
    3d9a:	11 24       	eor	r1, r1
    3d9c:	01 81       	ldd	r16, Z+1	; 0x01
    3d9e:	12 81       	ldd	r17, Z+2	; 0x02
    3da0:	04 0f       	add	r16, r20
    3da2:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
    3da4:	f6 01       	movw	r30, r12
    3da6:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
    3da8:	ff 20       	and	r15, r15
    3daa:	a9 f0       	breq	.+42     	; 0x3dd6 <gfx_mono_draw_char+0x9e>
    3dac:	d0 e0       	ldi	r29, 0x00	; 0
    3dae:	c0 e0       	ldi	r28, 0x00	; 0
    3db0:	8e 2d       	mov	r24, r14
    3db2:	8c 0f       	add	r24, r28
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
    3db4:	9c 2f       	mov	r25, r28
    3db6:	97 70       	andi	r25, 0x07	; 7
    3db8:	21 f4       	brne	.+8      	; 0x3dc2 <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
    3dba:	f8 01       	movw	r30, r16
    3dbc:	d4 91       	lpm	r29, Z
				glyph_data++;
    3dbe:	0f 5f       	subi	r16, 0xFF	; 255
    3dc0:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
    3dc2:	dd 23       	and	r29, r29
    3dc4:	24 f4       	brge	.+8      	; 0x3dce <gfx_mono_draw_char+0x96>
				gfx_mono_draw_pixel(inc_x, inc_y,
    3dc6:	41 e0       	ldi	r20, 0x01	; 1
    3dc8:	6b 2d       	mov	r22, r11
    3dca:	0e 94 55 05 	call	0xaaa	; 0xaaa <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
    3dce:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
    3dd0:	cf 5f       	subi	r28, 0xFF	; 255
    3dd2:	fc 12       	cpse	r15, r28
    3dd4:	ed cf       	rjmp	.-38     	; 0x3db0 <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
    3dd6:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
    3dd8:	aa 94       	dec	r10
	} while (rows_left > 0);
    3dda:	a1 10       	cpse	r10, r1
    3ddc:	e3 cf       	rjmp	.-58     	; 0x3da4 <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
    3dde:	df 91       	pop	r29
    3de0:	cf 91       	pop	r28
    3de2:	1f 91       	pop	r17
    3de4:	0f 91       	pop	r16
    3de6:	ff 90       	pop	r15
    3de8:	ef 90       	pop	r14
    3dea:	df 90       	pop	r13
    3dec:	cf 90       	pop	r12
    3dee:	bf 90       	pop	r11
    3df0:	af 90       	pop	r10
    3df2:	08 95       	ret

00003df4 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
    3df4:	df 92       	push	r13
    3df6:	ef 92       	push	r14
    3df8:	ff 92       	push	r15
    3dfa:	0f 93       	push	r16
    3dfc:	1f 93       	push	r17
    3dfe:	cf 93       	push	r28
    3e00:	df 93       	push	r29
    3e02:	d6 2e       	mov	r13, r22
    3e04:	04 2f       	mov	r16, r20
    3e06:	79 01       	movw	r14, r18
    3e08:	ec 01       	movw	r28, r24
    3e0a:	16 2f       	mov	r17, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
    3e0c:	89 91       	ld	r24, Y+
    3e0e:	8a 30       	cpi	r24, 0x0A	; 10
    3e10:	31 f4       	brne	.+12     	; 0x3e1e <gfx_mono_draw_string+0x2a>
			x = start_of_string_position_x;
			y += font->height + 1;
    3e12:	f7 01       	movw	r30, r14
    3e14:	84 81       	ldd	r24, Z+4	; 0x04
    3e16:	8f 5f       	subi	r24, 0xFF	; 255
    3e18:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
    3e1a:	1d 2d       	mov	r17, r13
    3e1c:	09 c0       	rjmp	.+18     	; 0x3e30 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
    3e1e:	8d 30       	cpi	r24, 0x0D	; 13
    3e20:	39 f0       	breq	.+14     	; 0x3e30 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
    3e22:	97 01       	movw	r18, r14
    3e24:	40 2f       	mov	r20, r16
    3e26:	61 2f       	mov	r22, r17
    3e28:	87 df       	rcall	.-242    	; 0x3d38 <gfx_mono_draw_char>
			x += font->width;
    3e2a:	f7 01       	movw	r30, r14
    3e2c:	83 81       	ldd	r24, Z+3	; 0x03
    3e2e:	18 0f       	add	r17, r24
		}
	} while (*(++str));
    3e30:	88 81       	ld	r24, Y
    3e32:	81 11       	cpse	r24, r1
    3e34:	eb cf       	rjmp	.-42     	; 0x3e0c <gfx_mono_draw_string+0x18>
}
    3e36:	df 91       	pop	r29
    3e38:	cf 91       	pop	r28
    3e3a:	1f 91       	pop	r17
    3e3c:	0f 91       	pop	r16
    3e3e:	ff 90       	pop	r15
    3e40:	ef 90       	pop	r14
    3e42:	df 90       	pop	r13
    3e44:	08 95       	ret

00003e46 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    3e46:	cf 93       	push	r28
    3e48:	df 93       	push	r29
    3e4a:	fc 01       	movw	r30, r24
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3e4c:	20 e0       	ldi	r18, 0x00	; 0
    3e4e:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    3e50:	c6 2f       	mov	r28, r22
    3e52:	d0 e0       	ldi	r29, 0x00	; 0
    3e54:	de 01       	movw	r26, r28
    3e56:	02 2e       	mov	r0, r18
    3e58:	02 c0       	rjmp	.+4      	; 0x3e5e <ioport_configure_port_pin+0x18>
    3e5a:	b5 95       	asr	r27
    3e5c:	a7 95       	ror	r26
    3e5e:	0a 94       	dec	r0
    3e60:	e2 f7       	brpl	.-8      	; 0x3e5a <ioport_configure_port_pin+0x14>
    3e62:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3e64:	50 8b       	std	Z+16, r21	; 0x10
    3e66:	2f 5f       	subi	r18, 0xFF	; 255
    3e68:	3f 4f       	sbci	r19, 0xFF	; 255
    3e6a:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    3e6c:	28 30       	cpi	r18, 0x08	; 8
    3e6e:	31 05       	cpc	r19, r1
    3e70:	89 f7       	brne	.-30     	; 0x3e54 <ioport_configure_port_pin+0xe>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    3e72:	40 ff       	sbrs	r20, 0
    3e74:	0a c0       	rjmp	.+20     	; 0x3e8a <ioport_configure_port_pin+0x44>
		if (flags & IOPORT_INIT_HIGH) {
    3e76:	41 ff       	sbrs	r20, 1
    3e78:	03 c0       	rjmp	.+6      	; 0x3e80 <ioport_configure_port_pin+0x3a>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    3e7a:	fc 01       	movw	r30, r24
    3e7c:	65 83       	std	Z+5, r22	; 0x05
    3e7e:	02 c0       	rjmp	.+4      	; 0x3e84 <ioport_configure_port_pin+0x3e>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    3e80:	fc 01       	movw	r30, r24
    3e82:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    3e84:	fc 01       	movw	r30, r24
    3e86:	61 83       	std	Z+1, r22	; 0x01
    3e88:	02 c0       	rjmp	.+4      	; 0x3e8e <ioport_configure_port_pin+0x48>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    3e8a:	fc 01       	movw	r30, r24
    3e8c:	62 83       	std	Z+2, r22	; 0x02
	}
}
    3e8e:	df 91       	pop	r29
    3e90:	cf 91       	pop	r28
    3e92:	08 95       	ret

00003e94 <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    3e94:	43 e0       	ldi	r20, 0x03	; 3
    3e96:	50 e0       	ldi	r21, 0x00	; 0
    3e98:	61 e0       	ldi	r22, 0x01	; 1
    3e9a:	80 ee       	ldi	r24, 0xE0	; 224
    3e9c:	97 e0       	ldi	r25, 0x07	; 7
    3e9e:	d3 df       	rcall	.-90     	; 0x3e46 <ioport_configure_port_pin>
    3ea0:	43 e0       	ldi	r20, 0x03	; 3
    3ea2:	50 e0       	ldi	r21, 0x00	; 0
    3ea4:	62 e0       	ldi	r22, 0x02	; 2
    3ea6:	80 ee       	ldi	r24, 0xE0	; 224
    3ea8:	97 e0       	ldi	r25, 0x07	; 7
    3eaa:	cd df       	rcall	.-102    	; 0x3e46 <ioport_configure_port_pin>
    3eac:	43 e0       	ldi	r20, 0x03	; 3
    3eae:	50 e0       	ldi	r21, 0x00	; 0
    3eb0:	60 e1       	ldi	r22, 0x10	; 16
    3eb2:	80 e6       	ldi	r24, 0x60	; 96
    3eb4:	96 e0       	ldi	r25, 0x06	; 6
    3eb6:	c7 df       	rcall	.-114    	; 0x3e46 <ioport_configure_port_pin>
    3eb8:	41 e0       	ldi	r20, 0x01	; 1
    3eba:	50 e4       	ldi	r21, 0x40	; 64
    3ebc:	60 e2       	ldi	r22, 0x20	; 32
    3ebe:	80 e6       	ldi	r24, 0x60	; 96
    3ec0:	96 e0       	ldi	r25, 0x06	; 6
    3ec2:	c1 df       	rcall	.-126    	; 0x3e46 <ioport_configure_port_pin>
    3ec4:	40 e0       	ldi	r20, 0x00	; 0
    3ec6:	5b e1       	ldi	r21, 0x1B	; 27
    3ec8:	60 e2       	ldi	r22, 0x20	; 32
    3eca:	80 e8       	ldi	r24, 0x80	; 128
    3ecc:	96 e0       	ldi	r25, 0x06	; 6
    3ece:	bb df       	rcall	.-138    	; 0x3e46 <ioport_configure_port_pin>
    3ed0:	40 e0       	ldi	r20, 0x00	; 0
    3ed2:	5b e1       	ldi	r21, 0x1B	; 27
    3ed4:	62 e0       	ldi	r22, 0x02	; 2
    3ed6:	80 ea       	ldi	r24, 0xA0	; 160
    3ed8:	96 e0       	ldi	r25, 0x06	; 6
    3eda:	b5 df       	rcall	.-150    	; 0x3e46 <ioport_configure_port_pin>
    3edc:	40 e0       	ldi	r20, 0x00	; 0
    3ede:	5b e1       	ldi	r21, 0x1B	; 27
    3ee0:	64 e0       	ldi	r22, 0x04	; 4
    3ee2:	80 ea       	ldi	r24, 0xA0	; 160
    3ee4:	96 e0       	ldi	r25, 0x06	; 6
    3ee6:	af df       	rcall	.-162    	; 0x3e46 <ioport_configure_port_pin>
    3ee8:	43 e0       	ldi	r20, 0x03	; 3
    3eea:	50 e0       	ldi	r21, 0x00	; 0
    3eec:	62 e0       	ldi	r22, 0x02	; 2
    3eee:	80 e6       	ldi	r24, 0x60	; 96
    3ef0:	96 e0       	ldi	r25, 0x06	; 6
    3ef2:	a9 df       	rcall	.-174    	; 0x3e46 <ioport_configure_port_pin>
    3ef4:	43 e0       	ldi	r20, 0x03	; 3
    3ef6:	50 e0       	ldi	r21, 0x00	; 0
    3ef8:	68 e0       	ldi	r22, 0x08	; 8
    3efa:	80 e6       	ldi	r24, 0x60	; 96
    3efc:	96 e0       	ldi	r25, 0x06	; 6
    3efe:	a3 df       	rcall	.-186    	; 0x3e46 <ioport_configure_port_pin>
    3f00:	43 e0       	ldi	r20, 0x03	; 3
    3f02:	50 e0       	ldi	r21, 0x00	; 0
    3f04:	68 e0       	ldi	r22, 0x08	; 8
    3f06:	80 ea       	ldi	r24, 0xA0	; 160
    3f08:	96 e0       	ldi	r25, 0x06	; 6
    3f0a:	9d df       	rcall	.-198    	; 0x3e46 <ioport_configure_port_pin>
    3f0c:	43 e0       	ldi	r20, 0x03	; 3
    3f0e:	50 e0       	ldi	r21, 0x00	; 0
    3f10:	61 e0       	ldi	r22, 0x01	; 1
    3f12:	80 e6       	ldi	r24, 0x60	; 96
    3f14:	96 e0       	ldi	r25, 0x06	; 6
    3f16:	97 df       	rcall	.-210    	; 0x3e46 <ioport_configure_port_pin>
    3f18:	43 e0       	ldi	r20, 0x03	; 3
    3f1a:	50 e0       	ldi	r21, 0x00	; 0
    3f1c:	68 e0       	ldi	r22, 0x08	; 8
    3f1e:	80 e0       	ldi	r24, 0x00	; 0
    3f20:	96 e0       	ldi	r25, 0x06	; 6
    3f22:	91 df       	rcall	.-222    	; 0x3e46 <ioport_configure_port_pin>
    3f24:	41 e0       	ldi	r20, 0x01	; 1
    3f26:	50 e0       	ldi	r21, 0x00	; 0
    3f28:	60 e1       	ldi	r22, 0x10	; 16
    3f2a:	80 e8       	ldi	r24, 0x80	; 128
    3f2c:	96 e0       	ldi	r25, 0x06	; 6
    3f2e:	8b df       	rcall	.-234    	; 0x3e46 <ioport_configure_port_pin>
    3f30:	43 e0       	ldi	r20, 0x03	; 3
    3f32:	50 e0       	ldi	r21, 0x00	; 0
    3f34:	62 e0       	ldi	r22, 0x02	; 2
    3f36:	80 e6       	ldi	r24, 0x60	; 96
    3f38:	96 e0       	ldi	r25, 0x06	; 6
    3f3a:	85 df       	rcall	.-246    	; 0x3e46 <ioport_configure_port_pin>
    3f3c:	43 e0       	ldi	r20, 0x03	; 3
    3f3e:	50 e0       	ldi	r21, 0x00	; 0
    3f40:	68 e0       	ldi	r22, 0x08	; 8
    3f42:	80 e6       	ldi	r24, 0x60	; 96
    3f44:	96 e0       	ldi	r25, 0x06	; 6
    3f46:	7f df       	rcall	.-258    	; 0x3e46 <ioport_configure_port_pin>
    3f48:	40 e0       	ldi	r20, 0x00	; 0
    3f4a:	50 e0       	ldi	r21, 0x00	; 0
    3f4c:	64 e0       	ldi	r22, 0x04	; 4
    3f4e:	80 e6       	ldi	r24, 0x60	; 96
    3f50:	96 e0       	ldi	r25, 0x06	; 6
    3f52:	79 df       	rcall	.-270    	; 0x3e46 <ioport_configure_port_pin>
    3f54:	43 e0       	ldi	r20, 0x03	; 3
    3f56:	50 e0       	ldi	r21, 0x00	; 0
    3f58:	60 e1       	ldi	r22, 0x10	; 16
    3f5a:	80 ea       	ldi	r24, 0xA0	; 160
    3f5c:	96 e0       	ldi	r25, 0x06	; 6
    3f5e:	73 df       	rcall	.-282    	; 0x3e46 <ioport_configure_port_pin>
    3f60:	40 e0       	ldi	r20, 0x00	; 0
    3f62:	50 e0       	ldi	r21, 0x00	; 0
    3f64:	61 e0       	ldi	r22, 0x01	; 1
    3f66:	80 e0       	ldi	r24, 0x00	; 0
    3f68:	96 e0       	ldi	r25, 0x06	; 6
    3f6a:	6d df       	rcall	.-294    	; 0x3e46 <ioport_configure_port_pin>
    3f6c:	40 e0       	ldi	r20, 0x00	; 0
    3f6e:	50 e0       	ldi	r21, 0x00	; 0
    3f70:	64 e0       	ldi	r22, 0x04	; 4
    3f72:	80 e0       	ldi	r24, 0x00	; 0
    3f74:	96 e0       	ldi	r25, 0x06	; 6
    3f76:	67 df       	rcall	.-306    	; 0x3e46 <ioport_configure_port_pin>
    3f78:	40 e0       	ldi	r20, 0x00	; 0
    3f7a:	50 e0       	ldi	r21, 0x00	; 0
    3f7c:	62 e0       	ldi	r22, 0x02	; 2
    3f7e:	80 e2       	ldi	r24, 0x20	; 32
    3f80:	96 e0       	ldi	r25, 0x06	; 6
    3f82:	61 df       	rcall	.-318    	; 0x3e46 <ioport_configure_port_pin>
    3f84:	43 e0       	ldi	r20, 0x03	; 3
    3f86:	50 e0       	ldi	r21, 0x00	; 0
    3f88:	68 e0       	ldi	r22, 0x08	; 8
    3f8a:	80 e4       	ldi	r24, 0x40	; 64
    3f8c:	96 e0       	ldi	r25, 0x06	; 6
    3f8e:	5b df       	rcall	.-330    	; 0x3e46 <ioport_configure_port_pin>
    3f90:	40 e0       	ldi	r20, 0x00	; 0
    3f92:	50 e0       	ldi	r21, 0x00	; 0
    3f94:	64 e0       	ldi	r22, 0x04	; 4
    3f96:	80 e4       	ldi	r24, 0x40	; 64
    3f98:	96 e0       	ldi	r25, 0x06	; 6
    3f9a:	55 df       	rcall	.-342    	; 0x3e46 <ioport_configure_port_pin>
    3f9c:	43 e0       	ldi	r20, 0x03	; 3
    3f9e:	50 e0       	ldi	r21, 0x00	; 0
    3fa0:	68 e0       	ldi	r22, 0x08	; 8
    3fa2:	80 e6       	ldi	r24, 0x60	; 96
    3fa4:	96 e0       	ldi	r25, 0x06	; 6
    3fa6:	4f df       	rcall	.-354    	; 0x3e46 <ioport_configure_port_pin>
    3fa8:	40 e0       	ldi	r20, 0x00	; 0
    3faa:	50 e0       	ldi	r21, 0x00	; 0
    3fac:	64 e0       	ldi	r22, 0x04	; 4
    3fae:	80 e6       	ldi	r24, 0x60	; 96
    3fb0:	96 e0       	ldi	r25, 0x06	; 6
    3fb2:	49 df       	rcall	.-366    	; 0x3e46 <ioport_configure_port_pin>
    3fb4:	43 e0       	ldi	r20, 0x03	; 3
    3fb6:	50 e0       	ldi	r21, 0x00	; 0
    3fb8:	68 e0       	ldi	r22, 0x08	; 8
    3fba:	80 e8       	ldi	r24, 0x80	; 128
    3fbc:	96 e0       	ldi	r25, 0x06	; 6
    3fbe:	43 df       	rcall	.-378    	; 0x3e46 <ioport_configure_port_pin>
    3fc0:	40 e0       	ldi	r20, 0x00	; 0
    3fc2:	50 e0       	ldi	r21, 0x00	; 0
    3fc4:	64 e0       	ldi	r22, 0x04	; 4
    3fc6:	80 e8       	ldi	r24, 0x80	; 128
    3fc8:	96 e0       	ldi	r25, 0x06	; 6
    3fca:	3d cf       	rjmp	.-390    	; 0x3e46 <ioport_configure_port_pin>
    3fcc:	08 95       	ret

00003fce <__portable_avr_delay_cycles>:


/* Functions for Photosensitive Sensor*/
// Setup PB3 as input
void setup_photosensitive_sensor(void) {
	PORTB.DIRCLR = PIN3_bm; // Set PB0 (connected to D0 pin of the sensor) as input
    3fce:	04 c0       	rjmp	.+8      	; 0x3fd8 <__portable_avr_delay_cycles+0xa>
    3fd0:	61 50       	subi	r22, 0x01	; 1
    3fd2:	71 09       	sbc	r23, r1
    3fd4:	81 09       	sbc	r24, r1
    3fd6:	91 09       	sbc	r25, r1
    3fd8:	61 15       	cp	r22, r1
    3fda:	71 05       	cpc	r23, r1
    3fdc:	81 05       	cpc	r24, r1
    3fde:	91 05       	cpc	r25, r1
    3fe0:	b9 f7       	brne	.-18     	; 0x3fd0 <__portable_avr_delay_cycles+0x2>
    3fe2:	08 95       	ret

00003fe4 <increment_distance>:
    3fe4:	80 91 e7 23 	lds	r24, 0x23E7	; 0x8023e7 <incremental>
    3fe8:	90 91 e8 23 	lds	r25, 0x23E8	; 0x8023e8 <incremental+0x1>
    3fec:	01 96       	adiw	r24, 0x01	; 1
    3fee:	80 93 e7 23 	sts	0x23E7, r24	; 0x8023e7 <incremental>
    3ff2:	90 93 e8 23 	sts	0x23E8, r25	; 0x8023e8 <incremental+0x1>
    3ff6:	08 95       	ret

00003ff8 <vReceiveUART>:
    3ff8:	cf 93       	push	r28
    3ffa:	df 93       	push	r29
    3ffc:	cd b7       	in	r28, 0x3d	; 61
    3ffe:	de b7       	in	r29, 0x3e	; 62
    4000:	c0 58       	subi	r28, 0x80	; 128
    4002:	d1 09       	sbc	r29, r1
    4004:	cd bf       	out	0x3d, r28	; 61
    4006:	de bf       	out	0x3e, r29	; 62
    4008:	ce 01       	movw	r24, r28
    400a:	01 96       	adiw	r24, 0x01	; 1
    400c:	7c 01       	movw	r14, r24
    400e:	0f 2e       	mov	r0, r31
    4010:	f3 e2       	ldi	r31, 0x23	; 35
    4012:	cf 2e       	mov	r12, r31
    4014:	f0 e2       	ldi	r31, 0x20	; 32
    4016:	df 2e       	mov	r13, r31
    4018:	f0 2d       	mov	r31, r0
    401a:	68 94       	set
    401c:	33 24       	eor	r3, r3
    401e:	37 f8       	bld	r3, 7
    4020:	0f 2e       	mov	r0, r31
    4022:	ff e0       	ldi	r31, 0x0F	; 15
    4024:	8f 2e       	mov	r8, r31
    4026:	f0 e2       	ldi	r31, 0x20	; 32
    4028:	9f 2e       	mov	r9, r31
    402a:	f0 2d       	mov	r31, r0
    402c:	0f 2e       	mov	r0, r31
    402e:	f0 e3       	ldi	r31, 0x30	; 48
    4030:	af 2e       	mov	r10, r31
    4032:	f0 e2       	ldi	r31, 0x20	; 32
    4034:	bf 2e       	mov	r11, r31
    4036:	f0 2d       	mov	r31, r0
    4038:	0f 2e       	mov	r0, r31
    403a:	fd e0       	ldi	r31, 0x0D	; 13
    403c:	6f 2e       	mov	r6, r31
    403e:	f0 e2       	ldi	r31, 0x20	; 32
    4040:	7f 2e       	mov	r7, r31
    4042:	f0 2d       	mov	r31, r0
    4044:	0f 2e       	mov	r0, r31
    4046:	fe e1       	ldi	r31, 0x1E	; 30
    4048:	4f 2e       	mov	r4, r31
    404a:	f0 e2       	ldi	r31, 0x20	; 32
    404c:	5f 2e       	mov	r5, r31
    404e:	f0 2d       	mov	r31, r0
    4050:	6a e0       	ldi	r22, 0x0A	; 10
    4052:	70 e0       	ldi	r23, 0x00	; 0
    4054:	80 91 c1 24 	lds	r24, 0x24C1	; 0x8024c1 <xSemaphore>
    4058:	90 91 c2 24 	lds	r25, 0x24C2	; 0x8024c2 <xSemaphore+0x1>
    405c:	0e 94 8a 16 	call	0x2d14	; 0x2d14 <xQueueSemaphoreTake>
    4060:	81 30       	cpi	r24, 0x01	; 1
    4062:	09 f0       	breq	.+2      	; 0x4066 <vReceiveUART+0x6e>
    4064:	57 c0       	rjmp	.+174    	; 0x4114 <vReceiveUART+0x11c>
    4066:	0f ee       	ldi	r16, 0xEF	; 239
    4068:	13 e2       	ldi	r17, 0x23	; 35
    406a:	80 ea       	ldi	r24, 0xA0	; 160
    406c:	98 e0       	ldi	r25, 0x08	; 8
    406e:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <usart_getchar>
    4072:	8f 3f       	cpi	r24, 0xFF	; 255
    4074:	09 f4       	brne	.+2      	; 0x4078 <vReceiveUART+0x80>
    4076:	5b c0       	rjmp	.+182    	; 0x412e <vReceiveUART+0x136>
    4078:	8a 30       	cpi	r24, 0x0A	; 10
    407a:	09 f4       	brne	.+2      	; 0x407e <vReceiveUART+0x86>
    407c:	4f c0       	rjmp	.+158    	; 0x411c <vReceiveUART+0x124>
    407e:	f8 01       	movw	r30, r16
    4080:	81 93       	st	Z+, r24
    4082:	8f 01       	movw	r16, r30
    4084:	f2 cf       	rjmp	.-28     	; 0x406a <vReceiveUART+0x72>
    4086:	7f 92       	push	r7
    4088:	6f 92       	push	r6
    408a:	5f 92       	push	r5
    408c:	4f 92       	push	r4
    408e:	9f 93       	push	r25
    4090:	8f 93       	push	r24
    4092:	3a d5       	rcall	.+2676   	; 0x4b08 <sscanf>
    4094:	0f 90       	pop	r0
    4096:	0f 90       	pop	r0
    4098:	0f 90       	pop	r0
    409a:	0f 90       	pop	r0
    409c:	0f 90       	pop	r0
    409e:	0f 90       	pop	r0
    40a0:	6c e4       	ldi	r22, 0x4C	; 76
    40a2:	70 e0       	ldi	r23, 0x00	; 0
    40a4:	8f ee       	ldi	r24, 0xEF	; 239
    40a6:	93 e2       	ldi	r25, 0x23	; 35
    40a8:	ee d4       	rcall	.+2524   	; 0x4a86 <strchr>
    40aa:	00 97       	sbiw	r24, 0x00	; 0
    40ac:	69 f0       	breq	.+26     	; 0x40c8 <vReceiveUART+0xd0>
    40ae:	9f 92       	push	r9
    40b0:	8f 92       	push	r8
    40b2:	bf 92       	push	r11
    40b4:	af 92       	push	r10
    40b6:	9f 93       	push	r25
    40b8:	8f 93       	push	r24
    40ba:	26 d5       	rcall	.+2636   	; 0x4b08 <sscanf>
    40bc:	0f 90       	pop	r0
    40be:	0f 90       	pop	r0
    40c0:	0f 90       	pop	r0
    40c2:	0f 90       	pop	r0
    40c4:	0f 90       	pop	r0
    40c6:	0f 90       	pop	r0
    40c8:	80 91 10 20 	lds	r24, 0x2010	; 0x802010 <lightUART+0x1>
    40cc:	8f 93       	push	r24
    40ce:	80 91 0f 20 	lds	r24, 0x200F	; 0x80200f <lightUART>
    40d2:	8f 93       	push	r24
    40d4:	80 91 0e 20 	lds	r24, 0x200E	; 0x80200e <pumpUART+0x1>
    40d8:	8f 93       	push	r24
    40da:	80 91 0d 20 	lds	r24, 0x200D	; 0x80200d <pumpUART>
    40de:	8f 93       	push	r24
    40e0:	df 92       	push	r13
    40e2:	cf 92       	push	r12
    40e4:	1f 92       	push	r1
    40e6:	3f 92       	push	r3
    40e8:	ff 92       	push	r15
    40ea:	ef 92       	push	r14
    40ec:	d7 d4       	rcall	.+2478   	; 0x4a9c <snprintf>
    40ee:	26 e0       	ldi	r18, 0x06	; 6
    40f0:	30 e2       	ldi	r19, 0x20	; 32
    40f2:	40 e1       	ldi	r20, 0x10	; 16
    40f4:	60 e0       	ldi	r22, 0x00	; 0
    40f6:	c7 01       	movw	r24, r14
    40f8:	7d de       	rcall	.-774    	; 0x3df4 <gfx_mono_draw_string>
    40fa:	cd bf       	out	0x3d, r28	; 61
    40fc:	de bf       	out	0x3e, r29	; 62
    40fe:	20 e0       	ldi	r18, 0x00	; 0
    4100:	40 e0       	ldi	r20, 0x00	; 0
    4102:	50 e0       	ldi	r21, 0x00	; 0
    4104:	60 e0       	ldi	r22, 0x00	; 0
    4106:	70 e0       	ldi	r23, 0x00	; 0
    4108:	80 91 c1 24 	lds	r24, 0x24C1	; 0x8024c1 <xSemaphore>
    410c:	90 91 c2 24 	lds	r25, 0x24C2	; 0x8024c2 <xSemaphore+0x1>
    4110:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <xQueueGenericSend>
    4114:	82 e3       	ldi	r24, 0x32	; 50
    4116:	90 e0       	ldi	r25, 0x00	; 0
    4118:	67 d9       	rcall	.-3378   	; 0x33e8 <vTaskDelay>
    411a:	9a cf       	rjmp	.-204    	; 0x4050 <vReceiveUART+0x58>
    411c:	60 e5       	ldi	r22, 0x50	; 80
    411e:	70 e0       	ldi	r23, 0x00	; 0
    4120:	8f ee       	ldi	r24, 0xEF	; 239
    4122:	93 e2       	ldi	r25, 0x23	; 35
    4124:	b0 d4       	rcall	.+2400   	; 0x4a86 <strchr>
    4126:	00 97       	sbiw	r24, 0x00	; 0
    4128:	09 f0       	breq	.+2      	; 0x412c <vReceiveUART+0x134>
    412a:	ad cf       	rjmp	.-166    	; 0x4086 <vReceiveUART+0x8e>
    412c:	b9 cf       	rjmp	.-142    	; 0x40a0 <vReceiveUART+0xa8>
    412e:	84 e1       	ldi	r24, 0x14	; 20
    4130:	e7 e3       	ldi	r30, 0x37	; 55
    4132:	f0 e2       	ldi	r31, 0x20	; 32
    4134:	d7 01       	movw	r26, r14
    4136:	01 90       	ld	r0, Z+
    4138:	0d 92       	st	X+, r0
    413a:	8a 95       	dec	r24
    413c:	e1 f7       	brne	.-8      	; 0x4136 <vReceiveUART+0x13e>
    413e:	26 e0       	ldi	r18, 0x06	; 6
    4140:	30 e2       	ldi	r19, 0x20	; 32
    4142:	40 e1       	ldi	r20, 0x10	; 16
    4144:	60 e0       	ldi	r22, 0x00	; 0
    4146:	c7 01       	movw	r24, r14
    4148:	55 de       	rcall	.-854    	; 0x3df4 <gfx_mono_draw_string>
    414a:	d9 cf       	rjmp	.-78     	; 0x40fe <vReceiveUART+0x106>

0000414c <vPhotosensitiveSensor>:
    414c:	cf 93       	push	r28
    414e:	df 93       	push	r29
    4150:	cd b7       	in	r28, 0x3d	; 61
    4152:	de b7       	in	r29, 0x3e	; 62
    4154:	c0 58       	subi	r28, 0x80	; 128
    4156:	d1 09       	sbc	r29, r1
    4158:	cd bf       	out	0x3d, r28	; 61
    415a:	de bf       	out	0x3e, r29	; 62
    415c:	0f 2e       	mov	r0, r31
    415e:	f0 e4       	ldi	r31, 0x40	; 64
    4160:	ef 2e       	mov	r14, r31
    4162:	f6 e0       	ldi	r31, 0x06	; 6
    4164:	ff 2e       	mov	r15, r31
    4166:	f0 2d       	mov	r31, r0
    4168:	12 e0       	ldi	r17, 0x02	; 2
    416a:	0f 2e       	mov	r0, r31
    416c:	f0 e2       	ldi	r31, 0x20	; 32
    416e:	cf 2e       	mov	r12, r31
    4170:	f6 e0       	ldi	r31, 0x06	; 6
    4172:	df 2e       	mov	r13, r31
    4174:	f0 2d       	mov	r31, r0
    4176:	aa 24       	eor	r10, r10
    4178:	a3 94       	inc	r10
    417a:	b1 2c       	mov	r11, r1
    417c:	6a e0       	ldi	r22, 0x0A	; 10
    417e:	70 e0       	ldi	r23, 0x00	; 0
    4180:	80 91 c1 24 	lds	r24, 0x24C1	; 0x8024c1 <xSemaphore>
    4184:	90 91 c2 24 	lds	r25, 0x24C2	; 0x8024c2 <xSemaphore+0x1>
    4188:	0e 94 8a 16 	call	0x2d14	; 0x2d14 <xQueueSemaphoreTake>
    418c:	81 30       	cpi	r24, 0x01	; 1
    418e:	09 f0       	breq	.+2      	; 0x4192 <vPhotosensitiveSensor+0x46>
    4190:	45 c0       	rjmp	.+138    	; 0x421c <vPhotosensitiveSensor+0xd0>
    4192:	f7 01       	movw	r30, r14
    4194:	11 83       	std	Z+1, r17	; 0x01
    4196:	f6 01       	movw	r30, r12
    4198:	80 85       	ldd	r24, Z+8	; 0x08
    419a:	83 fd       	sbrc	r24, 3
    419c:	17 c0       	rjmp	.+46     	; 0x41cc <vPhotosensitiveSensor+0x80>
    419e:	82 e1       	ldi	r24, 0x12	; 18
    41a0:	eb e4       	ldi	r30, 0x4B	; 75
    41a2:	f0 e2       	ldi	r31, 0x20	; 32
    41a4:	de 01       	movw	r26, r28
    41a6:	11 96       	adiw	r26, 0x01	; 1
    41a8:	01 90       	ld	r0, Z+
    41aa:	0d 92       	st	X+, r0
    41ac:	8a 95       	dec	r24
    41ae:	e1 f7       	brne	.-8      	; 0x41a8 <vPhotosensitiveSensor+0x5c>
    41b0:	80 91 0f 20 	lds	r24, 0x200F	; 0x80200f <lightUART>
    41b4:	90 91 10 20 	lds	r25, 0x2010	; 0x802010 <lightUART+0x1>
    41b8:	01 97       	sbiw	r24, 0x01	; 1
    41ba:	f1 f4       	brne	.+60     	; 0x41f8 <vPhotosensitiveSensor+0xac>
    41bc:	a0 92 ed 23 	sts	0x23ED, r10	; 0x8023ed <lightResult>
    41c0:	b0 92 ee 23 	sts	0x23EE, r11	; 0x8023ee <lightResult+0x1>
    41c4:	f7 01       	movw	r30, r14
    41c6:	15 83       	std	Z+5, r17	; 0x05
    41c8:	16 83       	std	Z+6, r17	; 0x06
    41ca:	16 c0       	rjmp	.+44     	; 0x41f8 <vPhotosensitiveSensor+0xac>
    41cc:	82 e1       	ldi	r24, 0x12	; 18
    41ce:	ed e5       	ldi	r30, 0x5D	; 93
    41d0:	f0 e2       	ldi	r31, 0x20	; 32
    41d2:	de 01       	movw	r26, r28
    41d4:	11 96       	adiw	r26, 0x01	; 1
    41d6:	01 90       	ld	r0, Z+
    41d8:	0d 92       	st	X+, r0
    41da:	8a 95       	dec	r24
    41dc:	e1 f7       	brne	.-8      	; 0x41d6 <vPhotosensitiveSensor+0x8a>
    41de:	80 91 0f 20 	lds	r24, 0x200F	; 0x80200f <lightUART>
    41e2:	90 91 10 20 	lds	r25, 0x2010	; 0x802010 <lightUART+0x1>
    41e6:	01 97       	sbiw	r24, 0x01	; 1
    41e8:	39 f4       	brne	.+14     	; 0x41f8 <vPhotosensitiveSensor+0xac>
    41ea:	10 92 ed 23 	sts	0x23ED, r1	; 0x8023ed <lightResult>
    41ee:	10 92 ee 23 	sts	0x23EE, r1	; 0x8023ee <lightResult+0x1>
    41f2:	f7 01       	movw	r30, r14
    41f4:	16 83       	std	Z+6, r17	; 0x06
    41f6:	15 83       	std	Z+5, r17	; 0x05
    41f8:	26 e0       	ldi	r18, 0x06	; 6
    41fa:	30 e2       	ldi	r19, 0x20	; 32
    41fc:	48 e0       	ldi	r20, 0x08	; 8
    41fe:	60 e0       	ldi	r22, 0x00	; 0
    4200:	ce 01       	movw	r24, r28
    4202:	01 96       	adiw	r24, 0x01	; 1
    4204:	f7 dd       	rcall	.-1042   	; 0x3df4 <gfx_mono_draw_string>
    4206:	20 e0       	ldi	r18, 0x00	; 0
    4208:	40 e0       	ldi	r20, 0x00	; 0
    420a:	50 e0       	ldi	r21, 0x00	; 0
    420c:	60 e0       	ldi	r22, 0x00	; 0
    420e:	70 e0       	ldi	r23, 0x00	; 0
    4210:	80 91 c1 24 	lds	r24, 0x24C1	; 0x8024c1 <xSemaphore>
    4214:	90 91 c2 24 	lds	r25, 0x24C2	; 0x8024c2 <xSemaphore+0x1>
    4218:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <xQueueGenericSend>
    421c:	82 e3       	ldi	r24, 0x32	; 50
    421e:	90 e0       	ldi	r25, 0x00	; 0
    4220:	e3 d8       	rcall	.-3642   	; 0x33e8 <vTaskDelay>
    4222:	ac cf       	rjmp	.-168    	; 0x417c <vPhotosensitiveSensor+0x30>

00004224 <vSendUART>:
    4224:	cf 93       	push	r28
    4226:	df 93       	push	r29
    4228:	cd b7       	in	r28, 0x3d	; 61
    422a:	de b7       	in	r29, 0x3e	; 62
    422c:	e2 97       	sbiw	r28, 0x32	; 50
    422e:	cd bf       	out	0x3d, r28	; 61
    4230:	de bf       	out	0x3e, r29	; 62
    4232:	0f 2e       	mov	r0, r31
    4234:	ff e6       	ldi	r31, 0x6F	; 111
    4236:	cf 2e       	mov	r12, r31
    4238:	f0 e2       	ldi	r31, 0x20	; 32
    423a:	df 2e       	mov	r13, r31
    423c:	f0 2d       	mov	r31, r0
    423e:	0f 2e       	mov	r0, r31
    4240:	f2 e3       	ldi	r31, 0x32	; 50
    4242:	bf 2e       	mov	r11, r31
    4244:	f0 2d       	mov	r31, r0
    4246:	ce 01       	movw	r24, r28
    4248:	01 96       	adiw	r24, 0x01	; 1
    424a:	7c 01       	movw	r14, r24
    424c:	6a e0       	ldi	r22, 0x0A	; 10
    424e:	70 e0       	ldi	r23, 0x00	; 0
    4250:	80 91 c1 24 	lds	r24, 0x24C1	; 0x8024c1 <xSemaphore>
    4254:	90 91 c2 24 	lds	r25, 0x24C2	; 0x8024c2 <xSemaphore+0x1>
    4258:	0e 94 8a 16 	call	0x2d14	; 0x2d14 <xQueueSemaphoreTake>
    425c:	81 30       	cpi	r24, 0x01	; 1
    425e:	09 f0       	breq	.+2      	; 0x4262 <vSendUART+0x3e>
    4260:	48 c0       	rjmp	.+144    	; 0x42f2 <vSendUART+0xce>
    4262:	80 91 ed 23 	lds	r24, 0x23ED	; 0x8023ed <lightResult>
    4266:	90 91 ee 23 	lds	r25, 0x23EE	; 0x8023ee <lightResult+0x1>
    426a:	9f 93       	push	r25
    426c:	8f 93       	push	r24
    426e:	20 91 ea 23 	lds	r18, 0x23EA	; 0x8023ea <pumpStatus+0x1>
    4272:	2f 93       	push	r18
    4274:	20 91 e9 23 	lds	r18, 0x23E9	; 0x8023e9 <pumpStatus>
    4278:	2f 93       	push	r18
    427a:	9f 93       	push	r25
    427c:	8f 93       	push	r24
    427e:	80 91 ec 23 	lds	r24, 0x23EC	; 0x8023ec <soilMoistureResult+0x1>
    4282:	8f 93       	push	r24
    4284:	80 91 eb 23 	lds	r24, 0x23EB	; 0x8023eb <soilMoistureResult>
    4288:	8f 93       	push	r24
    428a:	80 91 e4 23 	lds	r24, 0x23E4	; 0x8023e4 <distancePercentage+0x1>
    428e:	8f 93       	push	r24
    4290:	80 91 e3 23 	lds	r24, 0x23E3	; 0x8023e3 <distancePercentage>
    4294:	8f 93       	push	r24
    4296:	df 92       	push	r13
    4298:	cf 92       	push	r12
    429a:	1f 92       	push	r1
    429c:	bf 92       	push	r11
    429e:	ff 92       	push	r15
    42a0:	ef 92       	push	r14
    42a2:	fc d3       	rcall	.+2040   	; 0x4a9c <snprintf>
    42a4:	69 81       	ldd	r22, Y+1	; 0x01
    42a6:	cd bf       	out	0x3d, r28	; 61
    42a8:	de bf       	out	0x3e, r29	; 62
    42aa:	66 23       	and	r22, r22
    42ac:	89 f0       	breq	.+34     	; 0x42d0 <vSendUART+0xac>
    42ae:	8e 01       	movw	r16, r28
    42b0:	0e 5f       	subi	r16, 0xFE	; 254
    42b2:	1f 4f       	sbci	r17, 0xFF	; 255
    42b4:	80 ea       	ldi	r24, 0xA0	; 160
    42b6:	98 e0       	ldi	r25, 0x08	; 8
    42b8:	0e 94 c9 0f 	call	0x1f92	; 0x1f92 <usart_putchar>
    42bc:	6b e0       	ldi	r22, 0x0B	; 11
    42be:	7a e1       	ldi	r23, 0x1A	; 26
    42c0:	80 e0       	ldi	r24, 0x00	; 0
    42c2:	90 e0       	ldi	r25, 0x00	; 0
    42c4:	84 de       	rcall	.-760    	; 0x3fce <__portable_avr_delay_cycles>
    42c6:	f8 01       	movw	r30, r16
    42c8:	61 91       	ld	r22, Z+
    42ca:	8f 01       	movw	r16, r30
    42cc:	61 11       	cpse	r22, r1
    42ce:	f2 cf       	rjmp	.-28     	; 0x42b4 <vSendUART+0x90>
    42d0:	26 e0       	ldi	r18, 0x06	; 6
    42d2:	30 e2       	ldi	r19, 0x20	; 32
    42d4:	40 e1       	ldi	r20, 0x10	; 16
    42d6:	60 e0       	ldi	r22, 0x00	; 0
    42d8:	c7 01       	movw	r24, r14
    42da:	8c dd       	rcall	.-1256   	; 0x3df4 <gfx_mono_draw_string>
    42dc:	20 e0       	ldi	r18, 0x00	; 0
    42de:	40 e0       	ldi	r20, 0x00	; 0
    42e0:	50 e0       	ldi	r21, 0x00	; 0
    42e2:	60 e0       	ldi	r22, 0x00	; 0
    42e4:	70 e0       	ldi	r23, 0x00	; 0
    42e6:	80 91 c1 24 	lds	r24, 0x24C1	; 0x8024c1 <xSemaphore>
    42ea:	90 91 c2 24 	lds	r25, 0x24C2	; 0x8024c2 <xSemaphore+0x1>
    42ee:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <xQueueGenericSend>
    42f2:	82 e3       	ldi	r24, 0x32	; 50
    42f4:	90 e0       	ldi	r25, 0x00	; 0
    42f6:	78 d8       	rcall	.-3856   	; 0x33e8 <vTaskDelay>
    42f8:	a9 cf       	rjmp	.-174    	; 0x424c <vSendUART+0x28>

000042fa <vSoilSensor>:
    42fa:	cf 93       	push	r28
    42fc:	df 93       	push	r29
    42fe:	cd b7       	in	r28, 0x3d	; 61
    4300:	de b7       	in	r29, 0x3e	; 62
    4302:	c1 58       	subi	r28, 0x81	; 129
    4304:	d1 09       	sbc	r29, r1
    4306:	cd bf       	out	0x3d, r28	; 61
    4308:	de bf       	out	0x3e, r29	; 62
    430a:	e0 e4       	ldi	r30, 0x40	; 64
    430c:	f6 e0       	ldi	r31, 0x06	; 6
    430e:	81 e0       	ldi	r24, 0x01	; 1
    4310:	81 83       	std	Z+1, r24	; 0x01
    4312:	85 83       	std	Z+5, r24	; 0x05
    4314:	00 e0       	ldi	r16, 0x00	; 0
    4316:	12 e0       	ldi	r17, 0x02	; 2
    4318:	55 24       	eor	r5, r5
    431a:	53 94       	inc	r5
    431c:	0f 2e       	mov	r0, r31
    431e:	fb e8       	ldi	r31, 0x8B	; 139
    4320:	af 2e       	mov	r10, r31
    4322:	f0 e2       	ldi	r31, 0x20	; 32
    4324:	bf 2e       	mov	r11, r31
    4326:	f0 2d       	mov	r31, r0
    4328:	68 94       	set
    432a:	44 24       	eor	r4, r4
    432c:	47 f8       	bld	r4, 7
    432e:	ce 01       	movw	r24, r28
    4330:	01 96       	adiw	r24, 0x01	; 1
    4332:	6c 01       	movw	r12, r24
    4334:	88 24       	eor	r8, r8
    4336:	83 94       	inc	r8
    4338:	91 2c       	mov	r9, r1
    433a:	0f 2e       	mov	r0, r31
    433c:	f0 e4       	ldi	r31, 0x40	; 64
    433e:	6f 2e       	mov	r6, r31
    4340:	f6 e0       	ldi	r31, 0x06	; 6
    4342:	7f 2e       	mov	r7, r31
    4344:	f0 2d       	mov	r31, r0
    4346:	6a e0       	ldi	r22, 0x0A	; 10
    4348:	70 e0       	ldi	r23, 0x00	; 0
    434a:	80 91 c1 24 	lds	r24, 0x24C1	; 0x8024c1 <xSemaphore>
    434e:	90 91 c2 24 	lds	r25, 0x24C2	; 0x8024c2 <xSemaphore+0x1>
    4352:	0e 94 8a 16 	call	0x2d14	; 0x2d14 <xQueueSemaphoreTake>
    4356:	81 30       	cpi	r24, 0x01	; 1
    4358:	09 f0       	breq	.+2      	; 0x435c <vSoilSensor+0x62>
    435a:	94 c0       	rjmp	.+296    	; 0x4484 <vSoilSensor+0x18a>
    435c:	c8 01       	movw	r24, r16
    435e:	0e 94 cf 05 	call	0xb9e	; 0xb9e <adc_enable>
    4362:	8f b7       	in	r24, 0x3f	; 63
    4364:	cf 57       	subi	r28, 0x7F	; 127
    4366:	df 4f       	sbci	r29, 0xFF	; 255
    4368:	88 83       	st	Y, r24
    436a:	c1 58       	subi	r28, 0x81	; 129
    436c:	d0 40       	sbci	r29, 0x00	; 0
    436e:	f8 94       	cli
    4370:	cf 57       	subi	r28, 0x7F	; 127
    4372:	df 4f       	sbci	r29, 0xFF	; 255
    4374:	98 81       	ld	r25, Y
    4376:	c1 58       	subi	r28, 0x81	; 129
    4378:	d0 40       	sbci	r29, 0x00	; 0
    437a:	f8 01       	movw	r30, r16
    437c:	80 81       	ld	r24, Z
    437e:	84 60       	ori	r24, 0x04	; 4
    4380:	80 83       	st	Z, r24
    4382:	9f bf       	out	0x3f, r25	; 63
    4384:	f8 01       	movw	r30, r16
    4386:	86 81       	ldd	r24, Z+6	; 0x06
    4388:	80 ff       	sbrs	r24, 0
    438a:	fc cf       	rjmp	.-8      	; 0x4384 <vSoilSensor+0x8a>
    438c:	56 82       	std	Z+6, r5	; 0x06
    438e:	e4 a0       	ldd	r14, Z+36	; 0x24
    4390:	f5 a0       	ldd	r15, Z+37	; 0x25
    4392:	c8 01       	movw	r24, r16
    4394:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <adc_disable>
    4398:	ff 92       	push	r15
    439a:	ef 92       	push	r14
    439c:	bf 92       	push	r11
    439e:	af 92       	push	r10
    43a0:	1f 92       	push	r1
    43a2:	4f 92       	push	r4
    43a4:	df 92       	push	r13
    43a6:	cf 92       	push	r12
    43a8:	79 d3       	rcall	.+1778   	; 0x4a9c <snprintf>
    43aa:	26 e0       	ldi	r18, 0x06	; 6
    43ac:	30 e2       	ldi	r19, 0x20	; 32
    43ae:	40 e1       	ldi	r20, 0x10	; 16
    43b0:	60 e0       	ldi	r22, 0x00	; 0
    43b2:	c6 01       	movw	r24, r12
    43b4:	1f dd       	rcall	.-1474   	; 0x3df4 <gfx_mono_draw_string>
    43b6:	cd bf       	out	0x3d, r28	; 61
    43b8:	de bf       	out	0x3e, r29	; 62
    43ba:	99 ed       	ldi	r25, 0xD9	; 217
    43bc:	e9 16       	cp	r14, r25
    43be:	9e e0       	ldi	r25, 0x0E	; 14
    43c0:	f9 06       	cpc	r15, r25
    43c2:	40 f1       	brcs	.+80     	; 0x4414 <vSoilSensor+0x11a>
    43c4:	10 92 eb 23 	sts	0x23EB, r1	; 0x8023eb <soilMoistureResult>
    43c8:	10 92 ec 23 	sts	0x23EC, r1	; 0x8023ec <soilMoistureResult+0x1>
    43cc:	80 91 0d 20 	lds	r24, 0x200D	; 0x80200d <pumpUART>
    43d0:	90 91 0e 20 	lds	r25, 0x200E	; 0x80200e <pumpUART+0x1>
    43d4:	89 2b       	or	r24, r25
    43d6:	79 f4       	brne	.+30     	; 0x43f6 <vSoilSensor+0xfc>
    43d8:	10 92 e9 23 	sts	0x23E9, r1	; 0x8023e9 <pumpStatus>
    43dc:	10 92 ea 23 	sts	0x23EA, r1	; 0x8023ea <pumpStatus+0x1>
    43e0:	f3 01       	movw	r30, r6
    43e2:	55 82       	std	Z+5, r5	; 0x05
    43e4:	86 e1       	ldi	r24, 0x16	; 22
    43e6:	ed e9       	ldi	r30, 0x9D	; 157
    43e8:	f0 e2       	ldi	r31, 0x20	; 32
    43ea:	d6 01       	movw	r26, r12
    43ec:	01 90       	ld	r0, Z+
    43ee:	0d 92       	st	X+, r0
    43f0:	8a 95       	dec	r24
    43f2:	e1 f7       	brne	.-8      	; 0x43ec <vSoilSensor+0xf2>
    43f4:	36 c0       	rjmp	.+108    	; 0x4462 <vSoilSensor+0x168>
    43f6:	80 92 e9 23 	sts	0x23E9, r8	; 0x8023e9 <pumpStatus>
    43fa:	90 92 ea 23 	sts	0x23EA, r9	; 0x8023ea <pumpStatus+0x1>
    43fe:	f3 01       	movw	r30, r6
    4400:	56 82       	std	Z+6, r5	; 0x06
    4402:	86 e1       	ldi	r24, 0x16	; 22
    4404:	e3 eb       	ldi	r30, 0xB3	; 179
    4406:	f0 e2       	ldi	r31, 0x20	; 32
    4408:	d6 01       	movw	r26, r12
    440a:	01 90       	ld	r0, Z+
    440c:	0d 92       	st	X+, r0
    440e:	8a 95       	dec	r24
    4410:	e1 f7       	brne	.-8      	; 0x440a <vSoilSensor+0x110>
    4412:	27 c0       	rjmp	.+78     	; 0x4462 <vSoilSensor+0x168>
    4414:	80 92 eb 23 	sts	0x23EB, r8	; 0x8023eb <soilMoistureResult>
    4418:	90 92 ec 23 	sts	0x23EC, r9	; 0x8023ec <soilMoistureResult+0x1>
    441c:	80 91 0d 20 	lds	r24, 0x200D	; 0x80200d <pumpUART>
    4420:	90 91 0e 20 	lds	r25, 0x200E	; 0x80200e <pumpUART+0x1>
    4424:	89 2b       	or	r24, r25
    4426:	79 f4       	brne	.+30     	; 0x4446 <vSoilSensor+0x14c>
    4428:	10 92 e9 23 	sts	0x23E9, r1	; 0x8023e9 <pumpStatus>
    442c:	10 92 ea 23 	sts	0x23EA, r1	; 0x8023ea <pumpStatus+0x1>
    4430:	f3 01       	movw	r30, r6
    4432:	55 82       	std	Z+5, r5	; 0x05
    4434:	86 e1       	ldi	r24, 0x16	; 22
    4436:	e9 ec       	ldi	r30, 0xC9	; 201
    4438:	f0 e2       	ldi	r31, 0x20	; 32
    443a:	d6 01       	movw	r26, r12
    443c:	01 90       	ld	r0, Z+
    443e:	0d 92       	st	X+, r0
    4440:	8a 95       	dec	r24
    4442:	e1 f7       	brne	.-8      	; 0x443c <vSoilSensor+0x142>
    4444:	0e c0       	rjmp	.+28     	; 0x4462 <vSoilSensor+0x168>
    4446:	10 92 e9 23 	sts	0x23E9, r1	; 0x8023e9 <pumpStatus>
    444a:	10 92 ea 23 	sts	0x23EA, r1	; 0x8023ea <pumpStatus+0x1>
    444e:	f3 01       	movw	r30, r6
    4450:	55 82       	std	Z+5, r5	; 0x05
    4452:	86 e1       	ldi	r24, 0x16	; 22
    4454:	ef ed       	ldi	r30, 0xDF	; 223
    4456:	f0 e2       	ldi	r31, 0x20	; 32
    4458:	d6 01       	movw	r26, r12
    445a:	01 90       	ld	r0, Z+
    445c:	0d 92       	st	X+, r0
    445e:	8a 95       	dec	r24
    4460:	e1 f7       	brne	.-8      	; 0x445a <vSoilSensor+0x160>
    4462:	26 e0       	ldi	r18, 0x06	; 6
    4464:	30 e2       	ldi	r19, 0x20	; 32
    4466:	48 e1       	ldi	r20, 0x18	; 24
    4468:	60 e0       	ldi	r22, 0x00	; 0
    446a:	c6 01       	movw	r24, r12
    446c:	c3 dc       	rcall	.-1658   	; 0x3df4 <gfx_mono_draw_string>
    446e:	20 e0       	ldi	r18, 0x00	; 0
    4470:	40 e0       	ldi	r20, 0x00	; 0
    4472:	50 e0       	ldi	r21, 0x00	; 0
    4474:	60 e0       	ldi	r22, 0x00	; 0
    4476:	70 e0       	ldi	r23, 0x00	; 0
    4478:	80 91 c1 24 	lds	r24, 0x24C1	; 0x8024c1 <xSemaphore>
    447c:	90 91 c2 24 	lds	r25, 0x24C2	; 0x8024c2 <xSemaphore+0x1>
    4480:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <xQueueGenericSend>
    4484:	88 e2       	ldi	r24, 0x28	; 40
    4486:	90 e0       	ldi	r25, 0x00	; 0
    4488:	0e 94 f4 19 	call	0x33e8	; 0x33e8 <vTaskDelay>
    448c:	5c cf       	rjmp	.-328    	; 0x4346 <vSoilSensor+0x4c>

0000448e <vUltrasonicSensor>:
    448e:	cf 93       	push	r28
    4490:	df 93       	push	r29
    4492:	cd b7       	in	r28, 0x3d	; 61
    4494:	de b7       	in	r29, 0x3e	; 62
    4496:	c0 58       	subi	r28, 0x80	; 128
    4498:	d1 09       	sbc	r29, r1
    449a:	cd bf       	out	0x3d, r28	; 61
    449c:	de bf       	out	0x3e, r29	; 62
    449e:	0f 2e       	mov	r0, r31
    44a0:	f0 e4       	ldi	r31, 0x40	; 64
    44a2:	cf 2e       	mov	r12, r31
    44a4:	fa e0       	ldi	r31, 0x0A	; 10
    44a6:	df 2e       	mov	r13, r31
    44a8:	f0 2d       	mov	r31, r0
    44aa:	00 e2       	ldi	r16, 0x20	; 32
    44ac:	16 e0       	ldi	r17, 0x06	; 6
    44ae:	77 24       	eor	r7, r7
    44b0:	73 94       	inc	r7
    44b2:	0f 2e       	mov	r0, r31
    44b4:	f5 ef       	ldi	r31, 0xF5	; 245
    44b6:	2f 2e       	mov	r2, r31
    44b8:	f0 e2       	ldi	r31, 0x20	; 32
    44ba:	3f 2e       	mov	r3, r31
    44bc:	f0 2d       	mov	r31, r0
    44be:	68 94       	set
    44c0:	66 24       	eor	r6, r6
    44c2:	67 f8       	bld	r6, 7
    44c4:	ce 01       	movw	r24, r28
    44c6:	01 96       	adiw	r24, 0x01	; 1
    44c8:	5c 01       	movw	r10, r24
    44ca:	0f 2e       	mov	r0, r31
    44cc:	f4 e6       	ldi	r31, 0x64	; 100
    44ce:	8f 2e       	mov	r8, r31
    44d0:	91 2c       	mov	r9, r1
    44d2:	f0 2d       	mov	r31, r0
    44d4:	0f 2e       	mov	r0, r31
    44d6:	fc e2       	ldi	r31, 0x2C	; 44
    44d8:	4f 2e       	mov	r4, r31
    44da:	f0 2d       	mov	r31, r0
    44dc:	55 24       	eor	r5, r5
    44de:	53 94       	inc	r5
    44e0:	6a e0       	ldi	r22, 0x0A	; 10
    44e2:	70 e0       	ldi	r23, 0x00	; 0
    44e4:	80 91 c1 24 	lds	r24, 0x24C1	; 0x8024c1 <xSemaphore>
    44e8:	90 91 c2 24 	lds	r25, 0x24C2	; 0x8024c2 <xSemaphore+0x1>
    44ec:	0e 94 8a 16 	call	0x2d14	; 0x2d14 <xQueueSemaphoreTake>
    44f0:	81 30       	cpi	r24, 0x01	; 1
    44f2:	09 f0       	breq	.+2      	; 0x44f6 <vUltrasonicSensor+0x68>
    44f4:	85 c0       	rjmp	.+266    	; 0x4600 <vUltrasonicSensor+0x172>
    44f6:	f6 01       	movw	r30, r12
    44f8:	80 81       	ld	r24, Z
    44fa:	80 7f       	andi	r24, 0xF0	; 240
    44fc:	81 60       	ori	r24, 0x01	; 1
    44fe:	80 83       	st	Z, r24
    4500:	f8 01       	movw	r30, r16
    4502:	71 82       	std	Z+1, r7	; 0x01
    4504:	76 82       	std	Z+6, r7	; 0x06
    4506:	75 82       	std	Z+5, r7	; 0x05
    4508:	62 e0       	ldi	r22, 0x02	; 2
    450a:	70 e0       	ldi	r23, 0x00	; 0
    450c:	80 e0       	ldi	r24, 0x00	; 0
    450e:	90 e0       	ldi	r25, 0x00	; 0
    4510:	5e dd       	rcall	.-1348   	; 0x3fce <__portable_avr_delay_cycles>
    4512:	f8 01       	movw	r30, r16
    4514:	76 82       	std	Z+6, r7	; 0x06
    4516:	72 82       	std	Z+2, r7	; 0x02
    4518:	66 e8       	ldi	r22, 0x86	; 134
    451a:	70 e0       	ldi	r23, 0x00	; 0
    451c:	80 e0       	ldi	r24, 0x00	; 0
    451e:	90 e0       	ldi	r25, 0x00	; 0
    4520:	56 dd       	rcall	.-1364   	; 0x3fce <__portable_avr_delay_cycles>
    4522:	e0 90 e7 23 	lds	r14, 0x23E7	; 0x8023e7 <incremental>
    4526:	f0 90 e8 23 	lds	r15, 0x23E8	; 0x8023e8 <incremental+0x1>
    452a:	67 e2       	ldi	r22, 0x27	; 39
    452c:	70 e0       	ldi	r23, 0x00	; 0
    452e:	80 e0       	ldi	r24, 0x00	; 0
    4530:	90 e0       	ldi	r25, 0x00	; 0
    4532:	4d dd       	rcall	.-1382   	; 0x3fce <__portable_avr_delay_cycles>
    4534:	78 94       	sei
    4536:	f8 01       	movw	r30, r16
    4538:	80 85       	ldd	r24, Z+8	; 0x08
    453a:	80 fd       	sbrc	r24, 0
    453c:	fc cf       	rjmp	.-8      	; 0x4536 <vUltrasonicSensor+0xa8>
    453e:	20 91 e7 23 	lds	r18, 0x23E7	; 0x8023e7 <incremental>
    4542:	30 91 e8 23 	lds	r19, 0x23E8	; 0x8023e8 <incremental+0x1>
    4546:	f6 01       	movw	r30, r12
    4548:	80 81       	ld	r24, Z
    454a:	80 7f       	andi	r24, 0xF0	; 240
    454c:	80 83       	st	Z, r24
    454e:	f8 94       	cli
    4550:	80 91 e7 23 	lds	r24, 0x23E7	; 0x8023e7 <incremental>
    4554:	90 91 e8 23 	lds	r25, 0x23E8	; 0x8023e8 <incremental+0x1>
    4558:	8d 32       	cpi	r24, 0x2D	; 45
    455a:	91 40       	sbci	r25, 0x01	; 1
    455c:	38 f0       	brcs	.+14     	; 0x456c <vUltrasonicSensor+0xde>
    455e:	40 92 e5 23 	sts	0x23E5, r4	; 0x8023e5 <distance>
    4562:	50 92 e6 23 	sts	0x23E6, r5	; 0x8023e6 <distance+0x1>
    4566:	e4 2c       	mov	r14, r4
    4568:	f5 2c       	mov	r15, r5
    456a:	20 c0       	rjmp	.+64     	; 0x45ac <vUltrasonicSensor+0x11e>
    456c:	2e 19       	sub	r18, r14
    456e:	3f 09       	sbc	r19, r15
    4570:	79 01       	movw	r14, r18
    4572:	1a f4       	brpl	.+6      	; 0x457a <vUltrasonicSensor+0xec>
    4574:	4f ef       	ldi	r20, 0xFF	; 255
    4576:	e4 1a       	sub	r14, r20
    4578:	f4 0a       	sbc	r15, r20
    457a:	f5 94       	asr	r15
    457c:	e7 94       	ror	r14
    457e:	e0 92 e5 23 	sts	0x23E5, r14	; 0x8023e5 <distance>
    4582:	f0 92 e6 23 	sts	0x23E6, r15	; 0x8023e6 <distance+0x1>
    4586:	97 01       	movw	r18, r14
    4588:	a4 e6       	ldi	r26, 0x64	; 100
    458a:	b0 e0       	ldi	r27, 0x00	; 0
    458c:	43 d1       	rcall	.+646    	; 0x4814 <__umulhisi3>
    458e:	2b e0       	ldi	r18, 0x0B	; 11
    4590:	30 e0       	ldi	r19, 0x00	; 0
    4592:	40 e0       	ldi	r20, 0x00	; 0
    4594:	50 e0       	ldi	r21, 0x00	; 0
    4596:	14 d1       	rcall	.+552    	; 0x47c0 <__udivmodsi4>
    4598:	c4 01       	movw	r24, r8
    459a:	82 1b       	sub	r24, r18
    459c:	93 0b       	sbc	r25, r19
    459e:	80 93 e3 23 	sts	0x23E3, r24	; 0x8023e3 <distancePercentage>
    45a2:	90 93 e4 23 	sts	0x23E4, r25	; 0x8023e4 <distancePercentage+0x1>
    45a6:	85 36       	cpi	r24, 0x65	; 101
    45a8:	91 05       	cpc	r25, r1
    45aa:	20 f0       	brcs	.+8      	; 0x45b4 <vUltrasonicSensor+0x126>
    45ac:	10 92 e3 23 	sts	0x23E3, r1	; 0x8023e3 <distancePercentage>
    45b0:	10 92 e4 23 	sts	0x23E4, r1	; 0x8023e4 <distancePercentage+0x1>
    45b4:	80 91 e4 23 	lds	r24, 0x23E4	; 0x8023e4 <distancePercentage+0x1>
    45b8:	8f 93       	push	r24
    45ba:	80 91 e3 23 	lds	r24, 0x23E3	; 0x8023e3 <distancePercentage>
    45be:	8f 93       	push	r24
    45c0:	ff 92       	push	r15
    45c2:	ef 92       	push	r14
    45c4:	3f 92       	push	r3
    45c6:	2f 92       	push	r2
    45c8:	1f 92       	push	r1
    45ca:	6f 92       	push	r6
    45cc:	bf 92       	push	r11
    45ce:	af 92       	push	r10
    45d0:	65 d2       	rcall	.+1226   	; 0x4a9c <snprintf>
    45d2:	26 e0       	ldi	r18, 0x06	; 6
    45d4:	30 e2       	ldi	r19, 0x20	; 32
    45d6:	40 e0       	ldi	r20, 0x00	; 0
    45d8:	60 e0       	ldi	r22, 0x00	; 0
    45da:	c5 01       	movw	r24, r10
    45dc:	0b dc       	rcall	.-2026   	; 0x3df4 <gfx_mono_draw_string>
    45de:	10 92 e7 23 	sts	0x23E7, r1	; 0x8023e7 <incremental>
    45e2:	10 92 e8 23 	sts	0x23E8, r1	; 0x8023e8 <incremental+0x1>
    45e6:	20 e0       	ldi	r18, 0x00	; 0
    45e8:	40 e0       	ldi	r20, 0x00	; 0
    45ea:	50 e0       	ldi	r21, 0x00	; 0
    45ec:	60 e0       	ldi	r22, 0x00	; 0
    45ee:	70 e0       	ldi	r23, 0x00	; 0
    45f0:	80 91 c1 24 	lds	r24, 0x24C1	; 0x8024c1 <xSemaphore>
    45f4:	90 91 c2 24 	lds	r25, 0x24C2	; 0x8024c2 <xSemaphore+0x1>
    45f8:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <xQueueGenericSend>
    45fc:	cd bf       	out	0x3d, r28	; 61
    45fe:	de bf       	out	0x3e, r29	; 62
    4600:	8b e4       	ldi	r24, 0x4B	; 75
    4602:	90 e0       	ldi	r25, 0x00	; 0
    4604:	0e 94 f4 19 	call	0x33e8	; 0x33e8 <vTaskDelay>
    4608:	6b cf       	rjmp	.-298    	; 0x44e0 <vUltrasonicSensor+0x52>

0000460a <setUpSerial>:
    460a:	10 92 a7 08 	sts	0x08A7, r1	; 0x8008a7 <__TEXT_REGION_LENGTH__+0x7008a7>
    460e:	8c e0       	ldi	r24, 0x0C	; 12
    4610:	80 93 a6 08 	sts	0x08A6, r24	; 0x8008a6 <__TEXT_REGION_LENGTH__+0x7008a6>
    4614:	10 92 a3 08 	sts	0x08A3, r1	; 0x8008a3 <__TEXT_REGION_LENGTH__+0x7008a3>
    4618:	83 e0       	ldi	r24, 0x03	; 3
    461a:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <__TEXT_REGION_LENGTH__+0x7008a5>
    461e:	88 e1       	ldi	r24, 0x18	; 24
    4620:	80 93 a4 08 	sts	0x08A4, r24	; 0x8008a4 <__TEXT_REGION_LENGTH__+0x7008a4>
    4624:	08 95       	ret

00004626 <setup_timer>:
uint16_t distance = 0;
uint16_t distancePercentage = 0;		// Needed for UART

//Fungsi setup timer
void setup_timer(void){
	tc_enable(&TCE1);
    4626:	80 e4       	ldi	r24, 0x40	; 64
    4628:	9a e0       	ldi	r25, 0x0A	; 10
    462a:	0e 94 11 0f 	call	0x1e22	; 0x1e22 <tc_enable>
	tc_set_overflow_interrupt_callback(&TCE1,increment_distance);
    462e:	62 ef       	ldi	r22, 0xF2	; 242
    4630:	7f e1       	ldi	r23, 0x1F	; 31
    4632:	80 e4       	ldi	r24, 0x40	; 64
    4634:	9a e0       	ldi	r25, 0x0A	; 10
    4636:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <tc_set_overflow_interrupt_callback>
 * \param tc Pointer to TC module.
 * \param wgm : waveform generator
 */
static inline void tc_set_wgm(volatile void *tc, enum tc_wg_mode_t wgm)
{
	((TC0_t *)tc)->CTRLB = (((TC0_t *)tc)->CTRLB & ~TC0_WGMODE_gm) | wgm;
    463a:	e0 e4       	ldi	r30, 0x40	; 64
    463c:	fa e0       	ldi	r31, 0x0A	; 10
    463e:	81 81       	ldd	r24, Z+1	; 0x01
    4640:	88 7f       	andi	r24, 0xF8	; 248
    4642:	81 83       	std	Z+1, r24	; 0x01
 * \param tc Pointer to TC module.
 * \param per_value Period value : PER
 */
static inline void tc_write_period(volatile void *tc, uint16_t per_value)
{
	((TC0_t *)tc)->PER = per_value;
    4644:	8a e3       	ldi	r24, 0x3A	; 58
    4646:	90 e0       	ldi	r25, 0x00	; 0
    4648:	86 a3       	std	Z+38, r24	; 0x26
    464a:	97 a3       	std	Z+39, r25	; 0x27
 * \note  Configures OVFINTLVL in INTCTRLA
 */
static inline void tc_set_overflow_interrupt_level(volatile void *tc,
		enum TC_INT_LEVEL_t level)
{
	((TC0_t *)tc)->INTCTRLA = ((TC0_t *)tc)->INTCTRLA & ~TC0_OVFINTLVL_gm;
    464c:	86 81       	ldd	r24, Z+6	; 0x06
    464e:	8c 7f       	andi	r24, 0xFC	; 252
    4650:	86 83       	std	Z+6, r24	; 0x06
	((TC0_t *)tc)->INTCTRLA =
			((TC0_t *)tc)->INTCTRLA | (level << TC0_OVFINTLVL_gp);
    4652:	86 81       	ldd	r24, Z+6	; 0x06
 */
static inline void tc_set_overflow_interrupt_level(volatile void *tc,
		enum TC_INT_LEVEL_t level)
{
	((TC0_t *)tc)->INTCTRLA = ((TC0_t *)tc)->INTCTRLA & ~TC0_OVFINTLVL_gm;
	((TC0_t *)tc)->INTCTRLA =
    4654:	83 60       	ori	r24, 0x03	; 3
    4656:	86 83       	std	Z+6, r24	; 0x06
 */
static inline void tc_write_clock_source(volatile void *tc,
		TC_CLKSEL_t TC_CLKSEL_enum)
{
	((TC0_t *)tc)->CTRLA =
			(((TC0_t *)tc)->CTRLA & ~TC0_CLKSEL_gm) |
    4658:	80 81       	ld	r24, Z
 * \note Configuring the clock also starts the timer
 */
static inline void tc_write_clock_source(volatile void *tc,
		TC_CLKSEL_t TC_CLKSEL_enum)
{
	((TC0_t *)tc)->CTRLA =
    465a:	80 7f       	andi	r24, 0xF0	; 240
    465c:	80 83       	st	Z, r24
    465e:	08 95       	ret

00004660 <main>:



/* MAIN FUNCTION */
int main (void)
{
    4660:	ef 92       	push	r14
    4662:	ff 92       	push	r15
    4664:	0f 93       	push	r16
    4666:	cf 93       	push	r28
    4668:	df 93       	push	r29
    466a:	cd b7       	in	r28, 0x3d	; 61
    466c:	de b7       	in	r29, 0x3e	; 62
    466e:	2b 97       	sbiw	r28, 0x0b	; 11
    4670:	cd bf       	out	0x3d, r28	; 61
    4672:	de bf       	out	0x3e, r29	; 62
	/* Insert system clock initialization code here (sysclk_init()). */
	sysclk_init();
    4674:	1c db       	rcall	.-2504   	; 0x3cae <sysclk_init>
	board_init();
    4676:	0e dc       	rcall	.-2020   	; 0x3e94 <board_init>
    4678:	87 e0       	ldi	r24, 0x07	; 7
 * Enables all interrupt levels, with vectors located in the application section
 * and fixed priority scheduling.
 */
static inline void pmic_init(void)
{
	PMIC.CTRL = PMIC_LVL_LOW | PMIC_LVL_MEDIUM |
    467a:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    467e:	0e 94 10 05 	call	0xa20	; 0xa20 <gfx_mono_st7565r_init>
	pmic_init();
	gfx_mono_init();
    4682:	80 e1       	ldi	r24, 0x10	; 16
    4684:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
    4688:	26 e0       	ldi	r18, 0x06	; 6
	
	gpio_set_pin_high(LCD_BACKLIGHT_ENABLE_PIN);
	gfx_mono_draw_string("Proyek UAS Sinambos", 0, 0, &sysfont);
    468a:	30 e2       	ldi	r19, 0x20	; 32
    468c:	40 e0       	ldi	r20, 0x00	; 0
    468e:	60 e0       	ldi	r22, 0x00	; 0
    4690:	8b e0       	ldi	r24, 0x0B	; 11
    4692:	91 e2       	ldi	r25, 0x21	; 33
    4694:	af db       	rcall	.-2210   	; 0x3df4 <gfx_mono_draw_string>
    4696:	64 e0       	ldi	r22, 0x04	; 4
	
	// Workaround for known issue: Enable RTC32 sysclk
	sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
    4698:	80 e0       	ldi	r24, 0x00	; 0
    469a:	19 db       	rcall	.-2510   	; 0x3cce <sysclk_enable_module>
    469c:	e0 e2       	ldi	r30, 0x20	; 32
    469e:	f4 e0       	ldi	r31, 0x04	; 4
	while (RTC32.SYNCCTRL & RTC32_SYNCBUSY_bm) {
    46a0:	81 81       	ldd	r24, Z+1	; 0x01
    46a2:	80 fd       	sbrc	r24, 0
    46a4:	fd cf       	rjmp	.-6      	; 0x46a0 <main+0x40>
    46a6:	66 e1       	ldi	r22, 0x16	; 22
    46a8:	76 e1       	ldi	r23, 0x16	; 22
		// Wait for RTC32 sysclk to become stable
	}
	
	delay_ms(1000);
    46aa:	85 e0       	ldi	r24, 0x05	; 5
    46ac:	90 e0       	ldi	r25, 0x00	; 0
    46ae:	8f dc       	rcall	.-1762   	; 0x3fce <__portable_avr_delay_cycles>

	// Setup
	setUpSerial();
    46b0:	ac df       	rcall	.-168    	; 0x460a <setUpSerial>
    46b2:	b9 df       	rcall	.-142    	; 0x4626 <setup_timer>
	setup_timer();
    46b4:	be 01       	movw	r22, r28
    46b6:	6f 5f       	subi	r22, 0xFF	; 255
static void adc_init_soil(void) {
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	// Read current ADC configuration
	adc_read_configuration(&MY_ADC, &adc_conf);
    46b8:	7f 4f       	sbci	r23, 0xFF	; 255
    46ba:	80 e0       	ldi	r24, 0x00	; 0
    46bc:	92 e0       	ldi	r25, 0x02	; 2
    46be:	0e 94 1b 08 	call	0x1036	; 0x1036 <adc_read_configuration>
    46c2:	ae 01       	movw	r20, r28
    46c4:	48 5f       	subi	r20, 0xF8	; 248
	adcch_read_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    46c6:	5f 4f       	sbci	r21, 0xFF	; 255
    46c8:	61 e0       	ldi	r22, 0x01	; 1
    46ca:	80 e0       	ldi	r24, 0x00	; 0
    46cc:	92 e0       	ldi	r25, 0x02	; 2
    46ce:	0e 94 9f 08 	call	0x113e	; 0x113e <adcch_read_configuration>
    46d2:	9a 81       	ldd	r25, Y+2	; 0x02
    46d4:	8b 81       	ldd	r24, Y+3	; 0x03
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    46d6:	8f 78       	andi	r24, 0x8F	; 143
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
	conf->refctrl |= ref;
    46d8:	80 61       	ori	r24, 0x10	; 16
    46da:	8b 83       	std	Y+3, r24	; 0x03
    46dc:	89 2f       	mov	r24, r25
    46de:	81 7e       	andi	r24, 0xE1	; 225
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    46e0:	8a 83       	std	Y+2, r24	; 0x02
    46e2:	1c 82       	std	Y+4, r1	; 0x04
    46e4:	82 e0       	ldi	r24, 0x02	; 2
		conf->evctrl = ADC_EVACT_NONE_gc;
    46e6:	8d 83       	std	Y+5, r24	; 0x05
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    46e8:	81 e0       	ldi	r24, 0x01	; 1
    46ea:	88 87       	std	Y+8, r24	; 0x08
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    46ec:	80 e2       	ldi	r24, 0x20	; 32
    46ee:	89 87       	std	Y+9, r24	; 0x09
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    46f0:	be 01       	movw	r22, r28
    46f2:	6f 5f       	subi	r22, 0xFF	; 255
	adc_set_clock_rate(&adc_conf, 200000UL); // Clock rate for ADC

	// PA4 (ADC4) as the input channel
	adcch_set_input(&adcch_conf, ADCCH_POS_PIN4, ADCCH_NEG_NONE, 1); // ADC4 is PA4 (J2_PIN0)
	
	adc_write_configuration(&MY_ADC, &adc_conf);
    46f4:	7f 4f       	sbci	r23, 0xFF	; 255
    46f6:	80 e0       	ldi	r24, 0x00	; 0
    46f8:	92 e0       	ldi	r25, 0x02	; 2
    46fa:	0e 94 b1 07 	call	0xf62	; 0xf62 <adc_write_configuration>
    46fe:	ae 01       	movw	r20, r28
    4700:	48 5f       	subi	r20, 0xF8	; 248
	adcch_write_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    4702:	5f 4f       	sbci	r21, 0xFF	; 255
    4704:	61 e0       	ldi	r22, 0x01	; 1
    4706:	80 e0       	ldi	r24, 0x00	; 0
    4708:	92 e0       	ldi	r25, 0x02	; 2
    470a:	0e 94 54 08 	call	0x10a8	; 0x10a8 <adcch_write_configuration>
    470e:	88 e0       	ldi	r24, 0x08	; 8
    4710:	80 93 22 06 	sts	0x0622, r24	; 0x800622 <__TEXT_REGION_LENGTH__+0x700622>


/* Functions for Photosensitive Sensor*/
// Setup PB3 as input
void setup_photosensitive_sensor(void) {
	PORTB.DIRCLR = PIN3_bm; // Set PB0 (connected to D0 pin of the sensor) as input
    4714:	e1 2c       	mov	r14, r1
    4716:	f1 2c       	mov	r15, r1
	setup_timer();
	adc_init_soil();
	setup_photosensitive_sensor();
	
	/* Create the task */
	xTaskCreate(vUltrasonicSensor, "", 1000, NULL, tskIDLE_PRIORITY + 3, NULL);
    4718:	03 e0       	ldi	r16, 0x03	; 3
    471a:	20 e0       	ldi	r18, 0x00	; 0
    471c:	30 e0       	ldi	r19, 0x00	; 0
    471e:	48 ee       	ldi	r20, 0xE8	; 232
    4720:	53 e0       	ldi	r21, 0x03	; 3
    4722:	6e ed       	ldi	r22, 0xDE	; 222
    4724:	70 e2       	ldi	r23, 0x20	; 32
    4726:	87 e4       	ldi	r24, 0x47	; 71
    4728:	92 e2       	ldi	r25, 0x22	; 34
    472a:	0e 94 85 17 	call	0x2f0a	; 0x2f0a <xTaskCreate>
    472e:	05 e0       	ldi	r16, 0x05	; 5
    4730:	20 e0       	ldi	r18, 0x00	; 0
	xTaskCreate(vSoilSensor, "", 1000, NULL, tskIDLE_PRIORITY + 5, NULL);
    4732:	30 e0       	ldi	r19, 0x00	; 0
    4734:	48 ee       	ldi	r20, 0xE8	; 232
    4736:	53 e0       	ldi	r21, 0x03	; 3
    4738:	6e ed       	ldi	r22, 0xDE	; 222
    473a:	70 e2       	ldi	r23, 0x20	; 32
    473c:	8d e7       	ldi	r24, 0x7D	; 125
    473e:	91 e2       	ldi	r25, 0x21	; 33
    4740:	0e 94 85 17 	call	0x2f0a	; 0x2f0a <xTaskCreate>
    4744:	04 e0       	ldi	r16, 0x04	; 4
    4746:	20 e0       	ldi	r18, 0x00	; 0
	xTaskCreate(vPhotosensitiveSensor, "", 1000, NULL, tskIDLE_PRIORITY + 4, NULL);	
    4748:	30 e0       	ldi	r19, 0x00	; 0
    474a:	48 ee       	ldi	r20, 0xE8	; 232
    474c:	53 e0       	ldi	r21, 0x03	; 3
    474e:	6e ed       	ldi	r22, 0xDE	; 222
    4750:	70 e2       	ldi	r23, 0x20	; 32
    4752:	86 ea       	ldi	r24, 0xA6	; 166
    4754:	90 e2       	ldi	r25, 0x20	; 32
    4756:	0e 94 85 17 	call	0x2f0a	; 0x2f0a <xTaskCreate>
    475a:	01 e0       	ldi	r16, 0x01	; 1
    475c:	20 e0       	ldi	r18, 0x00	; 0
	xTaskCreate(vSendUART, "", 1000, NULL, tskIDLE_PRIORITY + 1, NULL);
    475e:	30 e0       	ldi	r19, 0x00	; 0
    4760:	48 ee       	ldi	r20, 0xE8	; 232
    4762:	53 e0       	ldi	r21, 0x03	; 3
    4764:	6e ed       	ldi	r22, 0xDE	; 222
    4766:	70 e2       	ldi	r23, 0x20	; 32
    4768:	82 e1       	ldi	r24, 0x12	; 18
    476a:	91 e2       	ldi	r25, 0x21	; 33
    476c:	0e 94 85 17 	call	0x2f0a	; 0x2f0a <xTaskCreate>
    4770:	02 e0       	ldi	r16, 0x02	; 2
    4772:	20 e0       	ldi	r18, 0x00	; 0
	xTaskCreate(vReceiveUART, "", 1000, NULL, tskIDLE_PRIORITY + 2, NULL);
    4774:	30 e0       	ldi	r19, 0x00	; 0
    4776:	48 ee       	ldi	r20, 0xE8	; 232
    4778:	53 e0       	ldi	r21, 0x03	; 3
    477a:	6e ed       	ldi	r22, 0xDE	; 222
    477c:	70 e2       	ldi	r23, 0x20	; 32
    477e:	8c ef       	ldi	r24, 0xFC	; 252
    4780:	9f e1       	ldi	r25, 0x1F	; 31
    4782:	0e 94 85 17 	call	0x2f0a	; 0x2f0a <xTaskCreate>
    4786:	43 e0       	ldi	r20, 0x03	; 3
    4788:	60 e0       	ldi	r22, 0x00	; 0
		
	/* Semaphore */
	xSemaphore = xSemaphoreCreateBinary();
    478a:	81 e0       	ldi	r24, 0x01	; 1
    478c:	0e 94 1e 15 	call	0x2a3c	; 0x2a3c <xQueueGenericCreate>
    4790:	80 93 c1 24 	sts	0x24C1, r24	; 0x8024c1 <xSemaphore>
    4794:	90 93 c2 24 	sts	0x24C2, r25	; 0x8024c2 <xSemaphore+0x1>
    4798:	20 e0       	ldi	r18, 0x00	; 0
    479a:	40 e0       	ldi	r20, 0x00	; 0
	xSemaphoreGive(xSemaphore);
    479c:	50 e0       	ldi	r21, 0x00	; 0
    479e:	60 e0       	ldi	r22, 0x00	; 0
    47a0:	70 e0       	ldi	r23, 0x00	; 0
    47a2:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <xQueueGenericSend>
    47a6:	0e 94 84 18 	call	0x3108	; 0x3108 <vTaskStartScheduler>
	
	/* Start the task */
	vTaskStartScheduler();
    47aa:	80 e0       	ldi	r24, 0x00	; 0
    47ac:	90 e0       	ldi	r25, 0x00	; 0
}
    47ae:	2b 96       	adiw	r28, 0x0b	; 11
    47b0:	cd bf       	out	0x3d, r28	; 61
    47b2:	de bf       	out	0x3e, r29	; 62
    47b4:	df 91       	pop	r29
    47b6:	cf 91       	pop	r28
    47b8:	0f 91       	pop	r16
    47ba:	ff 90       	pop	r15
    47bc:	ef 90       	pop	r14
    47be:	08 95       	ret

000047c0 <__udivmodsi4>:
    47c0:	a1 e2       	ldi	r26, 0x21	; 33
    47c2:	1a 2e       	mov	r1, r26
    47c4:	aa 1b       	sub	r26, r26
    47c6:	bb 1b       	sub	r27, r27
    47c8:	fd 01       	movw	r30, r26
    47ca:	0d c0       	rjmp	.+26     	; 0x47e6 <__udivmodsi4_ep>

000047cc <__udivmodsi4_loop>:
    47cc:	aa 1f       	adc	r26, r26
    47ce:	bb 1f       	adc	r27, r27
    47d0:	ee 1f       	adc	r30, r30
    47d2:	ff 1f       	adc	r31, r31
    47d4:	a2 17       	cp	r26, r18
    47d6:	b3 07       	cpc	r27, r19
    47d8:	e4 07       	cpc	r30, r20
    47da:	f5 07       	cpc	r31, r21
    47dc:	20 f0       	brcs	.+8      	; 0x47e6 <__udivmodsi4_ep>
    47de:	a2 1b       	sub	r26, r18
    47e0:	b3 0b       	sbc	r27, r19
    47e2:	e4 0b       	sbc	r30, r20
    47e4:	f5 0b       	sbc	r31, r21

000047e6 <__udivmodsi4_ep>:
    47e6:	66 1f       	adc	r22, r22
    47e8:	77 1f       	adc	r23, r23
    47ea:	88 1f       	adc	r24, r24
    47ec:	99 1f       	adc	r25, r25
    47ee:	1a 94       	dec	r1
    47f0:	69 f7       	brne	.-38     	; 0x47cc <__udivmodsi4_loop>
    47f2:	60 95       	com	r22
    47f4:	70 95       	com	r23
    47f6:	80 95       	com	r24
    47f8:	90 95       	com	r25
    47fa:	9b 01       	movw	r18, r22
    47fc:	ac 01       	movw	r20, r24
    47fe:	bd 01       	movw	r22, r26
    4800:	cf 01       	movw	r24, r30
    4802:	08 95       	ret

00004804 <__tablejump2__>:
    4804:	ee 0f       	add	r30, r30
    4806:	ff 1f       	adc	r31, r31
    4808:	88 1f       	adc	r24, r24
    480a:	8b bf       	out	0x3b, r24	; 59
    480c:	07 90       	elpm	r0, Z+
    480e:	f6 91       	elpm	r31, Z
    4810:	e0 2d       	mov	r30, r0
    4812:	19 94       	eijmp

00004814 <__umulhisi3>:
    4814:	a2 9f       	mul	r26, r18
    4816:	b0 01       	movw	r22, r0
    4818:	b3 9f       	mul	r27, r19
    481a:	c0 01       	movw	r24, r0
    481c:	a3 9f       	mul	r26, r19
    481e:	70 0d       	add	r23, r0
    4820:	81 1d       	adc	r24, r1
    4822:	11 24       	eor	r1, r1
    4824:	91 1d       	adc	r25, r1
    4826:	b2 9f       	mul	r27, r18
    4828:	70 0d       	add	r23, r0
    482a:	81 1d       	adc	r24, r1
    482c:	11 24       	eor	r1, r1
    482e:	91 1d       	adc	r25, r1
    4830:	08 95       	ret

00004832 <malloc>:
    4832:	0f 93       	push	r16
    4834:	1f 93       	push	r17
    4836:	cf 93       	push	r28
    4838:	df 93       	push	r29
    483a:	82 30       	cpi	r24, 0x02	; 2
    483c:	91 05       	cpc	r25, r1
    483e:	10 f4       	brcc	.+4      	; 0x4844 <malloc+0x12>
    4840:	82 e0       	ldi	r24, 0x02	; 2
    4842:	90 e0       	ldi	r25, 0x00	; 0
    4844:	e0 91 c5 24 	lds	r30, 0x24C5	; 0x8024c5 <__flp>
    4848:	f0 91 c6 24 	lds	r31, 0x24C6	; 0x8024c6 <__flp+0x1>
    484c:	20 e0       	ldi	r18, 0x00	; 0
    484e:	30 e0       	ldi	r19, 0x00	; 0
    4850:	a0 e0       	ldi	r26, 0x00	; 0
    4852:	b0 e0       	ldi	r27, 0x00	; 0
    4854:	30 97       	sbiw	r30, 0x00	; 0
    4856:	19 f1       	breq	.+70     	; 0x489e <malloc+0x6c>
    4858:	40 81       	ld	r20, Z
    485a:	51 81       	ldd	r21, Z+1	; 0x01
    485c:	02 81       	ldd	r16, Z+2	; 0x02
    485e:	13 81       	ldd	r17, Z+3	; 0x03
    4860:	48 17       	cp	r20, r24
    4862:	59 07       	cpc	r21, r25
    4864:	c8 f0       	brcs	.+50     	; 0x4898 <malloc+0x66>
    4866:	84 17       	cp	r24, r20
    4868:	95 07       	cpc	r25, r21
    486a:	69 f4       	brne	.+26     	; 0x4886 <malloc+0x54>
    486c:	10 97       	sbiw	r26, 0x00	; 0
    486e:	31 f0       	breq	.+12     	; 0x487c <malloc+0x4a>
    4870:	12 96       	adiw	r26, 0x02	; 2
    4872:	0c 93       	st	X, r16
    4874:	12 97       	sbiw	r26, 0x02	; 2
    4876:	13 96       	adiw	r26, 0x03	; 3
    4878:	1c 93       	st	X, r17
    487a:	27 c0       	rjmp	.+78     	; 0x48ca <malloc+0x98>
    487c:	00 93 c5 24 	sts	0x24C5, r16	; 0x8024c5 <__flp>
    4880:	10 93 c6 24 	sts	0x24C6, r17	; 0x8024c6 <__flp+0x1>
    4884:	22 c0       	rjmp	.+68     	; 0x48ca <malloc+0x98>
    4886:	21 15       	cp	r18, r1
    4888:	31 05       	cpc	r19, r1
    488a:	19 f0       	breq	.+6      	; 0x4892 <malloc+0x60>
    488c:	42 17       	cp	r20, r18
    488e:	53 07       	cpc	r21, r19
    4890:	18 f4       	brcc	.+6      	; 0x4898 <malloc+0x66>
    4892:	9a 01       	movw	r18, r20
    4894:	bd 01       	movw	r22, r26
    4896:	ef 01       	movw	r28, r30
    4898:	df 01       	movw	r26, r30
    489a:	f8 01       	movw	r30, r16
    489c:	db cf       	rjmp	.-74     	; 0x4854 <malloc+0x22>
    489e:	21 15       	cp	r18, r1
    48a0:	31 05       	cpc	r19, r1
    48a2:	f9 f0       	breq	.+62     	; 0x48e2 <malloc+0xb0>
    48a4:	28 1b       	sub	r18, r24
    48a6:	39 0b       	sbc	r19, r25
    48a8:	24 30       	cpi	r18, 0x04	; 4
    48aa:	31 05       	cpc	r19, r1
    48ac:	80 f4       	brcc	.+32     	; 0x48ce <malloc+0x9c>
    48ae:	8a 81       	ldd	r24, Y+2	; 0x02
    48b0:	9b 81       	ldd	r25, Y+3	; 0x03
    48b2:	61 15       	cp	r22, r1
    48b4:	71 05       	cpc	r23, r1
    48b6:	21 f0       	breq	.+8      	; 0x48c0 <malloc+0x8e>
    48b8:	fb 01       	movw	r30, r22
    48ba:	82 83       	std	Z+2, r24	; 0x02
    48bc:	93 83       	std	Z+3, r25	; 0x03
    48be:	04 c0       	rjmp	.+8      	; 0x48c8 <malloc+0x96>
    48c0:	80 93 c5 24 	sts	0x24C5, r24	; 0x8024c5 <__flp>
    48c4:	90 93 c6 24 	sts	0x24C6, r25	; 0x8024c6 <__flp+0x1>
    48c8:	fe 01       	movw	r30, r28
    48ca:	32 96       	adiw	r30, 0x02	; 2
    48cc:	44 c0       	rjmp	.+136    	; 0x4956 <malloc+0x124>
    48ce:	fe 01       	movw	r30, r28
    48d0:	e2 0f       	add	r30, r18
    48d2:	f3 1f       	adc	r31, r19
    48d4:	81 93       	st	Z+, r24
    48d6:	91 93       	st	Z+, r25
    48d8:	22 50       	subi	r18, 0x02	; 2
    48da:	31 09       	sbc	r19, r1
    48dc:	28 83       	st	Y, r18
    48de:	39 83       	std	Y+1, r19	; 0x01
    48e0:	3a c0       	rjmp	.+116    	; 0x4956 <malloc+0x124>
    48e2:	20 91 c3 24 	lds	r18, 0x24C3	; 0x8024c3 <__brkval>
    48e6:	30 91 c4 24 	lds	r19, 0x24C4	; 0x8024c4 <__brkval+0x1>
    48ea:	23 2b       	or	r18, r19
    48ec:	41 f4       	brne	.+16     	; 0x48fe <malloc+0xcc>
    48ee:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    48f2:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    48f6:	20 93 c3 24 	sts	0x24C3, r18	; 0x8024c3 <__brkval>
    48fa:	30 93 c4 24 	sts	0x24C4, r19	; 0x8024c4 <__brkval+0x1>
    48fe:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
    4902:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
    4906:	21 15       	cp	r18, r1
    4908:	31 05       	cpc	r19, r1
    490a:	41 f4       	brne	.+16     	; 0x491c <malloc+0xea>
    490c:	2d b7       	in	r18, 0x3d	; 61
    490e:	3e b7       	in	r19, 0x3e	; 62
    4910:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    4914:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    4918:	24 1b       	sub	r18, r20
    491a:	35 0b       	sbc	r19, r21
    491c:	e0 91 c3 24 	lds	r30, 0x24C3	; 0x8024c3 <__brkval>
    4920:	f0 91 c4 24 	lds	r31, 0x24C4	; 0x8024c4 <__brkval+0x1>
    4924:	e2 17       	cp	r30, r18
    4926:	f3 07       	cpc	r31, r19
    4928:	a0 f4       	brcc	.+40     	; 0x4952 <malloc+0x120>
    492a:	2e 1b       	sub	r18, r30
    492c:	3f 0b       	sbc	r19, r31
    492e:	28 17       	cp	r18, r24
    4930:	39 07       	cpc	r19, r25
    4932:	78 f0       	brcs	.+30     	; 0x4952 <malloc+0x120>
    4934:	ac 01       	movw	r20, r24
    4936:	4e 5f       	subi	r20, 0xFE	; 254
    4938:	5f 4f       	sbci	r21, 0xFF	; 255
    493a:	24 17       	cp	r18, r20
    493c:	35 07       	cpc	r19, r21
    493e:	48 f0       	brcs	.+18     	; 0x4952 <malloc+0x120>
    4940:	4e 0f       	add	r20, r30
    4942:	5f 1f       	adc	r21, r31
    4944:	40 93 c3 24 	sts	0x24C3, r20	; 0x8024c3 <__brkval>
    4948:	50 93 c4 24 	sts	0x24C4, r21	; 0x8024c4 <__brkval+0x1>
    494c:	81 93       	st	Z+, r24
    494e:	91 93       	st	Z+, r25
    4950:	02 c0       	rjmp	.+4      	; 0x4956 <malloc+0x124>
    4952:	e0 e0       	ldi	r30, 0x00	; 0
    4954:	f0 e0       	ldi	r31, 0x00	; 0
    4956:	cf 01       	movw	r24, r30
    4958:	df 91       	pop	r29
    495a:	cf 91       	pop	r28
    495c:	1f 91       	pop	r17
    495e:	0f 91       	pop	r16
    4960:	08 95       	ret

00004962 <free>:
    4962:	cf 93       	push	r28
    4964:	df 93       	push	r29
    4966:	00 97       	sbiw	r24, 0x00	; 0
    4968:	09 f4       	brne	.+2      	; 0x496c <free+0xa>
    496a:	81 c0       	rjmp	.+258    	; 0x4a6e <free+0x10c>
    496c:	fc 01       	movw	r30, r24
    496e:	32 97       	sbiw	r30, 0x02	; 2
    4970:	12 82       	std	Z+2, r1	; 0x02
    4972:	13 82       	std	Z+3, r1	; 0x03
    4974:	a0 91 c5 24 	lds	r26, 0x24C5	; 0x8024c5 <__flp>
    4978:	b0 91 c6 24 	lds	r27, 0x24C6	; 0x8024c6 <__flp+0x1>
    497c:	10 97       	sbiw	r26, 0x00	; 0
    497e:	81 f4       	brne	.+32     	; 0x49a0 <free+0x3e>
    4980:	20 81       	ld	r18, Z
    4982:	31 81       	ldd	r19, Z+1	; 0x01
    4984:	82 0f       	add	r24, r18
    4986:	93 1f       	adc	r25, r19
    4988:	20 91 c3 24 	lds	r18, 0x24C3	; 0x8024c3 <__brkval>
    498c:	30 91 c4 24 	lds	r19, 0x24C4	; 0x8024c4 <__brkval+0x1>
    4990:	28 17       	cp	r18, r24
    4992:	39 07       	cpc	r19, r25
    4994:	51 f5       	brne	.+84     	; 0x49ea <free+0x88>
    4996:	e0 93 c3 24 	sts	0x24C3, r30	; 0x8024c3 <__brkval>
    499a:	f0 93 c4 24 	sts	0x24C4, r31	; 0x8024c4 <__brkval+0x1>
    499e:	67 c0       	rjmp	.+206    	; 0x4a6e <free+0x10c>
    49a0:	ed 01       	movw	r28, r26
    49a2:	20 e0       	ldi	r18, 0x00	; 0
    49a4:	30 e0       	ldi	r19, 0x00	; 0
    49a6:	ce 17       	cp	r28, r30
    49a8:	df 07       	cpc	r29, r31
    49aa:	40 f4       	brcc	.+16     	; 0x49bc <free+0x5a>
    49ac:	4a 81       	ldd	r20, Y+2	; 0x02
    49ae:	5b 81       	ldd	r21, Y+3	; 0x03
    49b0:	9e 01       	movw	r18, r28
    49b2:	41 15       	cp	r20, r1
    49b4:	51 05       	cpc	r21, r1
    49b6:	f1 f0       	breq	.+60     	; 0x49f4 <free+0x92>
    49b8:	ea 01       	movw	r28, r20
    49ba:	f5 cf       	rjmp	.-22     	; 0x49a6 <free+0x44>
    49bc:	c2 83       	std	Z+2, r28	; 0x02
    49be:	d3 83       	std	Z+3, r29	; 0x03
    49c0:	40 81       	ld	r20, Z
    49c2:	51 81       	ldd	r21, Z+1	; 0x01
    49c4:	84 0f       	add	r24, r20
    49c6:	95 1f       	adc	r25, r21
    49c8:	c8 17       	cp	r28, r24
    49ca:	d9 07       	cpc	r29, r25
    49cc:	59 f4       	brne	.+22     	; 0x49e4 <free+0x82>
    49ce:	88 81       	ld	r24, Y
    49d0:	99 81       	ldd	r25, Y+1	; 0x01
    49d2:	84 0f       	add	r24, r20
    49d4:	95 1f       	adc	r25, r21
    49d6:	02 96       	adiw	r24, 0x02	; 2
    49d8:	80 83       	st	Z, r24
    49da:	91 83       	std	Z+1, r25	; 0x01
    49dc:	8a 81       	ldd	r24, Y+2	; 0x02
    49de:	9b 81       	ldd	r25, Y+3	; 0x03
    49e0:	82 83       	std	Z+2, r24	; 0x02
    49e2:	93 83       	std	Z+3, r25	; 0x03
    49e4:	21 15       	cp	r18, r1
    49e6:	31 05       	cpc	r19, r1
    49e8:	29 f4       	brne	.+10     	; 0x49f4 <free+0x92>
    49ea:	e0 93 c5 24 	sts	0x24C5, r30	; 0x8024c5 <__flp>
    49ee:	f0 93 c6 24 	sts	0x24C6, r31	; 0x8024c6 <__flp+0x1>
    49f2:	3d c0       	rjmp	.+122    	; 0x4a6e <free+0x10c>
    49f4:	e9 01       	movw	r28, r18
    49f6:	ea 83       	std	Y+2, r30	; 0x02
    49f8:	fb 83       	std	Y+3, r31	; 0x03
    49fa:	49 91       	ld	r20, Y+
    49fc:	59 91       	ld	r21, Y+
    49fe:	c4 0f       	add	r28, r20
    4a00:	d5 1f       	adc	r29, r21
    4a02:	ec 17       	cp	r30, r28
    4a04:	fd 07       	cpc	r31, r29
    4a06:	61 f4       	brne	.+24     	; 0x4a20 <free+0xbe>
    4a08:	80 81       	ld	r24, Z
    4a0a:	91 81       	ldd	r25, Z+1	; 0x01
    4a0c:	84 0f       	add	r24, r20
    4a0e:	95 1f       	adc	r25, r21
    4a10:	02 96       	adiw	r24, 0x02	; 2
    4a12:	e9 01       	movw	r28, r18
    4a14:	88 83       	st	Y, r24
    4a16:	99 83       	std	Y+1, r25	; 0x01
    4a18:	82 81       	ldd	r24, Z+2	; 0x02
    4a1a:	93 81       	ldd	r25, Z+3	; 0x03
    4a1c:	8a 83       	std	Y+2, r24	; 0x02
    4a1e:	9b 83       	std	Y+3, r25	; 0x03
    4a20:	e0 e0       	ldi	r30, 0x00	; 0
    4a22:	f0 e0       	ldi	r31, 0x00	; 0
    4a24:	12 96       	adiw	r26, 0x02	; 2
    4a26:	8d 91       	ld	r24, X+
    4a28:	9c 91       	ld	r25, X
    4a2a:	13 97       	sbiw	r26, 0x03	; 3
    4a2c:	00 97       	sbiw	r24, 0x00	; 0
    4a2e:	19 f0       	breq	.+6      	; 0x4a36 <free+0xd4>
    4a30:	fd 01       	movw	r30, r26
    4a32:	dc 01       	movw	r26, r24
    4a34:	f7 cf       	rjmp	.-18     	; 0x4a24 <free+0xc2>
    4a36:	8d 91       	ld	r24, X+
    4a38:	9c 91       	ld	r25, X
    4a3a:	11 97       	sbiw	r26, 0x01	; 1
    4a3c:	9d 01       	movw	r18, r26
    4a3e:	2e 5f       	subi	r18, 0xFE	; 254
    4a40:	3f 4f       	sbci	r19, 0xFF	; 255
    4a42:	82 0f       	add	r24, r18
    4a44:	93 1f       	adc	r25, r19
    4a46:	20 91 c3 24 	lds	r18, 0x24C3	; 0x8024c3 <__brkval>
    4a4a:	30 91 c4 24 	lds	r19, 0x24C4	; 0x8024c4 <__brkval+0x1>
    4a4e:	28 17       	cp	r18, r24
    4a50:	39 07       	cpc	r19, r25
    4a52:	69 f4       	brne	.+26     	; 0x4a6e <free+0x10c>
    4a54:	30 97       	sbiw	r30, 0x00	; 0
    4a56:	29 f4       	brne	.+10     	; 0x4a62 <free+0x100>
    4a58:	10 92 c5 24 	sts	0x24C5, r1	; 0x8024c5 <__flp>
    4a5c:	10 92 c6 24 	sts	0x24C6, r1	; 0x8024c6 <__flp+0x1>
    4a60:	02 c0       	rjmp	.+4      	; 0x4a66 <free+0x104>
    4a62:	12 82       	std	Z+2, r1	; 0x02
    4a64:	13 82       	std	Z+3, r1	; 0x03
    4a66:	a0 93 c3 24 	sts	0x24C3, r26	; 0x8024c3 <__brkval>
    4a6a:	b0 93 c4 24 	sts	0x24C4, r27	; 0x8024c4 <__brkval+0x1>
    4a6e:	df 91       	pop	r29
    4a70:	cf 91       	pop	r28
    4a72:	08 95       	ret

00004a74 <memcpy>:
    4a74:	fb 01       	movw	r30, r22
    4a76:	dc 01       	movw	r26, r24
    4a78:	02 c0       	rjmp	.+4      	; 0x4a7e <memcpy+0xa>
    4a7a:	01 90       	ld	r0, Z+
    4a7c:	0d 92       	st	X+, r0
    4a7e:	41 50       	subi	r20, 0x01	; 1
    4a80:	50 40       	sbci	r21, 0x00	; 0
    4a82:	d8 f7       	brcc	.-10     	; 0x4a7a <memcpy+0x6>
    4a84:	08 95       	ret

00004a86 <strchr>:
    4a86:	fc 01       	movw	r30, r24
    4a88:	81 91       	ld	r24, Z+
    4a8a:	86 17       	cp	r24, r22
    4a8c:	21 f0       	breq	.+8      	; 0x4a96 <strchr+0x10>
    4a8e:	88 23       	and	r24, r24
    4a90:	d9 f7       	brne	.-10     	; 0x4a88 <strchr+0x2>
    4a92:	99 27       	eor	r25, r25
    4a94:	08 95       	ret
    4a96:	31 97       	sbiw	r30, 0x01	; 1
    4a98:	cf 01       	movw	r24, r30
    4a9a:	08 95       	ret

00004a9c <snprintf>:
    4a9c:	0f 93       	push	r16
    4a9e:	1f 93       	push	r17
    4aa0:	cf 93       	push	r28
    4aa2:	df 93       	push	r29
    4aa4:	cd b7       	in	r28, 0x3d	; 61
    4aa6:	de b7       	in	r29, 0x3e	; 62
    4aa8:	2e 97       	sbiw	r28, 0x0e	; 14
    4aaa:	cd bf       	out	0x3d, r28	; 61
    4aac:	de bf       	out	0x3e, r29	; 62
    4aae:	0e 89       	ldd	r16, Y+22	; 0x16
    4ab0:	1f 89       	ldd	r17, Y+23	; 0x17
    4ab2:	88 8d       	ldd	r24, Y+24	; 0x18
    4ab4:	99 8d       	ldd	r25, Y+25	; 0x19
    4ab6:	26 e0       	ldi	r18, 0x06	; 6
    4ab8:	2c 83       	std	Y+4, r18	; 0x04
    4aba:	09 83       	std	Y+1, r16	; 0x01
    4abc:	1a 83       	std	Y+2, r17	; 0x02
    4abe:	97 ff       	sbrs	r25, 7
    4ac0:	02 c0       	rjmp	.+4      	; 0x4ac6 <snprintf+0x2a>
    4ac2:	80 e0       	ldi	r24, 0x00	; 0
    4ac4:	90 e8       	ldi	r25, 0x80	; 128
    4ac6:	01 97       	sbiw	r24, 0x01	; 1
    4ac8:	8d 83       	std	Y+5, r24	; 0x05
    4aca:	9e 83       	std	Y+6, r25	; 0x06
    4acc:	ae 01       	movw	r20, r28
    4ace:	44 5e       	subi	r20, 0xE4	; 228
    4ad0:	5f 4f       	sbci	r21, 0xFF	; 255
    4ad2:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4ad4:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4ad6:	ce 01       	movw	r24, r28
    4ad8:	01 96       	adiw	r24, 0x01	; 1
    4ada:	31 d0       	rcall	.+98     	; 0x4b3e <vfprintf>
    4adc:	4d 81       	ldd	r20, Y+5	; 0x05
    4ade:	5e 81       	ldd	r21, Y+6	; 0x06
    4ae0:	57 fd       	sbrc	r21, 7
    4ae2:	0a c0       	rjmp	.+20     	; 0x4af8 <snprintf+0x5c>
    4ae4:	2f 81       	ldd	r18, Y+7	; 0x07
    4ae6:	38 85       	ldd	r19, Y+8	; 0x08
    4ae8:	42 17       	cp	r20, r18
    4aea:	53 07       	cpc	r21, r19
    4aec:	0c f4       	brge	.+2      	; 0x4af0 <snprintf+0x54>
    4aee:	9a 01       	movw	r18, r20
    4af0:	f8 01       	movw	r30, r16
    4af2:	e2 0f       	add	r30, r18
    4af4:	f3 1f       	adc	r31, r19
    4af6:	10 82       	st	Z, r1
    4af8:	2e 96       	adiw	r28, 0x0e	; 14
    4afa:	cd bf       	out	0x3d, r28	; 61
    4afc:	de bf       	out	0x3e, r29	; 62
    4afe:	df 91       	pop	r29
    4b00:	cf 91       	pop	r28
    4b02:	1f 91       	pop	r17
    4b04:	0f 91       	pop	r16
    4b06:	08 95       	ret

00004b08 <sscanf>:
    4b08:	cf 93       	push	r28
    4b0a:	df 93       	push	r29
    4b0c:	cd b7       	in	r28, 0x3d	; 61
    4b0e:	de b7       	in	r29, 0x3e	; 62
    4b10:	2e 97       	sbiw	r28, 0x0e	; 14
    4b12:	cd bf       	out	0x3d, r28	; 61
    4b14:	de bf       	out	0x3e, r29	; 62
    4b16:	85 e0       	ldi	r24, 0x05	; 5
    4b18:	8c 83       	std	Y+4, r24	; 0x04
    4b1a:	8c 89       	ldd	r24, Y+20	; 0x14
    4b1c:	9d 89       	ldd	r25, Y+21	; 0x15
    4b1e:	89 83       	std	Y+1, r24	; 0x01
    4b20:	9a 83       	std	Y+2, r25	; 0x02
    4b22:	ae 01       	movw	r20, r28
    4b24:	48 5e       	subi	r20, 0xE8	; 232
    4b26:	5f 4f       	sbci	r21, 0xFF	; 255
    4b28:	6e 89       	ldd	r22, Y+22	; 0x16
    4b2a:	7f 89       	ldd	r23, Y+23	; 0x17
    4b2c:	ce 01       	movw	r24, r28
    4b2e:	01 96       	adiw	r24, 0x01	; 1
    4b30:	a9 d3       	rcall	.+1874   	; 0x5284 <vfscanf>
    4b32:	2e 96       	adiw	r28, 0x0e	; 14
    4b34:	cd bf       	out	0x3d, r28	; 61
    4b36:	de bf       	out	0x3e, r29	; 62
    4b38:	df 91       	pop	r29
    4b3a:	cf 91       	pop	r28
    4b3c:	08 95       	ret

00004b3e <vfprintf>:
    4b3e:	2f 92       	push	r2
    4b40:	3f 92       	push	r3
    4b42:	4f 92       	push	r4
    4b44:	5f 92       	push	r5
    4b46:	6f 92       	push	r6
    4b48:	7f 92       	push	r7
    4b4a:	8f 92       	push	r8
    4b4c:	9f 92       	push	r9
    4b4e:	af 92       	push	r10
    4b50:	bf 92       	push	r11
    4b52:	cf 92       	push	r12
    4b54:	df 92       	push	r13
    4b56:	ef 92       	push	r14
    4b58:	ff 92       	push	r15
    4b5a:	0f 93       	push	r16
    4b5c:	1f 93       	push	r17
    4b5e:	cf 93       	push	r28
    4b60:	df 93       	push	r29
    4b62:	cd b7       	in	r28, 0x3d	; 61
    4b64:	de b7       	in	r29, 0x3e	; 62
    4b66:	2b 97       	sbiw	r28, 0x0b	; 11
    4b68:	cd bf       	out	0x3d, r28	; 61
    4b6a:	de bf       	out	0x3e, r29	; 62
    4b6c:	6c 01       	movw	r12, r24
    4b6e:	7b 01       	movw	r14, r22
    4b70:	8a 01       	movw	r16, r20
    4b72:	fc 01       	movw	r30, r24
    4b74:	16 82       	std	Z+6, r1	; 0x06
    4b76:	17 82       	std	Z+7, r1	; 0x07
    4b78:	83 81       	ldd	r24, Z+3	; 0x03
    4b7a:	81 ff       	sbrs	r24, 1
    4b7c:	bf c1       	rjmp	.+894    	; 0x4efc <vfprintf+0x3be>
    4b7e:	ce 01       	movw	r24, r28
    4b80:	01 96       	adiw	r24, 0x01	; 1
    4b82:	3c 01       	movw	r6, r24
    4b84:	f6 01       	movw	r30, r12
    4b86:	93 81       	ldd	r25, Z+3	; 0x03
    4b88:	f7 01       	movw	r30, r14
    4b8a:	93 fd       	sbrc	r25, 3
    4b8c:	85 91       	lpm	r24, Z+
    4b8e:	93 ff       	sbrs	r25, 3
    4b90:	81 91       	ld	r24, Z+
    4b92:	7f 01       	movw	r14, r30
    4b94:	88 23       	and	r24, r24
    4b96:	09 f4       	brne	.+2      	; 0x4b9a <vfprintf+0x5c>
    4b98:	ad c1       	rjmp	.+858    	; 0x4ef4 <vfprintf+0x3b6>
    4b9a:	85 32       	cpi	r24, 0x25	; 37
    4b9c:	39 f4       	brne	.+14     	; 0x4bac <vfprintf+0x6e>
    4b9e:	93 fd       	sbrc	r25, 3
    4ba0:	85 91       	lpm	r24, Z+
    4ba2:	93 ff       	sbrs	r25, 3
    4ba4:	81 91       	ld	r24, Z+
    4ba6:	7f 01       	movw	r14, r30
    4ba8:	85 32       	cpi	r24, 0x25	; 37
    4baa:	21 f4       	brne	.+8      	; 0x4bb4 <vfprintf+0x76>
    4bac:	b6 01       	movw	r22, r12
    4bae:	90 e0       	ldi	r25, 0x00	; 0
    4bb0:	e7 d4       	rcall	.+2510   	; 0x5580 <fputc>
    4bb2:	e8 cf       	rjmp	.-48     	; 0x4b84 <vfprintf+0x46>
    4bb4:	91 2c       	mov	r9, r1
    4bb6:	21 2c       	mov	r2, r1
    4bb8:	31 2c       	mov	r3, r1
    4bba:	ff e1       	ldi	r31, 0x1F	; 31
    4bbc:	f3 15       	cp	r31, r3
    4bbe:	d8 f0       	brcs	.+54     	; 0x4bf6 <vfprintf+0xb8>
    4bc0:	8b 32       	cpi	r24, 0x2B	; 43
    4bc2:	79 f0       	breq	.+30     	; 0x4be2 <vfprintf+0xa4>
    4bc4:	38 f4       	brcc	.+14     	; 0x4bd4 <vfprintf+0x96>
    4bc6:	80 32       	cpi	r24, 0x20	; 32
    4bc8:	79 f0       	breq	.+30     	; 0x4be8 <vfprintf+0xaa>
    4bca:	83 32       	cpi	r24, 0x23	; 35
    4bcc:	a1 f4       	brne	.+40     	; 0x4bf6 <vfprintf+0xb8>
    4bce:	23 2d       	mov	r18, r3
    4bd0:	20 61       	ori	r18, 0x10	; 16
    4bd2:	1d c0       	rjmp	.+58     	; 0x4c0e <vfprintf+0xd0>
    4bd4:	8d 32       	cpi	r24, 0x2D	; 45
    4bd6:	61 f0       	breq	.+24     	; 0x4bf0 <vfprintf+0xb2>
    4bd8:	80 33       	cpi	r24, 0x30	; 48
    4bda:	69 f4       	brne	.+26     	; 0x4bf6 <vfprintf+0xb8>
    4bdc:	23 2d       	mov	r18, r3
    4bde:	21 60       	ori	r18, 0x01	; 1
    4be0:	16 c0       	rjmp	.+44     	; 0x4c0e <vfprintf+0xd0>
    4be2:	83 2d       	mov	r24, r3
    4be4:	82 60       	ori	r24, 0x02	; 2
    4be6:	38 2e       	mov	r3, r24
    4be8:	e3 2d       	mov	r30, r3
    4bea:	e4 60       	ori	r30, 0x04	; 4
    4bec:	3e 2e       	mov	r3, r30
    4bee:	2a c0       	rjmp	.+84     	; 0x4c44 <vfprintf+0x106>
    4bf0:	f3 2d       	mov	r31, r3
    4bf2:	f8 60       	ori	r31, 0x08	; 8
    4bf4:	1d c0       	rjmp	.+58     	; 0x4c30 <vfprintf+0xf2>
    4bf6:	37 fc       	sbrc	r3, 7
    4bf8:	2d c0       	rjmp	.+90     	; 0x4c54 <vfprintf+0x116>
    4bfa:	20 ed       	ldi	r18, 0xD0	; 208
    4bfc:	28 0f       	add	r18, r24
    4bfe:	2a 30       	cpi	r18, 0x0A	; 10
    4c00:	40 f0       	brcs	.+16     	; 0x4c12 <vfprintf+0xd4>
    4c02:	8e 32       	cpi	r24, 0x2E	; 46
    4c04:	b9 f4       	brne	.+46     	; 0x4c34 <vfprintf+0xf6>
    4c06:	36 fc       	sbrc	r3, 6
    4c08:	75 c1       	rjmp	.+746    	; 0x4ef4 <vfprintf+0x3b6>
    4c0a:	23 2d       	mov	r18, r3
    4c0c:	20 64       	ori	r18, 0x40	; 64
    4c0e:	32 2e       	mov	r3, r18
    4c10:	19 c0       	rjmp	.+50     	; 0x4c44 <vfprintf+0x106>
    4c12:	36 fe       	sbrs	r3, 6
    4c14:	06 c0       	rjmp	.+12     	; 0x4c22 <vfprintf+0xe4>
    4c16:	8a e0       	ldi	r24, 0x0A	; 10
    4c18:	98 9e       	mul	r9, r24
    4c1a:	20 0d       	add	r18, r0
    4c1c:	11 24       	eor	r1, r1
    4c1e:	92 2e       	mov	r9, r18
    4c20:	11 c0       	rjmp	.+34     	; 0x4c44 <vfprintf+0x106>
    4c22:	ea e0       	ldi	r30, 0x0A	; 10
    4c24:	2e 9e       	mul	r2, r30
    4c26:	20 0d       	add	r18, r0
    4c28:	11 24       	eor	r1, r1
    4c2a:	22 2e       	mov	r2, r18
    4c2c:	f3 2d       	mov	r31, r3
    4c2e:	f0 62       	ori	r31, 0x20	; 32
    4c30:	3f 2e       	mov	r3, r31
    4c32:	08 c0       	rjmp	.+16     	; 0x4c44 <vfprintf+0x106>
    4c34:	8c 36       	cpi	r24, 0x6C	; 108
    4c36:	21 f4       	brne	.+8      	; 0x4c40 <vfprintf+0x102>
    4c38:	83 2d       	mov	r24, r3
    4c3a:	80 68       	ori	r24, 0x80	; 128
    4c3c:	38 2e       	mov	r3, r24
    4c3e:	02 c0       	rjmp	.+4      	; 0x4c44 <vfprintf+0x106>
    4c40:	88 36       	cpi	r24, 0x68	; 104
    4c42:	41 f4       	brne	.+16     	; 0x4c54 <vfprintf+0x116>
    4c44:	f7 01       	movw	r30, r14
    4c46:	93 fd       	sbrc	r25, 3
    4c48:	85 91       	lpm	r24, Z+
    4c4a:	93 ff       	sbrs	r25, 3
    4c4c:	81 91       	ld	r24, Z+
    4c4e:	7f 01       	movw	r14, r30
    4c50:	81 11       	cpse	r24, r1
    4c52:	b3 cf       	rjmp	.-154    	; 0x4bba <vfprintf+0x7c>
    4c54:	98 2f       	mov	r25, r24
    4c56:	9f 7d       	andi	r25, 0xDF	; 223
    4c58:	95 54       	subi	r25, 0x45	; 69
    4c5a:	93 30       	cpi	r25, 0x03	; 3
    4c5c:	28 f4       	brcc	.+10     	; 0x4c68 <vfprintf+0x12a>
    4c5e:	0c 5f       	subi	r16, 0xFC	; 252
    4c60:	1f 4f       	sbci	r17, 0xFF	; 255
    4c62:	9f e3       	ldi	r25, 0x3F	; 63
    4c64:	99 83       	std	Y+1, r25	; 0x01
    4c66:	0d c0       	rjmp	.+26     	; 0x4c82 <vfprintf+0x144>
    4c68:	83 36       	cpi	r24, 0x63	; 99
    4c6a:	31 f0       	breq	.+12     	; 0x4c78 <vfprintf+0x13a>
    4c6c:	83 37       	cpi	r24, 0x73	; 115
    4c6e:	71 f0       	breq	.+28     	; 0x4c8c <vfprintf+0x14e>
    4c70:	83 35       	cpi	r24, 0x53	; 83
    4c72:	09 f0       	breq	.+2      	; 0x4c76 <vfprintf+0x138>
    4c74:	55 c0       	rjmp	.+170    	; 0x4d20 <vfprintf+0x1e2>
    4c76:	20 c0       	rjmp	.+64     	; 0x4cb8 <vfprintf+0x17a>
    4c78:	f8 01       	movw	r30, r16
    4c7a:	80 81       	ld	r24, Z
    4c7c:	89 83       	std	Y+1, r24	; 0x01
    4c7e:	0e 5f       	subi	r16, 0xFE	; 254
    4c80:	1f 4f       	sbci	r17, 0xFF	; 255
    4c82:	88 24       	eor	r8, r8
    4c84:	83 94       	inc	r8
    4c86:	91 2c       	mov	r9, r1
    4c88:	53 01       	movw	r10, r6
    4c8a:	12 c0       	rjmp	.+36     	; 0x4cb0 <vfprintf+0x172>
    4c8c:	28 01       	movw	r4, r16
    4c8e:	f2 e0       	ldi	r31, 0x02	; 2
    4c90:	4f 0e       	add	r4, r31
    4c92:	51 1c       	adc	r5, r1
    4c94:	f8 01       	movw	r30, r16
    4c96:	a0 80       	ld	r10, Z
    4c98:	b1 80       	ldd	r11, Z+1	; 0x01
    4c9a:	36 fe       	sbrs	r3, 6
    4c9c:	03 c0       	rjmp	.+6      	; 0x4ca4 <vfprintf+0x166>
    4c9e:	69 2d       	mov	r22, r9
    4ca0:	70 e0       	ldi	r23, 0x00	; 0
    4ca2:	02 c0       	rjmp	.+4      	; 0x4ca8 <vfprintf+0x16a>
    4ca4:	6f ef       	ldi	r22, 0xFF	; 255
    4ca6:	7f ef       	ldi	r23, 0xFF	; 255
    4ca8:	c5 01       	movw	r24, r10
    4caa:	21 d4       	rcall	.+2114   	; 0x54ee <strnlen>
    4cac:	4c 01       	movw	r8, r24
    4cae:	82 01       	movw	r16, r4
    4cb0:	f3 2d       	mov	r31, r3
    4cb2:	ff 77       	andi	r31, 0x7F	; 127
    4cb4:	3f 2e       	mov	r3, r31
    4cb6:	15 c0       	rjmp	.+42     	; 0x4ce2 <vfprintf+0x1a4>
    4cb8:	28 01       	movw	r4, r16
    4cba:	22 e0       	ldi	r18, 0x02	; 2
    4cbc:	42 0e       	add	r4, r18
    4cbe:	51 1c       	adc	r5, r1
    4cc0:	f8 01       	movw	r30, r16
    4cc2:	a0 80       	ld	r10, Z
    4cc4:	b1 80       	ldd	r11, Z+1	; 0x01
    4cc6:	36 fe       	sbrs	r3, 6
    4cc8:	03 c0       	rjmp	.+6      	; 0x4cd0 <vfprintf+0x192>
    4cca:	69 2d       	mov	r22, r9
    4ccc:	70 e0       	ldi	r23, 0x00	; 0
    4cce:	02 c0       	rjmp	.+4      	; 0x4cd4 <vfprintf+0x196>
    4cd0:	6f ef       	ldi	r22, 0xFF	; 255
    4cd2:	7f ef       	ldi	r23, 0xFF	; 255
    4cd4:	c5 01       	movw	r24, r10
    4cd6:	00 d4       	rcall	.+2048   	; 0x54d8 <strnlen_P>
    4cd8:	4c 01       	movw	r8, r24
    4cda:	f3 2d       	mov	r31, r3
    4cdc:	f0 68       	ori	r31, 0x80	; 128
    4cde:	3f 2e       	mov	r3, r31
    4ce0:	82 01       	movw	r16, r4
    4ce2:	33 fc       	sbrc	r3, 3
    4ce4:	19 c0       	rjmp	.+50     	; 0x4d18 <vfprintf+0x1da>
    4ce6:	82 2d       	mov	r24, r2
    4ce8:	90 e0       	ldi	r25, 0x00	; 0
    4cea:	88 16       	cp	r8, r24
    4cec:	99 06       	cpc	r9, r25
    4cee:	a0 f4       	brcc	.+40     	; 0x4d18 <vfprintf+0x1da>
    4cf0:	b6 01       	movw	r22, r12
    4cf2:	80 e2       	ldi	r24, 0x20	; 32
    4cf4:	90 e0       	ldi	r25, 0x00	; 0
    4cf6:	44 d4       	rcall	.+2184   	; 0x5580 <fputc>
    4cf8:	2a 94       	dec	r2
    4cfa:	f5 cf       	rjmp	.-22     	; 0x4ce6 <vfprintf+0x1a8>
    4cfc:	f5 01       	movw	r30, r10
    4cfe:	37 fc       	sbrc	r3, 7
    4d00:	85 91       	lpm	r24, Z+
    4d02:	37 fe       	sbrs	r3, 7
    4d04:	81 91       	ld	r24, Z+
    4d06:	5f 01       	movw	r10, r30
    4d08:	b6 01       	movw	r22, r12
    4d0a:	90 e0       	ldi	r25, 0x00	; 0
    4d0c:	39 d4       	rcall	.+2162   	; 0x5580 <fputc>
    4d0e:	21 10       	cpse	r2, r1
    4d10:	2a 94       	dec	r2
    4d12:	21 e0       	ldi	r18, 0x01	; 1
    4d14:	82 1a       	sub	r8, r18
    4d16:	91 08       	sbc	r9, r1
    4d18:	81 14       	cp	r8, r1
    4d1a:	91 04       	cpc	r9, r1
    4d1c:	79 f7       	brne	.-34     	; 0x4cfc <vfprintf+0x1be>
    4d1e:	e1 c0       	rjmp	.+450    	; 0x4ee2 <vfprintf+0x3a4>
    4d20:	84 36       	cpi	r24, 0x64	; 100
    4d22:	11 f0       	breq	.+4      	; 0x4d28 <vfprintf+0x1ea>
    4d24:	89 36       	cpi	r24, 0x69	; 105
    4d26:	39 f5       	brne	.+78     	; 0x4d76 <vfprintf+0x238>
    4d28:	f8 01       	movw	r30, r16
    4d2a:	37 fe       	sbrs	r3, 7
    4d2c:	07 c0       	rjmp	.+14     	; 0x4d3c <vfprintf+0x1fe>
    4d2e:	60 81       	ld	r22, Z
    4d30:	71 81       	ldd	r23, Z+1	; 0x01
    4d32:	82 81       	ldd	r24, Z+2	; 0x02
    4d34:	93 81       	ldd	r25, Z+3	; 0x03
    4d36:	0c 5f       	subi	r16, 0xFC	; 252
    4d38:	1f 4f       	sbci	r17, 0xFF	; 255
    4d3a:	08 c0       	rjmp	.+16     	; 0x4d4c <vfprintf+0x20e>
    4d3c:	60 81       	ld	r22, Z
    4d3e:	71 81       	ldd	r23, Z+1	; 0x01
    4d40:	07 2e       	mov	r0, r23
    4d42:	00 0c       	add	r0, r0
    4d44:	88 0b       	sbc	r24, r24
    4d46:	99 0b       	sbc	r25, r25
    4d48:	0e 5f       	subi	r16, 0xFE	; 254
    4d4a:	1f 4f       	sbci	r17, 0xFF	; 255
    4d4c:	f3 2d       	mov	r31, r3
    4d4e:	ff 76       	andi	r31, 0x6F	; 111
    4d50:	3f 2e       	mov	r3, r31
    4d52:	97 ff       	sbrs	r25, 7
    4d54:	09 c0       	rjmp	.+18     	; 0x4d68 <vfprintf+0x22a>
    4d56:	90 95       	com	r25
    4d58:	80 95       	com	r24
    4d5a:	70 95       	com	r23
    4d5c:	61 95       	neg	r22
    4d5e:	7f 4f       	sbci	r23, 0xFF	; 255
    4d60:	8f 4f       	sbci	r24, 0xFF	; 255
    4d62:	9f 4f       	sbci	r25, 0xFF	; 255
    4d64:	f0 68       	ori	r31, 0x80	; 128
    4d66:	3f 2e       	mov	r3, r31
    4d68:	2a e0       	ldi	r18, 0x0A	; 10
    4d6a:	30 e0       	ldi	r19, 0x00	; 0
    4d6c:	a3 01       	movw	r20, r6
    4d6e:	5d d4       	rcall	.+2234   	; 0x562a <__ultoa_invert>
    4d70:	88 2e       	mov	r8, r24
    4d72:	86 18       	sub	r8, r6
    4d74:	44 c0       	rjmp	.+136    	; 0x4dfe <vfprintf+0x2c0>
    4d76:	85 37       	cpi	r24, 0x75	; 117
    4d78:	31 f4       	brne	.+12     	; 0x4d86 <vfprintf+0x248>
    4d7a:	23 2d       	mov	r18, r3
    4d7c:	2f 7e       	andi	r18, 0xEF	; 239
    4d7e:	b2 2e       	mov	r11, r18
    4d80:	2a e0       	ldi	r18, 0x0A	; 10
    4d82:	30 e0       	ldi	r19, 0x00	; 0
    4d84:	25 c0       	rjmp	.+74     	; 0x4dd0 <vfprintf+0x292>
    4d86:	93 2d       	mov	r25, r3
    4d88:	99 7f       	andi	r25, 0xF9	; 249
    4d8a:	b9 2e       	mov	r11, r25
    4d8c:	8f 36       	cpi	r24, 0x6F	; 111
    4d8e:	c1 f0       	breq	.+48     	; 0x4dc0 <vfprintf+0x282>
    4d90:	18 f4       	brcc	.+6      	; 0x4d98 <vfprintf+0x25a>
    4d92:	88 35       	cpi	r24, 0x58	; 88
    4d94:	79 f0       	breq	.+30     	; 0x4db4 <vfprintf+0x276>
    4d96:	ae c0       	rjmp	.+348    	; 0x4ef4 <vfprintf+0x3b6>
    4d98:	80 37       	cpi	r24, 0x70	; 112
    4d9a:	19 f0       	breq	.+6      	; 0x4da2 <vfprintf+0x264>
    4d9c:	88 37       	cpi	r24, 0x78	; 120
    4d9e:	21 f0       	breq	.+8      	; 0x4da8 <vfprintf+0x26a>
    4da0:	a9 c0       	rjmp	.+338    	; 0x4ef4 <vfprintf+0x3b6>
    4da2:	e9 2f       	mov	r30, r25
    4da4:	e0 61       	ori	r30, 0x10	; 16
    4da6:	be 2e       	mov	r11, r30
    4da8:	b4 fe       	sbrs	r11, 4
    4daa:	0d c0       	rjmp	.+26     	; 0x4dc6 <vfprintf+0x288>
    4dac:	fb 2d       	mov	r31, r11
    4dae:	f4 60       	ori	r31, 0x04	; 4
    4db0:	bf 2e       	mov	r11, r31
    4db2:	09 c0       	rjmp	.+18     	; 0x4dc6 <vfprintf+0x288>
    4db4:	34 fe       	sbrs	r3, 4
    4db6:	0a c0       	rjmp	.+20     	; 0x4dcc <vfprintf+0x28e>
    4db8:	29 2f       	mov	r18, r25
    4dba:	26 60       	ori	r18, 0x06	; 6
    4dbc:	b2 2e       	mov	r11, r18
    4dbe:	06 c0       	rjmp	.+12     	; 0x4dcc <vfprintf+0x28e>
    4dc0:	28 e0       	ldi	r18, 0x08	; 8
    4dc2:	30 e0       	ldi	r19, 0x00	; 0
    4dc4:	05 c0       	rjmp	.+10     	; 0x4dd0 <vfprintf+0x292>
    4dc6:	20 e1       	ldi	r18, 0x10	; 16
    4dc8:	30 e0       	ldi	r19, 0x00	; 0
    4dca:	02 c0       	rjmp	.+4      	; 0x4dd0 <vfprintf+0x292>
    4dcc:	20 e1       	ldi	r18, 0x10	; 16
    4dce:	32 e0       	ldi	r19, 0x02	; 2
    4dd0:	f8 01       	movw	r30, r16
    4dd2:	b7 fe       	sbrs	r11, 7
    4dd4:	07 c0       	rjmp	.+14     	; 0x4de4 <vfprintf+0x2a6>
    4dd6:	60 81       	ld	r22, Z
    4dd8:	71 81       	ldd	r23, Z+1	; 0x01
    4dda:	82 81       	ldd	r24, Z+2	; 0x02
    4ddc:	93 81       	ldd	r25, Z+3	; 0x03
    4dde:	0c 5f       	subi	r16, 0xFC	; 252
    4de0:	1f 4f       	sbci	r17, 0xFF	; 255
    4de2:	06 c0       	rjmp	.+12     	; 0x4df0 <vfprintf+0x2b2>
    4de4:	60 81       	ld	r22, Z
    4de6:	71 81       	ldd	r23, Z+1	; 0x01
    4de8:	80 e0       	ldi	r24, 0x00	; 0
    4dea:	90 e0       	ldi	r25, 0x00	; 0
    4dec:	0e 5f       	subi	r16, 0xFE	; 254
    4dee:	1f 4f       	sbci	r17, 0xFF	; 255
    4df0:	a3 01       	movw	r20, r6
    4df2:	1b d4       	rcall	.+2102   	; 0x562a <__ultoa_invert>
    4df4:	88 2e       	mov	r8, r24
    4df6:	86 18       	sub	r8, r6
    4df8:	fb 2d       	mov	r31, r11
    4dfa:	ff 77       	andi	r31, 0x7F	; 127
    4dfc:	3f 2e       	mov	r3, r31
    4dfe:	36 fe       	sbrs	r3, 6
    4e00:	0d c0       	rjmp	.+26     	; 0x4e1c <vfprintf+0x2de>
    4e02:	23 2d       	mov	r18, r3
    4e04:	2e 7f       	andi	r18, 0xFE	; 254
    4e06:	a2 2e       	mov	r10, r18
    4e08:	89 14       	cp	r8, r9
    4e0a:	58 f4       	brcc	.+22     	; 0x4e22 <vfprintf+0x2e4>
    4e0c:	34 fe       	sbrs	r3, 4
    4e0e:	0b c0       	rjmp	.+22     	; 0x4e26 <vfprintf+0x2e8>
    4e10:	32 fc       	sbrc	r3, 2
    4e12:	09 c0       	rjmp	.+18     	; 0x4e26 <vfprintf+0x2e8>
    4e14:	83 2d       	mov	r24, r3
    4e16:	8e 7e       	andi	r24, 0xEE	; 238
    4e18:	a8 2e       	mov	r10, r24
    4e1a:	05 c0       	rjmp	.+10     	; 0x4e26 <vfprintf+0x2e8>
    4e1c:	b8 2c       	mov	r11, r8
    4e1e:	a3 2c       	mov	r10, r3
    4e20:	03 c0       	rjmp	.+6      	; 0x4e28 <vfprintf+0x2ea>
    4e22:	b8 2c       	mov	r11, r8
    4e24:	01 c0       	rjmp	.+2      	; 0x4e28 <vfprintf+0x2ea>
    4e26:	b9 2c       	mov	r11, r9
    4e28:	a4 fe       	sbrs	r10, 4
    4e2a:	0f c0       	rjmp	.+30     	; 0x4e4a <vfprintf+0x30c>
    4e2c:	fe 01       	movw	r30, r28
    4e2e:	e8 0d       	add	r30, r8
    4e30:	f1 1d       	adc	r31, r1
    4e32:	80 81       	ld	r24, Z
    4e34:	80 33       	cpi	r24, 0x30	; 48
    4e36:	21 f4       	brne	.+8      	; 0x4e40 <vfprintf+0x302>
    4e38:	9a 2d       	mov	r25, r10
    4e3a:	99 7e       	andi	r25, 0xE9	; 233
    4e3c:	a9 2e       	mov	r10, r25
    4e3e:	09 c0       	rjmp	.+18     	; 0x4e52 <vfprintf+0x314>
    4e40:	a2 fe       	sbrs	r10, 2
    4e42:	06 c0       	rjmp	.+12     	; 0x4e50 <vfprintf+0x312>
    4e44:	b3 94       	inc	r11
    4e46:	b3 94       	inc	r11
    4e48:	04 c0       	rjmp	.+8      	; 0x4e52 <vfprintf+0x314>
    4e4a:	8a 2d       	mov	r24, r10
    4e4c:	86 78       	andi	r24, 0x86	; 134
    4e4e:	09 f0       	breq	.+2      	; 0x4e52 <vfprintf+0x314>
    4e50:	b3 94       	inc	r11
    4e52:	a3 fc       	sbrc	r10, 3
    4e54:	10 c0       	rjmp	.+32     	; 0x4e76 <vfprintf+0x338>
    4e56:	a0 fe       	sbrs	r10, 0
    4e58:	06 c0       	rjmp	.+12     	; 0x4e66 <vfprintf+0x328>
    4e5a:	b2 14       	cp	r11, r2
    4e5c:	80 f4       	brcc	.+32     	; 0x4e7e <vfprintf+0x340>
    4e5e:	28 0c       	add	r2, r8
    4e60:	92 2c       	mov	r9, r2
    4e62:	9b 18       	sub	r9, r11
    4e64:	0d c0       	rjmp	.+26     	; 0x4e80 <vfprintf+0x342>
    4e66:	b2 14       	cp	r11, r2
    4e68:	58 f4       	brcc	.+22     	; 0x4e80 <vfprintf+0x342>
    4e6a:	b6 01       	movw	r22, r12
    4e6c:	80 e2       	ldi	r24, 0x20	; 32
    4e6e:	90 e0       	ldi	r25, 0x00	; 0
    4e70:	87 d3       	rcall	.+1806   	; 0x5580 <fputc>
    4e72:	b3 94       	inc	r11
    4e74:	f8 cf       	rjmp	.-16     	; 0x4e66 <vfprintf+0x328>
    4e76:	b2 14       	cp	r11, r2
    4e78:	18 f4       	brcc	.+6      	; 0x4e80 <vfprintf+0x342>
    4e7a:	2b 18       	sub	r2, r11
    4e7c:	02 c0       	rjmp	.+4      	; 0x4e82 <vfprintf+0x344>
    4e7e:	98 2c       	mov	r9, r8
    4e80:	21 2c       	mov	r2, r1
    4e82:	a4 fe       	sbrs	r10, 4
    4e84:	0f c0       	rjmp	.+30     	; 0x4ea4 <vfprintf+0x366>
    4e86:	b6 01       	movw	r22, r12
    4e88:	80 e3       	ldi	r24, 0x30	; 48
    4e8a:	90 e0       	ldi	r25, 0x00	; 0
    4e8c:	79 d3       	rcall	.+1778   	; 0x5580 <fputc>
    4e8e:	a2 fe       	sbrs	r10, 2
    4e90:	16 c0       	rjmp	.+44     	; 0x4ebe <vfprintf+0x380>
    4e92:	a1 fc       	sbrc	r10, 1
    4e94:	03 c0       	rjmp	.+6      	; 0x4e9c <vfprintf+0x35e>
    4e96:	88 e7       	ldi	r24, 0x78	; 120
    4e98:	90 e0       	ldi	r25, 0x00	; 0
    4e9a:	02 c0       	rjmp	.+4      	; 0x4ea0 <vfprintf+0x362>
    4e9c:	88 e5       	ldi	r24, 0x58	; 88
    4e9e:	90 e0       	ldi	r25, 0x00	; 0
    4ea0:	b6 01       	movw	r22, r12
    4ea2:	0c c0       	rjmp	.+24     	; 0x4ebc <vfprintf+0x37e>
    4ea4:	8a 2d       	mov	r24, r10
    4ea6:	86 78       	andi	r24, 0x86	; 134
    4ea8:	51 f0       	breq	.+20     	; 0x4ebe <vfprintf+0x380>
    4eaa:	a1 fe       	sbrs	r10, 1
    4eac:	02 c0       	rjmp	.+4      	; 0x4eb2 <vfprintf+0x374>
    4eae:	8b e2       	ldi	r24, 0x2B	; 43
    4eb0:	01 c0       	rjmp	.+2      	; 0x4eb4 <vfprintf+0x376>
    4eb2:	80 e2       	ldi	r24, 0x20	; 32
    4eb4:	a7 fc       	sbrc	r10, 7
    4eb6:	8d e2       	ldi	r24, 0x2D	; 45
    4eb8:	b6 01       	movw	r22, r12
    4eba:	90 e0       	ldi	r25, 0x00	; 0
    4ebc:	61 d3       	rcall	.+1730   	; 0x5580 <fputc>
    4ebe:	89 14       	cp	r8, r9
    4ec0:	30 f4       	brcc	.+12     	; 0x4ece <vfprintf+0x390>
    4ec2:	b6 01       	movw	r22, r12
    4ec4:	80 e3       	ldi	r24, 0x30	; 48
    4ec6:	90 e0       	ldi	r25, 0x00	; 0
    4ec8:	5b d3       	rcall	.+1718   	; 0x5580 <fputc>
    4eca:	9a 94       	dec	r9
    4ecc:	f8 cf       	rjmp	.-16     	; 0x4ebe <vfprintf+0x380>
    4ece:	8a 94       	dec	r8
    4ed0:	f3 01       	movw	r30, r6
    4ed2:	e8 0d       	add	r30, r8
    4ed4:	f1 1d       	adc	r31, r1
    4ed6:	80 81       	ld	r24, Z
    4ed8:	b6 01       	movw	r22, r12
    4eda:	90 e0       	ldi	r25, 0x00	; 0
    4edc:	51 d3       	rcall	.+1698   	; 0x5580 <fputc>
    4ede:	81 10       	cpse	r8, r1
    4ee0:	f6 cf       	rjmp	.-20     	; 0x4ece <vfprintf+0x390>
    4ee2:	22 20       	and	r2, r2
    4ee4:	09 f4       	brne	.+2      	; 0x4ee8 <vfprintf+0x3aa>
    4ee6:	4e ce       	rjmp	.-868    	; 0x4b84 <vfprintf+0x46>
    4ee8:	b6 01       	movw	r22, r12
    4eea:	80 e2       	ldi	r24, 0x20	; 32
    4eec:	90 e0       	ldi	r25, 0x00	; 0
    4eee:	48 d3       	rcall	.+1680   	; 0x5580 <fputc>
    4ef0:	2a 94       	dec	r2
    4ef2:	f7 cf       	rjmp	.-18     	; 0x4ee2 <vfprintf+0x3a4>
    4ef4:	f6 01       	movw	r30, r12
    4ef6:	86 81       	ldd	r24, Z+6	; 0x06
    4ef8:	97 81       	ldd	r25, Z+7	; 0x07
    4efa:	02 c0       	rjmp	.+4      	; 0x4f00 <vfprintf+0x3c2>
    4efc:	8f ef       	ldi	r24, 0xFF	; 255
    4efe:	9f ef       	ldi	r25, 0xFF	; 255
    4f00:	2b 96       	adiw	r28, 0x0b	; 11
    4f02:	cd bf       	out	0x3d, r28	; 61
    4f04:	de bf       	out	0x3e, r29	; 62
    4f06:	df 91       	pop	r29
    4f08:	cf 91       	pop	r28
    4f0a:	1f 91       	pop	r17
    4f0c:	0f 91       	pop	r16
    4f0e:	ff 90       	pop	r15
    4f10:	ef 90       	pop	r14
    4f12:	df 90       	pop	r13
    4f14:	cf 90       	pop	r12
    4f16:	bf 90       	pop	r11
    4f18:	af 90       	pop	r10
    4f1a:	9f 90       	pop	r9
    4f1c:	8f 90       	pop	r8
    4f1e:	7f 90       	pop	r7
    4f20:	6f 90       	pop	r6
    4f22:	5f 90       	pop	r5
    4f24:	4f 90       	pop	r4
    4f26:	3f 90       	pop	r3
    4f28:	2f 90       	pop	r2
    4f2a:	08 95       	ret

00004f2c <putval>:
    4f2c:	20 fd       	sbrc	r18, 0
    4f2e:	09 c0       	rjmp	.+18     	; 0x4f42 <putval+0x16>
    4f30:	fc 01       	movw	r30, r24
    4f32:	23 fd       	sbrc	r18, 3
    4f34:	05 c0       	rjmp	.+10     	; 0x4f40 <putval+0x14>
    4f36:	22 ff       	sbrs	r18, 2
    4f38:	02 c0       	rjmp	.+4      	; 0x4f3e <putval+0x12>
    4f3a:	73 83       	std	Z+3, r23	; 0x03
    4f3c:	62 83       	std	Z+2, r22	; 0x02
    4f3e:	51 83       	std	Z+1, r21	; 0x01
    4f40:	40 83       	st	Z, r20
    4f42:	08 95       	ret

00004f44 <mulacc>:
    4f44:	44 fd       	sbrc	r20, 4
    4f46:	17 c0       	rjmp	.+46     	; 0x4f76 <mulacc+0x32>
    4f48:	46 fd       	sbrc	r20, 6
    4f4a:	17 c0       	rjmp	.+46     	; 0x4f7a <mulacc+0x36>
    4f4c:	ab 01       	movw	r20, r22
    4f4e:	bc 01       	movw	r22, r24
    4f50:	da 01       	movw	r26, r20
    4f52:	fb 01       	movw	r30, r22
    4f54:	aa 0f       	add	r26, r26
    4f56:	bb 1f       	adc	r27, r27
    4f58:	ee 1f       	adc	r30, r30
    4f5a:	ff 1f       	adc	r31, r31
    4f5c:	10 94       	com	r1
    4f5e:	d1 f7       	brne	.-12     	; 0x4f54 <mulacc+0x10>
    4f60:	4a 0f       	add	r20, r26
    4f62:	5b 1f       	adc	r21, r27
    4f64:	6e 1f       	adc	r22, r30
    4f66:	7f 1f       	adc	r23, r31
    4f68:	cb 01       	movw	r24, r22
    4f6a:	ba 01       	movw	r22, r20
    4f6c:	66 0f       	add	r22, r22
    4f6e:	77 1f       	adc	r23, r23
    4f70:	88 1f       	adc	r24, r24
    4f72:	99 1f       	adc	r25, r25
    4f74:	09 c0       	rjmp	.+18     	; 0x4f88 <mulacc+0x44>
    4f76:	33 e0       	ldi	r19, 0x03	; 3
    4f78:	01 c0       	rjmp	.+2      	; 0x4f7c <mulacc+0x38>
    4f7a:	34 e0       	ldi	r19, 0x04	; 4
    4f7c:	66 0f       	add	r22, r22
    4f7e:	77 1f       	adc	r23, r23
    4f80:	88 1f       	adc	r24, r24
    4f82:	99 1f       	adc	r25, r25
    4f84:	31 50       	subi	r19, 0x01	; 1
    4f86:	d1 f7       	brne	.-12     	; 0x4f7c <mulacc+0x38>
    4f88:	62 0f       	add	r22, r18
    4f8a:	71 1d       	adc	r23, r1
    4f8c:	81 1d       	adc	r24, r1
    4f8e:	91 1d       	adc	r25, r1
    4f90:	08 95       	ret

00004f92 <skip_spaces>:
    4f92:	0f 93       	push	r16
    4f94:	1f 93       	push	r17
    4f96:	cf 93       	push	r28
    4f98:	df 93       	push	r29
    4f9a:	8c 01       	movw	r16, r24
    4f9c:	c8 01       	movw	r24, r16
    4f9e:	b2 d2       	rcall	.+1380   	; 0x5504 <fgetc>
    4fa0:	ec 01       	movw	r28, r24
    4fa2:	97 fd       	sbrc	r25, 7
    4fa4:	06 c0       	rjmp	.+12     	; 0x4fb2 <skip_spaces+0x20>
    4fa6:	85 d2       	rcall	.+1290   	; 0x54b2 <isspace>
    4fa8:	89 2b       	or	r24, r25
    4faa:	c1 f7       	brne	.-16     	; 0x4f9c <skip_spaces+0xa>
    4fac:	b8 01       	movw	r22, r16
    4fae:	ce 01       	movw	r24, r28
    4fb0:	23 d3       	rcall	.+1606   	; 0x55f8 <ungetc>
    4fb2:	ce 01       	movw	r24, r28
    4fb4:	df 91       	pop	r29
    4fb6:	cf 91       	pop	r28
    4fb8:	1f 91       	pop	r17
    4fba:	0f 91       	pop	r16
    4fbc:	08 95       	ret

00004fbe <conv_int>:
    4fbe:	8f 92       	push	r8
    4fc0:	9f 92       	push	r9
    4fc2:	af 92       	push	r10
    4fc4:	bf 92       	push	r11
    4fc6:	ef 92       	push	r14
    4fc8:	ff 92       	push	r15
    4fca:	0f 93       	push	r16
    4fcc:	1f 93       	push	r17
    4fce:	cf 93       	push	r28
    4fd0:	df 93       	push	r29
    4fd2:	8c 01       	movw	r16, r24
    4fd4:	d6 2f       	mov	r29, r22
    4fd6:	7a 01       	movw	r14, r20
    4fd8:	b2 2e       	mov	r11, r18
    4fda:	94 d2       	rcall	.+1320   	; 0x5504 <fgetc>
    4fdc:	9c 01       	movw	r18, r24
    4fde:	33 27       	eor	r19, r19
    4fe0:	2b 32       	cpi	r18, 0x2B	; 43
    4fe2:	31 05       	cpc	r19, r1
    4fe4:	31 f0       	breq	.+12     	; 0x4ff2 <conv_int+0x34>
    4fe6:	2d 32       	cpi	r18, 0x2D	; 45
    4fe8:	31 05       	cpc	r19, r1
    4fea:	59 f4       	brne	.+22     	; 0x5002 <conv_int+0x44>
    4fec:	8b 2d       	mov	r24, r11
    4fee:	80 68       	ori	r24, 0x80	; 128
    4ff0:	b8 2e       	mov	r11, r24
    4ff2:	d1 50       	subi	r29, 0x01	; 1
    4ff4:	11 f4       	brne	.+4      	; 0x4ffa <conv_int+0x3c>
    4ff6:	80 e0       	ldi	r24, 0x00	; 0
    4ff8:	61 c0       	rjmp	.+194    	; 0x50bc <conv_int+0xfe>
    4ffa:	c8 01       	movw	r24, r16
    4ffc:	83 d2       	rcall	.+1286   	; 0x5504 <fgetc>
    4ffe:	97 fd       	sbrc	r25, 7
    5000:	fa cf       	rjmp	.-12     	; 0x4ff6 <conv_int+0x38>
    5002:	cb 2d       	mov	r28, r11
    5004:	cd 7f       	andi	r28, 0xFD	; 253
    5006:	2b 2d       	mov	r18, r11
    5008:	20 73       	andi	r18, 0x30	; 48
    500a:	f9 f4       	brne	.+62     	; 0x504a <conv_int+0x8c>
    500c:	80 33       	cpi	r24, 0x30	; 48
    500e:	e9 f4       	brne	.+58     	; 0x504a <conv_int+0x8c>
    5010:	aa 24       	eor	r10, r10
    5012:	aa 94       	dec	r10
    5014:	ad 0e       	add	r10, r29
    5016:	09 f4       	brne	.+2      	; 0x501a <conv_int+0x5c>
    5018:	3e c0       	rjmp	.+124    	; 0x5096 <conv_int+0xd8>
    501a:	c8 01       	movw	r24, r16
    501c:	73 d2       	rcall	.+1254   	; 0x5504 <fgetc>
    501e:	97 fd       	sbrc	r25, 7
    5020:	3a c0       	rjmp	.+116    	; 0x5096 <conv_int+0xd8>
    5022:	9c 01       	movw	r18, r24
    5024:	2f 7d       	andi	r18, 0xDF	; 223
    5026:	33 27       	eor	r19, r19
    5028:	28 35       	cpi	r18, 0x58	; 88
    502a:	31 05       	cpc	r19, r1
    502c:	41 f4       	brne	.+16     	; 0x503e <conv_int+0x80>
    502e:	c2 64       	ori	r28, 0x42	; 66
    5030:	d2 50       	subi	r29, 0x02	; 2
    5032:	89 f1       	breq	.+98     	; 0x5096 <conv_int+0xd8>
    5034:	c8 01       	movw	r24, r16
    5036:	66 d2       	rcall	.+1228   	; 0x5504 <fgetc>
    5038:	97 ff       	sbrs	r25, 7
    503a:	07 c0       	rjmp	.+14     	; 0x504a <conv_int+0x8c>
    503c:	2c c0       	rjmp	.+88     	; 0x5096 <conv_int+0xd8>
    503e:	b6 fe       	sbrs	r11, 6
    5040:	02 c0       	rjmp	.+4      	; 0x5046 <conv_int+0x88>
    5042:	c2 60       	ori	r28, 0x02	; 2
    5044:	01 c0       	rjmp	.+2      	; 0x5048 <conv_int+0x8a>
    5046:	c2 61       	ori	r28, 0x12	; 18
    5048:	da 2d       	mov	r29, r10
    504a:	81 2c       	mov	r8, r1
    504c:	91 2c       	mov	r9, r1
    504e:	54 01       	movw	r10, r8
    5050:	20 ed       	ldi	r18, 0xD0	; 208
    5052:	28 0f       	add	r18, r24
    5054:	28 30       	cpi	r18, 0x08	; 8
    5056:	78 f0       	brcs	.+30     	; 0x5076 <conv_int+0xb8>
    5058:	c4 ff       	sbrs	r28, 4
    505a:	03 c0       	rjmp	.+6      	; 0x5062 <conv_int+0xa4>
    505c:	b8 01       	movw	r22, r16
    505e:	cc d2       	rcall	.+1432   	; 0x55f8 <ungetc>
    5060:	17 c0       	rjmp	.+46     	; 0x5090 <conv_int+0xd2>
    5062:	2a 30       	cpi	r18, 0x0A	; 10
    5064:	40 f0       	brcs	.+16     	; 0x5076 <conv_int+0xb8>
    5066:	c6 ff       	sbrs	r28, 6
    5068:	f9 cf       	rjmp	.-14     	; 0x505c <conv_int+0x9e>
    506a:	2f 7d       	andi	r18, 0xDF	; 223
    506c:	3f ee       	ldi	r19, 0xEF	; 239
    506e:	32 0f       	add	r19, r18
    5070:	36 30       	cpi	r19, 0x06	; 6
    5072:	a0 f7       	brcc	.-24     	; 0x505c <conv_int+0x9e>
    5074:	27 50       	subi	r18, 0x07	; 7
    5076:	4c 2f       	mov	r20, r28
    5078:	c5 01       	movw	r24, r10
    507a:	b4 01       	movw	r22, r8
    507c:	63 df       	rcall	.-314    	; 0x4f44 <mulacc>
    507e:	4b 01       	movw	r8, r22
    5080:	5c 01       	movw	r10, r24
    5082:	c2 60       	ori	r28, 0x02	; 2
    5084:	d1 50       	subi	r29, 0x01	; 1
    5086:	51 f0       	breq	.+20     	; 0x509c <conv_int+0xde>
    5088:	c8 01       	movw	r24, r16
    508a:	3c d2       	rcall	.+1144   	; 0x5504 <fgetc>
    508c:	97 ff       	sbrs	r25, 7
    508e:	e0 cf       	rjmp	.-64     	; 0x5050 <conv_int+0x92>
    5090:	c1 fd       	sbrc	r28, 1
    5092:	04 c0       	rjmp	.+8      	; 0x509c <conv_int+0xde>
    5094:	b0 cf       	rjmp	.-160    	; 0x4ff6 <conv_int+0x38>
    5096:	81 2c       	mov	r8, r1
    5098:	91 2c       	mov	r9, r1
    509a:	54 01       	movw	r10, r8
    509c:	c7 ff       	sbrs	r28, 7
    509e:	08 c0       	rjmp	.+16     	; 0x50b0 <conv_int+0xf2>
    50a0:	b0 94       	com	r11
    50a2:	a0 94       	com	r10
    50a4:	90 94       	com	r9
    50a6:	80 94       	com	r8
    50a8:	81 1c       	adc	r8, r1
    50aa:	91 1c       	adc	r9, r1
    50ac:	a1 1c       	adc	r10, r1
    50ae:	b1 1c       	adc	r11, r1
    50b0:	2c 2f       	mov	r18, r28
    50b2:	b5 01       	movw	r22, r10
    50b4:	a4 01       	movw	r20, r8
    50b6:	c7 01       	movw	r24, r14
    50b8:	39 df       	rcall	.-398    	; 0x4f2c <putval>
    50ba:	81 e0       	ldi	r24, 0x01	; 1
    50bc:	df 91       	pop	r29
    50be:	cf 91       	pop	r28
    50c0:	1f 91       	pop	r17
    50c2:	0f 91       	pop	r16
    50c4:	ff 90       	pop	r15
    50c6:	ef 90       	pop	r14
    50c8:	bf 90       	pop	r11
    50ca:	af 90       	pop	r10
    50cc:	9f 90       	pop	r9
    50ce:	8f 90       	pop	r8
    50d0:	08 95       	ret

000050d2 <conv_brk>:
    50d2:	5f 92       	push	r5
    50d4:	6f 92       	push	r6
    50d6:	7f 92       	push	r7
    50d8:	8f 92       	push	r8
    50da:	9f 92       	push	r9
    50dc:	af 92       	push	r10
    50de:	bf 92       	push	r11
    50e0:	cf 92       	push	r12
    50e2:	df 92       	push	r13
    50e4:	ef 92       	push	r14
    50e6:	ff 92       	push	r15
    50e8:	0f 93       	push	r16
    50ea:	1f 93       	push	r17
    50ec:	cf 93       	push	r28
    50ee:	df 93       	push	r29
    50f0:	cd b7       	in	r28, 0x3d	; 61
    50f2:	de b7       	in	r29, 0x3e	; 62
    50f4:	a0 97       	sbiw	r28, 0x20	; 32
    50f6:	cd bf       	out	0x3d, r28	; 61
    50f8:	de bf       	out	0x3e, r29	; 62
    50fa:	5c 01       	movw	r10, r24
    50fc:	96 2e       	mov	r9, r22
    50fe:	7a 01       	movw	r14, r20
    5100:	f9 01       	movw	r30, r18
    5102:	8e 01       	movw	r16, r28
    5104:	0f 5f       	subi	r16, 0xFF	; 255
    5106:	1f 4f       	sbci	r17, 0xFF	; 255
    5108:	68 01       	movw	r12, r16
    510a:	80 e2       	ldi	r24, 0x20	; 32
    510c:	d8 01       	movw	r26, r16
    510e:	1d 92       	st	X+, r1
    5110:	8a 95       	dec	r24
    5112:	e9 f7       	brne	.-6      	; 0x510e <conv_brk+0x3c>
    5114:	d5 01       	movw	r26, r10
    5116:	13 96       	adiw	r26, 0x03	; 3
    5118:	8c 90       	ld	r8, X
    511a:	80 e0       	ldi	r24, 0x00	; 0
    511c:	90 e0       	ldi	r25, 0x00	; 0
    511e:	61 2c       	mov	r6, r1
    5120:	71 2c       	mov	r7, r1
    5122:	30 e0       	ldi	r19, 0x00	; 0
    5124:	61 e0       	ldi	r22, 0x01	; 1
    5126:	70 e0       	ldi	r23, 0x00	; 0
    5128:	83 fc       	sbrc	r8, 3
    512a:	25 91       	lpm	r18, Z+
    512c:	83 fe       	sbrs	r8, 3
    512e:	21 91       	ld	r18, Z+
    5130:	8f 01       	movw	r16, r30
    5132:	52 2e       	mov	r5, r18
    5134:	21 11       	cpse	r18, r1
    5136:	03 c0       	rjmp	.+6      	; 0x513e <conv_brk+0x6c>
    5138:	80 e0       	ldi	r24, 0x00	; 0
    513a:	90 e0       	ldi	r25, 0x00	; 0
    513c:	90 c0       	rjmp	.+288    	; 0x525e <conv_brk+0x18c>
    513e:	2e 35       	cpi	r18, 0x5E	; 94
    5140:	11 f4       	brne	.+4      	; 0x5146 <conv_brk+0x74>
    5142:	00 97       	sbiw	r24, 0x00	; 0
    5144:	51 f1       	breq	.+84     	; 0x519a <conv_brk+0xc8>
    5146:	43 2f       	mov	r20, r19
    5148:	50 e0       	ldi	r21, 0x00	; 0
    514a:	48 17       	cp	r20, r24
    514c:	59 07       	cpc	r21, r25
    514e:	3c f4       	brge	.+14     	; 0x515e <conv_brk+0x8c>
    5150:	2d 35       	cpi	r18, 0x5D	; 93
    5152:	59 f1       	breq	.+86     	; 0x51aa <conv_brk+0xd8>
    5154:	2d 32       	cpi	r18, 0x2D	; 45
    5156:	19 f4       	brne	.+6      	; 0x515e <conv_brk+0x8c>
    5158:	77 20       	and	r7, r7
    515a:	09 f1       	breq	.+66     	; 0x519e <conv_brk+0xcc>
    515c:	03 c0       	rjmp	.+6      	; 0x5164 <conv_brk+0x92>
    515e:	77 20       	and	r7, r7
    5160:	09 f4       	brne	.+2      	; 0x5164 <conv_brk+0x92>
    5162:	68 c0       	rjmp	.+208    	; 0x5234 <conv_brk+0x162>
    5164:	45 2d       	mov	r20, r5
    5166:	46 95       	lsr	r20
    5168:	46 95       	lsr	r20
    516a:	46 95       	lsr	r20
    516c:	d6 01       	movw	r26, r12
    516e:	a4 0f       	add	r26, r20
    5170:	b1 1d       	adc	r27, r1
    5172:	45 2d       	mov	r20, r5
    5174:	47 70       	andi	r20, 0x07	; 7
    5176:	8b 01       	movw	r16, r22
    5178:	02 c0       	rjmp	.+4      	; 0x517e <conv_brk+0xac>
    517a:	00 0f       	add	r16, r16
    517c:	11 1f       	adc	r17, r17
    517e:	4a 95       	dec	r20
    5180:	e2 f7       	brpl	.-8      	; 0x517a <conv_brk+0xa8>
    5182:	a8 01       	movw	r20, r16
    5184:	5c 91       	ld	r21, X
    5186:	45 2b       	or	r20, r21
    5188:	4c 93       	st	X, r20
    518a:	65 14       	cp	r6, r5
    518c:	59 f0       	breq	.+22     	; 0x51a4 <conv_brk+0xd2>
    518e:	56 14       	cp	r5, r6
    5190:	10 f4       	brcc	.+4      	; 0x5196 <conv_brk+0xc4>
    5192:	53 94       	inc	r5
    5194:	e7 cf       	rjmp	.-50     	; 0x5164 <conv_brk+0x92>
    5196:	5a 94       	dec	r5
    5198:	e5 cf       	rjmp	.-54     	; 0x5164 <conv_brk+0x92>
    519a:	31 e0       	ldi	r19, 0x01	; 1
    519c:	04 c0       	rjmp	.+8      	; 0x51a6 <conv_brk+0xd4>
    519e:	77 24       	eor	r7, r7
    51a0:	73 94       	inc	r7
    51a2:	01 c0       	rjmp	.+2      	; 0x51a6 <conv_brk+0xd4>
    51a4:	71 2c       	mov	r7, r1
    51a6:	01 96       	adiw	r24, 0x01	; 1
    51a8:	bf cf       	rjmp	.-130    	; 0x5128 <conv_brk+0x56>
    51aa:	77 20       	and	r7, r7
    51ac:	19 f0       	breq	.+6      	; 0x51b4 <conv_brk+0xe2>
    51ae:	8e 81       	ldd	r24, Y+6	; 0x06
    51b0:	80 62       	ori	r24, 0x20	; 32
    51b2:	8e 83       	std	Y+6, r24	; 0x06
    51b4:	31 11       	cpse	r19, r1
    51b6:	03 c0       	rjmp	.+6      	; 0x51be <conv_brk+0xec>
    51b8:	88 24       	eor	r8, r8
    51ba:	83 94       	inc	r8
    51bc:	17 c0       	rjmp	.+46     	; 0x51ec <conv_brk+0x11a>
    51be:	f6 01       	movw	r30, r12
    51c0:	9e 01       	movw	r18, r28
    51c2:	2f 5d       	subi	r18, 0xDF	; 223
    51c4:	3f 4f       	sbci	r19, 0xFF	; 255
    51c6:	80 81       	ld	r24, Z
    51c8:	80 95       	com	r24
    51ca:	81 93       	st	Z+, r24
    51cc:	2e 17       	cp	r18, r30
    51ce:	3f 07       	cpc	r19, r31
    51d0:	d1 f7       	brne	.-12     	; 0x51c6 <conv_brk+0xf4>
    51d2:	f2 cf       	rjmp	.-28     	; 0x51b8 <conv_brk+0xe6>
    51d4:	e1 14       	cp	r14, r1
    51d6:	f1 04       	cpc	r15, r1
    51d8:	29 f0       	breq	.+10     	; 0x51e4 <conv_brk+0x112>
    51da:	d7 01       	movw	r26, r14
    51dc:	8c 93       	st	X, r24
    51de:	f7 01       	movw	r30, r14
    51e0:	31 96       	adiw	r30, 0x01	; 1
    51e2:	7f 01       	movw	r14, r30
    51e4:	9a 94       	dec	r9
    51e6:	81 2c       	mov	r8, r1
    51e8:	99 20       	and	r9, r9
    51ea:	e9 f0       	breq	.+58     	; 0x5226 <conv_brk+0x154>
    51ec:	c5 01       	movw	r24, r10
    51ee:	8a d1       	rcall	.+788    	; 0x5504 <fgetc>
    51f0:	97 fd       	sbrc	r25, 7
    51f2:	17 c0       	rjmp	.+46     	; 0x5222 <conv_brk+0x150>
    51f4:	fc 01       	movw	r30, r24
    51f6:	ff 27       	eor	r31, r31
    51f8:	23 e0       	ldi	r18, 0x03	; 3
    51fa:	f5 95       	asr	r31
    51fc:	e7 95       	ror	r30
    51fe:	2a 95       	dec	r18
    5200:	e1 f7       	brne	.-8      	; 0x51fa <conv_brk+0x128>
    5202:	ec 0d       	add	r30, r12
    5204:	fd 1d       	adc	r31, r13
    5206:	20 81       	ld	r18, Z
    5208:	30 e0       	ldi	r19, 0x00	; 0
    520a:	ac 01       	movw	r20, r24
    520c:	47 70       	andi	r20, 0x07	; 7
    520e:	55 27       	eor	r21, r21
    5210:	02 c0       	rjmp	.+4      	; 0x5216 <conv_brk+0x144>
    5212:	35 95       	asr	r19
    5214:	27 95       	ror	r18
    5216:	4a 95       	dec	r20
    5218:	e2 f7       	brpl	.-8      	; 0x5212 <conv_brk+0x140>
    521a:	20 fd       	sbrc	r18, 0
    521c:	db cf       	rjmp	.-74     	; 0x51d4 <conv_brk+0x102>
    521e:	b5 01       	movw	r22, r10
    5220:	eb d1       	rcall	.+982    	; 0x55f8 <ungetc>
    5222:	81 10       	cpse	r8, r1
    5224:	89 cf       	rjmp	.-238    	; 0x5138 <conv_brk+0x66>
    5226:	e1 14       	cp	r14, r1
    5228:	f1 04       	cpc	r15, r1
    522a:	11 f0       	breq	.+4      	; 0x5230 <conv_brk+0x15e>
    522c:	d7 01       	movw	r26, r14
    522e:	1c 92       	st	X, r1
    5230:	c8 01       	movw	r24, r16
    5232:	15 c0       	rjmp	.+42     	; 0x525e <conv_brk+0x18c>
    5234:	42 2f       	mov	r20, r18
    5236:	46 95       	lsr	r20
    5238:	46 95       	lsr	r20
    523a:	46 95       	lsr	r20
    523c:	d6 01       	movw	r26, r12
    523e:	a4 0f       	add	r26, r20
    5240:	b1 1d       	adc	r27, r1
    5242:	42 2f       	mov	r20, r18
    5244:	47 70       	andi	r20, 0x07	; 7
    5246:	8b 01       	movw	r16, r22
    5248:	02 c0       	rjmp	.+4      	; 0x524e <conv_brk+0x17c>
    524a:	00 0f       	add	r16, r16
    524c:	11 1f       	adc	r17, r17
    524e:	4a 95       	dec	r20
    5250:	e2 f7       	brpl	.-8      	; 0x524a <conv_brk+0x178>
    5252:	a8 01       	movw	r20, r16
    5254:	5c 91       	ld	r21, X
    5256:	45 2b       	or	r20, r21
    5258:	4c 93       	st	X, r20
    525a:	62 2e       	mov	r6, r18
    525c:	a4 cf       	rjmp	.-184    	; 0x51a6 <conv_brk+0xd4>
    525e:	a0 96       	adiw	r28, 0x20	; 32
    5260:	cd bf       	out	0x3d, r28	; 61
    5262:	de bf       	out	0x3e, r29	; 62
    5264:	df 91       	pop	r29
    5266:	cf 91       	pop	r28
    5268:	1f 91       	pop	r17
    526a:	0f 91       	pop	r16
    526c:	ff 90       	pop	r15
    526e:	ef 90       	pop	r14
    5270:	df 90       	pop	r13
    5272:	cf 90       	pop	r12
    5274:	bf 90       	pop	r11
    5276:	af 90       	pop	r10
    5278:	9f 90       	pop	r9
    527a:	8f 90       	pop	r8
    527c:	7f 90       	pop	r7
    527e:	6f 90       	pop	r6
    5280:	5f 90       	pop	r5
    5282:	08 95       	ret

00005284 <vfscanf>:
    5284:	5f 92       	push	r5
    5286:	6f 92       	push	r6
    5288:	7f 92       	push	r7
    528a:	8f 92       	push	r8
    528c:	9f 92       	push	r9
    528e:	af 92       	push	r10
    5290:	bf 92       	push	r11
    5292:	cf 92       	push	r12
    5294:	df 92       	push	r13
    5296:	ef 92       	push	r14
    5298:	ff 92       	push	r15
    529a:	0f 93       	push	r16
    529c:	1f 93       	push	r17
    529e:	cf 93       	push	r28
    52a0:	df 93       	push	r29
    52a2:	6c 01       	movw	r12, r24
    52a4:	eb 01       	movw	r28, r22
    52a6:	5a 01       	movw	r10, r20
    52a8:	fc 01       	movw	r30, r24
    52aa:	16 82       	std	Z+6, r1	; 0x06
    52ac:	17 82       	std	Z+7, r1	; 0x07
    52ae:	51 2c       	mov	r5, r1
    52b0:	f6 01       	movw	r30, r12
    52b2:	e3 80       	ldd	r14, Z+3	; 0x03
    52b4:	fe 01       	movw	r30, r28
    52b6:	e3 fc       	sbrc	r14, 3
    52b8:	85 91       	lpm	r24, Z+
    52ba:	e3 fe       	sbrs	r14, 3
    52bc:	81 91       	ld	r24, Z+
    52be:	18 2f       	mov	r17, r24
    52c0:	ef 01       	movw	r28, r30
    52c2:	88 23       	and	r24, r24
    52c4:	09 f4       	brne	.+2      	; 0x52c8 <vfscanf+0x44>
    52c6:	e0 c0       	rjmp	.+448    	; 0x5488 <vfscanf+0x204>
    52c8:	90 e0       	ldi	r25, 0x00	; 0
    52ca:	f3 d0       	rcall	.+486    	; 0x54b2 <isspace>
    52cc:	89 2b       	or	r24, r25
    52ce:	19 f0       	breq	.+6      	; 0x52d6 <vfscanf+0x52>
    52d0:	c6 01       	movw	r24, r12
    52d2:	5f de       	rcall	.-834    	; 0x4f92 <skip_spaces>
    52d4:	ed cf       	rjmp	.-38     	; 0x52b0 <vfscanf+0x2c>
    52d6:	15 32       	cpi	r17, 0x25	; 37
    52d8:	41 f4       	brne	.+16     	; 0x52ea <vfscanf+0x66>
    52da:	fe 01       	movw	r30, r28
    52dc:	e3 fc       	sbrc	r14, 3
    52de:	15 91       	lpm	r17, Z+
    52e0:	e3 fe       	sbrs	r14, 3
    52e2:	11 91       	ld	r17, Z+
    52e4:	ef 01       	movw	r28, r30
    52e6:	15 32       	cpi	r17, 0x25	; 37
    52e8:	71 f4       	brne	.+28     	; 0x5306 <vfscanf+0x82>
    52ea:	c6 01       	movw	r24, r12
    52ec:	0b d1       	rcall	.+534    	; 0x5504 <fgetc>
    52ee:	97 fd       	sbrc	r25, 7
    52f0:	c9 c0       	rjmp	.+402    	; 0x5484 <vfscanf+0x200>
    52f2:	41 2f       	mov	r20, r17
    52f4:	50 e0       	ldi	r21, 0x00	; 0
    52f6:	9c 01       	movw	r18, r24
    52f8:	33 27       	eor	r19, r19
    52fa:	24 17       	cp	r18, r20
    52fc:	35 07       	cpc	r19, r21
    52fe:	c1 f2       	breq	.-80     	; 0x52b0 <vfscanf+0x2c>
    5300:	b6 01       	movw	r22, r12
    5302:	7a d1       	rcall	.+756    	; 0x55f8 <ungetc>
    5304:	c1 c0       	rjmp	.+386    	; 0x5488 <vfscanf+0x204>
    5306:	1a 32       	cpi	r17, 0x2A	; 42
    5308:	39 f4       	brne	.+14     	; 0x5318 <vfscanf+0x94>
    530a:	e3 fc       	sbrc	r14, 3
    530c:	15 91       	lpm	r17, Z+
    530e:	e3 fe       	sbrs	r14, 3
    5310:	11 91       	ld	r17, Z+
    5312:	ef 01       	movw	r28, r30
    5314:	01 e0       	ldi	r16, 0x01	; 1
    5316:	01 c0       	rjmp	.+2      	; 0x531a <vfscanf+0x96>
    5318:	00 e0       	ldi	r16, 0x00	; 0
    531a:	f1 2c       	mov	r15, r1
    531c:	20 ed       	ldi	r18, 0xD0	; 208
    531e:	21 0f       	add	r18, r17
    5320:	2a 30       	cpi	r18, 0x0A	; 10
    5322:	78 f4       	brcc	.+30     	; 0x5342 <vfscanf+0xbe>
    5324:	02 60       	ori	r16, 0x02	; 2
    5326:	6f 2d       	mov	r22, r15
    5328:	70 e0       	ldi	r23, 0x00	; 0
    532a:	80 e0       	ldi	r24, 0x00	; 0
    532c:	90 e0       	ldi	r25, 0x00	; 0
    532e:	40 e2       	ldi	r20, 0x20	; 32
    5330:	09 de       	rcall	.-1006   	; 0x4f44 <mulacc>
    5332:	f6 2e       	mov	r15, r22
    5334:	fe 01       	movw	r30, r28
    5336:	e3 fc       	sbrc	r14, 3
    5338:	15 91       	lpm	r17, Z+
    533a:	e3 fe       	sbrs	r14, 3
    533c:	11 91       	ld	r17, Z+
    533e:	ef 01       	movw	r28, r30
    5340:	ed cf       	rjmp	.-38     	; 0x531c <vfscanf+0x98>
    5342:	01 ff       	sbrs	r16, 1
    5344:	03 c0       	rjmp	.+6      	; 0x534c <vfscanf+0xc8>
    5346:	f1 10       	cpse	r15, r1
    5348:	03 c0       	rjmp	.+6      	; 0x5350 <vfscanf+0xcc>
    534a:	9e c0       	rjmp	.+316    	; 0x5488 <vfscanf+0x204>
    534c:	ff 24       	eor	r15, r15
    534e:	fa 94       	dec	r15
    5350:	18 36       	cpi	r17, 0x68	; 104
    5352:	19 f0       	breq	.+6      	; 0x535a <vfscanf+0xd6>
    5354:	1c 36       	cpi	r17, 0x6C	; 108
    5356:	51 f0       	breq	.+20     	; 0x536c <vfscanf+0xe8>
    5358:	10 c0       	rjmp	.+32     	; 0x537a <vfscanf+0xf6>
    535a:	fe 01       	movw	r30, r28
    535c:	e3 fc       	sbrc	r14, 3
    535e:	15 91       	lpm	r17, Z+
    5360:	e3 fe       	sbrs	r14, 3
    5362:	11 91       	ld	r17, Z+
    5364:	ef 01       	movw	r28, r30
    5366:	18 36       	cpi	r17, 0x68	; 104
    5368:	41 f4       	brne	.+16     	; 0x537a <vfscanf+0xf6>
    536a:	08 60       	ori	r16, 0x08	; 8
    536c:	04 60       	ori	r16, 0x04	; 4
    536e:	fe 01       	movw	r30, r28
    5370:	e3 fc       	sbrc	r14, 3
    5372:	15 91       	lpm	r17, Z+
    5374:	e3 fe       	sbrs	r14, 3
    5376:	11 91       	ld	r17, Z+
    5378:	ef 01       	movw	r28, r30
    537a:	11 23       	and	r17, r17
    537c:	09 f4       	brne	.+2      	; 0x5380 <vfscanf+0xfc>
    537e:	84 c0       	rjmp	.+264    	; 0x5488 <vfscanf+0x204>
    5380:	61 2f       	mov	r22, r17
    5382:	70 e0       	ldi	r23, 0x00	; 0
    5384:	80 e1       	ldi	r24, 0x10	; 16
    5386:	92 e0       	ldi	r25, 0x02	; 2
    5388:	9c d0       	rcall	.+312    	; 0x54c2 <strchr_P>
    538a:	89 2b       	or	r24, r25
    538c:	09 f4       	brne	.+2      	; 0x5390 <vfscanf+0x10c>
    538e:	7c c0       	rjmp	.+248    	; 0x5488 <vfscanf+0x204>
    5390:	00 fd       	sbrc	r16, 0
    5392:	07 c0       	rjmp	.+14     	; 0x53a2 <vfscanf+0x11e>
    5394:	f5 01       	movw	r30, r10
    5396:	80 80       	ld	r8, Z
    5398:	91 80       	ldd	r9, Z+1	; 0x01
    539a:	c5 01       	movw	r24, r10
    539c:	02 96       	adiw	r24, 0x02	; 2
    539e:	5c 01       	movw	r10, r24
    53a0:	02 c0       	rjmp	.+4      	; 0x53a6 <vfscanf+0x122>
    53a2:	81 2c       	mov	r8, r1
    53a4:	91 2c       	mov	r9, r1
    53a6:	1e 36       	cpi	r17, 0x6E	; 110
    53a8:	49 f4       	brne	.+18     	; 0x53bc <vfscanf+0x138>
    53aa:	f6 01       	movw	r30, r12
    53ac:	46 81       	ldd	r20, Z+6	; 0x06
    53ae:	57 81       	ldd	r21, Z+7	; 0x07
    53b0:	60 e0       	ldi	r22, 0x00	; 0
    53b2:	70 e0       	ldi	r23, 0x00	; 0
    53b4:	20 2f       	mov	r18, r16
    53b6:	c4 01       	movw	r24, r8
    53b8:	b9 dd       	rcall	.-1166   	; 0x4f2c <putval>
    53ba:	7a cf       	rjmp	.-268    	; 0x52b0 <vfscanf+0x2c>
    53bc:	13 36       	cpi	r17, 0x63	; 99
    53be:	a1 f4       	brne	.+40     	; 0x53e8 <vfscanf+0x164>
    53c0:	01 fd       	sbrc	r16, 1
    53c2:	02 c0       	rjmp	.+4      	; 0x53c8 <vfscanf+0x144>
    53c4:	ff 24       	eor	r15, r15
    53c6:	f3 94       	inc	r15
    53c8:	c6 01       	movw	r24, r12
    53ca:	9c d0       	rcall	.+312    	; 0x5504 <fgetc>
    53cc:	97 fd       	sbrc	r25, 7
    53ce:	5a c0       	rjmp	.+180    	; 0x5484 <vfscanf+0x200>
    53d0:	81 14       	cp	r8, r1
    53d2:	91 04       	cpc	r9, r1
    53d4:	29 f0       	breq	.+10     	; 0x53e0 <vfscanf+0x15c>
    53d6:	f4 01       	movw	r30, r8
    53d8:	80 83       	st	Z, r24
    53da:	c4 01       	movw	r24, r8
    53dc:	01 96       	adiw	r24, 0x01	; 1
    53de:	4c 01       	movw	r8, r24
    53e0:	fa 94       	dec	r15
    53e2:	f1 10       	cpse	r15, r1
    53e4:	f1 cf       	rjmp	.-30     	; 0x53c8 <vfscanf+0x144>
    53e6:	4a c0       	rjmp	.+148    	; 0x547c <vfscanf+0x1f8>
    53e8:	1b 35       	cpi	r17, 0x5B	; 91
    53ea:	51 f4       	brne	.+20     	; 0x5400 <vfscanf+0x17c>
    53ec:	9e 01       	movw	r18, r28
    53ee:	a4 01       	movw	r20, r8
    53f0:	6f 2d       	mov	r22, r15
    53f2:	c6 01       	movw	r24, r12
    53f4:	6e de       	rcall	.-804    	; 0x50d2 <conv_brk>
    53f6:	ec 01       	movw	r28, r24
    53f8:	89 2b       	or	r24, r25
    53fa:	09 f0       	breq	.+2      	; 0x53fe <vfscanf+0x17a>
    53fc:	3f c0       	rjmp	.+126    	; 0x547c <vfscanf+0x1f8>
    53fe:	39 c0       	rjmp	.+114    	; 0x5472 <vfscanf+0x1ee>
    5400:	c6 01       	movw	r24, r12
    5402:	c7 dd       	rcall	.-1138   	; 0x4f92 <skip_spaces>
    5404:	97 fd       	sbrc	r25, 7
    5406:	3e c0       	rjmp	.+124    	; 0x5484 <vfscanf+0x200>
    5408:	1f 36       	cpi	r17, 0x6F	; 111
    540a:	49 f1       	breq	.+82     	; 0x545e <vfscanf+0x1da>
    540c:	28 f4       	brcc	.+10     	; 0x5418 <vfscanf+0x194>
    540e:	14 36       	cpi	r17, 0x64	; 100
    5410:	21 f1       	breq	.+72     	; 0x545a <vfscanf+0x1d6>
    5412:	19 36       	cpi	r17, 0x69	; 105
    5414:	39 f1       	breq	.+78     	; 0x5464 <vfscanf+0x1e0>
    5416:	25 c0       	rjmp	.+74     	; 0x5462 <vfscanf+0x1de>
    5418:	13 37       	cpi	r17, 0x73	; 115
    541a:	71 f0       	breq	.+28     	; 0x5438 <vfscanf+0x1b4>
    541c:	15 37       	cpi	r17, 0x75	; 117
    541e:	e9 f0       	breq	.+58     	; 0x545a <vfscanf+0x1d6>
    5420:	20 c0       	rjmp	.+64     	; 0x5462 <vfscanf+0x1de>
    5422:	81 14       	cp	r8, r1
    5424:	91 04       	cpc	r9, r1
    5426:	29 f0       	breq	.+10     	; 0x5432 <vfscanf+0x1ae>
    5428:	f4 01       	movw	r30, r8
    542a:	60 82       	st	Z, r6
    542c:	c4 01       	movw	r24, r8
    542e:	01 96       	adiw	r24, 0x01	; 1
    5430:	4c 01       	movw	r8, r24
    5432:	fa 94       	dec	r15
    5434:	ff 20       	and	r15, r15
    5436:	59 f0       	breq	.+22     	; 0x544e <vfscanf+0x1ca>
    5438:	c6 01       	movw	r24, r12
    543a:	64 d0       	rcall	.+200    	; 0x5504 <fgetc>
    543c:	3c 01       	movw	r6, r24
    543e:	97 fd       	sbrc	r25, 7
    5440:	06 c0       	rjmp	.+12     	; 0x544e <vfscanf+0x1ca>
    5442:	37 d0       	rcall	.+110    	; 0x54b2 <isspace>
    5444:	89 2b       	or	r24, r25
    5446:	69 f3       	breq	.-38     	; 0x5422 <vfscanf+0x19e>
    5448:	b6 01       	movw	r22, r12
    544a:	c3 01       	movw	r24, r6
    544c:	d5 d0       	rcall	.+426    	; 0x55f8 <ungetc>
    544e:	81 14       	cp	r8, r1
    5450:	91 04       	cpc	r9, r1
    5452:	a1 f0       	breq	.+40     	; 0x547c <vfscanf+0x1f8>
    5454:	f4 01       	movw	r30, r8
    5456:	10 82       	st	Z, r1
    5458:	11 c0       	rjmp	.+34     	; 0x547c <vfscanf+0x1f8>
    545a:	00 62       	ori	r16, 0x20	; 32
    545c:	03 c0       	rjmp	.+6      	; 0x5464 <vfscanf+0x1e0>
    545e:	00 61       	ori	r16, 0x10	; 16
    5460:	01 c0       	rjmp	.+2      	; 0x5464 <vfscanf+0x1e0>
    5462:	00 64       	ori	r16, 0x40	; 64
    5464:	20 2f       	mov	r18, r16
    5466:	a4 01       	movw	r20, r8
    5468:	6f 2d       	mov	r22, r15
    546a:	c6 01       	movw	r24, r12
    546c:	a8 dd       	rcall	.-1200   	; 0x4fbe <conv_int>
    546e:	81 11       	cpse	r24, r1
    5470:	05 c0       	rjmp	.+10     	; 0x547c <vfscanf+0x1f8>
    5472:	f6 01       	movw	r30, r12
    5474:	83 81       	ldd	r24, Z+3	; 0x03
    5476:	80 73       	andi	r24, 0x30	; 48
    5478:	29 f4       	brne	.+10     	; 0x5484 <vfscanf+0x200>
    547a:	06 c0       	rjmp	.+12     	; 0x5488 <vfscanf+0x204>
    547c:	00 fd       	sbrc	r16, 0
    547e:	18 cf       	rjmp	.-464    	; 0x52b0 <vfscanf+0x2c>
    5480:	53 94       	inc	r5
    5482:	16 cf       	rjmp	.-468    	; 0x52b0 <vfscanf+0x2c>
    5484:	55 20       	and	r5, r5
    5486:	19 f0       	breq	.+6      	; 0x548e <vfscanf+0x20a>
    5488:	85 2d       	mov	r24, r5
    548a:	90 e0       	ldi	r25, 0x00	; 0
    548c:	02 c0       	rjmp	.+4      	; 0x5492 <vfscanf+0x20e>
    548e:	8f ef       	ldi	r24, 0xFF	; 255
    5490:	9f ef       	ldi	r25, 0xFF	; 255
    5492:	df 91       	pop	r29
    5494:	cf 91       	pop	r28
    5496:	1f 91       	pop	r17
    5498:	0f 91       	pop	r16
    549a:	ff 90       	pop	r15
    549c:	ef 90       	pop	r14
    549e:	df 90       	pop	r13
    54a0:	cf 90       	pop	r12
    54a2:	bf 90       	pop	r11
    54a4:	af 90       	pop	r10
    54a6:	9f 90       	pop	r9
    54a8:	8f 90       	pop	r8
    54aa:	7f 90       	pop	r7
    54ac:	6f 90       	pop	r6
    54ae:	5f 90       	pop	r5
    54b0:	08 95       	ret

000054b2 <isspace>:
    54b2:	91 11       	cpse	r25, r1
    54b4:	18 c1       	rjmp	.+560    	; 0x56e6 <__ctype_isfalse>
    54b6:	80 32       	cpi	r24, 0x20	; 32
    54b8:	19 f0       	breq	.+6      	; 0x54c0 <isspace+0xe>
    54ba:	89 50       	subi	r24, 0x09	; 9
    54bc:	85 50       	subi	r24, 0x05	; 5
    54be:	d0 f7       	brcc	.-12     	; 0x54b4 <isspace+0x2>
    54c0:	08 95       	ret

000054c2 <strchr_P>:
    54c2:	fc 01       	movw	r30, r24
    54c4:	05 90       	lpm	r0, Z+
    54c6:	06 16       	cp	r0, r22
    54c8:	21 f0       	breq	.+8      	; 0x54d2 <strchr_P+0x10>
    54ca:	00 20       	and	r0, r0
    54cc:	d9 f7       	brne	.-10     	; 0x54c4 <strchr_P+0x2>
    54ce:	c0 01       	movw	r24, r0
    54d0:	08 95       	ret
    54d2:	31 97       	sbiw	r30, 0x01	; 1
    54d4:	cf 01       	movw	r24, r30
    54d6:	08 95       	ret

000054d8 <strnlen_P>:
    54d8:	fc 01       	movw	r30, r24
    54da:	05 90       	lpm	r0, Z+
    54dc:	61 50       	subi	r22, 0x01	; 1
    54de:	70 40       	sbci	r23, 0x00	; 0
    54e0:	01 10       	cpse	r0, r1
    54e2:	d8 f7       	brcc	.-10     	; 0x54da <strnlen_P+0x2>
    54e4:	80 95       	com	r24
    54e6:	90 95       	com	r25
    54e8:	8e 0f       	add	r24, r30
    54ea:	9f 1f       	adc	r25, r31
    54ec:	08 95       	ret

000054ee <strnlen>:
    54ee:	fc 01       	movw	r30, r24
    54f0:	61 50       	subi	r22, 0x01	; 1
    54f2:	70 40       	sbci	r23, 0x00	; 0
    54f4:	01 90       	ld	r0, Z+
    54f6:	01 10       	cpse	r0, r1
    54f8:	d8 f7       	brcc	.-10     	; 0x54f0 <strnlen+0x2>
    54fa:	80 95       	com	r24
    54fc:	90 95       	com	r25
    54fe:	8e 0f       	add	r24, r30
    5500:	9f 1f       	adc	r25, r31
    5502:	08 95       	ret

00005504 <fgetc>:
    5504:	cf 93       	push	r28
    5506:	df 93       	push	r29
    5508:	ec 01       	movw	r28, r24
    550a:	2b 81       	ldd	r18, Y+3	; 0x03
    550c:	20 ff       	sbrs	r18, 0
    550e:	33 c0       	rjmp	.+102    	; 0x5576 <fgetc+0x72>
    5510:	26 ff       	sbrs	r18, 6
    5512:	0a c0       	rjmp	.+20     	; 0x5528 <fgetc+0x24>
    5514:	2f 7b       	andi	r18, 0xBF	; 191
    5516:	2b 83       	std	Y+3, r18	; 0x03
    5518:	8e 81       	ldd	r24, Y+6	; 0x06
    551a:	9f 81       	ldd	r25, Y+7	; 0x07
    551c:	01 96       	adiw	r24, 0x01	; 1
    551e:	8e 83       	std	Y+6, r24	; 0x06
    5520:	9f 83       	std	Y+7, r25	; 0x07
    5522:	8a 81       	ldd	r24, Y+2	; 0x02
    5524:	90 e0       	ldi	r25, 0x00	; 0
    5526:	29 c0       	rjmp	.+82     	; 0x557a <fgetc+0x76>
    5528:	22 ff       	sbrs	r18, 2
    552a:	0f c0       	rjmp	.+30     	; 0x554a <fgetc+0x46>
    552c:	e8 81       	ld	r30, Y
    552e:	f9 81       	ldd	r31, Y+1	; 0x01
    5530:	80 81       	ld	r24, Z
    5532:	08 2e       	mov	r0, r24
    5534:	00 0c       	add	r0, r0
    5536:	99 0b       	sbc	r25, r25
    5538:	00 97       	sbiw	r24, 0x00	; 0
    553a:	19 f4       	brne	.+6      	; 0x5542 <fgetc+0x3e>
    553c:	20 62       	ori	r18, 0x20	; 32
    553e:	2b 83       	std	Y+3, r18	; 0x03
    5540:	1a c0       	rjmp	.+52     	; 0x5576 <fgetc+0x72>
    5542:	31 96       	adiw	r30, 0x01	; 1
    5544:	e8 83       	st	Y, r30
    5546:	f9 83       	std	Y+1, r31	; 0x01
    5548:	0e c0       	rjmp	.+28     	; 0x5566 <fgetc+0x62>
    554a:	ea 85       	ldd	r30, Y+10	; 0x0a
    554c:	fb 85       	ldd	r31, Y+11	; 0x0b
    554e:	19 95       	eicall
    5550:	97 ff       	sbrs	r25, 7
    5552:	09 c0       	rjmp	.+18     	; 0x5566 <fgetc+0x62>
    5554:	2b 81       	ldd	r18, Y+3	; 0x03
    5556:	01 96       	adiw	r24, 0x01	; 1
    5558:	11 f0       	breq	.+4      	; 0x555e <fgetc+0x5a>
    555a:	80 e2       	ldi	r24, 0x20	; 32
    555c:	01 c0       	rjmp	.+2      	; 0x5560 <fgetc+0x5c>
    555e:	80 e1       	ldi	r24, 0x10	; 16
    5560:	82 2b       	or	r24, r18
    5562:	8b 83       	std	Y+3, r24	; 0x03
    5564:	08 c0       	rjmp	.+16     	; 0x5576 <fgetc+0x72>
    5566:	2e 81       	ldd	r18, Y+6	; 0x06
    5568:	3f 81       	ldd	r19, Y+7	; 0x07
    556a:	2f 5f       	subi	r18, 0xFF	; 255
    556c:	3f 4f       	sbci	r19, 0xFF	; 255
    556e:	2e 83       	std	Y+6, r18	; 0x06
    5570:	3f 83       	std	Y+7, r19	; 0x07
    5572:	99 27       	eor	r25, r25
    5574:	02 c0       	rjmp	.+4      	; 0x557a <fgetc+0x76>
    5576:	8f ef       	ldi	r24, 0xFF	; 255
    5578:	9f ef       	ldi	r25, 0xFF	; 255
    557a:	df 91       	pop	r29
    557c:	cf 91       	pop	r28
    557e:	08 95       	ret

00005580 <fputc>:
    5580:	0f 93       	push	r16
    5582:	1f 93       	push	r17
    5584:	cf 93       	push	r28
    5586:	df 93       	push	r29
    5588:	fb 01       	movw	r30, r22
    558a:	23 81       	ldd	r18, Z+3	; 0x03
    558c:	21 fd       	sbrc	r18, 1
    558e:	03 c0       	rjmp	.+6      	; 0x5596 <fputc+0x16>
    5590:	8f ef       	ldi	r24, 0xFF	; 255
    5592:	9f ef       	ldi	r25, 0xFF	; 255
    5594:	2c c0       	rjmp	.+88     	; 0x55ee <fputc+0x6e>
    5596:	22 ff       	sbrs	r18, 2
    5598:	16 c0       	rjmp	.+44     	; 0x55c6 <fputc+0x46>
    559a:	46 81       	ldd	r20, Z+6	; 0x06
    559c:	57 81       	ldd	r21, Z+7	; 0x07
    559e:	24 81       	ldd	r18, Z+4	; 0x04
    55a0:	35 81       	ldd	r19, Z+5	; 0x05
    55a2:	42 17       	cp	r20, r18
    55a4:	53 07       	cpc	r21, r19
    55a6:	44 f4       	brge	.+16     	; 0x55b8 <fputc+0x38>
    55a8:	a0 81       	ld	r26, Z
    55aa:	b1 81       	ldd	r27, Z+1	; 0x01
    55ac:	9d 01       	movw	r18, r26
    55ae:	2f 5f       	subi	r18, 0xFF	; 255
    55b0:	3f 4f       	sbci	r19, 0xFF	; 255
    55b2:	20 83       	st	Z, r18
    55b4:	31 83       	std	Z+1, r19	; 0x01
    55b6:	8c 93       	st	X, r24
    55b8:	26 81       	ldd	r18, Z+6	; 0x06
    55ba:	37 81       	ldd	r19, Z+7	; 0x07
    55bc:	2f 5f       	subi	r18, 0xFF	; 255
    55be:	3f 4f       	sbci	r19, 0xFF	; 255
    55c0:	26 83       	std	Z+6, r18	; 0x06
    55c2:	37 83       	std	Z+7, r19	; 0x07
    55c4:	14 c0       	rjmp	.+40     	; 0x55ee <fputc+0x6e>
    55c6:	8b 01       	movw	r16, r22
    55c8:	ec 01       	movw	r28, r24
    55ca:	fb 01       	movw	r30, r22
    55cc:	00 84       	ldd	r0, Z+8	; 0x08
    55ce:	f1 85       	ldd	r31, Z+9	; 0x09
    55d0:	e0 2d       	mov	r30, r0
    55d2:	19 95       	eicall
    55d4:	89 2b       	or	r24, r25
    55d6:	e1 f6       	brne	.-72     	; 0x5590 <fputc+0x10>
    55d8:	d8 01       	movw	r26, r16
    55da:	16 96       	adiw	r26, 0x06	; 6
    55dc:	8d 91       	ld	r24, X+
    55de:	9c 91       	ld	r25, X
    55e0:	17 97       	sbiw	r26, 0x07	; 7
    55e2:	01 96       	adiw	r24, 0x01	; 1
    55e4:	16 96       	adiw	r26, 0x06	; 6
    55e6:	8d 93       	st	X+, r24
    55e8:	9c 93       	st	X, r25
    55ea:	17 97       	sbiw	r26, 0x07	; 7
    55ec:	ce 01       	movw	r24, r28
    55ee:	df 91       	pop	r29
    55f0:	cf 91       	pop	r28
    55f2:	1f 91       	pop	r17
    55f4:	0f 91       	pop	r16
    55f6:	08 95       	ret

000055f8 <ungetc>:
    55f8:	fb 01       	movw	r30, r22
    55fa:	23 81       	ldd	r18, Z+3	; 0x03
    55fc:	20 ff       	sbrs	r18, 0
    55fe:	12 c0       	rjmp	.+36     	; 0x5624 <ungetc+0x2c>
    5600:	26 fd       	sbrc	r18, 6
    5602:	10 c0       	rjmp	.+32     	; 0x5624 <ungetc+0x2c>
    5604:	8f 3f       	cpi	r24, 0xFF	; 255
    5606:	3f ef       	ldi	r19, 0xFF	; 255
    5608:	93 07       	cpc	r25, r19
    560a:	61 f0       	breq	.+24     	; 0x5624 <ungetc+0x2c>
    560c:	82 83       	std	Z+2, r24	; 0x02
    560e:	2f 7d       	andi	r18, 0xDF	; 223
    5610:	20 64       	ori	r18, 0x40	; 64
    5612:	23 83       	std	Z+3, r18	; 0x03
    5614:	26 81       	ldd	r18, Z+6	; 0x06
    5616:	37 81       	ldd	r19, Z+7	; 0x07
    5618:	21 50       	subi	r18, 0x01	; 1
    561a:	31 09       	sbc	r19, r1
    561c:	26 83       	std	Z+6, r18	; 0x06
    561e:	37 83       	std	Z+7, r19	; 0x07
    5620:	99 27       	eor	r25, r25
    5622:	08 95       	ret
    5624:	8f ef       	ldi	r24, 0xFF	; 255
    5626:	9f ef       	ldi	r25, 0xFF	; 255
    5628:	08 95       	ret

0000562a <__ultoa_invert>:
    562a:	fa 01       	movw	r30, r20
    562c:	aa 27       	eor	r26, r26
    562e:	28 30       	cpi	r18, 0x08	; 8
    5630:	51 f1       	breq	.+84     	; 0x5686 <__ultoa_invert+0x5c>
    5632:	20 31       	cpi	r18, 0x10	; 16
    5634:	81 f1       	breq	.+96     	; 0x5696 <__ultoa_invert+0x6c>
    5636:	e8 94       	clt
    5638:	6f 93       	push	r22
    563a:	6e 7f       	andi	r22, 0xFE	; 254
    563c:	6e 5f       	subi	r22, 0xFE	; 254
    563e:	7f 4f       	sbci	r23, 0xFF	; 255
    5640:	8f 4f       	sbci	r24, 0xFF	; 255
    5642:	9f 4f       	sbci	r25, 0xFF	; 255
    5644:	af 4f       	sbci	r26, 0xFF	; 255
    5646:	b1 e0       	ldi	r27, 0x01	; 1
    5648:	3e d0       	rcall	.+124    	; 0x56c6 <__ultoa_invert+0x9c>
    564a:	b4 e0       	ldi	r27, 0x04	; 4
    564c:	3c d0       	rcall	.+120    	; 0x56c6 <__ultoa_invert+0x9c>
    564e:	67 0f       	add	r22, r23
    5650:	78 1f       	adc	r23, r24
    5652:	89 1f       	adc	r24, r25
    5654:	9a 1f       	adc	r25, r26
    5656:	a1 1d       	adc	r26, r1
    5658:	68 0f       	add	r22, r24
    565a:	79 1f       	adc	r23, r25
    565c:	8a 1f       	adc	r24, r26
    565e:	91 1d       	adc	r25, r1
    5660:	a1 1d       	adc	r26, r1
    5662:	6a 0f       	add	r22, r26
    5664:	71 1d       	adc	r23, r1
    5666:	81 1d       	adc	r24, r1
    5668:	91 1d       	adc	r25, r1
    566a:	a1 1d       	adc	r26, r1
    566c:	20 d0       	rcall	.+64     	; 0x56ae <__ultoa_invert+0x84>
    566e:	09 f4       	brne	.+2      	; 0x5672 <__ultoa_invert+0x48>
    5670:	68 94       	set
    5672:	3f 91       	pop	r19
    5674:	2a e0       	ldi	r18, 0x0A	; 10
    5676:	26 9f       	mul	r18, r22
    5678:	11 24       	eor	r1, r1
    567a:	30 19       	sub	r19, r0
    567c:	30 5d       	subi	r19, 0xD0	; 208
    567e:	31 93       	st	Z+, r19
    5680:	de f6       	brtc	.-74     	; 0x5638 <__ultoa_invert+0xe>
    5682:	cf 01       	movw	r24, r30
    5684:	08 95       	ret
    5686:	46 2f       	mov	r20, r22
    5688:	47 70       	andi	r20, 0x07	; 7
    568a:	40 5d       	subi	r20, 0xD0	; 208
    568c:	41 93       	st	Z+, r20
    568e:	b3 e0       	ldi	r27, 0x03	; 3
    5690:	0f d0       	rcall	.+30     	; 0x56b0 <__ultoa_invert+0x86>
    5692:	c9 f7       	brne	.-14     	; 0x5686 <__ultoa_invert+0x5c>
    5694:	f6 cf       	rjmp	.-20     	; 0x5682 <__ultoa_invert+0x58>
    5696:	46 2f       	mov	r20, r22
    5698:	4f 70       	andi	r20, 0x0F	; 15
    569a:	40 5d       	subi	r20, 0xD0	; 208
    569c:	4a 33       	cpi	r20, 0x3A	; 58
    569e:	18 f0       	brcs	.+6      	; 0x56a6 <__ultoa_invert+0x7c>
    56a0:	49 5d       	subi	r20, 0xD9	; 217
    56a2:	31 fd       	sbrc	r19, 1
    56a4:	40 52       	subi	r20, 0x20	; 32
    56a6:	41 93       	st	Z+, r20
    56a8:	02 d0       	rcall	.+4      	; 0x56ae <__ultoa_invert+0x84>
    56aa:	a9 f7       	brne	.-22     	; 0x5696 <__ultoa_invert+0x6c>
    56ac:	ea cf       	rjmp	.-44     	; 0x5682 <__ultoa_invert+0x58>
    56ae:	b4 e0       	ldi	r27, 0x04	; 4
    56b0:	a6 95       	lsr	r26
    56b2:	97 95       	ror	r25
    56b4:	87 95       	ror	r24
    56b6:	77 95       	ror	r23
    56b8:	67 95       	ror	r22
    56ba:	ba 95       	dec	r27
    56bc:	c9 f7       	brne	.-14     	; 0x56b0 <__ultoa_invert+0x86>
    56be:	00 97       	sbiw	r24, 0x00	; 0
    56c0:	61 05       	cpc	r22, r1
    56c2:	71 05       	cpc	r23, r1
    56c4:	08 95       	ret
    56c6:	9b 01       	movw	r18, r22
    56c8:	ac 01       	movw	r20, r24
    56ca:	0a 2e       	mov	r0, r26
    56cc:	06 94       	lsr	r0
    56ce:	57 95       	ror	r21
    56d0:	47 95       	ror	r20
    56d2:	37 95       	ror	r19
    56d4:	27 95       	ror	r18
    56d6:	ba 95       	dec	r27
    56d8:	c9 f7       	brne	.-14     	; 0x56cc <__ultoa_invert+0xa2>
    56da:	62 0f       	add	r22, r18
    56dc:	73 1f       	adc	r23, r19
    56de:	84 1f       	adc	r24, r20
    56e0:	95 1f       	adc	r25, r21
    56e2:	a0 1d       	adc	r26, r0
    56e4:	08 95       	ret

000056e6 <__ctype_isfalse>:
    56e6:	99 27       	eor	r25, r25
    56e8:	88 27       	eor	r24, r24

000056ea <__ctype_istrue>:
    56ea:	08 95       	ret

000056ec <_exit>:
    56ec:	f8 94       	cli

000056ee <__stop_program>:
    56ee:	ff cf       	rjmp	.-2      	; 0x56ee <__stop_program>
