
ProjectUAS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004eb8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000b6  00802000  00004eb8  00004f4c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003db  008020b6  008020b6  00005002  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00005002  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  00005060  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000008c0  00000000  00000000  000050a8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00017e5f  00000000  00000000  00005968  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006211  00000000  00000000  0001d7c7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000708c  00000000  00000000  000239d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000025b8  00000000  00000000  0002aa64  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00007189  00000000  00000000  0002d01c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000d026  00000000  00000000  000341a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000ab8  00000000  00000000  000411d0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	50 c2       	rjmp	.+1184   	; 0x4a2 <__ctors_end>
       2:	00 00       	nop
       4:	6f c2       	rjmp	.+1246   	; 0x4e4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c2       	rjmp	.+1242   	; 0x4e4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c2       	rjmp	.+1238   	; 0x4e4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c2       	rjmp	.+1234   	; 0x4e4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c2       	rjmp	.+1230   	; 0x4e4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c2       	rjmp	.+1226   	; 0x4e4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c2       	rjmp	.+1222   	; 0x4e4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c2       	rjmp	.+1218   	; 0x4e4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c2       	rjmp	.+1214   	; 0x4e4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c2       	rjmp	.+1210   	; 0x4e4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c2       	rjmp	.+1206   	; 0x4e4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	59 c2       	rjmp	.+1202   	; 0x4e4 <__bad_interrupt>
      32:	00 00       	nop
      34:	57 c2       	rjmp	.+1198   	; 0x4e4 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 95 13 	jmp	0x272a	; 0x272a <__vector_14>
      3c:	0c 94 e4 08 	jmp	0x11c8	; 0x11c8 <__vector_15>
      40:	0c 94 11 09 	jmp	0x1222	; 0x1222 <__vector_16>
      44:	0c 94 3e 09 	jmp	0x127c	; 0x127c <__vector_17>
      48:	0c 94 6b 09 	jmp	0x12d6	; 0x12d6 <__vector_18>
      4c:	0c 94 98 09 	jmp	0x1330	; 0x1330 <__vector_19>
      50:	0c 94 c5 09 	jmp	0x138a	; 0x138a <__vector_20>
      54:	0c 94 f2 09 	jmp	0x13e4	; 0x13e4 <__vector_21>
      58:	0c 94 1f 0a 	jmp	0x143e	; 0x143e <__vector_22>
      5c:	0c 94 4c 0a 	jmp	0x1498	; 0x1498 <__vector_23>
      60:	41 c2       	rjmp	.+1154   	; 0x4e4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c2       	rjmp	.+1150   	; 0x4e4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c2       	rjmp	.+1146   	; 0x4e4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c2       	rjmp	.+1142   	; 0x4e4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	39 c2       	rjmp	.+1138   	; 0x4e4 <__bad_interrupt>
      72:	00 00       	nop
      74:	37 c2       	rjmp	.+1134   	; 0x4e4 <__bad_interrupt>
      76:	00 00       	nop
      78:	35 c2       	rjmp	.+1130   	; 0x4e4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	33 c2       	rjmp	.+1126   	; 0x4e4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c2       	rjmp	.+1122   	; 0x4e4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c2       	rjmp	.+1118   	; 0x4e4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c2       	rjmp	.+1114   	; 0x4e4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2b c2       	rjmp	.+1110   	; 0x4e4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	29 c2       	rjmp	.+1106   	; 0x4e4 <__bad_interrupt>
      92:	00 00       	nop
      94:	27 c2       	rjmp	.+1102   	; 0x4e4 <__bad_interrupt>
      96:	00 00       	nop
      98:	25 c2       	rjmp	.+1098   	; 0x4e4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	94 c6       	rjmp	.+3368   	; 0xdc6 <__vector_39>
      9e:	00 00       	nop
      a0:	c4 c6       	rjmp	.+3464   	; 0xe2a <__vector_40>
      a2:	00 00       	nop
      a4:	f4 c6       	rjmp	.+3560   	; 0xe8e <__vector_41>
      a6:	00 00       	nop
      a8:	24 c7       	rjmp	.+3656   	; 0xef2 <__vector_42>
      aa:	00 00       	nop
      ac:	1b c2       	rjmp	.+1078   	; 0x4e4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	19 c2       	rjmp	.+1074   	; 0x4e4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	17 c2       	rjmp	.+1070   	; 0x4e4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	15 c2       	rjmp	.+1066   	; 0x4e4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 3b 0c 	jmp	0x1876	; 0x1876 <__vector_47>
      c0:	0c 94 68 0c 	jmp	0x18d0	; 0x18d0 <__vector_48>
      c4:	0c 94 95 0c 	jmp	0x192a	; 0x192a <__vector_49>
      c8:	0c 94 c2 0c 	jmp	0x1984	; 0x1984 <__vector_50>
      cc:	0c 94 ef 0c 	jmp	0x19de	; 0x19de <__vector_51>
      d0:	0c 94 1c 0d 	jmp	0x1a38	; 0x1a38 <__vector_52>
      d4:	0c 94 49 0d 	jmp	0x1a92	; 0x1a92 <__vector_53>
      d8:	0c 94 76 0d 	jmp	0x1aec	; 0x1aec <__vector_54>
      dc:	0c 94 a3 0d 	jmp	0x1b46	; 0x1b46 <__vector_55>
      e0:	0c 94 d0 0d 	jmp	0x1ba0	; 0x1ba0 <__vector_56>
      e4:	ff c1       	rjmp	.+1022   	; 0x4e4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	fd c1       	rjmp	.+1018   	; 0x4e4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	fb c1       	rjmp	.+1014   	; 0x4e4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f9 c1       	rjmp	.+1010   	; 0x4e4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	f7 c1       	rjmp	.+1006   	; 0x4e4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	f5 c1       	rjmp	.+1002   	; 0x4e4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f3 c1       	rjmp	.+998    	; 0x4e4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f1 c1       	rjmp	.+994    	; 0x4e4 <__bad_interrupt>
     102:	00 00       	nop
     104:	ef c1       	rjmp	.+990    	; 0x4e4 <__bad_interrupt>
     106:	00 00       	nop
     108:	ed c1       	rjmp	.+986    	; 0x4e4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	eb c1       	rjmp	.+982    	; 0x4e4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e9 c1       	rjmp	.+978    	; 0x4e4 <__bad_interrupt>
     112:	00 00       	nop
     114:	e7 c1       	rjmp	.+974    	; 0x4e4 <__bad_interrupt>
     116:	00 00       	nop
     118:	e5 c1       	rjmp	.+970    	; 0x4e4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	8c c5       	rjmp	.+2840   	; 0xc36 <__vector_71>
     11e:	00 00       	nop
     120:	bc c5       	rjmp	.+2936   	; 0xc9a <__vector_72>
     122:	00 00       	nop
     124:	ec c5       	rjmp	.+3032   	; 0xcfe <__vector_73>
     126:	00 00       	nop
     128:	1c c6       	rjmp	.+3128   	; 0xd62 <__vector_74>
     12a:	00 00       	nop
     12c:	db c1       	rjmp	.+950    	; 0x4e4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d9 c1       	rjmp	.+946    	; 0x4e4 <__bad_interrupt>
     132:	00 00       	nop
     134:	0c 94 79 0a 	jmp	0x14f2	; 0x14f2 <__vector_77>
     138:	0c 94 a6 0a 	jmp	0x154c	; 0x154c <__vector_78>
     13c:	0c 94 d3 0a 	jmp	0x15a6	; 0x15a6 <__vector_79>
     140:	0c 94 00 0b 	jmp	0x1600	; 0x1600 <__vector_80>
     144:	0c 94 2d 0b 	jmp	0x165a	; 0x165a <__vector_81>
     148:	0c 94 5a 0b 	jmp	0x16b4	; 0x16b4 <__vector_82>
     14c:	0c 94 87 0b 	jmp	0x170e	; 0x170e <__vector_83>
     150:	0c 94 b4 0b 	jmp	0x1768	; 0x1768 <__vector_84>
     154:	0c 94 e1 0b 	jmp	0x17c2	; 0x17c2 <__vector_85>
     158:	0c 94 0e 0c 	jmp	0x181c	; 0x181c <__vector_86>
     15c:	c3 c1       	rjmp	.+902    	; 0x4e4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c1 c1       	rjmp	.+898    	; 0x4e4 <__bad_interrupt>
     162:	00 00       	nop
     164:	bf c1       	rjmp	.+894    	; 0x4e4 <__bad_interrupt>
     166:	00 00       	nop
     168:	bd c1       	rjmp	.+890    	; 0x4e4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	bb c1       	rjmp	.+886    	; 0x4e4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b9 c1       	rjmp	.+882    	; 0x4e4 <__bad_interrupt>
     172:	00 00       	nop
     174:	b7 c1       	rjmp	.+878    	; 0x4e4 <__bad_interrupt>
     176:	00 00       	nop
     178:	b5 c1       	rjmp	.+874    	; 0x4e4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b3 c1       	rjmp	.+870    	; 0x4e4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b1 c1       	rjmp	.+866    	; 0x4e4 <__bad_interrupt>
     182:	00 00       	nop
     184:	af c1       	rjmp	.+862    	; 0x4e4 <__bad_interrupt>
     186:	00 00       	nop
     188:	ad c1       	rjmp	.+858    	; 0x4e4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	ab c1       	rjmp	.+854    	; 0x4e4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a9 c1       	rjmp	.+850    	; 0x4e4 <__bad_interrupt>
     192:	00 00       	nop
     194:	a7 c1       	rjmp	.+846    	; 0x4e4 <__bad_interrupt>
     196:	00 00       	nop
     198:	a5 c1       	rjmp	.+842    	; 0x4e4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a3 c1       	rjmp	.+838    	; 0x4e4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a1 c1       	rjmp	.+834    	; 0x4e4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	9f c1       	rjmp	.+830    	; 0x4e4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	9d c1       	rjmp	.+826    	; 0x4e4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	9b c1       	rjmp	.+822    	; 0x4e4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	0c 94 fd 0d 	jmp	0x1bfa	; 0x1bfa <__vector_108>
     1b4:	0c 94 2a 0e 	jmp	0x1c54	; 0x1c54 <__vector_109>
     1b8:	0c 94 57 0e 	jmp	0x1cae	; 0x1cae <__vector_110>
     1bc:	0c 94 84 0e 	jmp	0x1d08	; 0x1d08 <__vector_111>
     1c0:	0c 94 b1 0e 	jmp	0x1d62	; 0x1d62 <__vector_112>
     1c4:	0c 94 de 0e 	jmp	0x1dbc	; 0x1dbc <__vector_113>
     1c8:	8d c1       	rjmp	.+794    	; 0x4e4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	8b c1       	rjmp	.+790    	; 0x4e4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	89 c1       	rjmp	.+786    	; 0x4e4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	87 c1       	rjmp	.+782    	; 0x4e4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	85 c1       	rjmp	.+778    	; 0x4e4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	83 c1       	rjmp	.+774    	; 0x4e4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	81 c1       	rjmp	.+770    	; 0x4e4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	7f c1       	rjmp	.+766    	; 0x4e4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	7d c1       	rjmp	.+762    	; 0x4e4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	7b c1       	rjmp	.+758    	; 0x4e4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	79 c1       	rjmp	.+754    	; 0x4e4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	77 c1       	rjmp	.+750    	; 0x4e4 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	75 c1       	rjmp	.+746    	; 0x4e4 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	b5 1c       	adc	r11, r5
     1fe:	b5 1c       	adc	r11, r5
     200:	b5 1c       	adc	r11, r5
     202:	e2 1c       	adc	r14, r2
     204:	ea 1c       	adc	r14, r10
     206:	f8 1c       	adc	r15, r8
     208:	b5 1c       	adc	r11, r5
     20a:	b5 1c       	adc	r11, r5
     20c:	e2 1c       	adc	r14, r2
     20e:	ea 1c       	adc	r14, r10

00000210 <__trampolines_end>:
     210:	00 00       	nop
     212:	00 00       	nop
     214:	00 00       	nop
     216:	00 20       	and	r0, r0
     218:	20 20       	and	r2, r0
     21a:	20 20       	and	r2, r0
     21c:	00 20       	and	r0, r0
     21e:	50 50       	subi	r21, 0x00	; 0
     220:	50 00       	.word	0x0050	; ????
     222:	00 00       	nop
     224:	00 50       	subi	r16, 0x00	; 0
     226:	50 f8       	bld	r5, 0
     228:	50 f8       	bld	r5, 0
     22a:	50 50       	subi	r21, 0x00	; 0
     22c:	20 78       	andi	r18, 0x80	; 128
     22e:	a0 70       	andi	r26, 0x00	; 0
     230:	28 f0       	brcs	.+10     	; 0x23c <__trampolines_end+0x2c>
     232:	20 c0       	rjmp	.+64     	; 0x274 <__trampolines_end+0x64>
     234:	c8 10       	cpse	r12, r8
     236:	20 40       	sbci	r18, 0x00	; 0
     238:	98 18       	sub	r9, r8
     23a:	60 90 a0 40 	lds	r6, 0x40A0	; 0x8040a0 <__bss_end+0x1c0f>
     23e:	a8 90       	.word	0x90a8	; ????
     240:	68 60       	ori	r22, 0x08	; 8
     242:	20 40       	sbci	r18, 0x00	; 0
     244:	00 00       	nop
     246:	00 00       	nop
     248:	10 20       	and	r1, r0
     24a:	40 40       	sbci	r20, 0x00	; 0
     24c:	40 20       	and	r4, r0
     24e:	10 40       	sbci	r17, 0x00	; 0
     250:	20 10       	cpse	r2, r0
     252:	10 10       	cpse	r1, r0
     254:	20 40       	sbci	r18, 0x00	; 0
     256:	00 50       	subi	r16, 0x00	; 0
     258:	20 f8       	bld	r2, 0
     25a:	20 50       	subi	r18, 0x00	; 0
     25c:	00 00       	nop
     25e:	20 20       	and	r2, r0
     260:	f8 20       	and	r15, r8
     262:	20 00       	.word	0x0020	; ????
     264:	00 00       	nop
     266:	00 00       	nop
     268:	60 20       	and	r6, r0
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	f8 00       	.word	0x00f8	; ????
     270:	00 00       	nop
     272:	00 00       	nop
     274:	00 00       	nop
     276:	00 60       	ori	r16, 0x00	; 0
     278:	60 00       	.word	0x0060	; ????
     27a:	08 10       	cpse	r0, r8
     27c:	20 40       	sbci	r18, 0x00	; 0
     27e:	80 00       	.word	0x0080	; ????
     280:	70 88       	ldd	r7, Z+16	; 0x10
     282:	98 a8       	ldd	r9, Y+48	; 0x30
     284:	c8 88       	ldd	r12, Y+16	; 0x10
     286:	70 20       	and	r7, r0
     288:	60 20       	and	r6, r0
     28a:	20 20       	and	r2, r0
     28c:	20 70       	andi	r18, 0x00	; 0
     28e:	70 88       	ldd	r7, Z+16	; 0x10
     290:	08 10       	cpse	r0, r8
     292:	20 40       	sbci	r18, 0x00	; 0
     294:	f8 f8       	.word	0xf8f8	; ????
     296:	10 20       	and	r1, r0
     298:	10 08       	sbc	r1, r0
     29a:	88 70       	andi	r24, 0x08	; 8
     29c:	10 30       	cpi	r17, 0x00	; 0
     29e:	50 90 f8 10 	lds	r5, 0x10F8	; 0x8010f8 <__TEXT_REGION_LENGTH__+0x7010f8>
     2a2:	10 f8       	bld	r1, 0
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <__trampolines_end+0xb6>
     2a6:	08 08       	sbc	r0, r8
     2a8:	88 70       	andi	r24, 0x08	; 8
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 f0       	brcs	.+32     	; 0x2ce <__trampolines_end+0xbe>
     2ae:	88 88       	ldd	r8, Y+16	; 0x10
     2b0:	70 f8       	bld	r7, 0
     2b2:	08 10       	cpse	r0, r8
     2b4:	20 40       	sbci	r18, 0x00	; 0
     2b6:	40 40       	sbci	r20, 0x00	; 0
     2b8:	70 88       	ldd	r7, Z+16	; 0x10
     2ba:	88 70       	andi	r24, 0x08	; 8
     2bc:	88 88       	ldd	r8, Y+16	; 0x10
     2be:	70 70       	andi	r23, 0x00	; 0
     2c0:	88 88       	ldd	r8, Y+16	; 0x10
     2c2:	78 08       	sbc	r7, r8
     2c4:	10 60       	ori	r17, 0x00	; 0
     2c6:	00 60       	ori	r16, 0x00	; 0
     2c8:	60 00       	.word	0x0060	; ????
     2ca:	60 60       	ori	r22, 0x00	; 0
     2cc:	00 00       	nop
     2ce:	60 60       	ori	r22, 0x00	; 0
     2d0:	00 60       	ori	r16, 0x00	; 0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	08 10       	cpse	r0, r8
     2d6:	20 40       	sbci	r18, 0x00	; 0
     2d8:	20 10       	cpse	r2, r0
     2da:	08 00       	.word	0x0008	; ????
     2dc:	00 f8       	bld	r0, 0
     2de:	00 f8       	bld	r0, 0
     2e0:	00 00       	nop
     2e2:	80 40       	sbci	r24, 0x00	; 0
     2e4:	20 10       	cpse	r2, r0
     2e6:	20 40       	sbci	r18, 0x00	; 0
     2e8:	80 70       	andi	r24, 0x00	; 0
     2ea:	88 08       	sbc	r8, r8
     2ec:	10 20       	and	r1, r0
     2ee:	00 20       	and	r0, r0
     2f0:	70 88       	ldd	r7, Z+16	; 0x10
     2f2:	08 68       	ori	r16, 0x88	; 136
     2f4:	a8 a8       	ldd	r10, Y+48	; 0x30
     2f6:	70 70       	andi	r23, 0x00	; 0
     2f8:	88 88       	ldd	r8, Y+16	; 0x10
     2fa:	88 f8       	.word	0xf888	; ????
     2fc:	88 88       	ldd	r8, Y+16	; 0x10
     2fe:	f0 88       	ldd	r15, Z+16	; 0x10
     300:	88 f0       	brcs	.+34     	; 0x324 <__trampolines_end+0x114>
     302:	88 88       	ldd	r8, Y+16	; 0x10
     304:	f0 70       	andi	r31, 0x00	; 0
     306:	88 80       	ld	r8, Y
     308:	80 80       	ld	r8, Z
     30a:	88 70       	andi	r24, 0x08	; 8
     30c:	e0 90 88 88 	lds	r14, 0x8888	; 0x808888 <__bss_end+0x63f7>
     310:	88 90       	.word	0x9088	; ????
     312:	e0 f8       	bld	r14, 0
     314:	80 80       	ld	r8, Z
     316:	f0 80       	ld	r15, Z
     318:	80 f8       	bld	r8, 0
     31a:	f8 80       	ld	r15, Y
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	80 80       	ld	r8, Z
     320:	80 70       	andi	r24, 0x00	; 0
     322:	88 80       	ld	r8, Y
     324:	80 98       	cbi	0x10, 0	; 16
     326:	88 70       	andi	r24, 0x08	; 8
     328:	88 88       	ldd	r8, Y+16	; 0x10
     32a:	88 f8       	.word	0xf888	; ????
     32c:	88 88       	ldd	r8, Y+16	; 0x10
     32e:	88 70       	andi	r24, 0x08	; 8
     330:	20 20       	and	r2, r0
     332:	20 20       	and	r2, r0
     334:	20 70       	andi	r18, 0x00	; 0
     336:	38 10       	cpse	r3, r8
     338:	10 10       	cpse	r1, r0
     33a:	10 90 60 88 	lds	r1, 0x8860	; 0x808860 <__bss_end+0x63cf>
     33e:	90 a0       	ldd	r9, Z+32	; 0x20
     340:	c0 a0       	ldd	r12, Z+32	; 0x20
     342:	90 88       	ldd	r9, Z+16	; 0x10
     344:	80 80       	ld	r8, Z
     346:	80 80       	ld	r8, Z
     348:	80 80       	ld	r8, Z
     34a:	f8 88       	ldd	r15, Y+16	; 0x10
     34c:	d8 a8       	ldd	r13, Y+48	; 0x30
     34e:	88 88       	ldd	r8, Y+16	; 0x10
     350:	88 88       	ldd	r8, Y+16	; 0x10
     352:	88 88       	ldd	r8, Y+16	; 0x10
     354:	c8 a8       	ldd	r12, Y+48	; 0x30
     356:	98 88       	ldd	r9, Y+16	; 0x10
     358:	88 70       	andi	r24, 0x08	; 8
     35a:	88 88       	ldd	r8, Y+16	; 0x10
     35c:	88 88       	ldd	r8, Y+16	; 0x10
     35e:	88 70       	andi	r24, 0x08	; 8
     360:	f0 88       	ldd	r15, Z+16	; 0x10
     362:	88 f0       	brcs	.+34     	; 0x386 <__trampolines_end+0x176>
     364:	80 80       	ld	r8, Z
     366:	80 70       	andi	r24, 0x00	; 0
     368:	88 88       	ldd	r8, Y+16	; 0x10
     36a:	88 a8       	ldd	r8, Y+48	; 0x30
     36c:	90 68       	ori	r25, 0x80	; 128
     36e:	f0 88       	ldd	r15, Z+16	; 0x10
     370:	88 f0       	brcs	.+34     	; 0x394 <__trampolines_end+0x184>
     372:	a0 90 88 78 	lds	r10, 0x7888	; 0x807888 <__bss_end+0x53f7>
     376:	80 80       	ld	r8, Z
     378:	70 08       	sbc	r7, r0
     37a:	08 f0       	brcs	.+2      	; 0x37e <__trampolines_end+0x16e>
     37c:	f8 20       	and	r15, r8
     37e:	20 20       	and	r2, r0
     380:	20 20       	and	r2, r0
     382:	20 88       	ldd	r2, Z+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	88 88       	ldd	r8, Y+16	; 0x10
     388:	88 70       	andi	r24, 0x08	; 8
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 88       	ldd	r8, Y+16	; 0x10
     38e:	88 50       	subi	r24, 0x08	; 8
     390:	20 88       	ldd	r2, Z+16	; 0x10
     392:	88 88       	ldd	r8, Y+16	; 0x10
     394:	a8 a8       	ldd	r10, Y+48	; 0x30
     396:	d8 88       	ldd	r13, Y+16	; 0x10
     398:	88 88       	ldd	r8, Y+16	; 0x10
     39a:	50 20       	and	r5, r0
     39c:	50 88       	ldd	r5, Z+16	; 0x10
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 50       	subi	r24, 0x08	; 8
     3a2:	20 20       	and	r2, r0
     3a4:	20 20       	and	r2, r0
     3a6:	f8 08       	sbc	r15, r8
     3a8:	10 20       	and	r1, r0
     3aa:	40 80       	ld	r4, Z
     3ac:	f8 38       	cpi	r31, 0x88	; 136
     3ae:	20 20       	and	r2, r0
     3b0:	20 20       	and	r2, r0
     3b2:	20 38       	cpi	r18, 0x80	; 128
     3b4:	00 80       	ld	r0, Z
     3b6:	40 20       	and	r4, r0
     3b8:	10 08       	sbc	r1, r0
     3ba:	00 e0       	ldi	r16, 0x00	; 0
     3bc:	20 20       	and	r2, r0
     3be:	20 20       	and	r2, r0
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	20 50       	subi	r18, 0x00	; 0
     3c4:	88 00       	.word	0x0088	; ????
	...
     3ce:	00 f8       	bld	r0, 0
     3d0:	40 20       	and	r4, r0
     3d2:	10 00       	.word	0x0010	; ????
     3d4:	00 00       	nop
     3d6:	00 00       	nop
     3d8:	00 70       	andi	r16, 0x00	; 0
     3da:	08 78       	andi	r16, 0x88	; 136
     3dc:	88 78       	andi	r24, 0x88	; 136
     3de:	80 80       	ld	r8, Z
     3e0:	b0 c8       	rjmp	.-3744   	; 0xfffff542 <__eeprom_end+0xff7ef542>
     3e2:	88 88       	ldd	r8, Y+16	; 0x10
     3e4:	f0 00       	.word	0x00f0	; ????
     3e6:	00 70       	andi	r16, 0x00	; 0
     3e8:	80 80       	ld	r8, Z
     3ea:	88 70       	andi	r24, 0x08	; 8
     3ec:	08 08       	sbc	r0, r8
     3ee:	68 98       	cbi	0x0d, 0	; 13
     3f0:	88 88       	ldd	r8, Y+16	; 0x10
     3f2:	78 00       	.word	0x0078	; ????
     3f4:	00 70       	andi	r16, 0x00	; 0
     3f6:	88 f8       	.word	0xf888	; ????
     3f8:	80 70       	andi	r24, 0x00	; 0
     3fa:	30 48       	sbci	r19, 0x80	; 128
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	40 40       	sbci	r20, 0x00	; 0
     400:	40 00       	.word	0x0040	; ????
     402:	00 78       	andi	r16, 0x80	; 128
     404:	88 78       	andi	r24, 0x88	; 136
     406:	08 30       	cpi	r16, 0x08	; 8
     408:	80 80       	ld	r8, Z
     40a:	b0 c8       	rjmp	.-3744   	; 0xfffff56c <__eeprom_end+0xff7ef56c>
     40c:	88 88       	ldd	r8, Y+16	; 0x10
     40e:	88 20       	and	r8, r8
     410:	00 60       	ori	r16, 0x00	; 0
     412:	20 20       	and	r2, r0
     414:	20 70       	andi	r18, 0x00	; 0
     416:	10 00       	.word	0x0010	; ????
     418:	30 10       	cpse	r3, r0
     41a:	10 90 60 40 	lds	r1, 0x4060	; 0x804060 <__bss_end+0x1bcf>
     41e:	40 48       	sbci	r20, 0x80	; 128
     420:	50 60       	ori	r21, 0x00	; 0
     422:	50 48       	sbci	r21, 0x80	; 128
     424:	60 20       	and	r6, r0
     426:	20 20       	and	r2, r0
     428:	20 20       	and	r2, r0
     42a:	70 00       	.word	0x0070	; ????
     42c:	00 d0       	rcall	.+0      	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
     42e:	a8 a8       	ldd	r10, Y+48	; 0x30
     430:	88 88       	ldd	r8, Y+16	; 0x10
     432:	00 00       	nop
     434:	b0 c8       	rjmp	.-3744   	; 0xfffff596 <__eeprom_end+0xff7ef596>
     436:	88 88       	ldd	r8, Y+16	; 0x10
     438:	88 00       	.word	0x0088	; ????
     43a:	00 70       	andi	r16, 0x00	; 0
     43c:	88 88       	ldd	r8, Y+16	; 0x10
     43e:	88 70       	andi	r24, 0x08	; 8
     440:	00 00       	nop
     442:	f0 88       	ldd	r15, Z+16	; 0x10
     444:	f0 80       	ld	r15, Z
     446:	80 00       	.word	0x0080	; ????
     448:	00 68       	ori	r16, 0x80	; 128
     44a:	98 78       	andi	r25, 0x88	; 136
     44c:	08 08       	sbc	r0, r8
     44e:	00 00       	nop
     450:	b0 c8       	rjmp	.-3744   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     452:	80 80       	ld	r8, Z
     454:	80 00       	.word	0x0080	; ????
     456:	00 70       	andi	r16, 0x00	; 0
     458:	80 70       	andi	r24, 0x00	; 0
     45a:	08 f0       	brcs	.+2      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     45c:	40 40       	sbci	r20, 0x00	; 0
     45e:	e0 40       	sbci	r30, 0x00	; 0
     460:	40 48       	sbci	r20, 0x80	; 128
     462:	30 00       	.word	0x0030	; ????
     464:	00 88       	ldd	r0, Z+16	; 0x10
     466:	88 88       	ldd	r8, Y+16	; 0x10
     468:	98 68       	ori	r25, 0x88	; 136
     46a:	00 00       	nop
     46c:	88 88       	ldd	r8, Y+16	; 0x10
     46e:	88 50       	subi	r24, 0x08	; 8
     470:	20 00       	.word	0x0020	; ????
     472:	00 88       	ldd	r0, Z+16	; 0x10
     474:	88 a8       	ldd	r8, Y+48	; 0x30
     476:	a8 50       	subi	r26, 0x08	; 8
     478:	00 00       	nop
     47a:	88 50       	subi	r24, 0x08	; 8
     47c:	20 50       	subi	r18, 0x00	; 0
     47e:	88 00       	.word	0x0088	; ????
     480:	00 88       	ldd	r0, Z+16	; 0x10
     482:	88 78       	andi	r24, 0x88	; 136
     484:	08 70       	andi	r16, 0x08	; 8
     486:	00 00       	nop
     488:	f8 10       	cpse	r15, r8
     48a:	20 40       	sbci	r18, 0x00	; 0
     48c:	f8 10       	cpse	r15, r8
     48e:	20 20       	and	r2, r0
     490:	40 20       	and	r4, r0
     492:	20 10       	cpse	r2, r0
     494:	20 20       	and	r2, r0
     496:	20 20       	and	r2, r0
     498:	20 20       	and	r2, r0
     49a:	20 40       	sbci	r18, 0x00	; 0
     49c:	20 20       	and	r2, r0
     49e:	10 20       	and	r1, r0
     4a0:	20 40       	sbci	r18, 0x00	; 0

000004a2 <__ctors_end>:
     4a2:	11 24       	eor	r1, r1
     4a4:	1f be       	out	0x3f, r1	; 63
     4a6:	cf ef       	ldi	r28, 0xFF	; 255
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	df e5       	ldi	r29, 0x5F	; 95
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	00 e0       	ldi	r16, 0x00	; 0
     4b0:	0c bf       	out	0x3c, r16	; 60

000004b2 <__do_copy_data>:
     4b2:	10 e2       	ldi	r17, 0x20	; 32
     4b4:	a0 e0       	ldi	r26, 0x00	; 0
     4b6:	b0 e2       	ldi	r27, 0x20	; 32
     4b8:	e8 eb       	ldi	r30, 0xB8	; 184
     4ba:	fe e4       	ldi	r31, 0x4E	; 78
     4bc:	00 e0       	ldi	r16, 0x00	; 0
     4be:	0b bf       	out	0x3b, r16	; 59
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__do_copy_data+0x14>
     4c2:	07 90       	elpm	r0, Z+
     4c4:	0d 92       	st	X+, r0
     4c6:	a6 3b       	cpi	r26, 0xB6	; 182
     4c8:	b1 07       	cpc	r27, r17
     4ca:	d9 f7       	brne	.-10     	; 0x4c2 <__do_copy_data+0x10>

000004cc <__do_clear_bss>:
     4cc:	24 e2       	ldi	r18, 0x24	; 36
     4ce:	a6 eb       	ldi	r26, 0xB6	; 182
     4d0:	b0 e2       	ldi	r27, 0x20	; 32
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <.do_clear_bss_start>

000004d4 <.do_clear_bss_loop>:
     4d4:	1d 92       	st	X+, r1

000004d6 <.do_clear_bss_start>:
     4d6:	a1 39       	cpi	r26, 0x91	; 145
     4d8:	b2 07       	cpc	r27, r18
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <.do_clear_bss_loop>
     4dc:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <main>
     4e0:	0c 94 5a 27 	jmp	0x4eb4	; 0x4eb4 <_exit>

000004e4 <__bad_interrupt>:
     4e4:	8d cd       	rjmp	.-1254   	; 0x0 <__vectors>

000004e6 <__portable_avr_delay_cycles>:
 *
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
     4e6:	04 c0       	rjmp	.+8      	; 0x4f0 <__portable_avr_delay_cycles+0xa>
	while (n) {
		barrier();
		n--;
     4e8:	61 50       	subi	r22, 0x01	; 1
     4ea:	71 09       	sbc	r23, r1
     4ec:	81 09       	sbc	r24, r1
     4ee:	91 09       	sbc	r25, r1
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	while (n) {
     4f0:	61 15       	cp	r22, r1
     4f2:	71 05       	cpc	r23, r1
     4f4:	81 05       	cpc	r24, r1
     4f6:	91 05       	cpc	r25, r1
     4f8:	b9 f7       	brne	.-18     	; 0x4e8 <__portable_avr_delay_cycles+0x2>
     4fa:	08 95       	ret

000004fc <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     4fc:	bf 92       	push	r11
     4fe:	cf 92       	push	r12
     500:	df 92       	push	r13
     502:	ef 92       	push	r14
     504:	ff 92       	push	r15
     506:	0f 93       	push	r16
     508:	1f 93       	push	r17
     50a:	cf 93       	push	r28
     50c:	df 93       	push	r29
     50e:	1f 92       	push	r1
     510:	cd b7       	in	r28, 0x3d	; 61
     512:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     514:	00 e0       	ldi	r16, 0x00	; 0
     516:	16 e0       	ldi	r17, 0x06	; 6
     518:	68 94       	set
     51a:	ff 24       	eor	r15, r15
     51c:	f3 f8       	bld	r15, 3
     51e:	f8 01       	movw	r30, r16
     520:	f6 82       	std	Z+6, r15	; 0x06
 * function, this command will control the RST pin.
 */
static inline void st7565r_hard_reset(void)
{
	ioport_set_pin_low(ST7565R_RESET_PIN);
	delay_us(10);
     522:	64 e0       	ldi	r22, 0x04	; 4
     524:	70 e0       	ldi	r23, 0x00	; 0
     526:	80 e0       	ldi	r24, 0x00	; 0
     528:	90 e0       	ldi	r25, 0x00	; 0
     52a:	dd df       	rcall	.-70     	; 0x4e6 <__portable_avr_delay_cycles>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     52c:	f8 01       	movw	r30, r16
     52e:	f5 82       	std	Z+5, r15	; 0x05
	ioport_set_pin_high(ST7565R_RESET_PIN);
	delay_us(10);
     530:	64 e0       	ldi	r22, 0x04	; 4
     532:	70 e0       	ldi	r23, 0x00	; 0
     534:	80 e0       	ldi	r24, 0x00	; 0
     536:	90 e0       	ldi	r25, 0x00	; 0
     538:	d6 df       	rcall	.-84     	; 0x4e6 <__portable_avr_delay_cycles>
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     53a:	0f 2e       	mov	r0, r31
     53c:	fb e2       	ldi	r31, 0x2B	; 43
     53e:	bf 2e       	mov	r11, r31
     540:	f0 2d       	mov	r31, r0
     542:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     544:	80 ea       	ldi	r24, 0xA0	; 160
     546:	99 e0       	ldi	r25, 0x09	; 9
     548:	0e 94 22 1d 	call	0x3a44	; 0x3a44 <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     54c:	c1 2c       	mov	r12, r1
     54e:	d1 2c       	mov	r13, r1
     550:	76 01       	movw	r14, r12
     552:	00 e4       	ldi	r16, 0x40	; 64
     554:	12 e4       	ldi	r17, 0x42	; 66
     556:	2f e0       	ldi	r18, 0x0F	; 15
     558:	30 e0       	ldi	r19, 0x00	; 0
     55a:	43 e0       	ldi	r20, 0x03	; 3
     55c:	be 01       	movw	r22, r28
     55e:	6f 5f       	subi	r22, 0xFF	; 255
     560:	7f 4f       	sbci	r23, 0xFF	; 255
     562:	80 ea       	ldi	r24, 0xA0	; 160
     564:	99 e0       	ldi	r25, 0x09	; 9
     566:	0e 94 51 1d 	call	0x3aa2	; 0x3aa2 <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     56a:	00 e6       	ldi	r16, 0x60	; 96
     56c:	16 e0       	ldi	r17, 0x06	; 6
     56e:	ff 24       	eor	r15, r15
     570:	f3 94       	inc	r15
     572:	f8 01       	movw	r30, r16
     574:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     576:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     578:	be 01       	movw	r22, r28
     57a:	6f 5f       	subi	r22, 0xFF	; 255
     57c:	7f 4f       	sbci	r23, 0xFF	; 255
     57e:	80 ea       	ldi	r24, 0xA0	; 160
     580:	99 e0       	ldi	r25, 0x09	; 9
     582:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     586:	f8 01       	movw	r30, r16
     588:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     58a:	e0 ea       	ldi	r30, 0xA0	; 160
     58c:	f9 e0       	ldi	r31, 0x09	; 9
     58e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     590:	85 ff       	sbrs	r24, 5
     592:	fd cf       	rjmp	.-6      	; 0x58e <st7565r_init+0x92>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     594:	80 ea       	ldi	r24, 0xA0	; 160
     596:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     59a:	e0 ea       	ldi	r30, 0xA0	; 160
     59c:	f9 e0       	ldi	r31, 0x09	; 9
     59e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5a0:	86 ff       	sbrs	r24, 6
     5a2:	fd cf       	rjmp	.-6      	; 0x59e <st7565r_init+0xa2>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5a4:	e0 ea       	ldi	r30, 0xA0	; 160
     5a6:	f9 e0       	ldi	r31, 0x09	; 9
     5a8:	80 e4       	ldi	r24, 0x40	; 64
     5aa:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5ac:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5ae:	be 01       	movw	r22, r28
     5b0:	6f 5f       	subi	r22, 0xFF	; 255
     5b2:	7f 4f       	sbci	r23, 0xFF	; 255
     5b4:	80 ea       	ldi	r24, 0xA0	; 160
     5b6:	99 e0       	ldi	r25, 0x09	; 9
     5b8:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5bc:	8b e2       	ldi	r24, 0x2B	; 43
     5be:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5c0:	be 01       	movw	r22, r28
     5c2:	6f 5f       	subi	r22, 0xFF	; 255
     5c4:	7f 4f       	sbci	r23, 0xFF	; 255
     5c6:	80 ea       	ldi	r24, 0xA0	; 160
     5c8:	99 e0       	ldi	r25, 0x09	; 9
     5ca:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     5ce:	81 e0       	ldi	r24, 0x01	; 1
     5d0:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     5d4:	e0 ea       	ldi	r30, 0xA0	; 160
     5d6:	f9 e0       	ldi	r31, 0x09	; 9
     5d8:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5da:	85 ff       	sbrs	r24, 5
     5dc:	fd cf       	rjmp	.-6      	; 0x5d8 <st7565r_init+0xdc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5de:	86 ea       	ldi	r24, 0xA6	; 166
     5e0:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5e4:	e0 ea       	ldi	r30, 0xA0	; 160
     5e6:	f9 e0       	ldi	r31, 0x09	; 9
     5e8:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5ea:	86 ff       	sbrs	r24, 6
     5ec:	fd cf       	rjmp	.-6      	; 0x5e8 <st7565r_init+0xec>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5ee:	e0 ea       	ldi	r30, 0xA0	; 160
     5f0:	f9 e0       	ldi	r31, 0x09	; 9
     5f2:	80 e4       	ldi	r24, 0x40	; 64
     5f4:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5f6:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5f8:	be 01       	movw	r22, r28
     5fa:	6f 5f       	subi	r22, 0xFF	; 255
     5fc:	7f 4f       	sbci	r23, 0xFF	; 255
     5fe:	80 ea       	ldi	r24, 0xA0	; 160
     600:	99 e0       	ldi	r25, 0x09	; 9
     602:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     606:	8b e2       	ldi	r24, 0x2B	; 43
     608:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     60a:	be 01       	movw	r22, r28
     60c:	6f 5f       	subi	r22, 0xFF	; 255
     60e:	7f 4f       	sbci	r23, 0xFF	; 255
     610:	80 ea       	ldi	r24, 0xA0	; 160
     612:	99 e0       	ldi	r25, 0x09	; 9
     614:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     618:	81 e0       	ldi	r24, 0x01	; 1
     61a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     61e:	e0 ea       	ldi	r30, 0xA0	; 160
     620:	f9 e0       	ldi	r31, 0x09	; 9
     622:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     624:	85 ff       	sbrs	r24, 5
     626:	fd cf       	rjmp	.-6      	; 0x622 <st7565r_init+0x126>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     628:	88 ec       	ldi	r24, 0xC8	; 200
     62a:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     62e:	e0 ea       	ldi	r30, 0xA0	; 160
     630:	f9 e0       	ldi	r31, 0x09	; 9
     632:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     634:	86 ff       	sbrs	r24, 6
     636:	fd cf       	rjmp	.-6      	; 0x632 <st7565r_init+0x136>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     638:	e0 ea       	ldi	r30, 0xA0	; 160
     63a:	f9 e0       	ldi	r31, 0x09	; 9
     63c:	80 e4       	ldi	r24, 0x40	; 64
     63e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     640:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     642:	be 01       	movw	r22, r28
     644:	6f 5f       	subi	r22, 0xFF	; 255
     646:	7f 4f       	sbci	r23, 0xFF	; 255
     648:	80 ea       	ldi	r24, 0xA0	; 160
     64a:	99 e0       	ldi	r25, 0x09	; 9
     64c:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     650:	8b e2       	ldi	r24, 0x2B	; 43
     652:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     654:	be 01       	movw	r22, r28
     656:	6f 5f       	subi	r22, 0xFF	; 255
     658:	7f 4f       	sbci	r23, 0xFF	; 255
     65a:	80 ea       	ldi	r24, 0xA0	; 160
     65c:	99 e0       	ldi	r25, 0x09	; 9
     65e:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     662:	81 e0       	ldi	r24, 0x01	; 1
     664:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     668:	e0 ea       	ldi	r30, 0xA0	; 160
     66a:	f9 e0       	ldi	r31, 0x09	; 9
     66c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     66e:	85 ff       	sbrs	r24, 5
     670:	fd cf       	rjmp	.-6      	; 0x66c <st7565r_init+0x170>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     672:	82 ea       	ldi	r24, 0xA2	; 162
     674:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     678:	e0 ea       	ldi	r30, 0xA0	; 160
     67a:	f9 e0       	ldi	r31, 0x09	; 9
     67c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     67e:	86 ff       	sbrs	r24, 6
     680:	fd cf       	rjmp	.-6      	; 0x67c <st7565r_init+0x180>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     682:	e0 ea       	ldi	r30, 0xA0	; 160
     684:	f9 e0       	ldi	r31, 0x09	; 9
     686:	80 e4       	ldi	r24, 0x40	; 64
     688:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     68a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     68c:	be 01       	movw	r22, r28
     68e:	6f 5f       	subi	r22, 0xFF	; 255
     690:	7f 4f       	sbci	r23, 0xFF	; 255
     692:	80 ea       	ldi	r24, 0xA0	; 160
     694:	99 e0       	ldi	r25, 0x09	; 9
     696:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     69a:	8b e2       	ldi	r24, 0x2B	; 43
     69c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     69e:	be 01       	movw	r22, r28
     6a0:	6f 5f       	subi	r22, 0xFF	; 255
     6a2:	7f 4f       	sbci	r23, 0xFF	; 255
     6a4:	80 ea       	ldi	r24, 0xA0	; 160
     6a6:	99 e0       	ldi	r25, 0x09	; 9
     6a8:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     6ac:	81 e0       	ldi	r24, 0x01	; 1
     6ae:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6b2:	e0 ea       	ldi	r30, 0xA0	; 160
     6b4:	f9 e0       	ldi	r31, 0x09	; 9
     6b6:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6b8:	85 ff       	sbrs	r24, 5
     6ba:	fd cf       	rjmp	.-6      	; 0x6b6 <st7565r_init+0x1ba>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6bc:	8f e2       	ldi	r24, 0x2F	; 47
     6be:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6c2:	e0 ea       	ldi	r30, 0xA0	; 160
     6c4:	f9 e0       	ldi	r31, 0x09	; 9
     6c6:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6c8:	86 ff       	sbrs	r24, 6
     6ca:	fd cf       	rjmp	.-6      	; 0x6c6 <st7565r_init+0x1ca>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6cc:	e0 ea       	ldi	r30, 0xA0	; 160
     6ce:	f9 e0       	ldi	r31, 0x09	; 9
     6d0:	80 e4       	ldi	r24, 0x40	; 64
     6d2:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6d4:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6d6:	be 01       	movw	r22, r28
     6d8:	6f 5f       	subi	r22, 0xFF	; 255
     6da:	7f 4f       	sbci	r23, 0xFF	; 255
     6dc:	80 ea       	ldi	r24, 0xA0	; 160
     6de:	99 e0       	ldi	r25, 0x09	; 9
     6e0:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6e4:	8b e2       	ldi	r24, 0x2B	; 43
     6e6:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6e8:	be 01       	movw	r22, r28
     6ea:	6f 5f       	subi	r22, 0xFF	; 255
     6ec:	7f 4f       	sbci	r23, 0xFF	; 255
     6ee:	80 ea       	ldi	r24, 0xA0	; 160
     6f0:	99 e0       	ldi	r25, 0x09	; 9
     6f2:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     6f6:	81 e0       	ldi	r24, 0x01	; 1
     6f8:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6fc:	e0 ea       	ldi	r30, 0xA0	; 160
     6fe:	f9 e0       	ldi	r31, 0x09	; 9
     700:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     702:	85 ff       	sbrs	r24, 5
     704:	fd cf       	rjmp	.-6      	; 0x700 <st7565r_init+0x204>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     706:	88 ef       	ldi	r24, 0xF8	; 248
     708:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     70c:	e0 ea       	ldi	r30, 0xA0	; 160
     70e:	f9 e0       	ldi	r31, 0x09	; 9
     710:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     712:	86 ff       	sbrs	r24, 6
     714:	fd cf       	rjmp	.-6      	; 0x710 <st7565r_init+0x214>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     716:	e0 ea       	ldi	r30, 0xA0	; 160
     718:	f9 e0       	ldi	r31, 0x09	; 9
     71a:	80 e4       	ldi	r24, 0x40	; 64
     71c:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     71e:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     720:	be 01       	movw	r22, r28
     722:	6f 5f       	subi	r22, 0xFF	; 255
     724:	7f 4f       	sbci	r23, 0xFF	; 255
     726:	80 ea       	ldi	r24, 0xA0	; 160
     728:	99 e0       	ldi	r25, 0x09	; 9
     72a:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     72e:	8b e2       	ldi	r24, 0x2B	; 43
     730:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     732:	be 01       	movw	r22, r28
     734:	6f 5f       	subi	r22, 0xFF	; 255
     736:	7f 4f       	sbci	r23, 0xFF	; 255
     738:	80 ea       	ldi	r24, 0xA0	; 160
     73a:	99 e0       	ldi	r25, 0x09	; 9
     73c:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     740:	81 e0       	ldi	r24, 0x01	; 1
     742:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     746:	e0 ea       	ldi	r30, 0xA0	; 160
     748:	f9 e0       	ldi	r31, 0x09	; 9
     74a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     74c:	85 ff       	sbrs	r24, 5
     74e:	fd cf       	rjmp	.-6      	; 0x74a <st7565r_init+0x24e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     750:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     754:	e0 ea       	ldi	r30, 0xA0	; 160
     756:	f9 e0       	ldi	r31, 0x09	; 9
     758:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     75a:	86 ff       	sbrs	r24, 6
     75c:	fd cf       	rjmp	.-6      	; 0x758 <st7565r_init+0x25c>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     75e:	e0 ea       	ldi	r30, 0xA0	; 160
     760:	f9 e0       	ldi	r31, 0x09	; 9
     762:	80 e4       	ldi	r24, 0x40	; 64
     764:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     766:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     768:	be 01       	movw	r22, r28
     76a:	6f 5f       	subi	r22, 0xFF	; 255
     76c:	7f 4f       	sbci	r23, 0xFF	; 255
     76e:	80 ea       	ldi	r24, 0xA0	; 160
     770:	99 e0       	ldi	r25, 0x09	; 9
     772:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     776:	8b e2       	ldi	r24, 0x2B	; 43
     778:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     77a:	be 01       	movw	r22, r28
     77c:	6f 5f       	subi	r22, 0xFF	; 255
     77e:	7f 4f       	sbci	r23, 0xFF	; 255
     780:	80 ea       	ldi	r24, 0xA0	; 160
     782:	99 e0       	ldi	r25, 0x09	; 9
     784:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     788:	81 e0       	ldi	r24, 0x01	; 1
     78a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     78e:	e0 ea       	ldi	r30, 0xA0	; 160
     790:	f9 e0       	ldi	r31, 0x09	; 9
     792:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     794:	85 ff       	sbrs	r24, 5
     796:	fd cf       	rjmp	.-6      	; 0x792 <st7565r_init+0x296>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     798:	81 e2       	ldi	r24, 0x21	; 33
     79a:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     79e:	e0 ea       	ldi	r30, 0xA0	; 160
     7a0:	f9 e0       	ldi	r31, 0x09	; 9
     7a2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7a4:	86 ff       	sbrs	r24, 6
     7a6:	fd cf       	rjmp	.-6      	; 0x7a2 <st7565r_init+0x2a6>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7a8:	e0 ea       	ldi	r30, 0xA0	; 160
     7aa:	f9 e0       	ldi	r31, 0x09	; 9
     7ac:	80 e4       	ldi	r24, 0x40	; 64
     7ae:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7b0:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7b2:	be 01       	movw	r22, r28
     7b4:	6f 5f       	subi	r22, 0xFF	; 255
     7b6:	7f 4f       	sbci	r23, 0xFF	; 255
     7b8:	80 ea       	ldi	r24, 0xA0	; 160
     7ba:	99 e0       	ldi	r25, 0x09	; 9
     7bc:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7c0:	8b e2       	ldi	r24, 0x2B	; 43
     7c2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7c4:	be 01       	movw	r22, r28
     7c6:	6f 5f       	subi	r22, 0xFF	; 255
     7c8:	7f 4f       	sbci	r23, 0xFF	; 255
     7ca:	80 ea       	ldi	r24, 0xA0	; 160
     7cc:	99 e0       	ldi	r25, 0x09	; 9
     7ce:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     7d2:	81 e0       	ldi	r24, 0x01	; 1
     7d4:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7d8:	e0 ea       	ldi	r30, 0xA0	; 160
     7da:	f9 e0       	ldi	r31, 0x09	; 9
     7dc:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7de:	85 ff       	sbrs	r24, 5
     7e0:	fd cf       	rjmp	.-6      	; 0x7dc <st7565r_init+0x2e0>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7e2:	81 e8       	ldi	r24, 0x81	; 129
     7e4:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7e8:	e0 ea       	ldi	r30, 0xA0	; 160
     7ea:	f9 e0       	ldi	r31, 0x09	; 9
     7ec:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7ee:	86 ff       	sbrs	r24, 6
     7f0:	fd cf       	rjmp	.-6      	; 0x7ec <st7565r_init+0x2f0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7f2:	e0 ea       	ldi	r30, 0xA0	; 160
     7f4:	f9 e0       	ldi	r31, 0x09	; 9
     7f6:	80 e4       	ldi	r24, 0x40	; 64
     7f8:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7fa:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7fc:	be 01       	movw	r22, r28
     7fe:	6f 5f       	subi	r22, 0xFF	; 255
     800:	7f 4f       	sbci	r23, 0xFF	; 255
     802:	80 ea       	ldi	r24, 0xA0	; 160
     804:	99 e0       	ldi	r25, 0x09	; 9
     806:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     80a:	8b e2       	ldi	r24, 0x2B	; 43
     80c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     80e:	be 01       	movw	r22, r28
     810:	6f 5f       	subi	r22, 0xFF	; 255
     812:	7f 4f       	sbci	r23, 0xFF	; 255
     814:	80 ea       	ldi	r24, 0xA0	; 160
     816:	99 e0       	ldi	r25, 0x09	; 9
     818:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     81c:	81 e0       	ldi	r24, 0x01	; 1
     81e:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     822:	e0 ea       	ldi	r30, 0xA0	; 160
     824:	f9 e0       	ldi	r31, 0x09	; 9
     826:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     828:	85 ff       	sbrs	r24, 5
     82a:	fd cf       	rjmp	.-6      	; 0x826 <st7565r_init+0x32a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     82c:	81 e2       	ldi	r24, 0x21	; 33
     82e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     832:	e0 ea       	ldi	r30, 0xA0	; 160
     834:	f9 e0       	ldi	r31, 0x09	; 9
     836:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     838:	86 ff       	sbrs	r24, 6
     83a:	fd cf       	rjmp	.-6      	; 0x836 <st7565r_init+0x33a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     83c:	e0 ea       	ldi	r30, 0xA0	; 160
     83e:	f9 e0       	ldi	r31, 0x09	; 9
     840:	80 e4       	ldi	r24, 0x40	; 64
     842:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     844:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     846:	be 01       	movw	r22, r28
     848:	6f 5f       	subi	r22, 0xFF	; 255
     84a:	7f 4f       	sbci	r23, 0xFF	; 255
     84c:	80 ea       	ldi	r24, 0xA0	; 160
     84e:	99 e0       	ldi	r25, 0x09	; 9
     850:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     854:	8b e2       	ldi	r24, 0x2B	; 43
     856:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     858:	be 01       	movw	r22, r28
     85a:	6f 5f       	subi	r22, 0xFF	; 255
     85c:	7f 4f       	sbci	r23, 0xFF	; 255
     85e:	80 ea       	ldi	r24, 0xA0	; 160
     860:	99 e0       	ldi	r25, 0x09	; 9
     862:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     866:	81 e0       	ldi	r24, 0x01	; 1
     868:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     86c:	e0 ea       	ldi	r30, 0xA0	; 160
     86e:	f9 e0       	ldi	r31, 0x09	; 9
     870:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     872:	85 ff       	sbrs	r24, 5
     874:	fd cf       	rjmp	.-6      	; 0x870 <st7565r_init+0x374>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     876:	8f ea       	ldi	r24, 0xAF	; 175
     878:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     87c:	e0 ea       	ldi	r30, 0xA0	; 160
     87e:	f9 e0       	ldi	r31, 0x09	; 9
     880:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     882:	86 ff       	sbrs	r24, 6
     884:	fd cf       	rjmp	.-6      	; 0x880 <st7565r_init+0x384>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     886:	e0 ea       	ldi	r30, 0xA0	; 160
     888:	f9 e0       	ldi	r31, 0x09	; 9
     88a:	80 e4       	ldi	r24, 0x40	; 64
     88c:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     88e:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     890:	be 01       	movw	r22, r28
     892:	6f 5f       	subi	r22, 0xFF	; 255
     894:	7f 4f       	sbci	r23, 0xFF	; 255
     896:	80 ea       	ldi	r24, 0xA0	; 160
     898:	99 e0       	ldi	r25, 0x09	; 9
     89a:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     89e:	0f 90       	pop	r0
     8a0:	df 91       	pop	r29
     8a2:	cf 91       	pop	r28
     8a4:	1f 91       	pop	r17
     8a6:	0f 91       	pop	r16
     8a8:	ff 90       	pop	r15
     8aa:	ef 90       	pop	r14
     8ac:	df 90       	pop	r13
     8ae:	cf 90       	pop	r12
     8b0:	bf 90       	pop	r11
     8b2:	08 95       	ret

000008b4 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     8b4:	ff 92       	push	r15
     8b6:	0f 93       	push	r16
     8b8:	1f 93       	push	r17
     8ba:	cf 93       	push	r28
     8bc:	df 93       	push	r29
     8be:	1f 92       	push	r1
     8c0:	cd b7       	in	r28, 0x3d	; 61
     8c2:	de b7       	in	r29, 0x3e	; 62
     8c4:	08 2f       	mov	r16, r24
     8c6:	f6 2e       	mov	r15, r22
     8c8:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     8ca:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <gfx_mono_framebuffer_put_byte>
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     8ce:	0f 70       	andi	r16, 0x0F	; 15
     8d0:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     8d2:	8b e2       	ldi	r24, 0x2B	; 43
     8d4:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8d6:	be 01       	movw	r22, r28
     8d8:	6f 5f       	subi	r22, 0xFF	; 255
     8da:	7f 4f       	sbci	r23, 0xFF	; 255
     8dc:	80 ea       	ldi	r24, 0xA0	; 160
     8de:	99 e0       	ldi	r25, 0x09	; 9
     8e0:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     8e4:	81 e0       	ldi	r24, 0x01	; 1
     8e6:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     8ea:	e0 ea       	ldi	r30, 0xA0	; 160
     8ec:	f9 e0       	ldi	r31, 0x09	; 9
     8ee:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     8f0:	95 ff       	sbrs	r25, 5
     8f2:	fd cf       	rjmp	.-6      	; 0x8ee <gfx_mono_st7565r_put_byte+0x3a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     8f4:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     8f8:	e0 ea       	ldi	r30, 0xA0	; 160
     8fa:	f9 e0       	ldi	r31, 0x09	; 9
     8fc:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     8fe:	86 ff       	sbrs	r24, 6
     900:	fd cf       	rjmp	.-6      	; 0x8fc <gfx_mono_st7565r_put_byte+0x48>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     902:	e0 ea       	ldi	r30, 0xA0	; 160
     904:	f9 e0       	ldi	r31, 0x09	; 9
     906:	80 e4       	ldi	r24, 0x40	; 64
     908:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     90a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     90c:	be 01       	movw	r22, r28
     90e:	6f 5f       	subi	r22, 0xFF	; 255
     910:	7f 4f       	sbci	r23, 0xFF	; 255
     912:	80 ea       	ldi	r24, 0xA0	; 160
     914:	99 e0       	ldi	r25, 0x09	; 9
     916:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     91a:	0f 2d       	mov	r16, r15
     91c:	0f 77       	andi	r16, 0x7F	; 127
     91e:	02 95       	swap	r16
     920:	0f 70       	andi	r16, 0x0F	; 15
     922:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     924:	8b e2       	ldi	r24, 0x2B	; 43
     926:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     928:	be 01       	movw	r22, r28
     92a:	6f 5f       	subi	r22, 0xFF	; 255
     92c:	7f 4f       	sbci	r23, 0xFF	; 255
     92e:	80 ea       	ldi	r24, 0xA0	; 160
     930:	99 e0       	ldi	r25, 0x09	; 9
     932:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     936:	81 e0       	ldi	r24, 0x01	; 1
     938:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     93c:	e0 ea       	ldi	r30, 0xA0	; 160
     93e:	f9 e0       	ldi	r31, 0x09	; 9
     940:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     942:	85 ff       	sbrs	r24, 5
     944:	fd cf       	rjmp	.-6      	; 0x940 <gfx_mono_st7565r_put_byte+0x8c>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     946:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     94a:	e0 ea       	ldi	r30, 0xA0	; 160
     94c:	f9 e0       	ldi	r31, 0x09	; 9
     94e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     950:	86 ff       	sbrs	r24, 6
     952:	fd cf       	rjmp	.-6      	; 0x94e <gfx_mono_st7565r_put_byte+0x9a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     954:	e0 ea       	ldi	r30, 0xA0	; 160
     956:	f9 e0       	ldi	r31, 0x09	; 9
     958:	80 e4       	ldi	r24, 0x40	; 64
     95a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     95c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     95e:	be 01       	movw	r22, r28
     960:	6f 5f       	subi	r22, 0xFF	; 255
     962:	7f 4f       	sbci	r23, 0xFF	; 255
     964:	80 ea       	ldi	r24, 0xA0	; 160
     966:	99 e0       	ldi	r25, 0x09	; 9
     968:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     96c:	0f 2d       	mov	r16, r15
     96e:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     970:	8b e2       	ldi	r24, 0x2B	; 43
     972:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     974:	be 01       	movw	r22, r28
     976:	6f 5f       	subi	r22, 0xFF	; 255
     978:	7f 4f       	sbci	r23, 0xFF	; 255
     97a:	80 ea       	ldi	r24, 0xA0	; 160
     97c:	99 e0       	ldi	r25, 0x09	; 9
     97e:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     988:	e0 ea       	ldi	r30, 0xA0	; 160
     98a:	f9 e0       	ldi	r31, 0x09	; 9
     98c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     98e:	85 ff       	sbrs	r24, 5
     990:	fd cf       	rjmp	.-6      	; 0x98c <gfx_mono_st7565r_put_byte+0xd8>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     992:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     996:	e0 ea       	ldi	r30, 0xA0	; 160
     998:	f9 e0       	ldi	r31, 0x09	; 9
     99a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     99c:	86 ff       	sbrs	r24, 6
     99e:	fd cf       	rjmp	.-6      	; 0x99a <gfx_mono_st7565r_put_byte+0xe6>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9a0:	e0 ea       	ldi	r30, 0xA0	; 160
     9a2:	f9 e0       	ldi	r31, 0x09	; 9
     9a4:	80 e4       	ldi	r24, 0x40	; 64
     9a6:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9a8:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9aa:	be 01       	movw	r22, r28
     9ac:	6f 5f       	subi	r22, 0xFF	; 255
     9ae:	7f 4f       	sbci	r23, 0xFF	; 255
     9b0:	80 ea       	ldi	r24, 0xA0	; 160
     9b2:	99 e0       	ldi	r25, 0x09	; 9
     9b4:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9b8:	8b e2       	ldi	r24, 0x2B	; 43
     9ba:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9bc:	be 01       	movw	r22, r28
     9be:	6f 5f       	subi	r22, 0xFF	; 255
     9c0:	7f 4f       	sbci	r23, 0xFF	; 255
     9c2:	80 ea       	ldi	r24, 0xA0	; 160
     9c4:	99 e0       	ldi	r25, 0x09	; 9
     9c6:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     9ca:	81 e0       	ldi	r24, 0x01	; 1
     9cc:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9d0:	e0 ea       	ldi	r30, 0xA0	; 160
     9d2:	f9 e0       	ldi	r31, 0x09	; 9
     9d4:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     9d6:	85 ff       	sbrs	r24, 5
     9d8:	fd cf       	rjmp	.-6      	; 0x9d4 <gfx_mono_st7565r_put_byte+0x120>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     9da:	10 93 a0 09 	sts	0x09A0, r17	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     9de:	e0 ea       	ldi	r30, 0xA0	; 160
     9e0:	f9 e0       	ldi	r31, 0x09	; 9
     9e2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9e4:	86 ff       	sbrs	r24, 6
     9e6:	fd cf       	rjmp	.-6      	; 0x9e2 <gfx_mono_st7565r_put_byte+0x12e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9e8:	e0 ea       	ldi	r30, 0xA0	; 160
     9ea:	f9 e0       	ldi	r31, 0x09	; 9
     9ec:	80 e4       	ldi	r24, 0x40	; 64
     9ee:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9f0:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     9f2:	81 e0       	ldi	r24, 0x01	; 1
     9f4:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9f8:	be 01       	movw	r22, r28
     9fa:	6f 5f       	subi	r22, 0xFF	; 255
     9fc:	7f 4f       	sbci	r23, 0xFF	; 255
     9fe:	80 ea       	ldi	r24, 0xA0	; 160
     a00:	99 e0       	ldi	r25, 0x09	; 9
     a02:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     a06:	0f 90       	pop	r0
     a08:	df 91       	pop	r29
     a0a:	cf 91       	pop	r28
     a0c:	1f 91       	pop	r17
     a0e:	0f 91       	pop	r16
     a10:	ff 90       	pop	r15
     a12:	08 95       	ret

00000a14 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a14:	0f 93       	push	r16
     a16:	1f 93       	push	r17
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
     a1c:	1f 92       	push	r1
     a1e:	cd b7       	in	r28, 0x3d	; 61
     a20:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     a22:	86 eb       	ldi	r24, 0xB6	; 182
     a24:	90 e2       	ldi	r25, 0x20	; 32
     a26:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     a2a:	68 dd       	rcall	.-1328   	; 0x4fc <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     a2c:	8b e2       	ldi	r24, 0x2B	; 43
     a2e:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     a30:	be 01       	movw	r22, r28
     a32:	6f 5f       	subi	r22, 0xFF	; 255
     a34:	7f 4f       	sbci	r23, 0xFF	; 255
     a36:	80 ea       	ldi	r24, 0xA0	; 160
     a38:	99 e0       	ldi	r25, 0x09	; 9
     a3a:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <usart_spi_select_device>
     a3e:	81 e0       	ldi	r24, 0x01	; 1
     a40:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     a44:	e0 ea       	ldi	r30, 0xA0	; 160
     a46:	f9 e0       	ldi	r31, 0x09	; 9
     a48:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a4a:	85 ff       	sbrs	r24, 5
     a4c:	fd cf       	rjmp	.-6      	; 0xa48 <gfx_mono_st7565r_init+0x34>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a4e:	80 e4       	ldi	r24, 0x40	; 64
     a50:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a54:	e0 ea       	ldi	r30, 0xA0	; 160
     a56:	f9 e0       	ldi	r31, 0x09	; 9
     a58:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a5a:	86 ff       	sbrs	r24, 6
     a5c:	fd cf       	rjmp	.-6      	; 0xa58 <gfx_mono_st7565r_init+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a5e:	e0 ea       	ldi	r30, 0xA0	; 160
     a60:	f9 e0       	ldi	r31, 0x09	; 9
     a62:	80 e4       	ldi	r24, 0x40	; 64
     a64:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a66:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a68:	be 01       	movw	r22, r28
     a6a:	6f 5f       	subi	r22, 0xFF	; 255
     a6c:	7f 4f       	sbci	r23, 0xFF	; 255
     a6e:	80 ea       	ldi	r24, 0xA0	; 160
     a70:	99 e0       	ldi	r25, 0x09	; 9
     a72:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a76:	00 e0       	ldi	r16, 0x00	; 0
     a78:	0a c0       	rjmp	.+20     	; 0xa8e <gfx_mono_st7565r_init+0x7a>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     a7a:	40 e0       	ldi	r20, 0x00	; 0
     a7c:	61 2f       	mov	r22, r17
     a7e:	80 2f       	mov	r24, r16
     a80:	19 df       	rcall	.-462    	; 0x8b4 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     a82:	1f 5f       	subi	r17, 0xFF	; 255
     a84:	10 38       	cpi	r17, 0x80	; 128
     a86:	c9 f7       	brne	.-14     	; 0xa7a <gfx_mono_st7565r_init+0x66>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a88:	0f 5f       	subi	r16, 0xFF	; 255
     a8a:	04 30       	cpi	r16, 0x04	; 4
     a8c:	11 f0       	breq	.+4      	; 0xa92 <gfx_mono_st7565r_init+0x7e>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a8e:	10 e0       	ldi	r17, 0x00	; 0
     a90:	f4 cf       	rjmp	.-24     	; 0xa7a <gfx_mono_st7565r_init+0x66>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     a92:	0f 90       	pop	r0
     a94:	df 91       	pop	r29
     a96:	cf 91       	pop	r28
     a98:	1f 91       	pop	r17
     a9a:	0f 91       	pop	r16
     a9c:	08 95       	ret

00000a9e <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     a9e:	ff 92       	push	r15
     aa0:	0f 93       	push	r16
     aa2:	1f 93       	push	r17
     aa4:	cf 93       	push	r28
     aa6:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     aa8:	88 23       	and	r24, r24
     aaa:	54 f1       	brlt	.+84     	; 0xb00 <gfx_mono_st7565r_draw_pixel+0x62>
     aac:	60 32       	cpi	r22, 0x20	; 32
     aae:	40 f5       	brcc	.+80     	; 0xb00 <gfx_mono_st7565r_draw_pixel+0x62>
     ab0:	d4 2f       	mov	r29, r20
     ab2:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     ab4:	f6 2e       	mov	r15, r22
     ab6:	f6 94       	lsr	r15
     ab8:	f6 94       	lsr	r15
     aba:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     abc:	70 e0       	ldi	r23, 0x00	; 0
     abe:	88 e0       	ldi	r24, 0x08	; 8
     ac0:	f8 9e       	mul	r15, r24
     ac2:	60 19       	sub	r22, r0
     ac4:	71 09       	sbc	r23, r1
     ac6:	11 24       	eor	r1, r1
     ac8:	81 e0       	ldi	r24, 0x01	; 1
     aca:	90 e0       	ldi	r25, 0x00	; 0
     acc:	8c 01       	movw	r16, r24
     ace:	02 c0       	rjmp	.+4      	; 0xad4 <gfx_mono_st7565r_draw_pixel+0x36>
     ad0:	00 0f       	add	r16, r16
     ad2:	11 1f       	adc	r17, r17
     ad4:	6a 95       	dec	r22
     ad6:	e2 f7       	brpl	.-8      	; 0xad0 <gfx_mono_st7565r_draw_pixel+0x32>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     ad8:	6c 2f       	mov	r22, r28
     ada:	8f 2d       	mov	r24, r15
     adc:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     ae0:	d1 30       	cpi	r29, 0x01	; 1
     ae2:	21 f0       	breq	.+8      	; 0xaec <gfx_mono_st7565r_draw_pixel+0x4e>
     ae4:	28 f0       	brcs	.+10     	; 0xaf0 <gfx_mono_st7565r_draw_pixel+0x52>
     ae6:	d2 30       	cpi	r29, 0x02	; 2
     ae8:	31 f0       	breq	.+12     	; 0xaf6 <gfx_mono_st7565r_draw_pixel+0x58>
     aea:	06 c0       	rjmp	.+12     	; 0xaf8 <gfx_mono_st7565r_draw_pixel+0x5a>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     aec:	80 2b       	or	r24, r16
		break;
     aee:	04 c0       	rjmp	.+8      	; 0xaf8 <gfx_mono_st7565r_draw_pixel+0x5a>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     af0:	00 95       	com	r16
     af2:	80 23       	and	r24, r16
		break;
     af4:	01 c0       	rjmp	.+2      	; 0xaf8 <gfx_mono_st7565r_draw_pixel+0x5a>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     af6:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     af8:	48 2f       	mov	r20, r24
     afa:	6c 2f       	mov	r22, r28
     afc:	8f 2d       	mov	r24, r15
     afe:	da de       	rcall	.-588    	; 0x8b4 <gfx_mono_st7565r_put_byte>
}
     b00:	df 91       	pop	r29
     b02:	cf 91       	pop	r28
     b04:	1f 91       	pop	r17
     b06:	0f 91       	pop	r16
     b08:	ff 90       	pop	r15
     b0a:	08 95       	ret

00000b0c <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     b0c:	0c 94 ab 1d 	jmp	0x3b56	; 0x3b56 <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
     b10:	08 95       	ret

00000b12 <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     b12:	81 15       	cp	r24, r1
     b14:	22 e0       	ldi	r18, 0x02	; 2
     b16:	92 07       	cpc	r25, r18
     b18:	69 f4       	brne	.+26     	; 0xb34 <adc_enable_clock+0x22>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
     b1a:	80 91 b7 22 	lds	r24, 0x22B7	; 0x8022b7 <adca_enable_count>
     b1e:	91 e0       	ldi	r25, 0x01	; 1
     b20:	98 0f       	add	r25, r24
     b22:	90 93 b7 22 	sts	0x22B7, r25	; 0x8022b7 <adca_enable_count>
     b26:	81 11       	cpse	r24, r1
     b28:	14 c0       	rjmp	.+40     	; 0xb52 <adc_enable_clock+0x40>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     b2a:	62 e0       	ldi	r22, 0x02	; 2
     b2c:	81 e0       	ldi	r24, 0x01	; 1
     b2e:	0c 94 4b 1e 	jmp	0x3c96	; 0x3c96 <sysclk_enable_module>
     b32:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     b34:	80 34       	cpi	r24, 0x40	; 64
     b36:	92 40       	sbci	r25, 0x02	; 2
     b38:	61 f4       	brne	.+24     	; 0xb52 <adc_enable_clock+0x40>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
     b3a:	80 91 b6 22 	lds	r24, 0x22B6	; 0x8022b6 <adcb_enable_count>
     b3e:	91 e0       	ldi	r25, 0x01	; 1
     b40:	98 0f       	add	r25, r24
     b42:	90 93 b6 22 	sts	0x22B6, r25	; 0x8022b6 <adcb_enable_count>
     b46:	81 11       	cpse	r24, r1
     b48:	04 c0       	rjmp	.+8      	; 0xb52 <adc_enable_clock+0x40>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     b4a:	62 e0       	ldi	r22, 0x02	; 2
     b4c:	82 e0       	ldi	r24, 0x02	; 2
     b4e:	0c 94 4b 1e 	jmp	0x3c96	; 0x3c96 <sysclk_enable_module>
     b52:	08 95       	ret

00000b54 <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     b54:	81 15       	cp	r24, r1
     b56:	22 e0       	ldi	r18, 0x02	; 2
     b58:	92 07       	cpc	r25, r18
     b5a:	61 f4       	brne	.+24     	; 0xb74 <adc_disable_clock+0x20>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
     b5c:	80 91 b7 22 	lds	r24, 0x22B7	; 0x8022b7 <adca_enable_count>
     b60:	81 50       	subi	r24, 0x01	; 1
     b62:	80 93 b7 22 	sts	0x22B7, r24	; 0x8022b7 <adca_enable_count>
     b66:	81 11       	cpse	r24, r1
     b68:	13 c0       	rjmp	.+38     	; 0xb90 <adc_disable_clock+0x3c>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     b6a:	62 e0       	ldi	r22, 0x02	; 2
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	0c 94 61 1e 	jmp	0x3cc2	; 0x3cc2 <sysclk_disable_module>
     b72:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     b74:	80 34       	cpi	r24, 0x40	; 64
     b76:	92 40       	sbci	r25, 0x02	; 2
     b78:	59 f4       	brne	.+22     	; 0xb90 <adc_disable_clock+0x3c>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
     b7a:	80 91 b6 22 	lds	r24, 0x22B6	; 0x8022b6 <adcb_enable_count>
     b7e:	81 50       	subi	r24, 0x01	; 1
     b80:	80 93 b6 22 	sts	0x22B6, r24	; 0x8022b6 <adcb_enable_count>
     b84:	81 11       	cpse	r24, r1
     b86:	04 c0       	rjmp	.+8      	; 0xb90 <adc_disable_clock+0x3c>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     b88:	62 e0       	ldi	r22, 0x02	; 2
     b8a:	82 e0       	ldi	r24, 0x02	; 2
     b8c:	0c 94 61 1e 	jmp	0x3cc2	; 0x3cc2 <sysclk_disable_module>
     b90:	08 95       	ret

00000b92 <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
     b92:	ef 92       	push	r14
     b94:	ff 92       	push	r15
     b96:	1f 93       	push	r17
     b98:	cf 93       	push	r28
     b9a:	df 93       	push	r29
     b9c:	1f 92       	push	r1
     b9e:	1f 92       	push	r1
     ba0:	cd b7       	in	r28, 0x3d	; 61
     ba2:	de b7       	in	r29, 0x3e	; 62
     ba4:	7c 01       	movw	r14, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     ba6:	8f b7       	in	r24, 0x3f	; 63
     ba8:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
     baa:	f8 94       	cli
	return flags;
     bac:	19 81       	ldd	r17, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
     bae:	c7 01       	movw	r24, r14
     bb0:	b0 df       	rcall	.-160    	; 0xb12 <adc_enable_clock>
	adc->CTRLA |= ADC_ENABLE_bm;
     bb2:	f7 01       	movw	r30, r14
     bb4:	80 81       	ld	r24, Z
     bb6:	81 60       	ori	r24, 0x01	; 1
     bb8:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     bba:	1f bf       	out	0x3f, r17	; 63
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
     bbc:	80 91 82 24 	lds	r24, 0x2482	; 0x802482 <sleepmgr_locks+0x1>
     bc0:	8f 3f       	cpi	r24, 0xFF	; 255
     bc2:	09 f4       	brne	.+2      	; 0xbc6 <adc_enable+0x34>
     bc4:	ff cf       	rjmp	.-2      	; 0xbc4 <adc_enable+0x32>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     bc6:	8f b7       	in	r24, 0x3f	; 63
     bc8:	8a 83       	std	Y+2, r24	; 0x02
	cpu_irq_disable();
     bca:	f8 94       	cli
	return flags;
     bcc:	9a 81       	ldd	r25, Y+2	; 0x02
	}

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
     bce:	e1 e8       	ldi	r30, 0x81	; 129
     bd0:	f4 e2       	ldi	r31, 0x24	; 36
     bd2:	81 81       	ldd	r24, Z+1	; 0x01
     bd4:	8f 5f       	subi	r24, 0xFF	; 255
     bd6:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     bd8:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
     bda:	0f 90       	pop	r0
     bdc:	0f 90       	pop	r0
     bde:	df 91       	pop	r29
     be0:	cf 91       	pop	r28
     be2:	1f 91       	pop	r17
     be4:	ff 90       	pop	r15
     be6:	ef 90       	pop	r14
     be8:	08 95       	ret

00000bea <adc_disable>:
 * Disables the ADC and unlocks IDLE mode for the sleep manager.
 *
 * \param adc Pointer to ADC module
 */
void adc_disable(ADC_t *adc)
{
     bea:	1f 93       	push	r17
     bec:	cf 93       	push	r28
     bee:	df 93       	push	r29
     bf0:	1f 92       	push	r1
     bf2:	1f 92       	push	r1
     bf4:	cd b7       	in	r28, 0x3d	; 61
     bf6:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     bf8:	2f b7       	in	r18, 0x3f	; 63
     bfa:	29 83       	std	Y+1, r18	; 0x01
	cpu_irq_disable();
     bfc:	f8 94       	cli
	return flags;
     bfe:	19 81       	ldd	r17, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();
	adc->CTRLA &= ~ADC_ENABLE_bm;
     c00:	fc 01       	movw	r30, r24
     c02:	20 81       	ld	r18, Z
     c04:	2e 7f       	andi	r18, 0xFE	; 254
     c06:	20 83       	st	Z, r18
	adc_disable_clock(adc);
     c08:	a5 df       	rcall	.-182    	; 0xb54 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     c0a:	1f bf       	out	0x3f, r17	; 63
static inline void sleepmgr_unlock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] == 0) {
     c0c:	80 91 82 24 	lds	r24, 0x2482	; 0x802482 <sleepmgr_locks+0x1>
     c10:	81 11       	cpse	r24, r1
     c12:	01 c0       	rjmp	.+2      	; 0xc16 <adc_disable+0x2c>
     c14:	ff cf       	rjmp	.-2      	; 0xc14 <adc_disable+0x2a>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     c16:	8f b7       	in	r24, 0x3f	; 63
     c18:	8a 83       	std	Y+2, r24	; 0x02
	cpu_irq_disable();
     c1a:	f8 94       	cli
	return flags;
     c1c:	9a 81       	ldd	r25, Y+2	; 0x02
	}

	// Enter a critical section
	flags = cpu_irq_save();

	--sleepmgr_locks[mode];
     c1e:	e1 e8       	ldi	r30, 0x81	; 129
     c20:	f4 e2       	ldi	r31, 0x24	; 36
     c22:	81 81       	ldd	r24, Z+1	; 0x01
     c24:	81 50       	subi	r24, 0x01	; 1
     c26:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     c28:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_unlock_mode(SLEEPMGR_IDLE);
}
     c2a:	0f 90       	pop	r0
     c2c:	0f 90       	pop	r0
     c2e:	df 91       	pop	r29
     c30:	cf 91       	pop	r28
     c32:	1f 91       	pop	r17
     c34:	08 95       	ret

00000c36 <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
     c36:	1f 92       	push	r1
     c38:	0f 92       	push	r0
     c3a:	0f b6       	in	r0, 0x3f	; 63
     c3c:	0f 92       	push	r0
     c3e:	11 24       	eor	r1, r1
     c40:	0b b6       	in	r0, 0x3b	; 59
     c42:	0f 92       	push	r0
     c44:	2f 93       	push	r18
     c46:	3f 93       	push	r19
     c48:	4f 93       	push	r20
     c4a:	5f 93       	push	r21
     c4c:	6f 93       	push	r22
     c4e:	7f 93       	push	r23
     c50:	8f 93       	push	r24
     c52:	9f 93       	push	r25
     c54:	af 93       	push	r26
     c56:	bf 93       	push	r27
     c58:	ef 93       	push	r30
     c5a:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
     c5c:	40 91 24 02 	lds	r20, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
     c60:	50 91 25 02 	lds	r21, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
     c64:	e0 91 89 24 	lds	r30, 0x2489	; 0x802489 <adca_callback>
     c68:	f0 91 8a 24 	lds	r31, 0x248A	; 0x80248a <adca_callback+0x1>
     c6c:	61 e0       	ldi	r22, 0x01	; 1
     c6e:	80 e0       	ldi	r24, 0x00	; 0
     c70:	92 e0       	ldi	r25, 0x02	; 2
     c72:	19 95       	eicall
}
     c74:	ff 91       	pop	r31
     c76:	ef 91       	pop	r30
     c78:	bf 91       	pop	r27
     c7a:	af 91       	pop	r26
     c7c:	9f 91       	pop	r25
     c7e:	8f 91       	pop	r24
     c80:	7f 91       	pop	r23
     c82:	6f 91       	pop	r22
     c84:	5f 91       	pop	r21
     c86:	4f 91       	pop	r20
     c88:	3f 91       	pop	r19
     c8a:	2f 91       	pop	r18
     c8c:	0f 90       	pop	r0
     c8e:	0b be       	out	0x3b, r0	; 59
     c90:	0f 90       	pop	r0
     c92:	0f be       	out	0x3f, r0	; 63
     c94:	0f 90       	pop	r0
     c96:	1f 90       	pop	r1
     c98:	18 95       	reti

00000c9a <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
     c9a:	1f 92       	push	r1
     c9c:	0f 92       	push	r0
     c9e:	0f b6       	in	r0, 0x3f	; 63
     ca0:	0f 92       	push	r0
     ca2:	11 24       	eor	r1, r1
     ca4:	0b b6       	in	r0, 0x3b	; 59
     ca6:	0f 92       	push	r0
     ca8:	2f 93       	push	r18
     caa:	3f 93       	push	r19
     cac:	4f 93       	push	r20
     cae:	5f 93       	push	r21
     cb0:	6f 93       	push	r22
     cb2:	7f 93       	push	r23
     cb4:	8f 93       	push	r24
     cb6:	9f 93       	push	r25
     cb8:	af 93       	push	r26
     cba:	bf 93       	push	r27
     cbc:	ef 93       	push	r30
     cbe:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
     cc0:	40 91 2c 02 	lds	r20, 0x022C	; 0x80022c <__TEXT_REGION_LENGTH__+0x70022c>
     cc4:	50 91 2d 02 	lds	r21, 0x022D	; 0x80022d <__TEXT_REGION_LENGTH__+0x70022d>
     cc8:	e0 91 89 24 	lds	r30, 0x2489	; 0x802489 <adca_callback>
     ccc:	f0 91 8a 24 	lds	r31, 0x248A	; 0x80248a <adca_callback+0x1>
     cd0:	62 e0       	ldi	r22, 0x02	; 2
     cd2:	80 e0       	ldi	r24, 0x00	; 0
     cd4:	92 e0       	ldi	r25, 0x02	; 2
     cd6:	19 95       	eicall
}
     cd8:	ff 91       	pop	r31
     cda:	ef 91       	pop	r30
     cdc:	bf 91       	pop	r27
     cde:	af 91       	pop	r26
     ce0:	9f 91       	pop	r25
     ce2:	8f 91       	pop	r24
     ce4:	7f 91       	pop	r23
     ce6:	6f 91       	pop	r22
     ce8:	5f 91       	pop	r21
     cea:	4f 91       	pop	r20
     cec:	3f 91       	pop	r19
     cee:	2f 91       	pop	r18
     cf0:	0f 90       	pop	r0
     cf2:	0b be       	out	0x3b, r0	; 59
     cf4:	0f 90       	pop	r0
     cf6:	0f be       	out	0x3f, r0	; 63
     cf8:	0f 90       	pop	r0
     cfa:	1f 90       	pop	r1
     cfc:	18 95       	reti

00000cfe <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
     cfe:	1f 92       	push	r1
     d00:	0f 92       	push	r0
     d02:	0f b6       	in	r0, 0x3f	; 63
     d04:	0f 92       	push	r0
     d06:	11 24       	eor	r1, r1
     d08:	0b b6       	in	r0, 0x3b	; 59
     d0a:	0f 92       	push	r0
     d0c:	2f 93       	push	r18
     d0e:	3f 93       	push	r19
     d10:	4f 93       	push	r20
     d12:	5f 93       	push	r21
     d14:	6f 93       	push	r22
     d16:	7f 93       	push	r23
     d18:	8f 93       	push	r24
     d1a:	9f 93       	push	r25
     d1c:	af 93       	push	r26
     d1e:	bf 93       	push	r27
     d20:	ef 93       	push	r30
     d22:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
     d24:	40 91 34 02 	lds	r20, 0x0234	; 0x800234 <__TEXT_REGION_LENGTH__+0x700234>
     d28:	50 91 35 02 	lds	r21, 0x0235	; 0x800235 <__TEXT_REGION_LENGTH__+0x700235>
     d2c:	e0 91 89 24 	lds	r30, 0x2489	; 0x802489 <adca_callback>
     d30:	f0 91 8a 24 	lds	r31, 0x248A	; 0x80248a <adca_callback+0x1>
     d34:	64 e0       	ldi	r22, 0x04	; 4
     d36:	80 e0       	ldi	r24, 0x00	; 0
     d38:	92 e0       	ldi	r25, 0x02	; 2
     d3a:	19 95       	eicall
}
     d3c:	ff 91       	pop	r31
     d3e:	ef 91       	pop	r30
     d40:	bf 91       	pop	r27
     d42:	af 91       	pop	r26
     d44:	9f 91       	pop	r25
     d46:	8f 91       	pop	r24
     d48:	7f 91       	pop	r23
     d4a:	6f 91       	pop	r22
     d4c:	5f 91       	pop	r21
     d4e:	4f 91       	pop	r20
     d50:	3f 91       	pop	r19
     d52:	2f 91       	pop	r18
     d54:	0f 90       	pop	r0
     d56:	0b be       	out	0x3b, r0	; 59
     d58:	0f 90       	pop	r0
     d5a:	0f be       	out	0x3f, r0	; 63
     d5c:	0f 90       	pop	r0
     d5e:	1f 90       	pop	r1
     d60:	18 95       	reti

00000d62 <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
     d62:	1f 92       	push	r1
     d64:	0f 92       	push	r0
     d66:	0f b6       	in	r0, 0x3f	; 63
     d68:	0f 92       	push	r0
     d6a:	11 24       	eor	r1, r1
     d6c:	0b b6       	in	r0, 0x3b	; 59
     d6e:	0f 92       	push	r0
     d70:	2f 93       	push	r18
     d72:	3f 93       	push	r19
     d74:	4f 93       	push	r20
     d76:	5f 93       	push	r21
     d78:	6f 93       	push	r22
     d7a:	7f 93       	push	r23
     d7c:	8f 93       	push	r24
     d7e:	9f 93       	push	r25
     d80:	af 93       	push	r26
     d82:	bf 93       	push	r27
     d84:	ef 93       	push	r30
     d86:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
     d88:	40 91 3c 02 	lds	r20, 0x023C	; 0x80023c <__TEXT_REGION_LENGTH__+0x70023c>
     d8c:	50 91 3d 02 	lds	r21, 0x023D	; 0x80023d <__TEXT_REGION_LENGTH__+0x70023d>
     d90:	e0 91 89 24 	lds	r30, 0x2489	; 0x802489 <adca_callback>
     d94:	f0 91 8a 24 	lds	r31, 0x248A	; 0x80248a <adca_callback+0x1>
     d98:	68 e0       	ldi	r22, 0x08	; 8
     d9a:	80 e0       	ldi	r24, 0x00	; 0
     d9c:	92 e0       	ldi	r25, 0x02	; 2
     d9e:	19 95       	eicall
}
     da0:	ff 91       	pop	r31
     da2:	ef 91       	pop	r30
     da4:	bf 91       	pop	r27
     da6:	af 91       	pop	r26
     da8:	9f 91       	pop	r25
     daa:	8f 91       	pop	r24
     dac:	7f 91       	pop	r23
     dae:	6f 91       	pop	r22
     db0:	5f 91       	pop	r21
     db2:	4f 91       	pop	r20
     db4:	3f 91       	pop	r19
     db6:	2f 91       	pop	r18
     db8:	0f 90       	pop	r0
     dba:	0b be       	out	0x3b, r0	; 59
     dbc:	0f 90       	pop	r0
     dbe:	0f be       	out	0x3f, r0	; 63
     dc0:	0f 90       	pop	r0
     dc2:	1f 90       	pop	r1
     dc4:	18 95       	reti

00000dc6 <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
     dc6:	1f 92       	push	r1
     dc8:	0f 92       	push	r0
     dca:	0f b6       	in	r0, 0x3f	; 63
     dcc:	0f 92       	push	r0
     dce:	11 24       	eor	r1, r1
     dd0:	0b b6       	in	r0, 0x3b	; 59
     dd2:	0f 92       	push	r0
     dd4:	2f 93       	push	r18
     dd6:	3f 93       	push	r19
     dd8:	4f 93       	push	r20
     dda:	5f 93       	push	r21
     ddc:	6f 93       	push	r22
     dde:	7f 93       	push	r23
     de0:	8f 93       	push	r24
     de2:	9f 93       	push	r25
     de4:	af 93       	push	r26
     de6:	bf 93       	push	r27
     de8:	ef 93       	push	r30
     dea:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
     dec:	40 91 64 02 	lds	r20, 0x0264	; 0x800264 <__TEXT_REGION_LENGTH__+0x700264>
     df0:	50 91 65 02 	lds	r21, 0x0265	; 0x800265 <__TEXT_REGION_LENGTH__+0x700265>
     df4:	e0 91 87 24 	lds	r30, 0x2487	; 0x802487 <adcb_callback>
     df8:	f0 91 88 24 	lds	r31, 0x2488	; 0x802488 <adcb_callback+0x1>
     dfc:	61 e0       	ldi	r22, 0x01	; 1
     dfe:	80 e4       	ldi	r24, 0x40	; 64
     e00:	92 e0       	ldi	r25, 0x02	; 2
     e02:	19 95       	eicall
}
     e04:	ff 91       	pop	r31
     e06:	ef 91       	pop	r30
     e08:	bf 91       	pop	r27
     e0a:	af 91       	pop	r26
     e0c:	9f 91       	pop	r25
     e0e:	8f 91       	pop	r24
     e10:	7f 91       	pop	r23
     e12:	6f 91       	pop	r22
     e14:	5f 91       	pop	r21
     e16:	4f 91       	pop	r20
     e18:	3f 91       	pop	r19
     e1a:	2f 91       	pop	r18
     e1c:	0f 90       	pop	r0
     e1e:	0b be       	out	0x3b, r0	; 59
     e20:	0f 90       	pop	r0
     e22:	0f be       	out	0x3f, r0	; 63
     e24:	0f 90       	pop	r0
     e26:	1f 90       	pop	r1
     e28:	18 95       	reti

00000e2a <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
     e2a:	1f 92       	push	r1
     e2c:	0f 92       	push	r0
     e2e:	0f b6       	in	r0, 0x3f	; 63
     e30:	0f 92       	push	r0
     e32:	11 24       	eor	r1, r1
     e34:	0b b6       	in	r0, 0x3b	; 59
     e36:	0f 92       	push	r0
     e38:	2f 93       	push	r18
     e3a:	3f 93       	push	r19
     e3c:	4f 93       	push	r20
     e3e:	5f 93       	push	r21
     e40:	6f 93       	push	r22
     e42:	7f 93       	push	r23
     e44:	8f 93       	push	r24
     e46:	9f 93       	push	r25
     e48:	af 93       	push	r26
     e4a:	bf 93       	push	r27
     e4c:	ef 93       	push	r30
     e4e:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
     e50:	40 91 6c 02 	lds	r20, 0x026C	; 0x80026c <__TEXT_REGION_LENGTH__+0x70026c>
     e54:	50 91 6d 02 	lds	r21, 0x026D	; 0x80026d <__TEXT_REGION_LENGTH__+0x70026d>
     e58:	e0 91 87 24 	lds	r30, 0x2487	; 0x802487 <adcb_callback>
     e5c:	f0 91 88 24 	lds	r31, 0x2488	; 0x802488 <adcb_callback+0x1>
     e60:	62 e0       	ldi	r22, 0x02	; 2
     e62:	80 e4       	ldi	r24, 0x40	; 64
     e64:	92 e0       	ldi	r25, 0x02	; 2
     e66:	19 95       	eicall
}
     e68:	ff 91       	pop	r31
     e6a:	ef 91       	pop	r30
     e6c:	bf 91       	pop	r27
     e6e:	af 91       	pop	r26
     e70:	9f 91       	pop	r25
     e72:	8f 91       	pop	r24
     e74:	7f 91       	pop	r23
     e76:	6f 91       	pop	r22
     e78:	5f 91       	pop	r21
     e7a:	4f 91       	pop	r20
     e7c:	3f 91       	pop	r19
     e7e:	2f 91       	pop	r18
     e80:	0f 90       	pop	r0
     e82:	0b be       	out	0x3b, r0	; 59
     e84:	0f 90       	pop	r0
     e86:	0f be       	out	0x3f, r0	; 63
     e88:	0f 90       	pop	r0
     e8a:	1f 90       	pop	r1
     e8c:	18 95       	reti

00000e8e <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
     e8e:	1f 92       	push	r1
     e90:	0f 92       	push	r0
     e92:	0f b6       	in	r0, 0x3f	; 63
     e94:	0f 92       	push	r0
     e96:	11 24       	eor	r1, r1
     e98:	0b b6       	in	r0, 0x3b	; 59
     e9a:	0f 92       	push	r0
     e9c:	2f 93       	push	r18
     e9e:	3f 93       	push	r19
     ea0:	4f 93       	push	r20
     ea2:	5f 93       	push	r21
     ea4:	6f 93       	push	r22
     ea6:	7f 93       	push	r23
     ea8:	8f 93       	push	r24
     eaa:	9f 93       	push	r25
     eac:	af 93       	push	r26
     eae:	bf 93       	push	r27
     eb0:	ef 93       	push	r30
     eb2:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
     eb4:	40 91 74 02 	lds	r20, 0x0274	; 0x800274 <__TEXT_REGION_LENGTH__+0x700274>
     eb8:	50 91 75 02 	lds	r21, 0x0275	; 0x800275 <__TEXT_REGION_LENGTH__+0x700275>
     ebc:	e0 91 87 24 	lds	r30, 0x2487	; 0x802487 <adcb_callback>
     ec0:	f0 91 88 24 	lds	r31, 0x2488	; 0x802488 <adcb_callback+0x1>
     ec4:	64 e0       	ldi	r22, 0x04	; 4
     ec6:	80 e4       	ldi	r24, 0x40	; 64
     ec8:	92 e0       	ldi	r25, 0x02	; 2
     eca:	19 95       	eicall
}
     ecc:	ff 91       	pop	r31
     ece:	ef 91       	pop	r30
     ed0:	bf 91       	pop	r27
     ed2:	af 91       	pop	r26
     ed4:	9f 91       	pop	r25
     ed6:	8f 91       	pop	r24
     ed8:	7f 91       	pop	r23
     eda:	6f 91       	pop	r22
     edc:	5f 91       	pop	r21
     ede:	4f 91       	pop	r20
     ee0:	3f 91       	pop	r19
     ee2:	2f 91       	pop	r18
     ee4:	0f 90       	pop	r0
     ee6:	0b be       	out	0x3b, r0	; 59
     ee8:	0f 90       	pop	r0
     eea:	0f be       	out	0x3f, r0	; 63
     eec:	0f 90       	pop	r0
     eee:	1f 90       	pop	r1
     ef0:	18 95       	reti

00000ef2 <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
     ef2:	1f 92       	push	r1
     ef4:	0f 92       	push	r0
     ef6:	0f b6       	in	r0, 0x3f	; 63
     ef8:	0f 92       	push	r0
     efa:	11 24       	eor	r1, r1
     efc:	0b b6       	in	r0, 0x3b	; 59
     efe:	0f 92       	push	r0
     f00:	2f 93       	push	r18
     f02:	3f 93       	push	r19
     f04:	4f 93       	push	r20
     f06:	5f 93       	push	r21
     f08:	6f 93       	push	r22
     f0a:	7f 93       	push	r23
     f0c:	8f 93       	push	r24
     f0e:	9f 93       	push	r25
     f10:	af 93       	push	r26
     f12:	bf 93       	push	r27
     f14:	ef 93       	push	r30
     f16:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
     f18:	40 91 7c 02 	lds	r20, 0x027C	; 0x80027c <__TEXT_REGION_LENGTH__+0x70027c>
     f1c:	50 91 7d 02 	lds	r21, 0x027D	; 0x80027d <__TEXT_REGION_LENGTH__+0x70027d>
     f20:	e0 91 87 24 	lds	r30, 0x2487	; 0x802487 <adcb_callback>
     f24:	f0 91 88 24 	lds	r31, 0x2488	; 0x802488 <adcb_callback+0x1>
     f28:	68 e0       	ldi	r22, 0x08	; 8
     f2a:	80 e4       	ldi	r24, 0x40	; 64
     f2c:	92 e0       	ldi	r25, 0x02	; 2
     f2e:	19 95       	eicall
}
     f30:	ff 91       	pop	r31
     f32:	ef 91       	pop	r30
     f34:	bf 91       	pop	r27
     f36:	af 91       	pop	r26
     f38:	9f 91       	pop	r25
     f3a:	8f 91       	pop	r24
     f3c:	7f 91       	pop	r23
     f3e:	6f 91       	pop	r22
     f40:	5f 91       	pop	r21
     f42:	4f 91       	pop	r20
     f44:	3f 91       	pop	r19
     f46:	2f 91       	pop	r18
     f48:	0f 90       	pop	r0
     f4a:	0b be       	out	0x3b, r0	; 59
     f4c:	0f 90       	pop	r0
     f4e:	0f be       	out	0x3f, r0	; 63
     f50:	0f 90       	pop	r0
     f52:	1f 90       	pop	r1
     f54:	18 95       	reti

00000f56 <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
     f56:	bf 92       	push	r11
     f58:	cf 92       	push	r12
     f5a:	df 92       	push	r13
     f5c:	ef 92       	push	r14
     f5e:	ff 92       	push	r15
     f60:	0f 93       	push	r16
     f62:	1f 93       	push	r17
     f64:	cf 93       	push	r28
     f66:	df 93       	push	r29
     f68:	1f 92       	push	r1
     f6a:	cd b7       	in	r28, 0x3d	; 61
     f6c:	de b7       	in	r29, 0x3e	; 62
     f6e:	8c 01       	movw	r16, r24
     f70:	7b 01       	movw	r14, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
     f72:	81 15       	cp	r24, r1
     f74:	22 e0       	ldi	r18, 0x02	; 2
     f76:	92 07       	cpc	r25, r18
     f78:	81 f4       	brne	.+32     	; 0xf9a <adc_write_configuration+0x44>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
     f7a:	61 e2       	ldi	r22, 0x21	; 33
     f7c:	70 e0       	ldi	r23, 0x00	; 0
     f7e:	82 e0       	ldi	r24, 0x02	; 2
     f80:	0e 94 76 1e 	call	0x3cec	; 0x3cec <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
     f84:	c8 2e       	mov	r12, r24
     f86:	d1 2c       	mov	r13, r1
     f88:	60 e2       	ldi	r22, 0x20	; 32
     f8a:	70 e0       	ldi	r23, 0x00	; 0
     f8c:	82 e0       	ldi	r24, 0x02	; 2
     f8e:	0e 94 76 1e 	call	0x3cec	; 0x3cec <nvm_read_byte>
		data <<= 8;
		data |= nvm_read_production_signature_row(ADCACAL0);
     f92:	dc 2c       	mov	r13, r12
     f94:	cc 24       	eor	r12, r12
     f96:	c8 2a       	or	r12, r24
     f98:	12 c0       	rjmp	.+36     	; 0xfbe <adc_write_configuration+0x68>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
     f9a:	80 34       	cpi	r24, 0x40	; 64
     f9c:	92 40       	sbci	r25, 0x02	; 2
     f9e:	d1 f5       	brne	.+116    	; 0x1014 <adc_write_configuration+0xbe>
     fa0:	65 e2       	ldi	r22, 0x25	; 37
     fa2:	70 e0       	ldi	r23, 0x00	; 0
     fa4:	82 e0       	ldi	r24, 0x02	; 2
     fa6:	0e 94 76 1e 	call	0x3cec	; 0x3cec <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
     faa:	c8 2e       	mov	r12, r24
     fac:	d1 2c       	mov	r13, r1
     fae:	64 e2       	ldi	r22, 0x24	; 36
     fb0:	70 e0       	ldi	r23, 0x00	; 0
     fb2:	82 e0       	ldi	r24, 0x02	; 2
     fb4:	0e 94 76 1e 	call	0x3cec	; 0x3cec <nvm_read_byte>
		data <<= 8;
		data |= nvm_read_production_signature_row(ADCBCAL0);
     fb8:	dc 2c       	mov	r13, r12
     fba:	cc 24       	eor	r12, r12
     fbc:	c8 2a       	or	r12, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     fbe:	8f b7       	in	r24, 0x3f	; 63
     fc0:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
     fc2:	f8 94       	cli
	return flags;
     fc4:	b9 80       	ldd	r11, Y+1	; 0x01
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
     fc6:	c8 01       	movw	r24, r16
     fc8:	a4 dd       	rcall	.-1208   	; 0xb12 <adc_enable_clock>
	enable = adc->CTRLA & ADC_ENABLE_bm;
     fca:	f8 01       	movw	r30, r16
     fcc:	80 81       	ld	r24, Z

	adc->CTRLA = ADC_FLUSH_bm;
     fce:	92 e0       	ldi	r25, 0x02	; 2
     fd0:	90 83       	st	Z, r25
	adc->CAL = cal;
     fd2:	c4 86       	std	Z+12, r12	; 0x0c
     fd4:	d5 86       	std	Z+13, r13	; 0x0d
	adc->CMP = conf->cmp;
     fd6:	f7 01       	movw	r30, r14
     fd8:	25 81       	ldd	r18, Z+5	; 0x05
     fda:	36 81       	ldd	r19, Z+6	; 0x06
     fdc:	f8 01       	movw	r30, r16
     fde:	20 8f       	std	Z+24, r18	; 0x18
     fe0:	31 8f       	std	Z+25, r19	; 0x19
	adc->REFCTRL = conf->refctrl;
     fe2:	f7 01       	movw	r30, r14
     fe4:	92 81       	ldd	r25, Z+2	; 0x02
     fe6:	f8 01       	movw	r30, r16
     fe8:	92 83       	std	Z+2, r25	; 0x02
	adc->PRESCALER = conf->prescaler;
     fea:	f7 01       	movw	r30, r14
     fec:	94 81       	ldd	r25, Z+4	; 0x04
     fee:	f8 01       	movw	r30, r16
     ff0:	94 83       	std	Z+4, r25	; 0x04
	adc->EVCTRL = conf->evctrl;
     ff2:	f7 01       	movw	r30, r14
     ff4:	93 81       	ldd	r25, Z+3	; 0x03
     ff6:	f8 01       	movw	r30, r16
     ff8:	93 83       	std	Z+3, r25	; 0x03
	adc->CTRLB = conf->ctrlb;
     ffa:	f7 01       	movw	r30, r14
     ffc:	91 81       	ldd	r25, Z+1	; 0x01
     ffe:	f8 01       	movw	r30, r16
    1000:	91 83       	std	Z+1, r25	; 0x01

	adc->CTRLA = enable | conf->ctrla;
    1002:	81 70       	andi	r24, 0x01	; 1
    1004:	f7 01       	movw	r30, r14
    1006:	90 81       	ld	r25, Z
    1008:	89 2b       	or	r24, r25
    100a:	f8 01       	movw	r30, r16
    100c:	80 83       	st	Z, r24

	adc_disable_clock(adc);
    100e:	c8 01       	movw	r24, r16
    1010:	a1 dd       	rcall	.-1214   	; 0xb54 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1012:	bf be       	out	0x3f, r11	; 63

	cpu_irq_restore(flags);
}
    1014:	0f 90       	pop	r0
    1016:	df 91       	pop	r29
    1018:	cf 91       	pop	r28
    101a:	1f 91       	pop	r17
    101c:	0f 91       	pop	r16
    101e:	ff 90       	pop	r15
    1020:	ef 90       	pop	r14
    1022:	df 90       	pop	r13
    1024:	cf 90       	pop	r12
    1026:	bf 90       	pop	r11
    1028:	08 95       	ret

0000102a <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    102a:	df 92       	push	r13
    102c:	ef 92       	push	r14
    102e:	ff 92       	push	r15
    1030:	0f 93       	push	r16
    1032:	1f 93       	push	r17
    1034:	cf 93       	push	r28
    1036:	df 93       	push	r29
    1038:	1f 92       	push	r1
    103a:	cd b7       	in	r28, 0x3d	; 61
    103c:	de b7       	in	r29, 0x3e	; 62
    103e:	8c 01       	movw	r16, r24
    1040:	7b 01       	movw	r14, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    1042:	8f b7       	in	r24, 0x3f	; 63
    1044:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    1046:	f8 94       	cli
	return flags;
    1048:	d9 80       	ldd	r13, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    104a:	c8 01       	movw	r24, r16
    104c:	62 dd       	rcall	.-1340   	; 0xb12 <adc_enable_clock>

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    104e:	f8 01       	movw	r30, r16
    1050:	80 81       	ld	r24, Z
    1052:	80 7c       	andi	r24, 0xC0	; 192
    1054:	f7 01       	movw	r30, r14
    1056:	80 83       	st	Z, r24

	conf->cmp = adc->CMP;
    1058:	f8 01       	movw	r30, r16
    105a:	80 8d       	ldd	r24, Z+24	; 0x18
    105c:	91 8d       	ldd	r25, Z+25	; 0x19
    105e:	f7 01       	movw	r30, r14
    1060:	85 83       	std	Z+5, r24	; 0x05
    1062:	96 83       	std	Z+6, r25	; 0x06
	conf->refctrl = adc->REFCTRL;
    1064:	f8 01       	movw	r30, r16
    1066:	82 81       	ldd	r24, Z+2	; 0x02
    1068:	f7 01       	movw	r30, r14
    106a:	82 83       	std	Z+2, r24	; 0x02
	conf->prescaler = adc->PRESCALER;
    106c:	f8 01       	movw	r30, r16
    106e:	84 81       	ldd	r24, Z+4	; 0x04
    1070:	f7 01       	movw	r30, r14
    1072:	84 83       	std	Z+4, r24	; 0x04
	conf->evctrl = adc->EVCTRL;
    1074:	f8 01       	movw	r30, r16
    1076:	83 81       	ldd	r24, Z+3	; 0x03
    1078:	f7 01       	movw	r30, r14
    107a:	83 83       	std	Z+3, r24	; 0x03
	conf->ctrlb = adc->CTRLB;
    107c:	f8 01       	movw	r30, r16
    107e:	81 81       	ldd	r24, Z+1	; 0x01
    1080:	f7 01       	movw	r30, r14
    1082:	81 83       	std	Z+1, r24	; 0x01

	adc_disable_clock(adc);
    1084:	c8 01       	movw	r24, r16
    1086:	66 dd       	rcall	.-1332   	; 0xb54 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1088:	df be       	out	0x3f, r13	; 63

	cpu_irq_restore(flags);
}
    108a:	0f 90       	pop	r0
    108c:	df 91       	pop	r29
    108e:	cf 91       	pop	r28
    1090:	1f 91       	pop	r17
    1092:	0f 91       	pop	r16
    1094:	ff 90       	pop	r15
    1096:	ef 90       	pop	r14
    1098:	df 90       	pop	r13
    109a:	08 95       	ret

0000109c <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    109c:	af 92       	push	r10
    109e:	bf 92       	push	r11
    10a0:	cf 92       	push	r12
    10a2:	df 92       	push	r13
    10a4:	ef 92       	push	r14
    10a6:	ff 92       	push	r15
    10a8:	0f 93       	push	r16
    10aa:	1f 93       	push	r17
    10ac:	cf 93       	push	r28
    10ae:	df 93       	push	r29
    10b0:	1f 92       	push	r1
    10b2:	cd b7       	in	r28, 0x3d	; 61
    10b4:	de b7       	in	r29, 0x3e	; 62
    10b6:	6c 01       	movw	r12, r24
    10b8:	b6 2e       	mov	r11, r22
    10ba:	7a 01       	movw	r14, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    10bc:	86 2f       	mov	r24, r22
    10be:	83 70       	andi	r24, 0x03	; 3
    10c0:	29 f4       	brne	.+10     	; 0x10cc <adcch_write_configuration+0x30>
		index += 2;
		ch_mask >>= 2;
    10c2:	96 2f       	mov	r25, r22
    10c4:	96 95       	lsr	r25
    10c6:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    10c8:	82 e0       	ldi	r24, 0x02	; 2
    10ca:	02 c0       	rjmp	.+4      	; 0x10d0 <adcch_write_configuration+0x34>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    10cc:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
__always_inline static  ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    10ce:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    10d0:	90 ff       	sbrs	r25, 0
		index++;
    10d2:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    10d4:	86 01       	movw	r16, r12
    10d6:	00 5e       	subi	r16, 0xE0	; 224
    10d8:	1f 4f       	sbci	r17, 0xFF	; 255
    10da:	98 e0       	ldi	r25, 0x08	; 8
    10dc:	89 9f       	mul	r24, r25
    10de:	00 0d       	add	r16, r0
    10e0:	11 1d       	adc	r17, r1
    10e2:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    10e4:	8f b7       	in	r24, 0x3f	; 63
    10e6:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    10e8:	f8 94       	cli
	return flags;
    10ea:	a9 80       	ldd	r10, Y+1	; 0x01
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    10ec:	c6 01       	movw	r24, r12
    10ee:	11 dd       	rcall	.-1502   	; 0xb12 <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    10f0:	f7 01       	movw	r30, r14
    10f2:	80 81       	ld	r24, Z
    10f4:	f8 01       	movw	r30, r16
    10f6:	80 83       	st	Z, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    10f8:	f7 01       	movw	r30, r14
    10fa:	82 81       	ldd	r24, Z+2	; 0x02
    10fc:	f8 01       	movw	r30, r16
    10fe:	82 83       	std	Z+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    1100:	f7 01       	movw	r30, r14
    1102:	81 81       	ldd	r24, Z+1	; 0x01
    1104:	f8 01       	movw	r30, r16
    1106:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1108:	b0 fe       	sbrs	r11, 0
    110a:	04 c0       	rjmp	.+8      	; 0x1114 <adcch_write_configuration+0x78>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    110c:	f7 01       	movw	r30, r14
    110e:	83 81       	ldd	r24, Z+3	; 0x03
    1110:	f8 01       	movw	r30, r16
    1112:	86 83       	std	Z+6, r24	; 0x06
	}
	adc_disable_clock(adc);
    1114:	c6 01       	movw	r24, r12
    1116:	1e dd       	rcall	.-1476   	; 0xb54 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1118:	af be       	out	0x3f, r10	; 63

	cpu_irq_restore(flags);
}
    111a:	0f 90       	pop	r0
    111c:	df 91       	pop	r29
    111e:	cf 91       	pop	r28
    1120:	1f 91       	pop	r17
    1122:	0f 91       	pop	r16
    1124:	ff 90       	pop	r15
    1126:	ef 90       	pop	r14
    1128:	df 90       	pop	r13
    112a:	cf 90       	pop	r12
    112c:	bf 90       	pop	r11
    112e:	af 90       	pop	r10
    1130:	08 95       	ret

00001132 <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    1132:	af 92       	push	r10
    1134:	bf 92       	push	r11
    1136:	cf 92       	push	r12
    1138:	df 92       	push	r13
    113a:	ef 92       	push	r14
    113c:	ff 92       	push	r15
    113e:	0f 93       	push	r16
    1140:	1f 93       	push	r17
    1142:	cf 93       	push	r28
    1144:	df 93       	push	r29
    1146:	1f 92       	push	r1
    1148:	cd b7       	in	r28, 0x3d	; 61
    114a:	de b7       	in	r29, 0x3e	; 62
    114c:	6c 01       	movw	r12, r24
    114e:	b6 2e       	mov	r11, r22
    1150:	7a 01       	movw	r14, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1152:	86 2f       	mov	r24, r22
    1154:	83 70       	andi	r24, 0x03	; 3
    1156:	29 f4       	brne	.+10     	; 0x1162 <adcch_read_configuration+0x30>
		index += 2;
		ch_mask >>= 2;
    1158:	96 2f       	mov	r25, r22
    115a:	96 95       	lsr	r25
    115c:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    115e:	82 e0       	ldi	r24, 0x02	; 2
    1160:	02 c0       	rjmp	.+4      	; 0x1166 <adcch_read_configuration+0x34>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1162:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
__always_inline static  ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    1164:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    1166:	90 ff       	sbrs	r25, 0
		index++;
    1168:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    116a:	86 01       	movw	r16, r12
    116c:	00 5e       	subi	r16, 0xE0	; 224
    116e:	1f 4f       	sbci	r17, 0xFF	; 255
    1170:	98 e0       	ldi	r25, 0x08	; 8
    1172:	89 9f       	mul	r24, r25
    1174:	00 0d       	add	r16, r0
    1176:	11 1d       	adc	r17, r1
    1178:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    117a:	8f b7       	in	r24, 0x3f	; 63
    117c:	89 83       	std	Y+1, r24	; 0x01
	cpu_irq_disable();
    117e:	f8 94       	cli
	return flags;
    1180:	a9 80       	ldd	r10, Y+1	; 0x01

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    1182:	c6 01       	movw	r24, r12
    1184:	c6 dc       	rcall	.-1652   	; 0xb12 <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    1186:	f8 01       	movw	r30, r16
    1188:	80 81       	ld	r24, Z
    118a:	f7 01       	movw	r30, r14
    118c:	80 83       	st	Z, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    118e:	f8 01       	movw	r30, r16
    1190:	82 81       	ldd	r24, Z+2	; 0x02
    1192:	f7 01       	movw	r30, r14
    1194:	82 83       	std	Z+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    1196:	f8 01       	movw	r30, r16
    1198:	81 81       	ldd	r24, Z+1	; 0x01
    119a:	f7 01       	movw	r30, r14
    119c:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    119e:	b0 fe       	sbrs	r11, 0
    11a0:	04 c0       	rjmp	.+8      	; 0x11aa <adcch_read_configuration+0x78>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    11a2:	f8 01       	movw	r30, r16
    11a4:	86 81       	ldd	r24, Z+6	; 0x06
    11a6:	f7 01       	movw	r30, r14
    11a8:	83 83       	std	Z+3, r24	; 0x03
	}
	adc_disable_clock(adc);
    11aa:	c6 01       	movw	r24, r12
    11ac:	d3 dc       	rcall	.-1626   	; 0xb54 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    11ae:	af be       	out	0x3f, r10	; 63

	cpu_irq_restore(flags);
}
    11b0:	0f 90       	pop	r0
    11b2:	df 91       	pop	r29
    11b4:	cf 91       	pop	r28
    11b6:	1f 91       	pop	r17
    11b8:	0f 91       	pop	r16
    11ba:	ff 90       	pop	r15
    11bc:	ef 90       	pop	r14
    11be:	df 90       	pop	r13
    11c0:	cf 90       	pop	r12
    11c2:	bf 90       	pop	r11
    11c4:	af 90       	pop	r10
    11c6:	08 95       	ret

000011c8 <__vector_15>:
	{
		cpu_irq_restore(iflags);
		return;
	}
	cpu_irq_restore(iflags);
}
    11c8:	1f 92       	push	r1
    11ca:	0f 92       	push	r0
    11cc:	0f b6       	in	r0, 0x3f	; 63
    11ce:	0f 92       	push	r0
    11d0:	11 24       	eor	r1, r1
    11d2:	0b b6       	in	r0, 0x3b	; 59
    11d4:	0f 92       	push	r0
    11d6:	2f 93       	push	r18
    11d8:	3f 93       	push	r19
    11da:	4f 93       	push	r20
    11dc:	5f 93       	push	r21
    11de:	6f 93       	push	r22
    11e0:	7f 93       	push	r23
    11e2:	8f 93       	push	r24
    11e4:	9f 93       	push	r25
    11e6:	af 93       	push	r26
    11e8:	bf 93       	push	r27
    11ea:	ef 93       	push	r30
    11ec:	ff 93       	push	r31
    11ee:	e0 91 fc 22 	lds	r30, 0x22FC	; 0x8022fc <tc_tcc0_err_callback>
    11f2:	f0 91 fd 22 	lds	r31, 0x22FD	; 0x8022fd <tc_tcc0_err_callback+0x1>
    11f6:	30 97       	sbiw	r30, 0x00	; 0
    11f8:	09 f0       	breq	.+2      	; 0x11fc <__vector_15+0x34>
    11fa:	19 95       	eicall
    11fc:	ff 91       	pop	r31
    11fe:	ef 91       	pop	r30
    1200:	bf 91       	pop	r27
    1202:	af 91       	pop	r26
    1204:	9f 91       	pop	r25
    1206:	8f 91       	pop	r24
    1208:	7f 91       	pop	r23
    120a:	6f 91       	pop	r22
    120c:	5f 91       	pop	r21
    120e:	4f 91       	pop	r20
    1210:	3f 91       	pop	r19
    1212:	2f 91       	pop	r18
    1214:	0f 90       	pop	r0
    1216:	0b be       	out	0x3b, r0	; 59
    1218:	0f 90       	pop	r0
    121a:	0f be       	out	0x3f, r0	; 63
    121c:	0f 90       	pop	r0
    121e:	1f 90       	pop	r1
    1220:	18 95       	reti

00001222 <__vector_16>:
    1222:	1f 92       	push	r1
    1224:	0f 92       	push	r0
    1226:	0f b6       	in	r0, 0x3f	; 63
    1228:	0f 92       	push	r0
    122a:	11 24       	eor	r1, r1
    122c:	0b b6       	in	r0, 0x3b	; 59
    122e:	0f 92       	push	r0
    1230:	2f 93       	push	r18
    1232:	3f 93       	push	r19
    1234:	4f 93       	push	r20
    1236:	5f 93       	push	r21
    1238:	6f 93       	push	r22
    123a:	7f 93       	push	r23
    123c:	8f 93       	push	r24
    123e:	9f 93       	push	r25
    1240:	af 93       	push	r26
    1242:	bf 93       	push	r27
    1244:	ef 93       	push	r30
    1246:	ff 93       	push	r31
    1248:	e0 91 fa 22 	lds	r30, 0x22FA	; 0x8022fa <tc_tcc0_cca_callback>
    124c:	f0 91 fb 22 	lds	r31, 0x22FB	; 0x8022fb <tc_tcc0_cca_callback+0x1>
    1250:	30 97       	sbiw	r30, 0x00	; 0
    1252:	09 f0       	breq	.+2      	; 0x1256 <__vector_16+0x34>
    1254:	19 95       	eicall
    1256:	ff 91       	pop	r31
    1258:	ef 91       	pop	r30
    125a:	bf 91       	pop	r27
    125c:	af 91       	pop	r26
    125e:	9f 91       	pop	r25
    1260:	8f 91       	pop	r24
    1262:	7f 91       	pop	r23
    1264:	6f 91       	pop	r22
    1266:	5f 91       	pop	r21
    1268:	4f 91       	pop	r20
    126a:	3f 91       	pop	r19
    126c:	2f 91       	pop	r18
    126e:	0f 90       	pop	r0
    1270:	0b be       	out	0x3b, r0	; 59
    1272:	0f 90       	pop	r0
    1274:	0f be       	out	0x3f, r0	; 63
    1276:	0f 90       	pop	r0
    1278:	1f 90       	pop	r1
    127a:	18 95       	reti

0000127c <__vector_17>:
    127c:	1f 92       	push	r1
    127e:	0f 92       	push	r0
    1280:	0f b6       	in	r0, 0x3f	; 63
    1282:	0f 92       	push	r0
    1284:	11 24       	eor	r1, r1
    1286:	0b b6       	in	r0, 0x3b	; 59
    1288:	0f 92       	push	r0
    128a:	2f 93       	push	r18
    128c:	3f 93       	push	r19
    128e:	4f 93       	push	r20
    1290:	5f 93       	push	r21
    1292:	6f 93       	push	r22
    1294:	7f 93       	push	r23
    1296:	8f 93       	push	r24
    1298:	9f 93       	push	r25
    129a:	af 93       	push	r26
    129c:	bf 93       	push	r27
    129e:	ef 93       	push	r30
    12a0:	ff 93       	push	r31
    12a2:	e0 91 f8 22 	lds	r30, 0x22F8	; 0x8022f8 <tc_tcc0_ccb_callback>
    12a6:	f0 91 f9 22 	lds	r31, 0x22F9	; 0x8022f9 <tc_tcc0_ccb_callback+0x1>
    12aa:	30 97       	sbiw	r30, 0x00	; 0
    12ac:	09 f0       	breq	.+2      	; 0x12b0 <__vector_17+0x34>
    12ae:	19 95       	eicall
    12b0:	ff 91       	pop	r31
    12b2:	ef 91       	pop	r30
    12b4:	bf 91       	pop	r27
    12b6:	af 91       	pop	r26
    12b8:	9f 91       	pop	r25
    12ba:	8f 91       	pop	r24
    12bc:	7f 91       	pop	r23
    12be:	6f 91       	pop	r22
    12c0:	5f 91       	pop	r21
    12c2:	4f 91       	pop	r20
    12c4:	3f 91       	pop	r19
    12c6:	2f 91       	pop	r18
    12c8:	0f 90       	pop	r0
    12ca:	0b be       	out	0x3b, r0	; 59
    12cc:	0f 90       	pop	r0
    12ce:	0f be       	out	0x3f, r0	; 63
    12d0:	0f 90       	pop	r0
    12d2:	1f 90       	pop	r1
    12d4:	18 95       	reti

000012d6 <__vector_18>:
    12d6:	1f 92       	push	r1
    12d8:	0f 92       	push	r0
    12da:	0f b6       	in	r0, 0x3f	; 63
    12dc:	0f 92       	push	r0
    12de:	11 24       	eor	r1, r1
    12e0:	0b b6       	in	r0, 0x3b	; 59
    12e2:	0f 92       	push	r0
    12e4:	2f 93       	push	r18
    12e6:	3f 93       	push	r19
    12e8:	4f 93       	push	r20
    12ea:	5f 93       	push	r21
    12ec:	6f 93       	push	r22
    12ee:	7f 93       	push	r23
    12f0:	8f 93       	push	r24
    12f2:	9f 93       	push	r25
    12f4:	af 93       	push	r26
    12f6:	bf 93       	push	r27
    12f8:	ef 93       	push	r30
    12fa:	ff 93       	push	r31
    12fc:	e0 91 f6 22 	lds	r30, 0x22F6	; 0x8022f6 <tc_tcc0_ccc_callback>
    1300:	f0 91 f7 22 	lds	r31, 0x22F7	; 0x8022f7 <tc_tcc0_ccc_callback+0x1>
    1304:	30 97       	sbiw	r30, 0x00	; 0
    1306:	09 f0       	breq	.+2      	; 0x130a <__vector_18+0x34>
    1308:	19 95       	eicall
    130a:	ff 91       	pop	r31
    130c:	ef 91       	pop	r30
    130e:	bf 91       	pop	r27
    1310:	af 91       	pop	r26
    1312:	9f 91       	pop	r25
    1314:	8f 91       	pop	r24
    1316:	7f 91       	pop	r23
    1318:	6f 91       	pop	r22
    131a:	5f 91       	pop	r21
    131c:	4f 91       	pop	r20
    131e:	3f 91       	pop	r19
    1320:	2f 91       	pop	r18
    1322:	0f 90       	pop	r0
    1324:	0b be       	out	0x3b, r0	; 59
    1326:	0f 90       	pop	r0
    1328:	0f be       	out	0x3f, r0	; 63
    132a:	0f 90       	pop	r0
    132c:	1f 90       	pop	r1
    132e:	18 95       	reti

00001330 <__vector_19>:
    1330:	1f 92       	push	r1
    1332:	0f 92       	push	r0
    1334:	0f b6       	in	r0, 0x3f	; 63
    1336:	0f 92       	push	r0
    1338:	11 24       	eor	r1, r1
    133a:	0b b6       	in	r0, 0x3b	; 59
    133c:	0f 92       	push	r0
    133e:	2f 93       	push	r18
    1340:	3f 93       	push	r19
    1342:	4f 93       	push	r20
    1344:	5f 93       	push	r21
    1346:	6f 93       	push	r22
    1348:	7f 93       	push	r23
    134a:	8f 93       	push	r24
    134c:	9f 93       	push	r25
    134e:	af 93       	push	r26
    1350:	bf 93       	push	r27
    1352:	ef 93       	push	r30
    1354:	ff 93       	push	r31
    1356:	e0 91 f4 22 	lds	r30, 0x22F4	; 0x8022f4 <tc_tcc0_ccd_callback>
    135a:	f0 91 f5 22 	lds	r31, 0x22F5	; 0x8022f5 <tc_tcc0_ccd_callback+0x1>
    135e:	30 97       	sbiw	r30, 0x00	; 0
    1360:	09 f0       	breq	.+2      	; 0x1364 <__vector_19+0x34>
    1362:	19 95       	eicall
    1364:	ff 91       	pop	r31
    1366:	ef 91       	pop	r30
    1368:	bf 91       	pop	r27
    136a:	af 91       	pop	r26
    136c:	9f 91       	pop	r25
    136e:	8f 91       	pop	r24
    1370:	7f 91       	pop	r23
    1372:	6f 91       	pop	r22
    1374:	5f 91       	pop	r21
    1376:	4f 91       	pop	r20
    1378:	3f 91       	pop	r19
    137a:	2f 91       	pop	r18
    137c:	0f 90       	pop	r0
    137e:	0b be       	out	0x3b, r0	; 59
    1380:	0f 90       	pop	r0
    1382:	0f be       	out	0x3f, r0	; 63
    1384:	0f 90       	pop	r0
    1386:	1f 90       	pop	r1
    1388:	18 95       	reti

0000138a <__vector_20>:
    138a:	1f 92       	push	r1
    138c:	0f 92       	push	r0
    138e:	0f b6       	in	r0, 0x3f	; 63
    1390:	0f 92       	push	r0
    1392:	11 24       	eor	r1, r1
    1394:	0b b6       	in	r0, 0x3b	; 59
    1396:	0f 92       	push	r0
    1398:	2f 93       	push	r18
    139a:	3f 93       	push	r19
    139c:	4f 93       	push	r20
    139e:	5f 93       	push	r21
    13a0:	6f 93       	push	r22
    13a2:	7f 93       	push	r23
    13a4:	8f 93       	push	r24
    13a6:	9f 93       	push	r25
    13a8:	af 93       	push	r26
    13aa:	bf 93       	push	r27
    13ac:	ef 93       	push	r30
    13ae:	ff 93       	push	r31
    13b0:	e0 91 f2 22 	lds	r30, 0x22F2	; 0x8022f2 <tc_tcc1_ovf_callback>
    13b4:	f0 91 f3 22 	lds	r31, 0x22F3	; 0x8022f3 <tc_tcc1_ovf_callback+0x1>
    13b8:	30 97       	sbiw	r30, 0x00	; 0
    13ba:	09 f0       	breq	.+2      	; 0x13be <__vector_20+0x34>
    13bc:	19 95       	eicall
    13be:	ff 91       	pop	r31
    13c0:	ef 91       	pop	r30
    13c2:	bf 91       	pop	r27
    13c4:	af 91       	pop	r26
    13c6:	9f 91       	pop	r25
    13c8:	8f 91       	pop	r24
    13ca:	7f 91       	pop	r23
    13cc:	6f 91       	pop	r22
    13ce:	5f 91       	pop	r21
    13d0:	4f 91       	pop	r20
    13d2:	3f 91       	pop	r19
    13d4:	2f 91       	pop	r18
    13d6:	0f 90       	pop	r0
    13d8:	0b be       	out	0x3b, r0	; 59
    13da:	0f 90       	pop	r0
    13dc:	0f be       	out	0x3f, r0	; 63
    13de:	0f 90       	pop	r0
    13e0:	1f 90       	pop	r1
    13e2:	18 95       	reti

000013e4 <__vector_21>:
    13e4:	1f 92       	push	r1
    13e6:	0f 92       	push	r0
    13e8:	0f b6       	in	r0, 0x3f	; 63
    13ea:	0f 92       	push	r0
    13ec:	11 24       	eor	r1, r1
    13ee:	0b b6       	in	r0, 0x3b	; 59
    13f0:	0f 92       	push	r0
    13f2:	2f 93       	push	r18
    13f4:	3f 93       	push	r19
    13f6:	4f 93       	push	r20
    13f8:	5f 93       	push	r21
    13fa:	6f 93       	push	r22
    13fc:	7f 93       	push	r23
    13fe:	8f 93       	push	r24
    1400:	9f 93       	push	r25
    1402:	af 93       	push	r26
    1404:	bf 93       	push	r27
    1406:	ef 93       	push	r30
    1408:	ff 93       	push	r31
    140a:	e0 91 f0 22 	lds	r30, 0x22F0	; 0x8022f0 <tc_tcc1_err_callback>
    140e:	f0 91 f1 22 	lds	r31, 0x22F1	; 0x8022f1 <tc_tcc1_err_callback+0x1>
    1412:	30 97       	sbiw	r30, 0x00	; 0
    1414:	09 f0       	breq	.+2      	; 0x1418 <__vector_21+0x34>
    1416:	19 95       	eicall
    1418:	ff 91       	pop	r31
    141a:	ef 91       	pop	r30
    141c:	bf 91       	pop	r27
    141e:	af 91       	pop	r26
    1420:	9f 91       	pop	r25
    1422:	8f 91       	pop	r24
    1424:	7f 91       	pop	r23
    1426:	6f 91       	pop	r22
    1428:	5f 91       	pop	r21
    142a:	4f 91       	pop	r20
    142c:	3f 91       	pop	r19
    142e:	2f 91       	pop	r18
    1430:	0f 90       	pop	r0
    1432:	0b be       	out	0x3b, r0	; 59
    1434:	0f 90       	pop	r0
    1436:	0f be       	out	0x3f, r0	; 63
    1438:	0f 90       	pop	r0
    143a:	1f 90       	pop	r1
    143c:	18 95       	reti

0000143e <__vector_22>:
    143e:	1f 92       	push	r1
    1440:	0f 92       	push	r0
    1442:	0f b6       	in	r0, 0x3f	; 63
    1444:	0f 92       	push	r0
    1446:	11 24       	eor	r1, r1
    1448:	0b b6       	in	r0, 0x3b	; 59
    144a:	0f 92       	push	r0
    144c:	2f 93       	push	r18
    144e:	3f 93       	push	r19
    1450:	4f 93       	push	r20
    1452:	5f 93       	push	r21
    1454:	6f 93       	push	r22
    1456:	7f 93       	push	r23
    1458:	8f 93       	push	r24
    145a:	9f 93       	push	r25
    145c:	af 93       	push	r26
    145e:	bf 93       	push	r27
    1460:	ef 93       	push	r30
    1462:	ff 93       	push	r31
    1464:	e0 91 ee 22 	lds	r30, 0x22EE	; 0x8022ee <tc_tcc1_cca_callback>
    1468:	f0 91 ef 22 	lds	r31, 0x22EF	; 0x8022ef <tc_tcc1_cca_callback+0x1>
    146c:	30 97       	sbiw	r30, 0x00	; 0
    146e:	09 f0       	breq	.+2      	; 0x1472 <__vector_22+0x34>
    1470:	19 95       	eicall
    1472:	ff 91       	pop	r31
    1474:	ef 91       	pop	r30
    1476:	bf 91       	pop	r27
    1478:	af 91       	pop	r26
    147a:	9f 91       	pop	r25
    147c:	8f 91       	pop	r24
    147e:	7f 91       	pop	r23
    1480:	6f 91       	pop	r22
    1482:	5f 91       	pop	r21
    1484:	4f 91       	pop	r20
    1486:	3f 91       	pop	r19
    1488:	2f 91       	pop	r18
    148a:	0f 90       	pop	r0
    148c:	0b be       	out	0x3b, r0	; 59
    148e:	0f 90       	pop	r0
    1490:	0f be       	out	0x3f, r0	; 63
    1492:	0f 90       	pop	r0
    1494:	1f 90       	pop	r1
    1496:	18 95       	reti

00001498 <__vector_23>:
    1498:	1f 92       	push	r1
    149a:	0f 92       	push	r0
    149c:	0f b6       	in	r0, 0x3f	; 63
    149e:	0f 92       	push	r0
    14a0:	11 24       	eor	r1, r1
    14a2:	0b b6       	in	r0, 0x3b	; 59
    14a4:	0f 92       	push	r0
    14a6:	2f 93       	push	r18
    14a8:	3f 93       	push	r19
    14aa:	4f 93       	push	r20
    14ac:	5f 93       	push	r21
    14ae:	6f 93       	push	r22
    14b0:	7f 93       	push	r23
    14b2:	8f 93       	push	r24
    14b4:	9f 93       	push	r25
    14b6:	af 93       	push	r26
    14b8:	bf 93       	push	r27
    14ba:	ef 93       	push	r30
    14bc:	ff 93       	push	r31
    14be:	e0 91 ec 22 	lds	r30, 0x22EC	; 0x8022ec <tc_tcc1_ccb_callback>
    14c2:	f0 91 ed 22 	lds	r31, 0x22ED	; 0x8022ed <tc_tcc1_ccb_callback+0x1>
    14c6:	30 97       	sbiw	r30, 0x00	; 0
    14c8:	09 f0       	breq	.+2      	; 0x14cc <__vector_23+0x34>
    14ca:	19 95       	eicall
    14cc:	ff 91       	pop	r31
    14ce:	ef 91       	pop	r30
    14d0:	bf 91       	pop	r27
    14d2:	af 91       	pop	r26
    14d4:	9f 91       	pop	r25
    14d6:	8f 91       	pop	r24
    14d8:	7f 91       	pop	r23
    14da:	6f 91       	pop	r22
    14dc:	5f 91       	pop	r21
    14de:	4f 91       	pop	r20
    14e0:	3f 91       	pop	r19
    14e2:	2f 91       	pop	r18
    14e4:	0f 90       	pop	r0
    14e6:	0b be       	out	0x3b, r0	; 59
    14e8:	0f 90       	pop	r0
    14ea:	0f be       	out	0x3f, r0	; 63
    14ec:	0f 90       	pop	r0
    14ee:	1f 90       	pop	r1
    14f0:	18 95       	reti

000014f2 <__vector_77>:
    14f2:	1f 92       	push	r1
    14f4:	0f 92       	push	r0
    14f6:	0f b6       	in	r0, 0x3f	; 63
    14f8:	0f 92       	push	r0
    14fa:	11 24       	eor	r1, r1
    14fc:	0b b6       	in	r0, 0x3b	; 59
    14fe:	0f 92       	push	r0
    1500:	2f 93       	push	r18
    1502:	3f 93       	push	r19
    1504:	4f 93       	push	r20
    1506:	5f 93       	push	r21
    1508:	6f 93       	push	r22
    150a:	7f 93       	push	r23
    150c:	8f 93       	push	r24
    150e:	9f 93       	push	r25
    1510:	af 93       	push	r26
    1512:	bf 93       	push	r27
    1514:	ef 93       	push	r30
    1516:	ff 93       	push	r31
    1518:	e0 91 ea 22 	lds	r30, 0x22EA	; 0x8022ea <tc_tcd0_ovf_callback>
    151c:	f0 91 eb 22 	lds	r31, 0x22EB	; 0x8022eb <tc_tcd0_ovf_callback+0x1>
    1520:	30 97       	sbiw	r30, 0x00	; 0
    1522:	09 f0       	breq	.+2      	; 0x1526 <__vector_77+0x34>
    1524:	19 95       	eicall
    1526:	ff 91       	pop	r31
    1528:	ef 91       	pop	r30
    152a:	bf 91       	pop	r27
    152c:	af 91       	pop	r26
    152e:	9f 91       	pop	r25
    1530:	8f 91       	pop	r24
    1532:	7f 91       	pop	r23
    1534:	6f 91       	pop	r22
    1536:	5f 91       	pop	r21
    1538:	4f 91       	pop	r20
    153a:	3f 91       	pop	r19
    153c:	2f 91       	pop	r18
    153e:	0f 90       	pop	r0
    1540:	0b be       	out	0x3b, r0	; 59
    1542:	0f 90       	pop	r0
    1544:	0f be       	out	0x3f, r0	; 63
    1546:	0f 90       	pop	r0
    1548:	1f 90       	pop	r1
    154a:	18 95       	reti

0000154c <__vector_78>:
    154c:	1f 92       	push	r1
    154e:	0f 92       	push	r0
    1550:	0f b6       	in	r0, 0x3f	; 63
    1552:	0f 92       	push	r0
    1554:	11 24       	eor	r1, r1
    1556:	0b b6       	in	r0, 0x3b	; 59
    1558:	0f 92       	push	r0
    155a:	2f 93       	push	r18
    155c:	3f 93       	push	r19
    155e:	4f 93       	push	r20
    1560:	5f 93       	push	r21
    1562:	6f 93       	push	r22
    1564:	7f 93       	push	r23
    1566:	8f 93       	push	r24
    1568:	9f 93       	push	r25
    156a:	af 93       	push	r26
    156c:	bf 93       	push	r27
    156e:	ef 93       	push	r30
    1570:	ff 93       	push	r31
    1572:	e0 91 e8 22 	lds	r30, 0x22E8	; 0x8022e8 <tc_tcd0_err_callback>
    1576:	f0 91 e9 22 	lds	r31, 0x22E9	; 0x8022e9 <tc_tcd0_err_callback+0x1>
    157a:	30 97       	sbiw	r30, 0x00	; 0
    157c:	09 f0       	breq	.+2      	; 0x1580 <__vector_78+0x34>
    157e:	19 95       	eicall
    1580:	ff 91       	pop	r31
    1582:	ef 91       	pop	r30
    1584:	bf 91       	pop	r27
    1586:	af 91       	pop	r26
    1588:	9f 91       	pop	r25
    158a:	8f 91       	pop	r24
    158c:	7f 91       	pop	r23
    158e:	6f 91       	pop	r22
    1590:	5f 91       	pop	r21
    1592:	4f 91       	pop	r20
    1594:	3f 91       	pop	r19
    1596:	2f 91       	pop	r18
    1598:	0f 90       	pop	r0
    159a:	0b be       	out	0x3b, r0	; 59
    159c:	0f 90       	pop	r0
    159e:	0f be       	out	0x3f, r0	; 63
    15a0:	0f 90       	pop	r0
    15a2:	1f 90       	pop	r1
    15a4:	18 95       	reti

000015a6 <__vector_79>:
    15a6:	1f 92       	push	r1
    15a8:	0f 92       	push	r0
    15aa:	0f b6       	in	r0, 0x3f	; 63
    15ac:	0f 92       	push	r0
    15ae:	11 24       	eor	r1, r1
    15b0:	0b b6       	in	r0, 0x3b	; 59
    15b2:	0f 92       	push	r0
    15b4:	2f 93       	push	r18
    15b6:	3f 93       	push	r19
    15b8:	4f 93       	push	r20
    15ba:	5f 93       	push	r21
    15bc:	6f 93       	push	r22
    15be:	7f 93       	push	r23
    15c0:	8f 93       	push	r24
    15c2:	9f 93       	push	r25
    15c4:	af 93       	push	r26
    15c6:	bf 93       	push	r27
    15c8:	ef 93       	push	r30
    15ca:	ff 93       	push	r31
    15cc:	e0 91 e6 22 	lds	r30, 0x22E6	; 0x8022e6 <tc_tcd0_cca_callback>
    15d0:	f0 91 e7 22 	lds	r31, 0x22E7	; 0x8022e7 <tc_tcd0_cca_callback+0x1>
    15d4:	30 97       	sbiw	r30, 0x00	; 0
    15d6:	09 f0       	breq	.+2      	; 0x15da <__vector_79+0x34>
    15d8:	19 95       	eicall
    15da:	ff 91       	pop	r31
    15dc:	ef 91       	pop	r30
    15de:	bf 91       	pop	r27
    15e0:	af 91       	pop	r26
    15e2:	9f 91       	pop	r25
    15e4:	8f 91       	pop	r24
    15e6:	7f 91       	pop	r23
    15e8:	6f 91       	pop	r22
    15ea:	5f 91       	pop	r21
    15ec:	4f 91       	pop	r20
    15ee:	3f 91       	pop	r19
    15f0:	2f 91       	pop	r18
    15f2:	0f 90       	pop	r0
    15f4:	0b be       	out	0x3b, r0	; 59
    15f6:	0f 90       	pop	r0
    15f8:	0f be       	out	0x3f, r0	; 63
    15fa:	0f 90       	pop	r0
    15fc:	1f 90       	pop	r1
    15fe:	18 95       	reti

00001600 <__vector_80>:
    1600:	1f 92       	push	r1
    1602:	0f 92       	push	r0
    1604:	0f b6       	in	r0, 0x3f	; 63
    1606:	0f 92       	push	r0
    1608:	11 24       	eor	r1, r1
    160a:	0b b6       	in	r0, 0x3b	; 59
    160c:	0f 92       	push	r0
    160e:	2f 93       	push	r18
    1610:	3f 93       	push	r19
    1612:	4f 93       	push	r20
    1614:	5f 93       	push	r21
    1616:	6f 93       	push	r22
    1618:	7f 93       	push	r23
    161a:	8f 93       	push	r24
    161c:	9f 93       	push	r25
    161e:	af 93       	push	r26
    1620:	bf 93       	push	r27
    1622:	ef 93       	push	r30
    1624:	ff 93       	push	r31
    1626:	e0 91 e4 22 	lds	r30, 0x22E4	; 0x8022e4 <tc_tcd0_ccb_callback>
    162a:	f0 91 e5 22 	lds	r31, 0x22E5	; 0x8022e5 <tc_tcd0_ccb_callback+0x1>
    162e:	30 97       	sbiw	r30, 0x00	; 0
    1630:	09 f0       	breq	.+2      	; 0x1634 <__vector_80+0x34>
    1632:	19 95       	eicall
    1634:	ff 91       	pop	r31
    1636:	ef 91       	pop	r30
    1638:	bf 91       	pop	r27
    163a:	af 91       	pop	r26
    163c:	9f 91       	pop	r25
    163e:	8f 91       	pop	r24
    1640:	7f 91       	pop	r23
    1642:	6f 91       	pop	r22
    1644:	5f 91       	pop	r21
    1646:	4f 91       	pop	r20
    1648:	3f 91       	pop	r19
    164a:	2f 91       	pop	r18
    164c:	0f 90       	pop	r0
    164e:	0b be       	out	0x3b, r0	; 59
    1650:	0f 90       	pop	r0
    1652:	0f be       	out	0x3f, r0	; 63
    1654:	0f 90       	pop	r0
    1656:	1f 90       	pop	r1
    1658:	18 95       	reti

0000165a <__vector_81>:
    165a:	1f 92       	push	r1
    165c:	0f 92       	push	r0
    165e:	0f b6       	in	r0, 0x3f	; 63
    1660:	0f 92       	push	r0
    1662:	11 24       	eor	r1, r1
    1664:	0b b6       	in	r0, 0x3b	; 59
    1666:	0f 92       	push	r0
    1668:	2f 93       	push	r18
    166a:	3f 93       	push	r19
    166c:	4f 93       	push	r20
    166e:	5f 93       	push	r21
    1670:	6f 93       	push	r22
    1672:	7f 93       	push	r23
    1674:	8f 93       	push	r24
    1676:	9f 93       	push	r25
    1678:	af 93       	push	r26
    167a:	bf 93       	push	r27
    167c:	ef 93       	push	r30
    167e:	ff 93       	push	r31
    1680:	e0 91 e2 22 	lds	r30, 0x22E2	; 0x8022e2 <tc_tcd0_ccc_callback>
    1684:	f0 91 e3 22 	lds	r31, 0x22E3	; 0x8022e3 <tc_tcd0_ccc_callback+0x1>
    1688:	30 97       	sbiw	r30, 0x00	; 0
    168a:	09 f0       	breq	.+2      	; 0x168e <__vector_81+0x34>
    168c:	19 95       	eicall
    168e:	ff 91       	pop	r31
    1690:	ef 91       	pop	r30
    1692:	bf 91       	pop	r27
    1694:	af 91       	pop	r26
    1696:	9f 91       	pop	r25
    1698:	8f 91       	pop	r24
    169a:	7f 91       	pop	r23
    169c:	6f 91       	pop	r22
    169e:	5f 91       	pop	r21
    16a0:	4f 91       	pop	r20
    16a2:	3f 91       	pop	r19
    16a4:	2f 91       	pop	r18
    16a6:	0f 90       	pop	r0
    16a8:	0b be       	out	0x3b, r0	; 59
    16aa:	0f 90       	pop	r0
    16ac:	0f be       	out	0x3f, r0	; 63
    16ae:	0f 90       	pop	r0
    16b0:	1f 90       	pop	r1
    16b2:	18 95       	reti

000016b4 <__vector_82>:
    16b4:	1f 92       	push	r1
    16b6:	0f 92       	push	r0
    16b8:	0f b6       	in	r0, 0x3f	; 63
    16ba:	0f 92       	push	r0
    16bc:	11 24       	eor	r1, r1
    16be:	0b b6       	in	r0, 0x3b	; 59
    16c0:	0f 92       	push	r0
    16c2:	2f 93       	push	r18
    16c4:	3f 93       	push	r19
    16c6:	4f 93       	push	r20
    16c8:	5f 93       	push	r21
    16ca:	6f 93       	push	r22
    16cc:	7f 93       	push	r23
    16ce:	8f 93       	push	r24
    16d0:	9f 93       	push	r25
    16d2:	af 93       	push	r26
    16d4:	bf 93       	push	r27
    16d6:	ef 93       	push	r30
    16d8:	ff 93       	push	r31
    16da:	e0 91 e0 22 	lds	r30, 0x22E0	; 0x8022e0 <tc_tcd0_ccd_callback>
    16de:	f0 91 e1 22 	lds	r31, 0x22E1	; 0x8022e1 <tc_tcd0_ccd_callback+0x1>
    16e2:	30 97       	sbiw	r30, 0x00	; 0
    16e4:	09 f0       	breq	.+2      	; 0x16e8 <__vector_82+0x34>
    16e6:	19 95       	eicall
    16e8:	ff 91       	pop	r31
    16ea:	ef 91       	pop	r30
    16ec:	bf 91       	pop	r27
    16ee:	af 91       	pop	r26
    16f0:	9f 91       	pop	r25
    16f2:	8f 91       	pop	r24
    16f4:	7f 91       	pop	r23
    16f6:	6f 91       	pop	r22
    16f8:	5f 91       	pop	r21
    16fa:	4f 91       	pop	r20
    16fc:	3f 91       	pop	r19
    16fe:	2f 91       	pop	r18
    1700:	0f 90       	pop	r0
    1702:	0b be       	out	0x3b, r0	; 59
    1704:	0f 90       	pop	r0
    1706:	0f be       	out	0x3f, r0	; 63
    1708:	0f 90       	pop	r0
    170a:	1f 90       	pop	r1
    170c:	18 95       	reti

0000170e <__vector_83>:
    170e:	1f 92       	push	r1
    1710:	0f 92       	push	r0
    1712:	0f b6       	in	r0, 0x3f	; 63
    1714:	0f 92       	push	r0
    1716:	11 24       	eor	r1, r1
    1718:	0b b6       	in	r0, 0x3b	; 59
    171a:	0f 92       	push	r0
    171c:	2f 93       	push	r18
    171e:	3f 93       	push	r19
    1720:	4f 93       	push	r20
    1722:	5f 93       	push	r21
    1724:	6f 93       	push	r22
    1726:	7f 93       	push	r23
    1728:	8f 93       	push	r24
    172a:	9f 93       	push	r25
    172c:	af 93       	push	r26
    172e:	bf 93       	push	r27
    1730:	ef 93       	push	r30
    1732:	ff 93       	push	r31
    1734:	e0 91 de 22 	lds	r30, 0x22DE	; 0x8022de <tc_tcd1_ovf_callback>
    1738:	f0 91 df 22 	lds	r31, 0x22DF	; 0x8022df <tc_tcd1_ovf_callback+0x1>
    173c:	30 97       	sbiw	r30, 0x00	; 0
    173e:	09 f0       	breq	.+2      	; 0x1742 <__vector_83+0x34>
    1740:	19 95       	eicall
    1742:	ff 91       	pop	r31
    1744:	ef 91       	pop	r30
    1746:	bf 91       	pop	r27
    1748:	af 91       	pop	r26
    174a:	9f 91       	pop	r25
    174c:	8f 91       	pop	r24
    174e:	7f 91       	pop	r23
    1750:	6f 91       	pop	r22
    1752:	5f 91       	pop	r21
    1754:	4f 91       	pop	r20
    1756:	3f 91       	pop	r19
    1758:	2f 91       	pop	r18
    175a:	0f 90       	pop	r0
    175c:	0b be       	out	0x3b, r0	; 59
    175e:	0f 90       	pop	r0
    1760:	0f be       	out	0x3f, r0	; 63
    1762:	0f 90       	pop	r0
    1764:	1f 90       	pop	r1
    1766:	18 95       	reti

00001768 <__vector_84>:
    1768:	1f 92       	push	r1
    176a:	0f 92       	push	r0
    176c:	0f b6       	in	r0, 0x3f	; 63
    176e:	0f 92       	push	r0
    1770:	11 24       	eor	r1, r1
    1772:	0b b6       	in	r0, 0x3b	; 59
    1774:	0f 92       	push	r0
    1776:	2f 93       	push	r18
    1778:	3f 93       	push	r19
    177a:	4f 93       	push	r20
    177c:	5f 93       	push	r21
    177e:	6f 93       	push	r22
    1780:	7f 93       	push	r23
    1782:	8f 93       	push	r24
    1784:	9f 93       	push	r25
    1786:	af 93       	push	r26
    1788:	bf 93       	push	r27
    178a:	ef 93       	push	r30
    178c:	ff 93       	push	r31
    178e:	e0 91 dc 22 	lds	r30, 0x22DC	; 0x8022dc <tc_tcd1_err_callback>
    1792:	f0 91 dd 22 	lds	r31, 0x22DD	; 0x8022dd <tc_tcd1_err_callback+0x1>
    1796:	30 97       	sbiw	r30, 0x00	; 0
    1798:	09 f0       	breq	.+2      	; 0x179c <__vector_84+0x34>
    179a:	19 95       	eicall
    179c:	ff 91       	pop	r31
    179e:	ef 91       	pop	r30
    17a0:	bf 91       	pop	r27
    17a2:	af 91       	pop	r26
    17a4:	9f 91       	pop	r25
    17a6:	8f 91       	pop	r24
    17a8:	7f 91       	pop	r23
    17aa:	6f 91       	pop	r22
    17ac:	5f 91       	pop	r21
    17ae:	4f 91       	pop	r20
    17b0:	3f 91       	pop	r19
    17b2:	2f 91       	pop	r18
    17b4:	0f 90       	pop	r0
    17b6:	0b be       	out	0x3b, r0	; 59
    17b8:	0f 90       	pop	r0
    17ba:	0f be       	out	0x3f, r0	; 63
    17bc:	0f 90       	pop	r0
    17be:	1f 90       	pop	r1
    17c0:	18 95       	reti

000017c2 <__vector_85>:
    17c2:	1f 92       	push	r1
    17c4:	0f 92       	push	r0
    17c6:	0f b6       	in	r0, 0x3f	; 63
    17c8:	0f 92       	push	r0
    17ca:	11 24       	eor	r1, r1
    17cc:	0b b6       	in	r0, 0x3b	; 59
    17ce:	0f 92       	push	r0
    17d0:	2f 93       	push	r18
    17d2:	3f 93       	push	r19
    17d4:	4f 93       	push	r20
    17d6:	5f 93       	push	r21
    17d8:	6f 93       	push	r22
    17da:	7f 93       	push	r23
    17dc:	8f 93       	push	r24
    17de:	9f 93       	push	r25
    17e0:	af 93       	push	r26
    17e2:	bf 93       	push	r27
    17e4:	ef 93       	push	r30
    17e6:	ff 93       	push	r31
    17e8:	e0 91 da 22 	lds	r30, 0x22DA	; 0x8022da <tc_tcd1_cca_callback>
    17ec:	f0 91 db 22 	lds	r31, 0x22DB	; 0x8022db <tc_tcd1_cca_callback+0x1>
    17f0:	30 97       	sbiw	r30, 0x00	; 0
    17f2:	09 f0       	breq	.+2      	; 0x17f6 <__vector_85+0x34>
    17f4:	19 95       	eicall
    17f6:	ff 91       	pop	r31
    17f8:	ef 91       	pop	r30
    17fa:	bf 91       	pop	r27
    17fc:	af 91       	pop	r26
    17fe:	9f 91       	pop	r25
    1800:	8f 91       	pop	r24
    1802:	7f 91       	pop	r23
    1804:	6f 91       	pop	r22
    1806:	5f 91       	pop	r21
    1808:	4f 91       	pop	r20
    180a:	3f 91       	pop	r19
    180c:	2f 91       	pop	r18
    180e:	0f 90       	pop	r0
    1810:	0b be       	out	0x3b, r0	; 59
    1812:	0f 90       	pop	r0
    1814:	0f be       	out	0x3f, r0	; 63
    1816:	0f 90       	pop	r0
    1818:	1f 90       	pop	r1
    181a:	18 95       	reti

0000181c <__vector_86>:
    181c:	1f 92       	push	r1
    181e:	0f 92       	push	r0
    1820:	0f b6       	in	r0, 0x3f	; 63
    1822:	0f 92       	push	r0
    1824:	11 24       	eor	r1, r1
    1826:	0b b6       	in	r0, 0x3b	; 59
    1828:	0f 92       	push	r0
    182a:	2f 93       	push	r18
    182c:	3f 93       	push	r19
    182e:	4f 93       	push	r20
    1830:	5f 93       	push	r21
    1832:	6f 93       	push	r22
    1834:	7f 93       	push	r23
    1836:	8f 93       	push	r24
    1838:	9f 93       	push	r25
    183a:	af 93       	push	r26
    183c:	bf 93       	push	r27
    183e:	ef 93       	push	r30
    1840:	ff 93       	push	r31
    1842:	e0 91 d8 22 	lds	r30, 0x22D8	; 0x8022d8 <tc_tcd1_ccb_callback>
    1846:	f0 91 d9 22 	lds	r31, 0x22D9	; 0x8022d9 <tc_tcd1_ccb_callback+0x1>
    184a:	30 97       	sbiw	r30, 0x00	; 0
    184c:	09 f0       	breq	.+2      	; 0x1850 <__vector_86+0x34>
    184e:	19 95       	eicall
    1850:	ff 91       	pop	r31
    1852:	ef 91       	pop	r30
    1854:	bf 91       	pop	r27
    1856:	af 91       	pop	r26
    1858:	9f 91       	pop	r25
    185a:	8f 91       	pop	r24
    185c:	7f 91       	pop	r23
    185e:	6f 91       	pop	r22
    1860:	5f 91       	pop	r21
    1862:	4f 91       	pop	r20
    1864:	3f 91       	pop	r19
    1866:	2f 91       	pop	r18
    1868:	0f 90       	pop	r0
    186a:	0b be       	out	0x3b, r0	; 59
    186c:	0f 90       	pop	r0
    186e:	0f be       	out	0x3f, r0	; 63
    1870:	0f 90       	pop	r0
    1872:	1f 90       	pop	r1
    1874:	18 95       	reti

00001876 <__vector_47>:
    1876:	1f 92       	push	r1
    1878:	0f 92       	push	r0
    187a:	0f b6       	in	r0, 0x3f	; 63
    187c:	0f 92       	push	r0
    187e:	11 24       	eor	r1, r1
    1880:	0b b6       	in	r0, 0x3b	; 59
    1882:	0f 92       	push	r0
    1884:	2f 93       	push	r18
    1886:	3f 93       	push	r19
    1888:	4f 93       	push	r20
    188a:	5f 93       	push	r21
    188c:	6f 93       	push	r22
    188e:	7f 93       	push	r23
    1890:	8f 93       	push	r24
    1892:	9f 93       	push	r25
    1894:	af 93       	push	r26
    1896:	bf 93       	push	r27
    1898:	ef 93       	push	r30
    189a:	ff 93       	push	r31
    189c:	e0 91 d6 22 	lds	r30, 0x22D6	; 0x8022d6 <tc_tce0_ovf_callback>
    18a0:	f0 91 d7 22 	lds	r31, 0x22D7	; 0x8022d7 <tc_tce0_ovf_callback+0x1>
    18a4:	30 97       	sbiw	r30, 0x00	; 0
    18a6:	09 f0       	breq	.+2      	; 0x18aa <__vector_47+0x34>
    18a8:	19 95       	eicall
    18aa:	ff 91       	pop	r31
    18ac:	ef 91       	pop	r30
    18ae:	bf 91       	pop	r27
    18b0:	af 91       	pop	r26
    18b2:	9f 91       	pop	r25
    18b4:	8f 91       	pop	r24
    18b6:	7f 91       	pop	r23
    18b8:	6f 91       	pop	r22
    18ba:	5f 91       	pop	r21
    18bc:	4f 91       	pop	r20
    18be:	3f 91       	pop	r19
    18c0:	2f 91       	pop	r18
    18c2:	0f 90       	pop	r0
    18c4:	0b be       	out	0x3b, r0	; 59
    18c6:	0f 90       	pop	r0
    18c8:	0f be       	out	0x3f, r0	; 63
    18ca:	0f 90       	pop	r0
    18cc:	1f 90       	pop	r1
    18ce:	18 95       	reti

000018d0 <__vector_48>:
    18d0:	1f 92       	push	r1
    18d2:	0f 92       	push	r0
    18d4:	0f b6       	in	r0, 0x3f	; 63
    18d6:	0f 92       	push	r0
    18d8:	11 24       	eor	r1, r1
    18da:	0b b6       	in	r0, 0x3b	; 59
    18dc:	0f 92       	push	r0
    18de:	2f 93       	push	r18
    18e0:	3f 93       	push	r19
    18e2:	4f 93       	push	r20
    18e4:	5f 93       	push	r21
    18e6:	6f 93       	push	r22
    18e8:	7f 93       	push	r23
    18ea:	8f 93       	push	r24
    18ec:	9f 93       	push	r25
    18ee:	af 93       	push	r26
    18f0:	bf 93       	push	r27
    18f2:	ef 93       	push	r30
    18f4:	ff 93       	push	r31
    18f6:	e0 91 d4 22 	lds	r30, 0x22D4	; 0x8022d4 <tc_tce0_err_callback>
    18fa:	f0 91 d5 22 	lds	r31, 0x22D5	; 0x8022d5 <tc_tce0_err_callback+0x1>
    18fe:	30 97       	sbiw	r30, 0x00	; 0
    1900:	09 f0       	breq	.+2      	; 0x1904 <__vector_48+0x34>
    1902:	19 95       	eicall
    1904:	ff 91       	pop	r31
    1906:	ef 91       	pop	r30
    1908:	bf 91       	pop	r27
    190a:	af 91       	pop	r26
    190c:	9f 91       	pop	r25
    190e:	8f 91       	pop	r24
    1910:	7f 91       	pop	r23
    1912:	6f 91       	pop	r22
    1914:	5f 91       	pop	r21
    1916:	4f 91       	pop	r20
    1918:	3f 91       	pop	r19
    191a:	2f 91       	pop	r18
    191c:	0f 90       	pop	r0
    191e:	0b be       	out	0x3b, r0	; 59
    1920:	0f 90       	pop	r0
    1922:	0f be       	out	0x3f, r0	; 63
    1924:	0f 90       	pop	r0
    1926:	1f 90       	pop	r1
    1928:	18 95       	reti

0000192a <__vector_49>:
    192a:	1f 92       	push	r1
    192c:	0f 92       	push	r0
    192e:	0f b6       	in	r0, 0x3f	; 63
    1930:	0f 92       	push	r0
    1932:	11 24       	eor	r1, r1
    1934:	0b b6       	in	r0, 0x3b	; 59
    1936:	0f 92       	push	r0
    1938:	2f 93       	push	r18
    193a:	3f 93       	push	r19
    193c:	4f 93       	push	r20
    193e:	5f 93       	push	r21
    1940:	6f 93       	push	r22
    1942:	7f 93       	push	r23
    1944:	8f 93       	push	r24
    1946:	9f 93       	push	r25
    1948:	af 93       	push	r26
    194a:	bf 93       	push	r27
    194c:	ef 93       	push	r30
    194e:	ff 93       	push	r31
    1950:	e0 91 d2 22 	lds	r30, 0x22D2	; 0x8022d2 <tc_tce0_cca_callback>
    1954:	f0 91 d3 22 	lds	r31, 0x22D3	; 0x8022d3 <tc_tce0_cca_callback+0x1>
    1958:	30 97       	sbiw	r30, 0x00	; 0
    195a:	09 f0       	breq	.+2      	; 0x195e <__vector_49+0x34>
    195c:	19 95       	eicall
    195e:	ff 91       	pop	r31
    1960:	ef 91       	pop	r30
    1962:	bf 91       	pop	r27
    1964:	af 91       	pop	r26
    1966:	9f 91       	pop	r25
    1968:	8f 91       	pop	r24
    196a:	7f 91       	pop	r23
    196c:	6f 91       	pop	r22
    196e:	5f 91       	pop	r21
    1970:	4f 91       	pop	r20
    1972:	3f 91       	pop	r19
    1974:	2f 91       	pop	r18
    1976:	0f 90       	pop	r0
    1978:	0b be       	out	0x3b, r0	; 59
    197a:	0f 90       	pop	r0
    197c:	0f be       	out	0x3f, r0	; 63
    197e:	0f 90       	pop	r0
    1980:	1f 90       	pop	r1
    1982:	18 95       	reti

00001984 <__vector_50>:
    1984:	1f 92       	push	r1
    1986:	0f 92       	push	r0
    1988:	0f b6       	in	r0, 0x3f	; 63
    198a:	0f 92       	push	r0
    198c:	11 24       	eor	r1, r1
    198e:	0b b6       	in	r0, 0x3b	; 59
    1990:	0f 92       	push	r0
    1992:	2f 93       	push	r18
    1994:	3f 93       	push	r19
    1996:	4f 93       	push	r20
    1998:	5f 93       	push	r21
    199a:	6f 93       	push	r22
    199c:	7f 93       	push	r23
    199e:	8f 93       	push	r24
    19a0:	9f 93       	push	r25
    19a2:	af 93       	push	r26
    19a4:	bf 93       	push	r27
    19a6:	ef 93       	push	r30
    19a8:	ff 93       	push	r31
    19aa:	e0 91 d0 22 	lds	r30, 0x22D0	; 0x8022d0 <tc_tce0_ccb_callback>
    19ae:	f0 91 d1 22 	lds	r31, 0x22D1	; 0x8022d1 <tc_tce0_ccb_callback+0x1>
    19b2:	30 97       	sbiw	r30, 0x00	; 0
    19b4:	09 f0       	breq	.+2      	; 0x19b8 <__vector_50+0x34>
    19b6:	19 95       	eicall
    19b8:	ff 91       	pop	r31
    19ba:	ef 91       	pop	r30
    19bc:	bf 91       	pop	r27
    19be:	af 91       	pop	r26
    19c0:	9f 91       	pop	r25
    19c2:	8f 91       	pop	r24
    19c4:	7f 91       	pop	r23
    19c6:	6f 91       	pop	r22
    19c8:	5f 91       	pop	r21
    19ca:	4f 91       	pop	r20
    19cc:	3f 91       	pop	r19
    19ce:	2f 91       	pop	r18
    19d0:	0f 90       	pop	r0
    19d2:	0b be       	out	0x3b, r0	; 59
    19d4:	0f 90       	pop	r0
    19d6:	0f be       	out	0x3f, r0	; 63
    19d8:	0f 90       	pop	r0
    19da:	1f 90       	pop	r1
    19dc:	18 95       	reti

000019de <__vector_51>:
    19de:	1f 92       	push	r1
    19e0:	0f 92       	push	r0
    19e2:	0f b6       	in	r0, 0x3f	; 63
    19e4:	0f 92       	push	r0
    19e6:	11 24       	eor	r1, r1
    19e8:	0b b6       	in	r0, 0x3b	; 59
    19ea:	0f 92       	push	r0
    19ec:	2f 93       	push	r18
    19ee:	3f 93       	push	r19
    19f0:	4f 93       	push	r20
    19f2:	5f 93       	push	r21
    19f4:	6f 93       	push	r22
    19f6:	7f 93       	push	r23
    19f8:	8f 93       	push	r24
    19fa:	9f 93       	push	r25
    19fc:	af 93       	push	r26
    19fe:	bf 93       	push	r27
    1a00:	ef 93       	push	r30
    1a02:	ff 93       	push	r31
    1a04:	e0 91 ce 22 	lds	r30, 0x22CE	; 0x8022ce <tc_tce0_ccc_callback>
    1a08:	f0 91 cf 22 	lds	r31, 0x22CF	; 0x8022cf <tc_tce0_ccc_callback+0x1>
    1a0c:	30 97       	sbiw	r30, 0x00	; 0
    1a0e:	09 f0       	breq	.+2      	; 0x1a12 <__vector_51+0x34>
    1a10:	19 95       	eicall
    1a12:	ff 91       	pop	r31
    1a14:	ef 91       	pop	r30
    1a16:	bf 91       	pop	r27
    1a18:	af 91       	pop	r26
    1a1a:	9f 91       	pop	r25
    1a1c:	8f 91       	pop	r24
    1a1e:	7f 91       	pop	r23
    1a20:	6f 91       	pop	r22
    1a22:	5f 91       	pop	r21
    1a24:	4f 91       	pop	r20
    1a26:	3f 91       	pop	r19
    1a28:	2f 91       	pop	r18
    1a2a:	0f 90       	pop	r0
    1a2c:	0b be       	out	0x3b, r0	; 59
    1a2e:	0f 90       	pop	r0
    1a30:	0f be       	out	0x3f, r0	; 63
    1a32:	0f 90       	pop	r0
    1a34:	1f 90       	pop	r1
    1a36:	18 95       	reti

00001a38 <__vector_52>:
    1a38:	1f 92       	push	r1
    1a3a:	0f 92       	push	r0
    1a3c:	0f b6       	in	r0, 0x3f	; 63
    1a3e:	0f 92       	push	r0
    1a40:	11 24       	eor	r1, r1
    1a42:	0b b6       	in	r0, 0x3b	; 59
    1a44:	0f 92       	push	r0
    1a46:	2f 93       	push	r18
    1a48:	3f 93       	push	r19
    1a4a:	4f 93       	push	r20
    1a4c:	5f 93       	push	r21
    1a4e:	6f 93       	push	r22
    1a50:	7f 93       	push	r23
    1a52:	8f 93       	push	r24
    1a54:	9f 93       	push	r25
    1a56:	af 93       	push	r26
    1a58:	bf 93       	push	r27
    1a5a:	ef 93       	push	r30
    1a5c:	ff 93       	push	r31
    1a5e:	e0 91 cc 22 	lds	r30, 0x22CC	; 0x8022cc <tc_tce0_ccd_callback>
    1a62:	f0 91 cd 22 	lds	r31, 0x22CD	; 0x8022cd <tc_tce0_ccd_callback+0x1>
    1a66:	30 97       	sbiw	r30, 0x00	; 0
    1a68:	09 f0       	breq	.+2      	; 0x1a6c <__vector_52+0x34>
    1a6a:	19 95       	eicall
    1a6c:	ff 91       	pop	r31
    1a6e:	ef 91       	pop	r30
    1a70:	bf 91       	pop	r27
    1a72:	af 91       	pop	r26
    1a74:	9f 91       	pop	r25
    1a76:	8f 91       	pop	r24
    1a78:	7f 91       	pop	r23
    1a7a:	6f 91       	pop	r22
    1a7c:	5f 91       	pop	r21
    1a7e:	4f 91       	pop	r20
    1a80:	3f 91       	pop	r19
    1a82:	2f 91       	pop	r18
    1a84:	0f 90       	pop	r0
    1a86:	0b be       	out	0x3b, r0	; 59
    1a88:	0f 90       	pop	r0
    1a8a:	0f be       	out	0x3f, r0	; 63
    1a8c:	0f 90       	pop	r0
    1a8e:	1f 90       	pop	r1
    1a90:	18 95       	reti

00001a92 <__vector_53>:
    1a92:	1f 92       	push	r1
    1a94:	0f 92       	push	r0
    1a96:	0f b6       	in	r0, 0x3f	; 63
    1a98:	0f 92       	push	r0
    1a9a:	11 24       	eor	r1, r1
    1a9c:	0b b6       	in	r0, 0x3b	; 59
    1a9e:	0f 92       	push	r0
    1aa0:	2f 93       	push	r18
    1aa2:	3f 93       	push	r19
    1aa4:	4f 93       	push	r20
    1aa6:	5f 93       	push	r21
    1aa8:	6f 93       	push	r22
    1aaa:	7f 93       	push	r23
    1aac:	8f 93       	push	r24
    1aae:	9f 93       	push	r25
    1ab0:	af 93       	push	r26
    1ab2:	bf 93       	push	r27
    1ab4:	ef 93       	push	r30
    1ab6:	ff 93       	push	r31
    1ab8:	e0 91 ca 22 	lds	r30, 0x22CA	; 0x8022ca <tc_tce1_ovf_callback>
    1abc:	f0 91 cb 22 	lds	r31, 0x22CB	; 0x8022cb <tc_tce1_ovf_callback+0x1>
    1ac0:	30 97       	sbiw	r30, 0x00	; 0
    1ac2:	09 f0       	breq	.+2      	; 0x1ac6 <__vector_53+0x34>
    1ac4:	19 95       	eicall
    1ac6:	ff 91       	pop	r31
    1ac8:	ef 91       	pop	r30
    1aca:	bf 91       	pop	r27
    1acc:	af 91       	pop	r26
    1ace:	9f 91       	pop	r25
    1ad0:	8f 91       	pop	r24
    1ad2:	7f 91       	pop	r23
    1ad4:	6f 91       	pop	r22
    1ad6:	5f 91       	pop	r21
    1ad8:	4f 91       	pop	r20
    1ada:	3f 91       	pop	r19
    1adc:	2f 91       	pop	r18
    1ade:	0f 90       	pop	r0
    1ae0:	0b be       	out	0x3b, r0	; 59
    1ae2:	0f 90       	pop	r0
    1ae4:	0f be       	out	0x3f, r0	; 63
    1ae6:	0f 90       	pop	r0
    1ae8:	1f 90       	pop	r1
    1aea:	18 95       	reti

00001aec <__vector_54>:
    1aec:	1f 92       	push	r1
    1aee:	0f 92       	push	r0
    1af0:	0f b6       	in	r0, 0x3f	; 63
    1af2:	0f 92       	push	r0
    1af4:	11 24       	eor	r1, r1
    1af6:	0b b6       	in	r0, 0x3b	; 59
    1af8:	0f 92       	push	r0
    1afa:	2f 93       	push	r18
    1afc:	3f 93       	push	r19
    1afe:	4f 93       	push	r20
    1b00:	5f 93       	push	r21
    1b02:	6f 93       	push	r22
    1b04:	7f 93       	push	r23
    1b06:	8f 93       	push	r24
    1b08:	9f 93       	push	r25
    1b0a:	af 93       	push	r26
    1b0c:	bf 93       	push	r27
    1b0e:	ef 93       	push	r30
    1b10:	ff 93       	push	r31
    1b12:	e0 91 c8 22 	lds	r30, 0x22C8	; 0x8022c8 <tc_tce1_err_callback>
    1b16:	f0 91 c9 22 	lds	r31, 0x22C9	; 0x8022c9 <tc_tce1_err_callback+0x1>
    1b1a:	30 97       	sbiw	r30, 0x00	; 0
    1b1c:	09 f0       	breq	.+2      	; 0x1b20 <__vector_54+0x34>
    1b1e:	19 95       	eicall
    1b20:	ff 91       	pop	r31
    1b22:	ef 91       	pop	r30
    1b24:	bf 91       	pop	r27
    1b26:	af 91       	pop	r26
    1b28:	9f 91       	pop	r25
    1b2a:	8f 91       	pop	r24
    1b2c:	7f 91       	pop	r23
    1b2e:	6f 91       	pop	r22
    1b30:	5f 91       	pop	r21
    1b32:	4f 91       	pop	r20
    1b34:	3f 91       	pop	r19
    1b36:	2f 91       	pop	r18
    1b38:	0f 90       	pop	r0
    1b3a:	0b be       	out	0x3b, r0	; 59
    1b3c:	0f 90       	pop	r0
    1b3e:	0f be       	out	0x3f, r0	; 63
    1b40:	0f 90       	pop	r0
    1b42:	1f 90       	pop	r1
    1b44:	18 95       	reti

00001b46 <__vector_55>:
    1b46:	1f 92       	push	r1
    1b48:	0f 92       	push	r0
    1b4a:	0f b6       	in	r0, 0x3f	; 63
    1b4c:	0f 92       	push	r0
    1b4e:	11 24       	eor	r1, r1
    1b50:	0b b6       	in	r0, 0x3b	; 59
    1b52:	0f 92       	push	r0
    1b54:	2f 93       	push	r18
    1b56:	3f 93       	push	r19
    1b58:	4f 93       	push	r20
    1b5a:	5f 93       	push	r21
    1b5c:	6f 93       	push	r22
    1b5e:	7f 93       	push	r23
    1b60:	8f 93       	push	r24
    1b62:	9f 93       	push	r25
    1b64:	af 93       	push	r26
    1b66:	bf 93       	push	r27
    1b68:	ef 93       	push	r30
    1b6a:	ff 93       	push	r31
    1b6c:	e0 91 c6 22 	lds	r30, 0x22C6	; 0x8022c6 <tc_tce1_cca_callback>
    1b70:	f0 91 c7 22 	lds	r31, 0x22C7	; 0x8022c7 <tc_tce1_cca_callback+0x1>
    1b74:	30 97       	sbiw	r30, 0x00	; 0
    1b76:	09 f0       	breq	.+2      	; 0x1b7a <__vector_55+0x34>
    1b78:	19 95       	eicall
    1b7a:	ff 91       	pop	r31
    1b7c:	ef 91       	pop	r30
    1b7e:	bf 91       	pop	r27
    1b80:	af 91       	pop	r26
    1b82:	9f 91       	pop	r25
    1b84:	8f 91       	pop	r24
    1b86:	7f 91       	pop	r23
    1b88:	6f 91       	pop	r22
    1b8a:	5f 91       	pop	r21
    1b8c:	4f 91       	pop	r20
    1b8e:	3f 91       	pop	r19
    1b90:	2f 91       	pop	r18
    1b92:	0f 90       	pop	r0
    1b94:	0b be       	out	0x3b, r0	; 59
    1b96:	0f 90       	pop	r0
    1b98:	0f be       	out	0x3f, r0	; 63
    1b9a:	0f 90       	pop	r0
    1b9c:	1f 90       	pop	r1
    1b9e:	18 95       	reti

00001ba0 <__vector_56>:
    1ba0:	1f 92       	push	r1
    1ba2:	0f 92       	push	r0
    1ba4:	0f b6       	in	r0, 0x3f	; 63
    1ba6:	0f 92       	push	r0
    1ba8:	11 24       	eor	r1, r1
    1baa:	0b b6       	in	r0, 0x3b	; 59
    1bac:	0f 92       	push	r0
    1bae:	2f 93       	push	r18
    1bb0:	3f 93       	push	r19
    1bb2:	4f 93       	push	r20
    1bb4:	5f 93       	push	r21
    1bb6:	6f 93       	push	r22
    1bb8:	7f 93       	push	r23
    1bba:	8f 93       	push	r24
    1bbc:	9f 93       	push	r25
    1bbe:	af 93       	push	r26
    1bc0:	bf 93       	push	r27
    1bc2:	ef 93       	push	r30
    1bc4:	ff 93       	push	r31
    1bc6:	e0 91 c4 22 	lds	r30, 0x22C4	; 0x8022c4 <tc_tce1_ccb_callback>
    1bca:	f0 91 c5 22 	lds	r31, 0x22C5	; 0x8022c5 <tc_tce1_ccb_callback+0x1>
    1bce:	30 97       	sbiw	r30, 0x00	; 0
    1bd0:	09 f0       	breq	.+2      	; 0x1bd4 <__vector_56+0x34>
    1bd2:	19 95       	eicall
    1bd4:	ff 91       	pop	r31
    1bd6:	ef 91       	pop	r30
    1bd8:	bf 91       	pop	r27
    1bda:	af 91       	pop	r26
    1bdc:	9f 91       	pop	r25
    1bde:	8f 91       	pop	r24
    1be0:	7f 91       	pop	r23
    1be2:	6f 91       	pop	r22
    1be4:	5f 91       	pop	r21
    1be6:	4f 91       	pop	r20
    1be8:	3f 91       	pop	r19
    1bea:	2f 91       	pop	r18
    1bec:	0f 90       	pop	r0
    1bee:	0b be       	out	0x3b, r0	; 59
    1bf0:	0f 90       	pop	r0
    1bf2:	0f be       	out	0x3f, r0	; 63
    1bf4:	0f 90       	pop	r0
    1bf6:	1f 90       	pop	r1
    1bf8:	18 95       	reti

00001bfa <__vector_108>:
    1bfa:	1f 92       	push	r1
    1bfc:	0f 92       	push	r0
    1bfe:	0f b6       	in	r0, 0x3f	; 63
    1c00:	0f 92       	push	r0
    1c02:	11 24       	eor	r1, r1
    1c04:	0b b6       	in	r0, 0x3b	; 59
    1c06:	0f 92       	push	r0
    1c08:	2f 93       	push	r18
    1c0a:	3f 93       	push	r19
    1c0c:	4f 93       	push	r20
    1c0e:	5f 93       	push	r21
    1c10:	6f 93       	push	r22
    1c12:	7f 93       	push	r23
    1c14:	8f 93       	push	r24
    1c16:	9f 93       	push	r25
    1c18:	af 93       	push	r26
    1c1a:	bf 93       	push	r27
    1c1c:	ef 93       	push	r30
    1c1e:	ff 93       	push	r31
    1c20:	e0 91 c2 22 	lds	r30, 0x22C2	; 0x8022c2 <tc_tcf0_ovf_callback>
    1c24:	f0 91 c3 22 	lds	r31, 0x22C3	; 0x8022c3 <tc_tcf0_ovf_callback+0x1>
    1c28:	30 97       	sbiw	r30, 0x00	; 0
    1c2a:	09 f0       	breq	.+2      	; 0x1c2e <__vector_108+0x34>
    1c2c:	19 95       	eicall
    1c2e:	ff 91       	pop	r31
    1c30:	ef 91       	pop	r30
    1c32:	bf 91       	pop	r27
    1c34:	af 91       	pop	r26
    1c36:	9f 91       	pop	r25
    1c38:	8f 91       	pop	r24
    1c3a:	7f 91       	pop	r23
    1c3c:	6f 91       	pop	r22
    1c3e:	5f 91       	pop	r21
    1c40:	4f 91       	pop	r20
    1c42:	3f 91       	pop	r19
    1c44:	2f 91       	pop	r18
    1c46:	0f 90       	pop	r0
    1c48:	0b be       	out	0x3b, r0	; 59
    1c4a:	0f 90       	pop	r0
    1c4c:	0f be       	out	0x3f, r0	; 63
    1c4e:	0f 90       	pop	r0
    1c50:	1f 90       	pop	r1
    1c52:	18 95       	reti

00001c54 <__vector_109>:
    1c54:	1f 92       	push	r1
    1c56:	0f 92       	push	r0
    1c58:	0f b6       	in	r0, 0x3f	; 63
    1c5a:	0f 92       	push	r0
    1c5c:	11 24       	eor	r1, r1
    1c5e:	0b b6       	in	r0, 0x3b	; 59
    1c60:	0f 92       	push	r0
    1c62:	2f 93       	push	r18
    1c64:	3f 93       	push	r19
    1c66:	4f 93       	push	r20
    1c68:	5f 93       	push	r21
    1c6a:	6f 93       	push	r22
    1c6c:	7f 93       	push	r23
    1c6e:	8f 93       	push	r24
    1c70:	9f 93       	push	r25
    1c72:	af 93       	push	r26
    1c74:	bf 93       	push	r27
    1c76:	ef 93       	push	r30
    1c78:	ff 93       	push	r31
    1c7a:	e0 91 c0 22 	lds	r30, 0x22C0	; 0x8022c0 <tc_tcf0_err_callback>
    1c7e:	f0 91 c1 22 	lds	r31, 0x22C1	; 0x8022c1 <tc_tcf0_err_callback+0x1>
    1c82:	30 97       	sbiw	r30, 0x00	; 0
    1c84:	09 f0       	breq	.+2      	; 0x1c88 <__vector_109+0x34>
    1c86:	19 95       	eicall
    1c88:	ff 91       	pop	r31
    1c8a:	ef 91       	pop	r30
    1c8c:	bf 91       	pop	r27
    1c8e:	af 91       	pop	r26
    1c90:	9f 91       	pop	r25
    1c92:	8f 91       	pop	r24
    1c94:	7f 91       	pop	r23
    1c96:	6f 91       	pop	r22
    1c98:	5f 91       	pop	r21
    1c9a:	4f 91       	pop	r20
    1c9c:	3f 91       	pop	r19
    1c9e:	2f 91       	pop	r18
    1ca0:	0f 90       	pop	r0
    1ca2:	0b be       	out	0x3b, r0	; 59
    1ca4:	0f 90       	pop	r0
    1ca6:	0f be       	out	0x3f, r0	; 63
    1ca8:	0f 90       	pop	r0
    1caa:	1f 90       	pop	r1
    1cac:	18 95       	reti

00001cae <__vector_110>:
    1cae:	1f 92       	push	r1
    1cb0:	0f 92       	push	r0
    1cb2:	0f b6       	in	r0, 0x3f	; 63
    1cb4:	0f 92       	push	r0
    1cb6:	11 24       	eor	r1, r1
    1cb8:	0b b6       	in	r0, 0x3b	; 59
    1cba:	0f 92       	push	r0
    1cbc:	2f 93       	push	r18
    1cbe:	3f 93       	push	r19
    1cc0:	4f 93       	push	r20
    1cc2:	5f 93       	push	r21
    1cc4:	6f 93       	push	r22
    1cc6:	7f 93       	push	r23
    1cc8:	8f 93       	push	r24
    1cca:	9f 93       	push	r25
    1ccc:	af 93       	push	r26
    1cce:	bf 93       	push	r27
    1cd0:	ef 93       	push	r30
    1cd2:	ff 93       	push	r31
    1cd4:	e0 91 be 22 	lds	r30, 0x22BE	; 0x8022be <tc_tcf0_cca_callback>
    1cd8:	f0 91 bf 22 	lds	r31, 0x22BF	; 0x8022bf <tc_tcf0_cca_callback+0x1>
    1cdc:	30 97       	sbiw	r30, 0x00	; 0
    1cde:	09 f0       	breq	.+2      	; 0x1ce2 <__vector_110+0x34>
    1ce0:	19 95       	eicall
    1ce2:	ff 91       	pop	r31
    1ce4:	ef 91       	pop	r30
    1ce6:	bf 91       	pop	r27
    1ce8:	af 91       	pop	r26
    1cea:	9f 91       	pop	r25
    1cec:	8f 91       	pop	r24
    1cee:	7f 91       	pop	r23
    1cf0:	6f 91       	pop	r22
    1cf2:	5f 91       	pop	r21
    1cf4:	4f 91       	pop	r20
    1cf6:	3f 91       	pop	r19
    1cf8:	2f 91       	pop	r18
    1cfa:	0f 90       	pop	r0
    1cfc:	0b be       	out	0x3b, r0	; 59
    1cfe:	0f 90       	pop	r0
    1d00:	0f be       	out	0x3f, r0	; 63
    1d02:	0f 90       	pop	r0
    1d04:	1f 90       	pop	r1
    1d06:	18 95       	reti

00001d08 <__vector_111>:
    1d08:	1f 92       	push	r1
    1d0a:	0f 92       	push	r0
    1d0c:	0f b6       	in	r0, 0x3f	; 63
    1d0e:	0f 92       	push	r0
    1d10:	11 24       	eor	r1, r1
    1d12:	0b b6       	in	r0, 0x3b	; 59
    1d14:	0f 92       	push	r0
    1d16:	2f 93       	push	r18
    1d18:	3f 93       	push	r19
    1d1a:	4f 93       	push	r20
    1d1c:	5f 93       	push	r21
    1d1e:	6f 93       	push	r22
    1d20:	7f 93       	push	r23
    1d22:	8f 93       	push	r24
    1d24:	9f 93       	push	r25
    1d26:	af 93       	push	r26
    1d28:	bf 93       	push	r27
    1d2a:	ef 93       	push	r30
    1d2c:	ff 93       	push	r31
    1d2e:	e0 91 bc 22 	lds	r30, 0x22BC	; 0x8022bc <tc_tcf0_ccb_callback>
    1d32:	f0 91 bd 22 	lds	r31, 0x22BD	; 0x8022bd <tc_tcf0_ccb_callback+0x1>
    1d36:	30 97       	sbiw	r30, 0x00	; 0
    1d38:	09 f0       	breq	.+2      	; 0x1d3c <__vector_111+0x34>
    1d3a:	19 95       	eicall
    1d3c:	ff 91       	pop	r31
    1d3e:	ef 91       	pop	r30
    1d40:	bf 91       	pop	r27
    1d42:	af 91       	pop	r26
    1d44:	9f 91       	pop	r25
    1d46:	8f 91       	pop	r24
    1d48:	7f 91       	pop	r23
    1d4a:	6f 91       	pop	r22
    1d4c:	5f 91       	pop	r21
    1d4e:	4f 91       	pop	r20
    1d50:	3f 91       	pop	r19
    1d52:	2f 91       	pop	r18
    1d54:	0f 90       	pop	r0
    1d56:	0b be       	out	0x3b, r0	; 59
    1d58:	0f 90       	pop	r0
    1d5a:	0f be       	out	0x3f, r0	; 63
    1d5c:	0f 90       	pop	r0
    1d5e:	1f 90       	pop	r1
    1d60:	18 95       	reti

00001d62 <__vector_112>:
    1d62:	1f 92       	push	r1
    1d64:	0f 92       	push	r0
    1d66:	0f b6       	in	r0, 0x3f	; 63
    1d68:	0f 92       	push	r0
    1d6a:	11 24       	eor	r1, r1
    1d6c:	0b b6       	in	r0, 0x3b	; 59
    1d6e:	0f 92       	push	r0
    1d70:	2f 93       	push	r18
    1d72:	3f 93       	push	r19
    1d74:	4f 93       	push	r20
    1d76:	5f 93       	push	r21
    1d78:	6f 93       	push	r22
    1d7a:	7f 93       	push	r23
    1d7c:	8f 93       	push	r24
    1d7e:	9f 93       	push	r25
    1d80:	af 93       	push	r26
    1d82:	bf 93       	push	r27
    1d84:	ef 93       	push	r30
    1d86:	ff 93       	push	r31
    1d88:	e0 91 ba 22 	lds	r30, 0x22BA	; 0x8022ba <tc_tcf0_ccc_callback>
    1d8c:	f0 91 bb 22 	lds	r31, 0x22BB	; 0x8022bb <tc_tcf0_ccc_callback+0x1>
    1d90:	30 97       	sbiw	r30, 0x00	; 0
    1d92:	09 f0       	breq	.+2      	; 0x1d96 <__vector_112+0x34>
    1d94:	19 95       	eicall
    1d96:	ff 91       	pop	r31
    1d98:	ef 91       	pop	r30
    1d9a:	bf 91       	pop	r27
    1d9c:	af 91       	pop	r26
    1d9e:	9f 91       	pop	r25
    1da0:	8f 91       	pop	r24
    1da2:	7f 91       	pop	r23
    1da4:	6f 91       	pop	r22
    1da6:	5f 91       	pop	r21
    1da8:	4f 91       	pop	r20
    1daa:	3f 91       	pop	r19
    1dac:	2f 91       	pop	r18
    1dae:	0f 90       	pop	r0
    1db0:	0b be       	out	0x3b, r0	; 59
    1db2:	0f 90       	pop	r0
    1db4:	0f be       	out	0x3f, r0	; 63
    1db6:	0f 90       	pop	r0
    1db8:	1f 90       	pop	r1
    1dba:	18 95       	reti

00001dbc <__vector_113>:
    1dbc:	1f 92       	push	r1
    1dbe:	0f 92       	push	r0
    1dc0:	0f b6       	in	r0, 0x3f	; 63
    1dc2:	0f 92       	push	r0
    1dc4:	11 24       	eor	r1, r1
    1dc6:	0b b6       	in	r0, 0x3b	; 59
    1dc8:	0f 92       	push	r0
    1dca:	2f 93       	push	r18
    1dcc:	3f 93       	push	r19
    1dce:	4f 93       	push	r20
    1dd0:	5f 93       	push	r21
    1dd2:	6f 93       	push	r22
    1dd4:	7f 93       	push	r23
    1dd6:	8f 93       	push	r24
    1dd8:	9f 93       	push	r25
    1dda:	af 93       	push	r26
    1ddc:	bf 93       	push	r27
    1dde:	ef 93       	push	r30
    1de0:	ff 93       	push	r31
    1de2:	e0 91 b8 22 	lds	r30, 0x22B8	; 0x8022b8 <tc_tcf0_ccd_callback>
    1de6:	f0 91 b9 22 	lds	r31, 0x22B9	; 0x8022b9 <tc_tcf0_ccd_callback+0x1>
    1dea:	30 97       	sbiw	r30, 0x00	; 0
    1dec:	09 f0       	breq	.+2      	; 0x1df0 <__vector_113+0x34>
    1dee:	19 95       	eicall
    1df0:	ff 91       	pop	r31
    1df2:	ef 91       	pop	r30
    1df4:	bf 91       	pop	r27
    1df6:	af 91       	pop	r26
    1df8:	9f 91       	pop	r25
    1dfa:	8f 91       	pop	r24
    1dfc:	7f 91       	pop	r23
    1dfe:	6f 91       	pop	r22
    1e00:	5f 91       	pop	r21
    1e02:	4f 91       	pop	r20
    1e04:	3f 91       	pop	r19
    1e06:	2f 91       	pop	r18
    1e08:	0f 90       	pop	r0
    1e0a:	0b be       	out	0x3b, r0	; 59
    1e0c:	0f 90       	pop	r0
    1e0e:	0f be       	out	0x3f, r0	; 63
    1e10:	0f 90       	pop	r0
    1e12:	1f 90       	pop	r1
    1e14:	18 95       	reti

00001e16 <tc_enable>:
    1e16:	1f 93       	push	r17
    1e18:	cf 93       	push	r28
    1e1a:	df 93       	push	r29
    1e1c:	1f 92       	push	r1
    1e1e:	1f 92       	push	r1
    1e20:	cd b7       	in	r28, 0x3d	; 61
    1e22:	de b7       	in	r29, 0x3e	; 62
    1e24:	2f b7       	in	r18, 0x3f	; 63
    1e26:	2a 83       	std	Y+2, r18	; 0x02
    1e28:	f8 94       	cli
    1e2a:	1a 81       	ldd	r17, Y+2	; 0x02
    1e2c:	28 2f       	mov	r18, r24
    1e2e:	39 2f       	mov	r19, r25
    1e30:	21 15       	cp	r18, r1
    1e32:	88 e0       	ldi	r24, 0x08	; 8
    1e34:	38 07       	cpc	r19, r24
    1e36:	49 f4       	brne	.+18     	; 0x1e4a <tc_enable+0x34>
    1e38:	61 e0       	ldi	r22, 0x01	; 1
    1e3a:	83 e0       	ldi	r24, 0x03	; 3
    1e3c:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    1e40:	64 e0       	ldi	r22, 0x04	; 4
    1e42:	83 e0       	ldi	r24, 0x03	; 3
    1e44:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    1e48:	4f c0       	rjmp	.+158    	; 0x1ee8 <tc_enable+0xd2>
    1e4a:	20 34       	cpi	r18, 0x40	; 64
    1e4c:	88 e0       	ldi	r24, 0x08	; 8
    1e4e:	38 07       	cpc	r19, r24
    1e50:	49 f4       	brne	.+18     	; 0x1e64 <tc_enable+0x4e>
    1e52:	62 e0       	ldi	r22, 0x02	; 2
    1e54:	83 e0       	ldi	r24, 0x03	; 3
    1e56:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    1e5a:	64 e0       	ldi	r22, 0x04	; 4
    1e5c:	83 e0       	ldi	r24, 0x03	; 3
    1e5e:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    1e62:	42 c0       	rjmp	.+132    	; 0x1ee8 <tc_enable+0xd2>
    1e64:	21 15       	cp	r18, r1
    1e66:	89 e0       	ldi	r24, 0x09	; 9
    1e68:	38 07       	cpc	r19, r24
    1e6a:	49 f4       	brne	.+18     	; 0x1e7e <tc_enable+0x68>
    1e6c:	61 e0       	ldi	r22, 0x01	; 1
    1e6e:	84 e0       	ldi	r24, 0x04	; 4
    1e70:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    1e74:	64 e0       	ldi	r22, 0x04	; 4
    1e76:	84 e0       	ldi	r24, 0x04	; 4
    1e78:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    1e7c:	35 c0       	rjmp	.+106    	; 0x1ee8 <tc_enable+0xd2>
    1e7e:	20 34       	cpi	r18, 0x40	; 64
    1e80:	89 e0       	ldi	r24, 0x09	; 9
    1e82:	38 07       	cpc	r19, r24
    1e84:	49 f4       	brne	.+18     	; 0x1e98 <tc_enable+0x82>
    1e86:	62 e0       	ldi	r22, 0x02	; 2
    1e88:	84 e0       	ldi	r24, 0x04	; 4
    1e8a:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    1e8e:	64 e0       	ldi	r22, 0x04	; 4
    1e90:	84 e0       	ldi	r24, 0x04	; 4
    1e92:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    1e96:	28 c0       	rjmp	.+80     	; 0x1ee8 <tc_enable+0xd2>
    1e98:	21 15       	cp	r18, r1
    1e9a:	8a e0       	ldi	r24, 0x0A	; 10
    1e9c:	38 07       	cpc	r19, r24
    1e9e:	49 f4       	brne	.+18     	; 0x1eb2 <tc_enable+0x9c>
    1ea0:	61 e0       	ldi	r22, 0x01	; 1
    1ea2:	85 e0       	ldi	r24, 0x05	; 5
    1ea4:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    1ea8:	64 e0       	ldi	r22, 0x04	; 4
    1eaa:	85 e0       	ldi	r24, 0x05	; 5
    1eac:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    1eb0:	1b c0       	rjmp	.+54     	; 0x1ee8 <tc_enable+0xd2>
    1eb2:	20 34       	cpi	r18, 0x40	; 64
    1eb4:	8a e0       	ldi	r24, 0x0A	; 10
    1eb6:	38 07       	cpc	r19, r24
    1eb8:	49 f4       	brne	.+18     	; 0x1ecc <tc_enable+0xb6>
    1eba:	62 e0       	ldi	r22, 0x02	; 2
    1ebc:	85 e0       	ldi	r24, 0x05	; 5
    1ebe:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    1ec2:	64 e0       	ldi	r22, 0x04	; 4
    1ec4:	85 e0       	ldi	r24, 0x05	; 5
    1ec6:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    1eca:	0e c0       	rjmp	.+28     	; 0x1ee8 <tc_enable+0xd2>
    1ecc:	21 15       	cp	r18, r1
    1ece:	3b 40       	sbci	r19, 0x0B	; 11
    1ed0:	49 f4       	brne	.+18     	; 0x1ee4 <tc_enable+0xce>
    1ed2:	61 e0       	ldi	r22, 0x01	; 1
    1ed4:	86 e0       	ldi	r24, 0x06	; 6
    1ed6:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    1eda:	64 e0       	ldi	r22, 0x04	; 4
    1edc:	86 e0       	ldi	r24, 0x06	; 6
    1ede:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    1ee2:	02 c0       	rjmp	.+4      	; 0x1ee8 <tc_enable+0xd2>
    1ee4:	1f bf       	out	0x3f, r17	; 63
    1ee6:	10 c0       	rjmp	.+32     	; 0x1f08 <tc_enable+0xf2>
    1ee8:	80 91 82 24 	lds	r24, 0x2482	; 0x802482 <sleepmgr_locks+0x1>
    1eec:	8f 3f       	cpi	r24, 0xFF	; 255
    1eee:	09 f4       	brne	.+2      	; 0x1ef2 <tc_enable+0xdc>
    1ef0:	ff cf       	rjmp	.-2      	; 0x1ef0 <tc_enable+0xda>
    1ef2:	8f b7       	in	r24, 0x3f	; 63
    1ef4:	89 83       	std	Y+1, r24	; 0x01
    1ef6:	f8 94       	cli
    1ef8:	99 81       	ldd	r25, Y+1	; 0x01
    1efa:	e1 e8       	ldi	r30, 0x81	; 129
    1efc:	f4 e2       	ldi	r31, 0x24	; 36
    1efe:	81 81       	ldd	r24, Z+1	; 0x01
    1f00:	8f 5f       	subi	r24, 0xFF	; 255
    1f02:	81 83       	std	Z+1, r24	; 0x01
    1f04:	9f bf       	out	0x3f, r25	; 63
    1f06:	1f bf       	out	0x3f, r17	; 63
    1f08:	0f 90       	pop	r0
    1f0a:	0f 90       	pop	r0
    1f0c:	df 91       	pop	r29
    1f0e:	cf 91       	pop	r28
    1f10:	1f 91       	pop	r17
    1f12:	08 95       	ret

00001f14 <tc_set_overflow_interrupt_callback>:

void tc_set_overflow_interrupt_callback(volatile void *tc,
		tc_callback_t callback)
{
#ifdef TCC0
	if ((uintptr_t) tc == (uintptr_t) & TCC0) {
    1f14:	81 15       	cp	r24, r1
    1f16:	28 e0       	ldi	r18, 0x08	; 8
    1f18:	92 07       	cpc	r25, r18
    1f1a:	a1 f1       	breq	.+104    	; 0x1f84 <tc_set_overflow_interrupt_callback+0x70>
		tc_tcc0_ovf_callback = callback;
	} else
#endif
#ifdef TCC1
	if ((uintptr_t) tc == (uintptr_t) & TCC1) {
    1f1c:	80 34       	cpi	r24, 0x40	; 64
    1f1e:	28 e0       	ldi	r18, 0x08	; 8
    1f20:	92 07       	cpc	r25, r18
    1f22:	29 f4       	brne	.+10     	; 0x1f2e <tc_set_overflow_interrupt_callback+0x1a>
		tc_tcc1_ovf_callback = callback;
    1f24:	60 93 f2 22 	sts	0x22F2, r22	; 0x8022f2 <tc_tcc1_ovf_callback>
    1f28:	70 93 f3 22 	sts	0x22F3, r23	; 0x8022f3 <tc_tcc1_ovf_callback+0x1>
    1f2c:	08 95       	ret
	} else
#endif
#ifdef TCD0
	if ((uintptr_t) tc == (uintptr_t) & TCD0) {
    1f2e:	81 15       	cp	r24, r1
    1f30:	29 e0       	ldi	r18, 0x09	; 9
    1f32:	92 07       	cpc	r25, r18
    1f34:	29 f4       	brne	.+10     	; 0x1f40 <tc_set_overflow_interrupt_callback+0x2c>
		tc_tcd0_ovf_callback = callback;
    1f36:	60 93 ea 22 	sts	0x22EA, r22	; 0x8022ea <tc_tcd0_ovf_callback>
    1f3a:	70 93 eb 22 	sts	0x22EB, r23	; 0x8022eb <tc_tcd0_ovf_callback+0x1>
    1f3e:	08 95       	ret
	} else
#endif
#ifdef TCD1
	if ((uintptr_t) tc == (uintptr_t) & TCD1) {
    1f40:	80 34       	cpi	r24, 0x40	; 64
    1f42:	29 e0       	ldi	r18, 0x09	; 9
    1f44:	92 07       	cpc	r25, r18
    1f46:	29 f4       	brne	.+10     	; 0x1f52 <tc_set_overflow_interrupt_callback+0x3e>
		tc_tcd1_ovf_callback = callback;
    1f48:	60 93 de 22 	sts	0x22DE, r22	; 0x8022de <tc_tcd1_ovf_callback>
    1f4c:	70 93 df 22 	sts	0x22DF, r23	; 0x8022df <tc_tcd1_ovf_callback+0x1>
    1f50:	08 95       	ret
	} else
#endif
#ifdef TCE0
	if ((uintptr_t) tc == (uintptr_t) & TCE0) {
    1f52:	81 15       	cp	r24, r1
    1f54:	2a e0       	ldi	r18, 0x0A	; 10
    1f56:	92 07       	cpc	r25, r18
    1f58:	29 f4       	brne	.+10     	; 0x1f64 <tc_set_overflow_interrupt_callback+0x50>
		tc_tce0_ovf_callback = callback;
    1f5a:	60 93 d6 22 	sts	0x22D6, r22	; 0x8022d6 <tc_tce0_ovf_callback>
    1f5e:	70 93 d7 22 	sts	0x22D7, r23	; 0x8022d7 <tc_tce0_ovf_callback+0x1>
    1f62:	08 95       	ret
	} else
#endif
#ifdef TCE1
	if ((uintptr_t) tc == (uintptr_t) & TCE1) {
    1f64:	80 34       	cpi	r24, 0x40	; 64
    1f66:	2a e0       	ldi	r18, 0x0A	; 10
    1f68:	92 07       	cpc	r25, r18
    1f6a:	29 f4       	brne	.+10     	; 0x1f76 <tc_set_overflow_interrupt_callback+0x62>
		tc_tce1_ovf_callback = callback;
    1f6c:	60 93 ca 22 	sts	0x22CA, r22	; 0x8022ca <tc_tce1_ovf_callback>
    1f70:	70 93 cb 22 	sts	0x22CB, r23	; 0x8022cb <tc_tce1_ovf_callback+0x1>
    1f74:	08 95       	ret
	} else
#endif
#ifdef TCF0
	if ((uintptr_t) tc == (uintptr_t) & TCF0) {
    1f76:	81 15       	cp	r24, r1
    1f78:	9b 40       	sbci	r25, 0x0B	; 11
    1f7a:	21 f4       	brne	.+8      	; 0x1f84 <tc_set_overflow_interrupt_callback+0x70>
		tc_tcf0_ovf_callback = callback;
    1f7c:	60 93 c2 22 	sts	0x22C2, r22	; 0x8022c2 <tc_tcf0_ovf_callback>
    1f80:	70 93 c3 22 	sts	0x22C3, r23	; 0x8022c3 <tc_tcf0_ovf_callback+0x1>
    1f84:	08 95       	ret

00001f86 <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    1f86:	cf 92       	push	r12
    1f88:	df 92       	push	r13
    1f8a:	ef 92       	push	r14
    1f8c:	ff 92       	push	r15
    1f8e:	0f 93       	push	r16
    1f90:	1f 93       	push	r17
    1f92:	cf 93       	push	r28
    1f94:	df 93       	push	r29
    1f96:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    1f98:	d9 01       	movw	r26, r18
    1f9a:	c8 01       	movw	r24, r16
    1f9c:	b6 95       	lsr	r27
    1f9e:	a7 95       	ror	r26
    1fa0:	97 95       	ror	r25
    1fa2:	87 95       	ror	r24
    1fa4:	48 17       	cp	r20, r24
    1fa6:	59 07       	cpc	r21, r25
    1fa8:	6a 07       	cpc	r22, r26
    1faa:	7b 07       	cpc	r23, r27
    1fac:	78 f4       	brcc	.+30     	; 0x1fcc <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    1fae:	6a 01       	movw	r12, r20
    1fb0:	7b 01       	movw	r14, r22
    1fb2:	cc 0c       	add	r12, r12
    1fb4:	dd 1c       	adc	r13, r13
    1fb6:	ee 1c       	adc	r14, r14
    1fb8:	ff 1c       	adc	r15, r15
    1fba:	c9 01       	movw	r24, r18
    1fbc:	b8 01       	movw	r22, r16
    1fbe:	a7 01       	movw	r20, r14
    1fc0:	96 01       	movw	r18, r12
    1fc2:	0e 94 1a 23 	call	0x4634	; 0x4634 <__udivmodsi4>
    1fc6:	21 50       	subi	r18, 0x01	; 1
    1fc8:	31 09       	sbc	r19, r1
    1fca:	02 c0       	rjmp	.+4      	; 0x1fd0 <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    1fcc:	20 e0       	ldi	r18, 0x00	; 0
    1fce:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    1fd0:	83 2f       	mov	r24, r19
    1fd2:	8f 70       	andi	r24, 0x0F	; 15
    1fd4:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    1fd6:	2e 83       	std	Y+6, r18	; 0x06
}
    1fd8:	df 91       	pop	r29
    1fda:	cf 91       	pop	r28
    1fdc:	1f 91       	pop	r17
    1fde:	0f 91       	pop	r16
    1fe0:	ff 90       	pop	r15
    1fe2:	ef 90       	pop	r14
    1fe4:	df 90       	pop	r13
    1fe6:	cf 90       	pop	r12
    1fe8:	08 95       	ret

00001fea <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1fea:	df 92       	push	r13
    1fec:	ef 92       	push	r14
    1fee:	ff 92       	push	r15
    1ff0:	0f 93       	push	r16
    1ff2:	1f 93       	push	r17
    1ff4:	cf 93       	push	r28
    1ff6:	df 93       	push	r29
    1ff8:	1f 92       	push	r1
    1ffa:	cd b7       	in	r28, 0x3d	; 61
    1ffc:	de b7       	in	r29, 0x3e	; 62
    1ffe:	7c 01       	movw	r14, r24
    2000:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    2002:	00 97       	sbiw	r24, 0x00	; 0
    2004:	09 f4       	brne	.+2      	; 0x2008 <usart_init_spi+0x1e>
    2006:	cf c1       	rjmp	.+926    	; 0x23a6 <usart_init_spi+0x3bc>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    2008:	80 3c       	cpi	r24, 0xC0	; 192
    200a:	91 05       	cpc	r25, r1
    200c:	29 f4       	brne	.+10     	; 0x2018 <usart_init_spi+0x2e>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    200e:	60 e1       	ldi	r22, 0x10	; 16
    2010:	80 e0       	ldi	r24, 0x00	; 0
    2012:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    2016:	c7 c1       	rjmp	.+910    	; 0x23a6 <usart_init_spi+0x3bc>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    2018:	80 e8       	ldi	r24, 0x80	; 128
    201a:	e8 16       	cp	r14, r24
    201c:	81 e0       	ldi	r24, 0x01	; 1
    201e:	f8 06       	cpc	r15, r24
    2020:	29 f4       	brne	.+10     	; 0x202c <usart_init_spi+0x42>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    2022:	62 e0       	ldi	r22, 0x02	; 2
    2024:	80 e0       	ldi	r24, 0x00	; 0
    2026:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    202a:	bd c1       	rjmp	.+890    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    202c:	e1 14       	cp	r14, r1
    202e:	e1 e0       	ldi	r30, 0x01	; 1
    2030:	fe 06       	cpc	r15, r30
    2032:	29 f4       	brne	.+10     	; 0x203e <usart_init_spi+0x54>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    2034:	61 e0       	ldi	r22, 0x01	; 1
    2036:	80 e0       	ldi	r24, 0x00	; 0
    2038:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    203c:	b4 c1       	rjmp	.+872    	; 0x23a6 <usart_init_spi+0x3bc>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    203e:	f0 e8       	ldi	r31, 0x80	; 128
    2040:	ef 16       	cp	r14, r31
    2042:	f3 e0       	ldi	r31, 0x03	; 3
    2044:	ff 06       	cpc	r15, r31
    2046:	29 f4       	brne	.+10     	; 0x2052 <usart_init_spi+0x68>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    2048:	61 e0       	ldi	r22, 0x01	; 1
    204a:	81 e0       	ldi	r24, 0x01	; 1
    204c:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    2050:	aa c1       	rjmp	.+852    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    2052:	30 e9       	ldi	r19, 0x90	; 144
    2054:	e3 16       	cp	r14, r19
    2056:	33 e0       	ldi	r19, 0x03	; 3
    2058:	f3 06       	cpc	r15, r19
    205a:	29 f4       	brne	.+10     	; 0x2066 <usart_init_spi+0x7c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    205c:	61 e0       	ldi	r22, 0x01	; 1
    205e:	82 e0       	ldi	r24, 0x02	; 2
    2060:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    2064:	a0 c1       	rjmp	.+832    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    2066:	e1 14       	cp	r14, r1
    2068:	82 e0       	ldi	r24, 0x02	; 2
    206a:	f8 06       	cpc	r15, r24
    206c:	29 f4       	brne	.+10     	; 0x2078 <usart_init_spi+0x8e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    206e:	62 e0       	ldi	r22, 0x02	; 2
    2070:	81 e0       	ldi	r24, 0x01	; 1
    2072:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    2076:	97 c1       	rjmp	.+814    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    2078:	e0 e4       	ldi	r30, 0x40	; 64
    207a:	ee 16       	cp	r14, r30
    207c:	e2 e0       	ldi	r30, 0x02	; 2
    207e:	fe 06       	cpc	r15, r30
    2080:	29 f4       	brne	.+10     	; 0x208c <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    2082:	62 e0       	ldi	r22, 0x02	; 2
    2084:	82 e0       	ldi	r24, 0x02	; 2
    2086:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    208a:	8d c1       	rjmp	.+794    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    208c:	f0 e2       	ldi	r31, 0x20	; 32
    208e:	ef 16       	cp	r14, r31
    2090:	f3 e0       	ldi	r31, 0x03	; 3
    2092:	ff 06       	cpc	r15, r31
    2094:	29 f4       	brne	.+10     	; 0x20a0 <usart_init_spi+0xb6>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    2096:	64 e0       	ldi	r22, 0x04	; 4
    2098:	82 e0       	ldi	r24, 0x02	; 2
    209a:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    209e:	83 c1       	rjmp	.+774    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    20a0:	e1 14       	cp	r14, r1
    20a2:	38 e0       	ldi	r19, 0x08	; 8
    20a4:	f3 06       	cpc	r15, r19
    20a6:	29 f4       	brne	.+10     	; 0x20b2 <usart_init_spi+0xc8>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    20a8:	61 e0       	ldi	r22, 0x01	; 1
    20aa:	83 e0       	ldi	r24, 0x03	; 3
    20ac:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    20b0:	7a c1       	rjmp	.+756    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    20b2:	e1 14       	cp	r14, r1
    20b4:	89 e0       	ldi	r24, 0x09	; 9
    20b6:	f8 06       	cpc	r15, r24
    20b8:	29 f4       	brne	.+10     	; 0x20c4 <usart_init_spi+0xda>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    20ba:	61 e0       	ldi	r22, 0x01	; 1
    20bc:	84 e0       	ldi	r24, 0x04	; 4
    20be:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    20c2:	71 c1       	rjmp	.+738    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    20c4:	e1 14       	cp	r14, r1
    20c6:	ea e0       	ldi	r30, 0x0A	; 10
    20c8:	fe 06       	cpc	r15, r30
    20ca:	29 f4       	brne	.+10     	; 0x20d6 <usart_init_spi+0xec>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    20cc:	61 e0       	ldi	r22, 0x01	; 1
    20ce:	85 e0       	ldi	r24, 0x05	; 5
    20d0:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    20d4:	68 c1       	rjmp	.+720    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    20d6:	e1 14       	cp	r14, r1
    20d8:	fb e0       	ldi	r31, 0x0B	; 11
    20da:	ff 06       	cpc	r15, r31
    20dc:	29 f4       	brne	.+10     	; 0x20e8 <usart_init_spi+0xfe>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    20de:	61 e0       	ldi	r22, 0x01	; 1
    20e0:	86 e0       	ldi	r24, 0x06	; 6
    20e2:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    20e6:	5f c1       	rjmp	.+702    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    20e8:	30 e4       	ldi	r19, 0x40	; 64
    20ea:	e3 16       	cp	r14, r19
    20ec:	38 e0       	ldi	r19, 0x08	; 8
    20ee:	f3 06       	cpc	r15, r19
    20f0:	29 f4       	brne	.+10     	; 0x20fc <usart_init_spi+0x112>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    20f2:	62 e0       	ldi	r22, 0x02	; 2
    20f4:	83 e0       	ldi	r24, 0x03	; 3
    20f6:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    20fa:	55 c1       	rjmp	.+682    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    20fc:	80 e4       	ldi	r24, 0x40	; 64
    20fe:	e8 16       	cp	r14, r24
    2100:	89 e0       	ldi	r24, 0x09	; 9
    2102:	f8 06       	cpc	r15, r24
    2104:	29 f4       	brne	.+10     	; 0x2110 <usart_init_spi+0x126>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    2106:	62 e0       	ldi	r22, 0x02	; 2
    2108:	84 e0       	ldi	r24, 0x04	; 4
    210a:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    210e:	4b c1       	rjmp	.+662    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    2110:	e0 e4       	ldi	r30, 0x40	; 64
    2112:	ee 16       	cp	r14, r30
    2114:	ea e0       	ldi	r30, 0x0A	; 10
    2116:	fe 06       	cpc	r15, r30
    2118:	29 f4       	brne	.+10     	; 0x2124 <usart_init_spi+0x13a>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    211a:	62 e0       	ldi	r22, 0x02	; 2
    211c:	85 e0       	ldi	r24, 0x05	; 5
    211e:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    2122:	41 c1       	rjmp	.+642    	; 0x23a6 <usart_init_spi+0x3bc>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    2124:	f0 e9       	ldi	r31, 0x90	; 144
    2126:	ef 16       	cp	r14, r31
    2128:	f8 e0       	ldi	r31, 0x08	; 8
    212a:	ff 06       	cpc	r15, r31
    212c:	29 f4       	brne	.+10     	; 0x2138 <usart_init_spi+0x14e>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    212e:	64 e0       	ldi	r22, 0x04	; 4
    2130:	83 e0       	ldi	r24, 0x03	; 3
    2132:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    2136:	37 c1       	rjmp	.+622    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    2138:	30 e9       	ldi	r19, 0x90	; 144
    213a:	e3 16       	cp	r14, r19
    213c:	39 e0       	ldi	r19, 0x09	; 9
    213e:	f3 06       	cpc	r15, r19
    2140:	29 f4       	brne	.+10     	; 0x214c <usart_init_spi+0x162>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    2142:	64 e0       	ldi	r22, 0x04	; 4
    2144:	84 e0       	ldi	r24, 0x04	; 4
    2146:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    214a:	2d c1       	rjmp	.+602    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    214c:	80 e9       	ldi	r24, 0x90	; 144
    214e:	e8 16       	cp	r14, r24
    2150:	8a e0       	ldi	r24, 0x0A	; 10
    2152:	f8 06       	cpc	r15, r24
    2154:	29 f4       	brne	.+10     	; 0x2160 <usart_init_spi+0x176>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    2156:	64 e0       	ldi	r22, 0x04	; 4
    2158:	85 e0       	ldi	r24, 0x05	; 5
    215a:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    215e:	23 c1       	rjmp	.+582    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    2160:	e0 e9       	ldi	r30, 0x90	; 144
    2162:	ee 16       	cp	r14, r30
    2164:	eb e0       	ldi	r30, 0x0B	; 11
    2166:	fe 06       	cpc	r15, r30
    2168:	29 f4       	brne	.+10     	; 0x2174 <usart_init_spi+0x18a>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    216a:	64 e0       	ldi	r22, 0x04	; 4
    216c:	86 e0       	ldi	r24, 0x06	; 6
    216e:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    2172:	19 c1       	rjmp	.+562    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    2174:	f0 ec       	ldi	r31, 0xC0	; 192
    2176:	ef 16       	cp	r14, r31
    2178:	f8 e0       	ldi	r31, 0x08	; 8
    217a:	ff 06       	cpc	r15, r31
    217c:	29 f4       	brne	.+10     	; 0x2188 <usart_init_spi+0x19e>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    217e:	68 e0       	ldi	r22, 0x08	; 8
    2180:	83 e0       	ldi	r24, 0x03	; 3
    2182:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    2186:	0f c1       	rjmp	.+542    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    2188:	30 ec       	ldi	r19, 0xC0	; 192
    218a:	e3 16       	cp	r14, r19
    218c:	39 e0       	ldi	r19, 0x09	; 9
    218e:	f3 06       	cpc	r15, r19
    2190:	29 f4       	brne	.+10     	; 0x219c <usart_init_spi+0x1b2>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    2192:	68 e0       	ldi	r22, 0x08	; 8
    2194:	84 e0       	ldi	r24, 0x04	; 4
    2196:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    219a:	05 c1       	rjmp	.+522    	; 0x23a6 <usart_init_spi+0x3bc>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    219c:	80 ea       	ldi	r24, 0xA0	; 160
    219e:	e8 16       	cp	r14, r24
    21a0:	88 e0       	ldi	r24, 0x08	; 8
    21a2:	f8 06       	cpc	r15, r24
    21a4:	69 f4       	brne	.+26     	; 0x21c0 <usart_init_spi+0x1d6>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    21a6:	60 e1       	ldi	r22, 0x10	; 16
    21a8:	83 e0       	ldi	r24, 0x03	; 3
    21aa:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    21ae:	e0 ea       	ldi	r30, 0xA0	; 160
    21b0:	f8 e0       	ldi	r31, 0x08	; 8
    21b2:	84 81       	ldd	r24, Z+4	; 0x04
    21b4:	8f 7e       	andi	r24, 0xEF	; 239
    21b6:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    21b8:	f8 01       	movw	r30, r16
    21ba:	24 81       	ldd	r18, Z+4	; 0x04
    21bc:	22 50       	subi	r18, 0x02	; 2
    21be:	53 c0       	rjmp	.+166    	; 0x2266 <usart_init_spi+0x27c>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    21c0:	f0 ea       	ldi	r31, 0xA0	; 160
    21c2:	ef 16       	cp	r14, r31
    21c4:	f9 e0       	ldi	r31, 0x09	; 9
    21c6:	ff 06       	cpc	r15, r31
    21c8:	29 f4       	brne	.+10     	; 0x21d4 <usart_init_spi+0x1ea>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    21ca:	60 e1       	ldi	r22, 0x10	; 16
    21cc:	84 e0       	ldi	r24, 0x04	; 4
    21ce:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    21d2:	e9 c0       	rjmp	.+466    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    21d4:	30 ea       	ldi	r19, 0xA0	; 160
    21d6:	e3 16       	cp	r14, r19
    21d8:	3a e0       	ldi	r19, 0x0A	; 10
    21da:	f3 06       	cpc	r15, r19
    21dc:	29 f4       	brne	.+10     	; 0x21e8 <usart_init_spi+0x1fe>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    21de:	60 e1       	ldi	r22, 0x10	; 16
    21e0:	85 e0       	ldi	r24, 0x05	; 5
    21e2:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    21e6:	df c0       	rjmp	.+446    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    21e8:	80 ea       	ldi	r24, 0xA0	; 160
    21ea:	e8 16       	cp	r14, r24
    21ec:	8b e0       	ldi	r24, 0x0B	; 11
    21ee:	f8 06       	cpc	r15, r24
    21f0:	29 f4       	brne	.+10     	; 0x21fc <usart_init_spi+0x212>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    21f2:	60 e1       	ldi	r22, 0x10	; 16
    21f4:	86 e0       	ldi	r24, 0x06	; 6
    21f6:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    21fa:	d5 c0       	rjmp	.+426    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    21fc:	e0 eb       	ldi	r30, 0xB0	; 176
    21fe:	ee 16       	cp	r14, r30
    2200:	e8 e0       	ldi	r30, 0x08	; 8
    2202:	fe 06       	cpc	r15, r30
    2204:	29 f4       	brne	.+10     	; 0x2210 <usart_init_spi+0x226>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    2206:	60 e2       	ldi	r22, 0x20	; 32
    2208:	83 e0       	ldi	r24, 0x03	; 3
    220a:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    220e:	cb c0       	rjmp	.+406    	; 0x23a6 <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    2210:	f0 eb       	ldi	r31, 0xB0	; 176
    2212:	ef 16       	cp	r14, r31
    2214:	f9 e0       	ldi	r31, 0x09	; 9
    2216:	ff 06       	cpc	r15, r31
    2218:	29 f4       	brne	.+10     	; 0x2224 <usart_init_spi+0x23a>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    221a:	60 e2       	ldi	r22, 0x20	; 32
    221c:	84 e0       	ldi	r24, 0x04	; 4
    221e:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    2222:	c1 c0       	rjmp	.+386    	; 0x23a6 <usart_init_spi+0x3bc>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    2224:	30 e8       	ldi	r19, 0x80	; 128
    2226:	e3 16       	cp	r14, r19
    2228:	34 e0       	ldi	r19, 0x04	; 4
    222a:	f3 06       	cpc	r15, r19
    222c:	29 f4       	brne	.+10     	; 0x2238 <usart_init_spi+0x24e>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    222e:	60 e4       	ldi	r22, 0x40	; 64
    2230:	83 e0       	ldi	r24, 0x03	; 3
    2232:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    2236:	b7 c0       	rjmp	.+366    	; 0x23a6 <usart_init_spi+0x3bc>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    2238:	80 ea       	ldi	r24, 0xA0	; 160
    223a:	e8 16       	cp	r14, r24
    223c:	84 e0       	ldi	r24, 0x04	; 4
    223e:	f8 06       	cpc	r15, r24
    2240:	29 f4       	brne	.+10     	; 0x224c <usart_init_spi+0x262>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    2242:	60 e4       	ldi	r22, 0x40	; 64
    2244:	85 e0       	ldi	r24, 0x05	; 5
    2246:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <sysclk_enable_module>
    224a:	ad c0       	rjmp	.+346    	; 0x23a6 <usart_init_spi+0x3bc>
    224c:	f7 01       	movw	r30, r14
    224e:	84 81       	ldd	r24, Z+4	; 0x04
    2250:	8f 7e       	andi	r24, 0xEF	; 239
    2252:	84 83       	std	Z+4, r24	; 0x04
    2254:	fb 01       	movw	r30, r22
    2256:	24 81       	ldd	r18, Z+4	; 0x04
    2258:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    225a:	c7 01       	movw	r24, r14
    225c:	f0 ea       	ldi	r31, 0xA0	; 160
    225e:	ef 16       	cp	r14, r31
    2260:	f8 e0       	ldi	r31, 0x08	; 8
    2262:	ff 06       	cpc	r15, r31
    2264:	49 f4       	brne	.+18     	; 0x2278 <usart_init_spi+0x28e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    2266:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <__TEXT_REGION_LENGTH__+0x70064e>
    226a:	84 fd       	sbrc	r24, 4
    226c:	a5 c0       	rjmp	.+330    	; 0x23b8 <usart_init_spi+0x3ce>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    226e:	0f 2e       	mov	r0, r31
    2270:	f1 e1       	ldi	r31, 0x11	; 17
    2272:	df 2e       	mov	r13, r31
    2274:	f0 2d       	mov	r31, r0
    2276:	a4 c0       	rjmp	.+328    	; 0x23c0 <usart_init_spi+0x3d6>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    2278:	80 3b       	cpi	r24, 0xB0	; 176
    227a:	38 e0       	ldi	r19, 0x08	; 8
    227c:	93 07       	cpc	r25, r19
    227e:	91 f0       	breq	.+36     	; 0x22a4 <usart_init_spi+0x2ba>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    2280:	80 3a       	cpi	r24, 0xA0	; 160
    2282:	e9 e0       	ldi	r30, 0x09	; 9
    2284:	9e 07       	cpc	r25, r30
    2286:	49 f4       	brne	.+18     	; 0x229a <usart_init_spi+0x2b0>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    2288:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
    228c:	34 fd       	sbrc	r19, 4
    228e:	9b c0       	rjmp	.+310    	; 0x23c6 <usart_init_spi+0x3dc>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    2290:	0f 2e       	mov	r0, r31
    2292:	f9 e1       	ldi	r31, 0x19	; 25
    2294:	df 2e       	mov	r13, r31
    2296:	f0 2d       	mov	r31, r0
    2298:	16 c0       	rjmp	.+44     	; 0x22c6 <usart_init_spi+0x2dc>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    229a:	80 3b       	cpi	r24, 0xB0	; 176
    229c:	f9 e0       	ldi	r31, 0x09	; 9
    229e:	9f 07       	cpc	r25, r31
    22a0:	f1 f0       	breq	.+60     	; 0x22de <usart_init_spi+0x2f4>
    22a2:	04 c0       	rjmp	.+8      	; 0x22ac <usart_init_spi+0x2c2>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    22a4:	0f 2e       	mov	r0, r31
    22a6:	f5 e1       	ldi	r31, 0x15	; 21
    22a8:	df 2e       	mov	r13, r31
    22aa:	f0 2d       	mov	r31, r0
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    22ac:	80 3a       	cpi	r24, 0xA0	; 160
    22ae:	3a e0       	ldi	r19, 0x0A	; 10
    22b0:	93 07       	cpc	r25, r19
    22b2:	49 f4       	brne	.+18     	; 0x22c6 <usart_init_spi+0x2dc>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    22b4:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__TEXT_REGION_LENGTH__+0x70068e>
    22b8:	84 fd       	sbrc	r24, 4
    22ba:	8a c0       	rjmp	.+276    	; 0x23d0 <usart_init_spi+0x3e6>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    22bc:	0f 2e       	mov	r0, r31
    22be:	f1 e2       	ldi	r31, 0x21	; 33
    22c0:	df 2e       	mov	r13, r31
    22c2:	f0 2d       	mov	r31, r0
    22c4:	15 c0       	rjmp	.+42     	; 0x22f0 <usart_init_spi+0x306>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    22c6:	80 3a       	cpi	r24, 0xA0	; 160
    22c8:	9b 40       	sbci	r25, 0x0B	; 11
    22ca:	91 f4       	brne	.+36     	; 0x22f0 <usart_init_spi+0x306>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    22cc:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <__TEXT_REGION_LENGTH__+0x7006ae>
    22d0:	84 fd       	sbrc	r24, 4
    22d2:	0a c0       	rjmp	.+20     	; 0x22e8 <usart_init_spi+0x2fe>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    22d4:	0f 2e       	mov	r0, r31
    22d6:	f9 e2       	ldi	r31, 0x29	; 41
    22d8:	df 2e       	mov	r13, r31
    22da:	f0 2d       	mov	r31, r0
    22dc:	09 c0       	rjmp	.+18     	; 0x22f0 <usart_init_spi+0x306>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    22de:	0f 2e       	mov	r0, r31
    22e0:	fd e1       	ldi	r31, 0x1D	; 29
    22e2:	df 2e       	mov	r13, r31
    22e4:	f0 2d       	mov	r31, r0
    22e6:	04 c0       	rjmp	.+8      	; 0x22f0 <usart_init_spi+0x306>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    22e8:	0f 2e       	mov	r0, r31
    22ea:	fd e2       	ldi	r31, 0x2D	; 45
    22ec:	df 2e       	mov	r13, r31
    22ee:	f0 2d       	mov	r31, r0
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    22f0:	ed 2d       	mov	r30, r13
    22f2:	e6 95       	lsr	r30
    22f4:	e6 95       	lsr	r30
    22f6:	e6 95       	lsr	r30
    22f8:	30 e2       	ldi	r19, 0x20	; 32
    22fa:	e3 9f       	mul	r30, r19
    22fc:	f0 01       	movw	r30, r0
    22fe:	11 24       	eor	r1, r1
    2300:	fa 5f       	subi	r31, 0xFA	; 250
    2302:	3d 2d       	mov	r19, r13
    2304:	37 70       	andi	r19, 0x07	; 7
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    2306:	81 e0       	ldi	r24, 0x01	; 1
    2308:	90 e0       	ldi	r25, 0x00	; 0
    230a:	03 2e       	mov	r0, r19
    230c:	02 c0       	rjmp	.+4      	; 0x2312 <usart_init_spi+0x328>
    230e:	88 0f       	add	r24, r24
    2310:	99 1f       	adc	r25, r25
    2312:	0a 94       	dec	r0
    2314:	e2 f7       	brpl	.-8      	; 0x230e <usart_init_spi+0x324>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    2316:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    2318:	22 30       	cpi	r18, 0x02	; 2
    231a:	10 f0       	brcs	.+4      	; 0x2320 <usart_init_spi+0x336>
    231c:	40 e0       	ldi	r20, 0x00	; 0
    231e:	01 c0       	rjmp	.+2      	; 0x2322 <usart_init_spi+0x338>
    2320:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    2322:	df 01       	movw	r26, r30
    2324:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    2326:	a3 0f       	add	r26, r19
    2328:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    232a:	9f b7       	in	r25, 0x3f	; 63
    232c:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
    232e:	f8 94       	cli
	return flags;
    2330:	39 81       	ldd	r19, Y+1	; 0x01
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    2332:	2c 91       	ld	r18, X
    2334:	27 70       	andi	r18, 0x07	; 7
    2336:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    2338:	9c 91       	ld	r25, X
    233a:	94 2b       	or	r25, r20
    233c:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    233e:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    2340:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    2342:	f7 01       	movw	r30, r14
    2344:	85 81       	ldd	r24, Z+5	; 0x05
    2346:	80 6c       	ori	r24, 0xC0	; 192
    2348:	85 83       	std	Z+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    234a:	f8 01       	movw	r30, r16
    234c:	84 81       	ldd	r24, Z+4	; 0x04
    234e:	8d 7f       	andi	r24, 0xFD	; 253
    2350:	81 30       	cpi	r24, 0x01	; 1
    2352:	29 f4       	brne	.+10     	; 0x235e <usart_init_spi+0x374>
		usart->CTRLC |= USART_UCPHA_bm;
    2354:	f7 01       	movw	r30, r14
    2356:	85 81       	ldd	r24, Z+5	; 0x05
    2358:	82 60       	ori	r24, 0x02	; 2
    235a:	85 83       	std	Z+5, r24	; 0x05
    235c:	04 c0       	rjmp	.+8      	; 0x2366 <usart_init_spi+0x37c>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    235e:	f7 01       	movw	r30, r14
    2360:	85 81       	ldd	r24, Z+5	; 0x05
    2362:	8d 7f       	andi	r24, 0xFD	; 253
    2364:	85 83       	std	Z+5, r24	; 0x05
	}
	if (opt->data_order) {
    2366:	f8 01       	movw	r30, r16
    2368:	85 81       	ldd	r24, Z+5	; 0x05
    236a:	88 23       	and	r24, r24
    236c:	29 f0       	breq	.+10     	; 0x2378 <usart_init_spi+0x38e>
		(usart)->CTRLC |= USART_DORD_bm;
    236e:	f7 01       	movw	r30, r14
    2370:	85 81       	ldd	r24, Z+5	; 0x05
    2372:	84 60       	ori	r24, 0x04	; 4
    2374:	85 83       	std	Z+5, r24	; 0x05
    2376:	04 c0       	rjmp	.+8      	; 0x2380 <usart_init_spi+0x396>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    2378:	f7 01       	movw	r30, r14
    237a:	85 81       	ldd	r24, Z+5	; 0x05
    237c:	8b 7f       	andi	r24, 0xFB	; 251
    237e:	85 83       	std	Z+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    2380:	f8 01       	movw	r30, r16
    2382:	40 81       	ld	r20, Z
    2384:	51 81       	ldd	r21, Z+1	; 0x01
    2386:	62 81       	ldd	r22, Z+2	; 0x02
    2388:	73 81       	ldd	r23, Z+3	; 0x03
    238a:	00 e8       	ldi	r16, 0x80	; 128
    238c:	14 e8       	ldi	r17, 0x84	; 132
    238e:	2e e1       	ldi	r18, 0x1E	; 30
    2390:	30 e0       	ldi	r19, 0x00	; 0
    2392:	c7 01       	movw	r24, r14
    2394:	f8 dd       	rcall	.-1040   	; 0x1f86 <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    2396:	f7 01       	movw	r30, r14
    2398:	84 81       	ldd	r24, Z+4	; 0x04
    239a:	88 60       	ori	r24, 0x08	; 8
    239c:	84 83       	std	Z+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    239e:	84 81       	ldd	r24, Z+4	; 0x04
    23a0:	80 61       	ori	r24, 0x10	; 16
    23a2:	84 83       	std	Z+4, r24	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    23a4:	1a c0       	rjmp	.+52     	; 0x23da <usart_init_spi+0x3f0>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    23a6:	f7 01       	movw	r30, r14
    23a8:	84 81       	ldd	r24, Z+4	; 0x04
    23aa:	8f 7e       	andi	r24, 0xEF	; 239
    23ac:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    23ae:	f8 01       	movw	r30, r16
    23b0:	24 81       	ldd	r18, Z+4	; 0x04
    23b2:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    23b4:	c7 01       	movw	r24, r14
    23b6:	60 cf       	rjmp	.-320    	; 0x2278 <usart_init_spi+0x28e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    23b8:	0f 2e       	mov	r0, r31
    23ba:	f5 e1       	ldi	r31, 0x15	; 21
    23bc:	df 2e       	mov	r13, r31
    23be:	f0 2d       	mov	r31, r0
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    23c0:	80 ea       	ldi	r24, 0xA0	; 160
    23c2:	98 e0       	ldi	r25, 0x08	; 8
    23c4:	6a cf       	rjmp	.-300    	; 0x229a <usart_init_spi+0x2b0>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    23c6:	0f 2e       	mov	r0, r31
    23c8:	fd e1       	ldi	r31, 0x1D	; 29
    23ca:	df 2e       	mov	r13, r31
    23cc:	f0 2d       	mov	r31, r0
    23ce:	7b cf       	rjmp	.-266    	; 0x22c6 <usart_init_spi+0x2dc>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    23d0:	0f 2e       	mov	r0, r31
    23d2:	f5 e2       	ldi	r31, 0x25	; 37
    23d4:	df 2e       	mov	r13, r31
    23d6:	f0 2d       	mov	r31, r0
    23d8:	8b cf       	rjmp	.-234    	; 0x22f0 <usart_init_spi+0x306>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    23da:	0f 90       	pop	r0
    23dc:	df 91       	pop	r29
    23de:	cf 91       	pop	r28
    23e0:	1f 91       	pop	r17
    23e2:	0f 91       	pop	r16
    23e4:	ff 90       	pop	r15
    23e6:	ef 90       	pop	r14
    23e8:	df 90       	pop	r13
    23ea:	08 95       	ret

000023ec <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    23ec:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    23ee:	03 96       	adiw	r24, 0x03	; 3
    23f0:	81 83       	std	Z+1, r24	; 0x01
    23f2:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    23f4:	2f ef       	ldi	r18, 0xFF	; 255
    23f6:	3f ef       	ldi	r19, 0xFF	; 255
    23f8:	23 83       	std	Z+3, r18	; 0x03
    23fa:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    23fc:	85 83       	std	Z+5, r24	; 0x05
    23fe:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2400:	87 83       	std	Z+7, r24	; 0x07
    2402:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2404:	10 82       	st	Z, r1
    2406:	08 95       	ret

00002408 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    2408:	fc 01       	movw	r30, r24
    240a:	10 86       	std	Z+8, r1	; 0x08
    240c:	11 86       	std	Z+9, r1	; 0x09
    240e:	08 95       	ret

00002410 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2410:	cf 93       	push	r28
    2412:	df 93       	push	r29
    2414:	9c 01       	movw	r18, r24
    2416:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2418:	dc 01       	movw	r26, r24
    241a:	11 96       	adiw	r26, 0x01	; 1
    241c:	cd 91       	ld	r28, X+
    241e:	dc 91       	ld	r29, X
    2420:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    2422:	c2 83       	std	Z+2, r28	; 0x02
    2424:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2426:	8c 81       	ldd	r24, Y+4	; 0x04
    2428:	9d 81       	ldd	r25, Y+5	; 0x05
    242a:	84 83       	std	Z+4, r24	; 0x04
    242c:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    242e:	8c 81       	ldd	r24, Y+4	; 0x04
    2430:	9d 81       	ldd	r25, Y+5	; 0x05
    2432:	dc 01       	movw	r26, r24
    2434:	12 96       	adiw	r26, 0x02	; 2
    2436:	6d 93       	st	X+, r22
    2438:	7c 93       	st	X, r23
    243a:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    243c:	6c 83       	std	Y+4, r22	; 0x04
    243e:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    2440:	20 87       	std	Z+8, r18	; 0x08
    2442:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    2444:	f9 01       	movw	r30, r18
    2446:	80 81       	ld	r24, Z
    2448:	8f 5f       	subi	r24, 0xFF	; 255
    244a:	80 83       	st	Z, r24
}
    244c:	df 91       	pop	r29
    244e:	cf 91       	pop	r28
    2450:	08 95       	ret

00002452 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2452:	cf 93       	push	r28
    2454:	df 93       	push	r29
    2456:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2458:	48 81       	ld	r20, Y
    245a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    245c:	4f 3f       	cpi	r20, 0xFF	; 255
    245e:	2f ef       	ldi	r18, 0xFF	; 255
    2460:	52 07       	cpc	r21, r18
    2462:	21 f4       	brne	.+8      	; 0x246c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2464:	fc 01       	movw	r30, r24
    2466:	a7 81       	ldd	r26, Z+7	; 0x07
    2468:	b0 85       	ldd	r27, Z+8	; 0x08
    246a:	0d c0       	rjmp	.+26     	; 0x2486 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    246c:	dc 01       	movw	r26, r24
    246e:	13 96       	adiw	r26, 0x03	; 3
    2470:	01 c0       	rjmp	.+2      	; 0x2474 <vListInsert+0x22>
    2472:	df 01       	movw	r26, r30
    2474:	12 96       	adiw	r26, 0x02	; 2
    2476:	ed 91       	ld	r30, X+
    2478:	fc 91       	ld	r31, X
    247a:	13 97       	sbiw	r26, 0x03	; 3
    247c:	20 81       	ld	r18, Z
    247e:	31 81       	ldd	r19, Z+1	; 0x01
    2480:	42 17       	cp	r20, r18
    2482:	53 07       	cpc	r21, r19
    2484:	b0 f7       	brcc	.-20     	; 0x2472 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2486:	12 96       	adiw	r26, 0x02	; 2
    2488:	ed 91       	ld	r30, X+
    248a:	fc 91       	ld	r31, X
    248c:	13 97       	sbiw	r26, 0x03	; 3
    248e:	ea 83       	std	Y+2, r30	; 0x02
    2490:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2492:	c4 83       	std	Z+4, r28	; 0x04
    2494:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    2496:	ac 83       	std	Y+4, r26	; 0x04
    2498:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    249a:	12 96       	adiw	r26, 0x02	; 2
    249c:	cd 93       	st	X+, r28
    249e:	dc 93       	st	X, r29
    24a0:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    24a2:	88 87       	std	Y+8, r24	; 0x08
    24a4:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    24a6:	fc 01       	movw	r30, r24
    24a8:	20 81       	ld	r18, Z
    24aa:	2f 5f       	subi	r18, 0xFF	; 255
    24ac:	20 83       	st	Z, r18
}
    24ae:	df 91       	pop	r29
    24b0:	cf 91       	pop	r28
    24b2:	08 95       	ret

000024b4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    24b4:	cf 93       	push	r28
    24b6:	df 93       	push	r29
    24b8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    24ba:	a0 85       	ldd	r26, Z+8	; 0x08
    24bc:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    24be:	c2 81       	ldd	r28, Z+2	; 0x02
    24c0:	d3 81       	ldd	r29, Z+3	; 0x03
    24c2:	84 81       	ldd	r24, Z+4	; 0x04
    24c4:	95 81       	ldd	r25, Z+5	; 0x05
    24c6:	8c 83       	std	Y+4, r24	; 0x04
    24c8:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    24ca:	c4 81       	ldd	r28, Z+4	; 0x04
    24cc:	d5 81       	ldd	r29, Z+5	; 0x05
    24ce:	82 81       	ldd	r24, Z+2	; 0x02
    24d0:	93 81       	ldd	r25, Z+3	; 0x03
    24d2:	8a 83       	std	Y+2, r24	; 0x02
    24d4:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    24d6:	11 96       	adiw	r26, 0x01	; 1
    24d8:	8d 91       	ld	r24, X+
    24da:	9c 91       	ld	r25, X
    24dc:	12 97       	sbiw	r26, 0x02	; 2
    24de:	e8 17       	cp	r30, r24
    24e0:	f9 07       	cpc	r31, r25
    24e2:	31 f4       	brne	.+12     	; 0x24f0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    24e4:	84 81       	ldd	r24, Z+4	; 0x04
    24e6:	95 81       	ldd	r25, Z+5	; 0x05
    24e8:	11 96       	adiw	r26, 0x01	; 1
    24ea:	8d 93       	st	X+, r24
    24ec:	9c 93       	st	X, r25
    24ee:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    24f0:	10 86       	std	Z+8, r1	; 0x08
    24f2:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    24f4:	8c 91       	ld	r24, X
    24f6:	81 50       	subi	r24, 0x01	; 1
    24f8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    24fa:	8c 91       	ld	r24, X
}
    24fc:	df 91       	pop	r29
    24fe:	cf 91       	pop	r28
    2500:	08 95       	ret

00002502 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2502:	0f 93       	push	r16
    2504:	1f 93       	push	r17
    2506:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    2508:	71 e1       	ldi	r23, 0x11	; 17
    250a:	fc 01       	movw	r30, r24
    250c:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    250e:	31 97       	sbiw	r30, 0x01	; 1
    2510:	62 e2       	ldi	r22, 0x22	; 34
    2512:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    2514:	31 97       	sbiw	r30, 0x01	; 1
    2516:	23 e3       	ldi	r18, 0x33	; 51
    2518:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    251a:	01 2e       	mov	r0, r17
    251c:	00 0c       	add	r0, r0
    251e:	22 0b       	sbc	r18, r18
    2520:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    2522:	31 97       	sbiw	r30, 0x01	; 1
    2524:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    2526:	31 97       	sbiw	r30, 0x01	; 1
    2528:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    252a:	31 97       	sbiw	r30, 0x01	; 1
    252c:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    252e:	31 97       	sbiw	r30, 0x01	; 1
    2530:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    2532:	31 97       	sbiw	r30, 0x01	; 1
    2534:	20 e8       	ldi	r18, 0x80	; 128
    2536:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    2538:	31 97       	sbiw	r30, 0x01	; 1
    253a:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    253c:	31 97       	sbiw	r30, 0x01	; 1
    253e:	22 e0       	ldi	r18, 0x02	; 2
    2540:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    2542:	31 97       	sbiw	r30, 0x01	; 1
    2544:	23 e0       	ldi	r18, 0x03	; 3
    2546:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    2548:	31 97       	sbiw	r30, 0x01	; 1
    254a:	24 e0       	ldi	r18, 0x04	; 4
    254c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    254e:	31 97       	sbiw	r30, 0x01	; 1
    2550:	25 e0       	ldi	r18, 0x05	; 5
    2552:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    2554:	31 97       	sbiw	r30, 0x01	; 1
    2556:	26 e0       	ldi	r18, 0x06	; 6
    2558:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    255a:	31 97       	sbiw	r30, 0x01	; 1
    255c:	27 e0       	ldi	r18, 0x07	; 7
    255e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    2560:	31 97       	sbiw	r30, 0x01	; 1
    2562:	28 e0       	ldi	r18, 0x08	; 8
    2564:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    2566:	31 97       	sbiw	r30, 0x01	; 1
    2568:	29 e0       	ldi	r18, 0x09	; 9
    256a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    256c:	31 97       	sbiw	r30, 0x01	; 1
    256e:	20 e1       	ldi	r18, 0x10	; 16
    2570:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    2572:	31 97       	sbiw	r30, 0x01	; 1
    2574:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    2576:	31 97       	sbiw	r30, 0x01	; 1
    2578:	22 e1       	ldi	r18, 0x12	; 18
    257a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    257c:	31 97       	sbiw	r30, 0x01	; 1
    257e:	23 e1       	ldi	r18, 0x13	; 19
    2580:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    2582:	31 97       	sbiw	r30, 0x01	; 1
    2584:	24 e1       	ldi	r18, 0x14	; 20
    2586:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    2588:	31 97       	sbiw	r30, 0x01	; 1
    258a:	25 e1       	ldi	r18, 0x15	; 21
    258c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    258e:	31 97       	sbiw	r30, 0x01	; 1
    2590:	26 e1       	ldi	r18, 0x16	; 22
    2592:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    2594:	31 97       	sbiw	r30, 0x01	; 1
    2596:	27 e1       	ldi	r18, 0x17	; 23
    2598:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    259a:	31 97       	sbiw	r30, 0x01	; 1
    259c:	28 e1       	ldi	r18, 0x18	; 24
    259e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    25a0:	31 97       	sbiw	r30, 0x01	; 1
    25a2:	29 e1       	ldi	r18, 0x19	; 25
    25a4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    25a6:	31 97       	sbiw	r30, 0x01	; 1
    25a8:	20 e2       	ldi	r18, 0x20	; 32
    25aa:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    25ac:	31 97       	sbiw	r30, 0x01	; 1
    25ae:	21 e2       	ldi	r18, 0x21	; 33
    25b0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    25b2:	31 97       	sbiw	r30, 0x01	; 1
    25b4:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    25b6:	31 97       	sbiw	r30, 0x01	; 1
    25b8:	23 e2       	ldi	r18, 0x23	; 35
    25ba:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    25bc:	31 97       	sbiw	r30, 0x01	; 1
    25be:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    25c0:	31 97       	sbiw	r30, 0x01	; 1
    25c2:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    25c4:	31 97       	sbiw	r30, 0x01	; 1
    25c6:	26 e2       	ldi	r18, 0x26	; 38
    25c8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    25ca:	31 97       	sbiw	r30, 0x01	; 1
    25cc:	27 e2       	ldi	r18, 0x27	; 39
    25ce:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    25d0:	31 97       	sbiw	r30, 0x01	; 1
    25d2:	28 e2       	ldi	r18, 0x28	; 40
    25d4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    25d6:	31 97       	sbiw	r30, 0x01	; 1
    25d8:	29 e2       	ldi	r18, 0x29	; 41
    25da:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    25dc:	31 97       	sbiw	r30, 0x01	; 1
    25de:	20 e3       	ldi	r18, 0x30	; 48
    25e0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    25e2:	31 97       	sbiw	r30, 0x01	; 1
    25e4:	21 e3       	ldi	r18, 0x31	; 49
    25e6:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    25e8:	87 97       	sbiw	r24, 0x27	; 39
    25ea:	1f 91       	pop	r17
    25ec:	0f 91       	pop	r16
    25ee:	08 95       	ret

000025f0 <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    25f0:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    25f2:	e0 e7       	ldi	r30, 0x70	; 112
    25f4:	f0 e0       	ldi	r31, 0x00	; 0
    25f6:	83 81       	ldd	r24, Z+3	; 0x03
    25f8:	8a 7f       	andi	r24, 0xFA	; 250
    25fa:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    25fc:	e0 e0       	ldi	r30, 0x00	; 0
    25fe:	f8 e0       	ldi	r31, 0x08	; 8
    2600:	80 e0       	ldi	r24, 0x00	; 0
    2602:	9a ef       	ldi	r25, 0xFA	; 250
    2604:	86 a3       	std	Z+38, r24	; 0x26
    2606:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    2608:	91 e0       	ldi	r25, 0x01	; 1
    260a:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    260c:	a0 ea       	ldi	r26, 0xA0	; 160
    260e:	b0 e0       	ldi	r27, 0x00	; 0
    2610:	12 96       	adiw	r26, 0x02	; 2
    2612:	8c 91       	ld	r24, X
    2614:	12 97       	sbiw	r26, 0x02	; 2
    2616:	81 60       	ori	r24, 0x01	; 1
    2618:	12 96       	adiw	r26, 0x02	; 2
    261a:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    261c:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    261e:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    2620:	a0 91 59 23 	lds	r26, 0x2359	; 0x802359 <pxCurrentTCB>
    2624:	b0 91 5a 23 	lds	r27, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    2628:	0d 90       	ld	r0, X+
    262a:	0d be       	out	0x3d, r0	; 61
    262c:	0d 90       	ld	r0, X+
    262e:	0e be       	out	0x3e, r0	; 62
    2630:	ff 91       	pop	r31
    2632:	ef 91       	pop	r30
    2634:	df 91       	pop	r29
    2636:	cf 91       	pop	r28
    2638:	bf 91       	pop	r27
    263a:	af 91       	pop	r26
    263c:	9f 91       	pop	r25
    263e:	8f 91       	pop	r24
    2640:	7f 91       	pop	r23
    2642:	6f 91       	pop	r22
    2644:	5f 91       	pop	r21
    2646:	4f 91       	pop	r20
    2648:	3f 91       	pop	r19
    264a:	2f 91       	pop	r18
    264c:	1f 91       	pop	r17
    264e:	0f 91       	pop	r16
    2650:	ff 90       	pop	r15
    2652:	ef 90       	pop	r14
    2654:	df 90       	pop	r13
    2656:	cf 90       	pop	r12
    2658:	bf 90       	pop	r11
    265a:	af 90       	pop	r10
    265c:	9f 90       	pop	r9
    265e:	8f 90       	pop	r8
    2660:	7f 90       	pop	r7
    2662:	6f 90       	pop	r6
    2664:	5f 90       	pop	r5
    2666:	4f 90       	pop	r4
    2668:	3f 90       	pop	r3
    266a:	2f 90       	pop	r2
    266c:	1f 90       	pop	r1
    266e:	0f 90       	pop	r0
    2670:	0f be       	out	0x3f, r0	; 63
    2672:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    2674:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    2676:	81 e0       	ldi	r24, 0x01	; 1
    2678:	08 95       	ret

0000267a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    267a:	0f 92       	push	r0
    267c:	0f b6       	in	r0, 0x3f	; 63
    267e:	f8 94       	cli
    2680:	0f 92       	push	r0
    2682:	1f 92       	push	r1
    2684:	11 24       	eor	r1, r1
    2686:	2f 92       	push	r2
    2688:	3f 92       	push	r3
    268a:	4f 92       	push	r4
    268c:	5f 92       	push	r5
    268e:	6f 92       	push	r6
    2690:	7f 92       	push	r7
    2692:	8f 92       	push	r8
    2694:	9f 92       	push	r9
    2696:	af 92       	push	r10
    2698:	bf 92       	push	r11
    269a:	cf 92       	push	r12
    269c:	df 92       	push	r13
    269e:	ef 92       	push	r14
    26a0:	ff 92       	push	r15
    26a2:	0f 93       	push	r16
    26a4:	1f 93       	push	r17
    26a6:	2f 93       	push	r18
    26a8:	3f 93       	push	r19
    26aa:	4f 93       	push	r20
    26ac:	5f 93       	push	r21
    26ae:	6f 93       	push	r22
    26b0:	7f 93       	push	r23
    26b2:	8f 93       	push	r24
    26b4:	9f 93       	push	r25
    26b6:	af 93       	push	r26
    26b8:	bf 93       	push	r27
    26ba:	cf 93       	push	r28
    26bc:	df 93       	push	r29
    26be:	ef 93       	push	r30
    26c0:	ff 93       	push	r31
    26c2:	a0 91 59 23 	lds	r26, 0x2359	; 0x802359 <pxCurrentTCB>
    26c6:	b0 91 5a 23 	lds	r27, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    26ca:	0d b6       	in	r0, 0x3d	; 61
    26cc:	0d 92       	st	X+, r0
    26ce:	0e b6       	in	r0, 0x3e	; 62
    26d0:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    26d2:	7e d6       	rcall	.+3324   	; 0x33d0 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    26d4:	a0 91 59 23 	lds	r26, 0x2359	; 0x802359 <pxCurrentTCB>
    26d8:	b0 91 5a 23 	lds	r27, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    26dc:	0d 90       	ld	r0, X+
    26de:	0d be       	out	0x3d, r0	; 61
    26e0:	0d 90       	ld	r0, X+
    26e2:	0e be       	out	0x3e, r0	; 62
    26e4:	ff 91       	pop	r31
    26e6:	ef 91       	pop	r30
    26e8:	df 91       	pop	r29
    26ea:	cf 91       	pop	r28
    26ec:	bf 91       	pop	r27
    26ee:	af 91       	pop	r26
    26f0:	9f 91       	pop	r25
    26f2:	8f 91       	pop	r24
    26f4:	7f 91       	pop	r23
    26f6:	6f 91       	pop	r22
    26f8:	5f 91       	pop	r21
    26fa:	4f 91       	pop	r20
    26fc:	3f 91       	pop	r19
    26fe:	2f 91       	pop	r18
    2700:	1f 91       	pop	r17
    2702:	0f 91       	pop	r16
    2704:	ff 90       	pop	r15
    2706:	ef 90       	pop	r14
    2708:	df 90       	pop	r13
    270a:	cf 90       	pop	r12
    270c:	bf 90       	pop	r11
    270e:	af 90       	pop	r10
    2710:	9f 90       	pop	r9
    2712:	8f 90       	pop	r8
    2714:	7f 90       	pop	r7
    2716:	6f 90       	pop	r6
    2718:	5f 90       	pop	r5
    271a:	4f 90       	pop	r4
    271c:	3f 90       	pop	r3
    271e:	2f 90       	pop	r2
    2720:	1f 90       	pop	r1
    2722:	0f 90       	pop	r0
    2724:	0f be       	out	0x3f, r0	; 63
    2726:	0f 90       	pop	r0

    asm volatile ( "ret" );
    2728:	08 95       	ret

0000272a <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    272a:	0f 92       	push	r0
    272c:	0f b6       	in	r0, 0x3f	; 63
    272e:	f8 94       	cli
    2730:	0f 92       	push	r0
    2732:	1f 92       	push	r1
    2734:	11 24       	eor	r1, r1
    2736:	2f 92       	push	r2
    2738:	3f 92       	push	r3
    273a:	4f 92       	push	r4
    273c:	5f 92       	push	r5
    273e:	6f 92       	push	r6
    2740:	7f 92       	push	r7
    2742:	8f 92       	push	r8
    2744:	9f 92       	push	r9
    2746:	af 92       	push	r10
    2748:	bf 92       	push	r11
    274a:	cf 92       	push	r12
    274c:	df 92       	push	r13
    274e:	ef 92       	push	r14
    2750:	ff 92       	push	r15
    2752:	0f 93       	push	r16
    2754:	1f 93       	push	r17
    2756:	2f 93       	push	r18
    2758:	3f 93       	push	r19
    275a:	4f 93       	push	r20
    275c:	5f 93       	push	r21
    275e:	6f 93       	push	r22
    2760:	7f 93       	push	r23
    2762:	8f 93       	push	r24
    2764:	9f 93       	push	r25
    2766:	af 93       	push	r26
    2768:	bf 93       	push	r27
    276a:	cf 93       	push	r28
    276c:	df 93       	push	r29
    276e:	ef 93       	push	r30
    2770:	ff 93       	push	r31
    2772:	a0 91 59 23 	lds	r26, 0x2359	; 0x802359 <pxCurrentTCB>
    2776:	b0 91 5a 23 	lds	r27, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    277a:	0d b6       	in	r0, 0x3d	; 61
    277c:	0d 92       	st	X+, r0
    277e:	0e b6       	in	r0, 0x3e	; 62
    2780:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    2782:	e1 d4       	rcall	.+2498   	; 0x3146 <xTaskIncrementTick>
    2784:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    2786:	24 d6       	rcall	.+3144   	; 0x33d0 <vTaskSwitchContext>
    2788:	a0 91 59 23 	lds	r26, 0x2359	; 0x802359 <pxCurrentTCB>
        }
        portRESTORE_CONTEXT();
    278c:	b0 91 5a 23 	lds	r27, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    2790:	0d 90       	ld	r0, X+
    2792:	0d be       	out	0x3d, r0	; 61
    2794:	0d 90       	ld	r0, X+
    2796:	0e be       	out	0x3e, r0	; 62
    2798:	ff 91       	pop	r31
    279a:	ef 91       	pop	r30
    279c:	df 91       	pop	r29
    279e:	cf 91       	pop	r28
    27a0:	bf 91       	pop	r27
    27a2:	af 91       	pop	r26
    27a4:	9f 91       	pop	r25
    27a6:	8f 91       	pop	r24
    27a8:	7f 91       	pop	r23
    27aa:	6f 91       	pop	r22
    27ac:	5f 91       	pop	r21
    27ae:	4f 91       	pop	r20
    27b0:	3f 91       	pop	r19
    27b2:	2f 91       	pop	r18
    27b4:	1f 91       	pop	r17
    27b6:	0f 91       	pop	r16
    27b8:	ff 90       	pop	r15
    27ba:	ef 90       	pop	r14
    27bc:	df 90       	pop	r13
    27be:	cf 90       	pop	r12
    27c0:	bf 90       	pop	r11
    27c2:	af 90       	pop	r10
    27c4:	9f 90       	pop	r9
    27c6:	8f 90       	pop	r8
    27c8:	7f 90       	pop	r7
    27ca:	6f 90       	pop	r6
    27cc:	5f 90       	pop	r5
    27ce:	4f 90       	pop	r4
    27d0:	3f 90       	pop	r3
    27d2:	2f 90       	pop	r2
    27d4:	1f 90       	pop	r1
    27d6:	0f 90       	pop	r0
    27d8:	0f be       	out	0x3f, r0	; 63
    27da:	0f 90       	pop	r0
    27dc:	18 95       	reti

000027de <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    27de:	cf 93       	push	r28
    27e0:	df 93       	push	r29
    27e2:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    27e4:	a0 d4       	rcall	.+2368   	; 0x3126 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    27e6:	ce 01       	movw	r24, r28
    27e8:	0e 94 53 23 	call	0x46a6	; 0x46a6 <malloc>
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    27ec:	ec 01       	movw	r28, r24
    27ee:	63 d5       	rcall	.+2758   	; 0x32b6 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    27f0:	ce 01       	movw	r24, r28
    27f2:	df 91       	pop	r29
    27f4:	cf 91       	pop	r28
    27f6:	08 95       	ret

000027f8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    27f8:	cf 93       	push	r28
    27fa:	df 93       	push	r29
	if( pv )
    27fc:	00 97       	sbiw	r24, 0x00	; 0
    27fe:	31 f0       	breq	.+12     	; 0x280c <vPortFree+0x14>
    2800:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    2802:	91 d4       	rcall	.+2338   	; 0x3126 <vTaskSuspendAll>
		{
			free( pv );
    2804:	ce 01       	movw	r24, r28
    2806:	0e 94 eb 23 	call	0x47d6	; 0x47d6 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    280a:	55 d5       	rcall	.+2730   	; 0x32b6 <xTaskResumeAll>
	}
}
    280c:	df 91       	pop	r29
    280e:	cf 91       	pop	r28
    2810:	08 95       	ret

00002812 <prvIsQueueEmpty>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2812:	0f b6       	in	r0, 0x3f	; 63
    2814:	f8 94       	cli
    2816:	0f 92       	push	r0
    2818:	fc 01       	movw	r30, r24
    281a:	92 8d       	ldd	r25, Z+26	; 0x1a
    281c:	0f 90       	pop	r0
    281e:	0f be       	out	0x3f, r0	; 63
    2820:	81 e0       	ldi	r24, 0x01	; 1
    2822:	91 11       	cpse	r25, r1
    2824:	80 e0       	ldi	r24, 0x00	; 0
    2826:	08 95       	ret

00002828 <prvCopyDataToQueue>:
    2828:	0f 93       	push	r16
    282a:	1f 93       	push	r17
    282c:	cf 93       	push	r28
    282e:	df 93       	push	r29
    2830:	ec 01       	movw	r28, r24
    2832:	04 2f       	mov	r16, r20
    2834:	1a 8d       	ldd	r17, Y+26	; 0x1a
    2836:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2838:	44 23       	and	r20, r20
    283a:	b9 f1       	breq	.+110    	; 0x28aa <prvCopyDataToQueue+0x82>
    283c:	01 11       	cpse	r16, r1
    283e:	16 c0       	rjmp	.+44     	; 0x286c <prvCopyDataToQueue+0x44>
    2840:	50 e0       	ldi	r21, 0x00	; 0
    2842:	8a 81       	ldd	r24, Y+2	; 0x02
    2844:	9b 81       	ldd	r25, Y+3	; 0x03
    2846:	0e 94 74 24 	call	0x48e8	; 0x48e8 <memcpy>
    284a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    284c:	8a 81       	ldd	r24, Y+2	; 0x02
    284e:	9b 81       	ldd	r25, Y+3	; 0x03
    2850:	82 0f       	add	r24, r18
    2852:	91 1d       	adc	r25, r1
    2854:	8a 83       	std	Y+2, r24	; 0x02
    2856:	9b 83       	std	Y+3, r25	; 0x03
    2858:	2c 81       	ldd	r18, Y+4	; 0x04
    285a:	3d 81       	ldd	r19, Y+5	; 0x05
    285c:	82 17       	cp	r24, r18
    285e:	93 07       	cpc	r25, r19
    2860:	20 f1       	brcs	.+72     	; 0x28aa <prvCopyDataToQueue+0x82>
    2862:	88 81       	ld	r24, Y
    2864:	99 81       	ldd	r25, Y+1	; 0x01
    2866:	8a 83       	std	Y+2, r24	; 0x02
    2868:	9b 83       	std	Y+3, r25	; 0x03
    286a:	1f c0       	rjmp	.+62     	; 0x28aa <prvCopyDataToQueue+0x82>
    286c:	50 e0       	ldi	r21, 0x00	; 0
    286e:	8e 81       	ldd	r24, Y+6	; 0x06
    2870:	9f 81       	ldd	r25, Y+7	; 0x07
    2872:	0e 94 74 24 	call	0x48e8	; 0x48e8 <memcpy>
    2876:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2878:	90 e0       	ldi	r25, 0x00	; 0
    287a:	91 95       	neg	r25
    287c:	81 95       	neg	r24
    287e:	91 09       	sbc	r25, r1
    2880:	2e 81       	ldd	r18, Y+6	; 0x06
    2882:	3f 81       	ldd	r19, Y+7	; 0x07
    2884:	28 0f       	add	r18, r24
    2886:	39 1f       	adc	r19, r25
    2888:	2e 83       	std	Y+6, r18	; 0x06
    288a:	3f 83       	std	Y+7, r19	; 0x07
    288c:	48 81       	ld	r20, Y
    288e:	59 81       	ldd	r21, Y+1	; 0x01
    2890:	24 17       	cp	r18, r20
    2892:	35 07       	cpc	r19, r21
    2894:	30 f4       	brcc	.+12     	; 0x28a2 <prvCopyDataToQueue+0x7a>
    2896:	2c 81       	ldd	r18, Y+4	; 0x04
    2898:	3d 81       	ldd	r19, Y+5	; 0x05
    289a:	82 0f       	add	r24, r18
    289c:	93 1f       	adc	r25, r19
    289e:	8e 83       	std	Y+6, r24	; 0x06
    28a0:	9f 83       	std	Y+7, r25	; 0x07
    28a2:	02 30       	cpi	r16, 0x02	; 2
    28a4:	11 f4       	brne	.+4      	; 0x28aa <prvCopyDataToQueue+0x82>
    28a6:	11 11       	cpse	r17, r1
    28a8:	11 50       	subi	r17, 0x01	; 1
    28aa:	1f 5f       	subi	r17, 0xFF	; 255
    28ac:	1a 8f       	std	Y+26, r17	; 0x1a
    28ae:	80 e0       	ldi	r24, 0x00	; 0
    28b0:	df 91       	pop	r29
    28b2:	cf 91       	pop	r28
    28b4:	1f 91       	pop	r17
    28b6:	0f 91       	pop	r16
    28b8:	08 95       	ret

000028ba <prvCopyDataFromQueue>:
    28ba:	fc 01       	movw	r30, r24
    28bc:	44 8d       	ldd	r20, Z+28	; 0x1c
    28be:	44 23       	and	r20, r20
    28c0:	a9 f0       	breq	.+42     	; 0x28ec <prvCopyDataFromQueue+0x32>
    28c2:	50 e0       	ldi	r21, 0x00	; 0
    28c4:	26 81       	ldd	r18, Z+6	; 0x06
    28c6:	37 81       	ldd	r19, Z+7	; 0x07
    28c8:	24 0f       	add	r18, r20
    28ca:	35 1f       	adc	r19, r21
    28cc:	26 83       	std	Z+6, r18	; 0x06
    28ce:	37 83       	std	Z+7, r19	; 0x07
    28d0:	84 81       	ldd	r24, Z+4	; 0x04
    28d2:	95 81       	ldd	r25, Z+5	; 0x05
    28d4:	28 17       	cp	r18, r24
    28d6:	39 07       	cpc	r19, r25
    28d8:	20 f0       	brcs	.+8      	; 0x28e2 <prvCopyDataFromQueue+0x28>
    28da:	80 81       	ld	r24, Z
    28dc:	91 81       	ldd	r25, Z+1	; 0x01
    28de:	86 83       	std	Z+6, r24	; 0x06
    28e0:	97 83       	std	Z+7, r25	; 0x07
    28e2:	cb 01       	movw	r24, r22
    28e4:	66 81       	ldd	r22, Z+6	; 0x06
    28e6:	77 81       	ldd	r23, Z+7	; 0x07
    28e8:	0c 94 74 24 	jmp	0x48e8	; 0x48e8 <memcpy>
    28ec:	08 95       	ret

000028ee <prvUnlockQueue>:
    28ee:	ef 92       	push	r14
    28f0:	ff 92       	push	r15
    28f2:	0f 93       	push	r16
    28f4:	1f 93       	push	r17
    28f6:	cf 93       	push	r28
    28f8:	8c 01       	movw	r16, r24
    28fa:	0f b6       	in	r0, 0x3f	; 63
    28fc:	f8 94       	cli
    28fe:	0f 92       	push	r0
    2900:	fc 01       	movw	r30, r24
    2902:	c6 8d       	ldd	r28, Z+30	; 0x1e
    2904:	1c 16       	cp	r1, r28
    2906:	9c f4       	brge	.+38     	; 0x292e <prvUnlockQueue+0x40>
    2908:	81 89       	ldd	r24, Z+17	; 0x11
    290a:	81 11       	cpse	r24, r1
    290c:	06 c0       	rjmp	.+12     	; 0x291a <prvUnlockQueue+0x2c>
    290e:	0f c0       	rjmp	.+30     	; 0x292e <prvUnlockQueue+0x40>
    2910:	f8 01       	movw	r30, r16
    2912:	81 89       	ldd	r24, Z+17	; 0x11
    2914:	81 11       	cpse	r24, r1
    2916:	05 c0       	rjmp	.+10     	; 0x2922 <prvUnlockQueue+0x34>
    2918:	0a c0       	rjmp	.+20     	; 0x292e <prvUnlockQueue+0x40>
    291a:	78 01       	movw	r14, r16
    291c:	f1 e1       	ldi	r31, 0x11	; 17
    291e:	ef 0e       	add	r14, r31
    2920:	f1 1c       	adc	r15, r1
    2922:	c7 01       	movw	r24, r14
    2924:	e4 d5       	rcall	.+3016   	; 0x34ee <xTaskRemoveFromEventList>
    2926:	81 11       	cpse	r24, r1
    2928:	60 d6       	rcall	.+3264   	; 0x35ea <vTaskMissedYield>
    292a:	c1 50       	subi	r28, 0x01	; 1
    292c:	89 f7       	brne	.-30     	; 0x2910 <prvUnlockQueue+0x22>
    292e:	8f ef       	ldi	r24, 0xFF	; 255
    2930:	f8 01       	movw	r30, r16
    2932:	86 8f       	std	Z+30, r24	; 0x1e
    2934:	0f 90       	pop	r0
    2936:	0f be       	out	0x3f, r0	; 63
    2938:	0f b6       	in	r0, 0x3f	; 63
    293a:	f8 94       	cli
    293c:	0f 92       	push	r0
    293e:	c5 8d       	ldd	r28, Z+29	; 0x1d
    2940:	1c 16       	cp	r1, r28
    2942:	9c f4       	brge	.+38     	; 0x296a <prvUnlockQueue+0x7c>
    2944:	80 85       	ldd	r24, Z+8	; 0x08
    2946:	81 11       	cpse	r24, r1
    2948:	06 c0       	rjmp	.+12     	; 0x2956 <prvUnlockQueue+0x68>
    294a:	0f c0       	rjmp	.+30     	; 0x296a <prvUnlockQueue+0x7c>
    294c:	f8 01       	movw	r30, r16
    294e:	80 85       	ldd	r24, Z+8	; 0x08
    2950:	81 11       	cpse	r24, r1
    2952:	05 c0       	rjmp	.+10     	; 0x295e <prvUnlockQueue+0x70>
    2954:	0a c0       	rjmp	.+20     	; 0x296a <prvUnlockQueue+0x7c>
    2956:	78 01       	movw	r14, r16
    2958:	f8 e0       	ldi	r31, 0x08	; 8
    295a:	ef 0e       	add	r14, r31
    295c:	f1 1c       	adc	r15, r1
    295e:	c7 01       	movw	r24, r14
    2960:	c6 d5       	rcall	.+2956   	; 0x34ee <xTaskRemoveFromEventList>
    2962:	81 11       	cpse	r24, r1
    2964:	42 d6       	rcall	.+3204   	; 0x35ea <vTaskMissedYield>
    2966:	c1 50       	subi	r28, 0x01	; 1
    2968:	89 f7       	brne	.-30     	; 0x294c <prvUnlockQueue+0x5e>
    296a:	8f ef       	ldi	r24, 0xFF	; 255
    296c:	f8 01       	movw	r30, r16
    296e:	85 8f       	std	Z+29, r24	; 0x1d
    2970:	0f 90       	pop	r0
    2972:	0f be       	out	0x3f, r0	; 63
    2974:	cf 91       	pop	r28
    2976:	1f 91       	pop	r17
    2978:	0f 91       	pop	r16
    297a:	ff 90       	pop	r15
    297c:	ef 90       	pop	r14
    297e:	08 95       	ret

00002980 <xQueueGenericReset>:
    2980:	cf 93       	push	r28
    2982:	df 93       	push	r29
    2984:	ec 01       	movw	r28, r24
    2986:	0f b6       	in	r0, 0x3f	; 63
    2988:	f8 94       	cli
    298a:	0f 92       	push	r0
    298c:	e8 81       	ld	r30, Y
    298e:	f9 81       	ldd	r31, Y+1	; 0x01
    2990:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2992:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2994:	90 e0       	ldi	r25, 0x00	; 0
    2996:	30 e0       	ldi	r19, 0x00	; 0
    2998:	82 9f       	mul	r24, r18
    299a:	a0 01       	movw	r20, r0
    299c:	83 9f       	mul	r24, r19
    299e:	50 0d       	add	r21, r0
    29a0:	92 9f       	mul	r25, r18
    29a2:	50 0d       	add	r21, r0
    29a4:	11 24       	eor	r1, r1
    29a6:	4e 0f       	add	r20, r30
    29a8:	5f 1f       	adc	r21, r31
    29aa:	4c 83       	std	Y+4, r20	; 0x04
    29ac:	5d 83       	std	Y+5, r21	; 0x05
    29ae:	1a 8e       	std	Y+26, r1	; 0x1a
    29b0:	ea 83       	std	Y+2, r30	; 0x02
    29b2:	fb 83       	std	Y+3, r31	; 0x03
    29b4:	01 97       	sbiw	r24, 0x01	; 1
    29b6:	82 9f       	mul	r24, r18
    29b8:	a0 01       	movw	r20, r0
    29ba:	83 9f       	mul	r24, r19
    29bc:	50 0d       	add	r21, r0
    29be:	92 9f       	mul	r25, r18
    29c0:	50 0d       	add	r21, r0
    29c2:	11 24       	eor	r1, r1
    29c4:	cf 01       	movw	r24, r30
    29c6:	84 0f       	add	r24, r20
    29c8:	95 1f       	adc	r25, r21
    29ca:	8e 83       	std	Y+6, r24	; 0x06
    29cc:	9f 83       	std	Y+7, r25	; 0x07
    29ce:	8f ef       	ldi	r24, 0xFF	; 255
    29d0:	8d 8f       	std	Y+29, r24	; 0x1d
    29d2:	8e 8f       	std	Y+30, r24	; 0x1e
    29d4:	61 11       	cpse	r22, r1
    29d6:	0a c0       	rjmp	.+20     	; 0x29ec <xQueueGenericReset+0x6c>
    29d8:	88 85       	ldd	r24, Y+8	; 0x08
    29da:	88 23       	and	r24, r24
    29dc:	69 f0       	breq	.+26     	; 0x29f8 <xQueueGenericReset+0x78>
    29de:	ce 01       	movw	r24, r28
    29e0:	08 96       	adiw	r24, 0x08	; 8
    29e2:	85 d5       	rcall	.+2826   	; 0x34ee <xTaskRemoveFromEventList>
    29e4:	88 23       	and	r24, r24
    29e6:	41 f0       	breq	.+16     	; 0x29f8 <xQueueGenericReset+0x78>
    29e8:	48 de       	rcall	.-880    	; 0x267a <vPortYield>
    29ea:	06 c0       	rjmp	.+12     	; 0x29f8 <xQueueGenericReset+0x78>
    29ec:	ce 01       	movw	r24, r28
    29ee:	08 96       	adiw	r24, 0x08	; 8
    29f0:	fd dc       	rcall	.-1542   	; 0x23ec <vListInitialise>
    29f2:	ce 01       	movw	r24, r28
    29f4:	41 96       	adiw	r24, 0x11	; 17
    29f6:	fa dc       	rcall	.-1548   	; 0x23ec <vListInitialise>
    29f8:	0f 90       	pop	r0
    29fa:	0f be       	out	0x3f, r0	; 63
    29fc:	81 e0       	ldi	r24, 0x01	; 1
    29fe:	df 91       	pop	r29
    2a00:	cf 91       	pop	r28
    2a02:	08 95       	ret

00002a04 <xQueueGenericCreate>:
    2a04:	0f 93       	push	r16
    2a06:	1f 93       	push	r17
    2a08:	cf 93       	push	r28
    2a0a:	df 93       	push	r29
    2a0c:	08 2f       	mov	r16, r24
    2a0e:	16 2f       	mov	r17, r22
    2a10:	86 9f       	mul	r24, r22
    2a12:	c0 01       	movw	r24, r0
    2a14:	11 24       	eor	r1, r1
    2a16:	4f 96       	adiw	r24, 0x1f	; 31
    2a18:	e2 de       	rcall	.-572    	; 0x27de <pvPortMalloc>
    2a1a:	ec 01       	movw	r28, r24
    2a1c:	00 97       	sbiw	r24, 0x00	; 0
    2a1e:	69 f0       	breq	.+26     	; 0x2a3a <xQueueGenericCreate+0x36>
    2a20:	11 11       	cpse	r17, r1
    2a22:	03 c0       	rjmp	.+6      	; 0x2a2a <xQueueGenericCreate+0x26>
    2a24:	88 83       	st	Y, r24
    2a26:	99 83       	std	Y+1, r25	; 0x01
    2a28:	03 c0       	rjmp	.+6      	; 0x2a30 <xQueueGenericCreate+0x2c>
    2a2a:	4f 96       	adiw	r24, 0x1f	; 31
    2a2c:	88 83       	st	Y, r24
    2a2e:	99 83       	std	Y+1, r25	; 0x01
    2a30:	0b 8f       	std	Y+27, r16	; 0x1b
    2a32:	1c 8f       	std	Y+28, r17	; 0x1c
    2a34:	61 e0       	ldi	r22, 0x01	; 1
    2a36:	ce 01       	movw	r24, r28
    2a38:	a3 df       	rcall	.-186    	; 0x2980 <xQueueGenericReset>
    2a3a:	ce 01       	movw	r24, r28
    2a3c:	df 91       	pop	r29
    2a3e:	cf 91       	pop	r28
    2a40:	1f 91       	pop	r17
    2a42:	0f 91       	pop	r16
    2a44:	08 95       	ret

00002a46 <xQueueGenericSend>:
    2a46:	af 92       	push	r10
    2a48:	bf 92       	push	r11
    2a4a:	cf 92       	push	r12
    2a4c:	df 92       	push	r13
    2a4e:	ef 92       	push	r14
    2a50:	ff 92       	push	r15
    2a52:	0f 93       	push	r16
    2a54:	1f 93       	push	r17
    2a56:	cf 93       	push	r28
    2a58:	df 93       	push	r29
    2a5a:	cd b7       	in	r28, 0x3d	; 61
    2a5c:	de b7       	in	r29, 0x3e	; 62
    2a5e:	25 97       	sbiw	r28, 0x05	; 5
    2a60:	cd bf       	out	0x3d, r28	; 61
    2a62:	de bf       	out	0x3e, r29	; 62
    2a64:	8c 01       	movw	r16, r24
    2a66:	6b 01       	movw	r12, r22
    2a68:	4c 83       	std	Y+4, r20	; 0x04
    2a6a:	5d 83       	std	Y+5, r21	; 0x05
    2a6c:	a2 2e       	mov	r10, r18
    2a6e:	b1 2c       	mov	r11, r1
    2a70:	7c 01       	movw	r14, r24
    2a72:	88 e0       	ldi	r24, 0x08	; 8
    2a74:	e8 0e       	add	r14, r24
    2a76:	f1 1c       	adc	r15, r1
    2a78:	0f b6       	in	r0, 0x3f	; 63
    2a7a:	f8 94       	cli
    2a7c:	0f 92       	push	r0
    2a7e:	f8 01       	movw	r30, r16
    2a80:	92 8d       	ldd	r25, Z+26	; 0x1a
    2a82:	83 8d       	ldd	r24, Z+27	; 0x1b
    2a84:	98 17       	cp	r25, r24
    2a86:	18 f0       	brcs	.+6      	; 0x2a8e <xQueueGenericSend+0x48>
    2a88:	f2 e0       	ldi	r31, 0x02	; 2
    2a8a:	af 12       	cpse	r10, r31
    2a8c:	15 c0       	rjmp	.+42     	; 0x2ab8 <xQueueGenericSend+0x72>
    2a8e:	4a 2d       	mov	r20, r10
    2a90:	b6 01       	movw	r22, r12
    2a92:	c8 01       	movw	r24, r16
    2a94:	c9 de       	rcall	.-622    	; 0x2828 <prvCopyDataToQueue>
    2a96:	f8 01       	movw	r30, r16
    2a98:	91 89       	ldd	r25, Z+17	; 0x11
    2a9a:	99 23       	and	r25, r25
    2a9c:	39 f0       	breq	.+14     	; 0x2aac <xQueueGenericSend+0x66>
    2a9e:	c8 01       	movw	r24, r16
    2aa0:	41 96       	adiw	r24, 0x11	; 17
    2aa2:	25 d5       	rcall	.+2634   	; 0x34ee <xTaskRemoveFromEventList>
    2aa4:	88 23       	and	r24, r24
    2aa6:	21 f0       	breq	.+8      	; 0x2ab0 <xQueueGenericSend+0x6a>
    2aa8:	e8 dd       	rcall	.-1072   	; 0x267a <vPortYield>
    2aaa:	02 c0       	rjmp	.+4      	; 0x2ab0 <xQueueGenericSend+0x6a>
    2aac:	81 11       	cpse	r24, r1
    2aae:	e5 dd       	rcall	.-1078   	; 0x267a <vPortYield>
    2ab0:	0f 90       	pop	r0
    2ab2:	0f be       	out	0x3f, r0	; 63
    2ab4:	81 e0       	ldi	r24, 0x01	; 1
    2ab6:	46 c0       	rjmp	.+140    	; 0x2b44 <xQueueGenericSend+0xfe>
    2ab8:	8c 81       	ldd	r24, Y+4	; 0x04
    2aba:	9d 81       	ldd	r25, Y+5	; 0x05
    2abc:	89 2b       	or	r24, r25
    2abe:	21 f4       	brne	.+8      	; 0x2ac8 <xQueueGenericSend+0x82>
    2ac0:	0f 90       	pop	r0
    2ac2:	0f be       	out	0x3f, r0	; 63
    2ac4:	80 e0       	ldi	r24, 0x00	; 0
    2ac6:	3e c0       	rjmp	.+124    	; 0x2b44 <xQueueGenericSend+0xfe>
    2ac8:	b1 10       	cpse	r11, r1
    2aca:	05 c0       	rjmp	.+10     	; 0x2ad6 <xQueueGenericSend+0x90>
    2acc:	ce 01       	movw	r24, r28
    2ace:	01 96       	adiw	r24, 0x01	; 1
    2ad0:	56 d5       	rcall	.+2732   	; 0x357e <vTaskInternalSetTimeOutState>
    2ad2:	bb 24       	eor	r11, r11
    2ad4:	b3 94       	inc	r11
    2ad6:	0f 90       	pop	r0
    2ad8:	0f be       	out	0x3f, r0	; 63
    2ada:	25 d3       	rcall	.+1610   	; 0x3126 <vTaskSuspendAll>
    2adc:	0f b6       	in	r0, 0x3f	; 63
    2ade:	f8 94       	cli
    2ae0:	0f 92       	push	r0
    2ae2:	f8 01       	movw	r30, r16
    2ae4:	85 8d       	ldd	r24, Z+29	; 0x1d
    2ae6:	8f 3f       	cpi	r24, 0xFF	; 255
    2ae8:	09 f4       	brne	.+2      	; 0x2aec <xQueueGenericSend+0xa6>
    2aea:	15 8e       	std	Z+29, r1	; 0x1d
    2aec:	f8 01       	movw	r30, r16
    2aee:	86 8d       	ldd	r24, Z+30	; 0x1e
    2af0:	8f 3f       	cpi	r24, 0xFF	; 255
    2af2:	09 f4       	brne	.+2      	; 0x2af6 <xQueueGenericSend+0xb0>
    2af4:	16 8e       	std	Z+30, r1	; 0x1e
    2af6:	0f 90       	pop	r0
    2af8:	0f be       	out	0x3f, r0	; 63
    2afa:	be 01       	movw	r22, r28
    2afc:	6c 5f       	subi	r22, 0xFC	; 252
    2afe:	7f 4f       	sbci	r23, 0xFF	; 255
    2b00:	ce 01       	movw	r24, r28
    2b02:	01 96       	adiw	r24, 0x01	; 1
    2b04:	47 d5       	rcall	.+2702   	; 0x3594 <xTaskCheckForTimeOut>
    2b06:	81 11       	cpse	r24, r1
    2b08:	19 c0       	rjmp	.+50     	; 0x2b3c <xQueueGenericSend+0xf6>
    2b0a:	0f b6       	in	r0, 0x3f	; 63
    2b0c:	f8 94       	cli
    2b0e:	0f 92       	push	r0
    2b10:	f8 01       	movw	r30, r16
    2b12:	92 8d       	ldd	r25, Z+26	; 0x1a
    2b14:	0f 90       	pop	r0
    2b16:	0f be       	out	0x3f, r0	; 63
    2b18:	83 8d       	ldd	r24, Z+27	; 0x1b
    2b1a:	98 13       	cpse	r25, r24
    2b1c:	0b c0       	rjmp	.+22     	; 0x2b34 <xQueueGenericSend+0xee>
    2b1e:	6c 81       	ldd	r22, Y+4	; 0x04
    2b20:	7d 81       	ldd	r23, Y+5	; 0x05
    2b22:	c7 01       	movw	r24, r14
    2b24:	bb d4       	rcall	.+2422   	; 0x349c <vTaskPlaceOnEventList>
    2b26:	c8 01       	movw	r24, r16
    2b28:	e2 de       	rcall	.-572    	; 0x28ee <prvUnlockQueue>
    2b2a:	c5 d3       	rcall	.+1930   	; 0x32b6 <xTaskResumeAll>
    2b2c:	81 11       	cpse	r24, r1
    2b2e:	a4 cf       	rjmp	.-184    	; 0x2a78 <xQueueGenericSend+0x32>
    2b30:	a4 dd       	rcall	.-1208   	; 0x267a <vPortYield>
    2b32:	a2 cf       	rjmp	.-188    	; 0x2a78 <xQueueGenericSend+0x32>
    2b34:	c8 01       	movw	r24, r16
    2b36:	db de       	rcall	.-586    	; 0x28ee <prvUnlockQueue>
    2b38:	be d3       	rcall	.+1916   	; 0x32b6 <xTaskResumeAll>
    2b3a:	9e cf       	rjmp	.-196    	; 0x2a78 <xQueueGenericSend+0x32>
    2b3c:	c8 01       	movw	r24, r16
    2b3e:	d7 de       	rcall	.-594    	; 0x28ee <prvUnlockQueue>
    2b40:	ba d3       	rcall	.+1908   	; 0x32b6 <xTaskResumeAll>
    2b42:	80 e0       	ldi	r24, 0x00	; 0
    2b44:	25 96       	adiw	r28, 0x05	; 5
    2b46:	cd bf       	out	0x3d, r28	; 61
    2b48:	de bf       	out	0x3e, r29	; 62
    2b4a:	df 91       	pop	r29
    2b4c:	cf 91       	pop	r28
    2b4e:	1f 91       	pop	r17
    2b50:	0f 91       	pop	r16
    2b52:	ff 90       	pop	r15
    2b54:	ef 90       	pop	r14
    2b56:	df 90       	pop	r13
    2b58:	cf 90       	pop	r12
    2b5a:	bf 90       	pop	r11
    2b5c:	af 90       	pop	r10
    2b5e:	08 95       	ret

00002b60 <xQueueGenericSendFromISR>:
    2b60:	ef 92       	push	r14
    2b62:	ff 92       	push	r15
    2b64:	0f 93       	push	r16
    2b66:	1f 93       	push	r17
    2b68:	cf 93       	push	r28
    2b6a:	df 93       	push	r29
    2b6c:	8a 01       	movw	r16, r20
    2b6e:	fc 01       	movw	r30, r24
    2b70:	52 8d       	ldd	r21, Z+26	; 0x1a
    2b72:	33 8d       	ldd	r19, Z+27	; 0x1b
    2b74:	53 17       	cp	r21, r19
    2b76:	10 f0       	brcs	.+4      	; 0x2b7c <xQueueGenericSendFromISR+0x1c>
    2b78:	22 30       	cpi	r18, 0x02	; 2
    2b7a:	f1 f4       	brne	.+60     	; 0x2bb8 <xQueueGenericSendFromISR+0x58>
    2b7c:	42 2f       	mov	r20, r18
    2b7e:	78 01       	movw	r14, r16
    2b80:	ec 01       	movw	r28, r24
    2b82:	1e 8d       	ldd	r17, Y+30	; 0x1e
    2b84:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b86:	ce 01       	movw	r24, r28
    2b88:	4f de       	rcall	.-866    	; 0x2828 <prvCopyDataToQueue>
    2b8a:	1f 3f       	cpi	r17, 0xFF	; 255
    2b8c:	79 f4       	brne	.+30     	; 0x2bac <xQueueGenericSendFromISR+0x4c>
    2b8e:	89 89       	ldd	r24, Y+17	; 0x11
    2b90:	88 23       	and	r24, r24
    2b92:	a1 f0       	breq	.+40     	; 0x2bbc <xQueueGenericSendFromISR+0x5c>
    2b94:	ce 01       	movw	r24, r28
    2b96:	41 96       	adiw	r24, 0x11	; 17
    2b98:	aa d4       	rcall	.+2388   	; 0x34ee <xTaskRemoveFromEventList>
    2b9a:	88 23       	and	r24, r24
    2b9c:	89 f0       	breq	.+34     	; 0x2bc0 <xQueueGenericSendFromISR+0x60>
    2b9e:	e1 14       	cp	r14, r1
    2ba0:	f1 04       	cpc	r15, r1
    2ba2:	81 f0       	breq	.+32     	; 0x2bc4 <xQueueGenericSendFromISR+0x64>
    2ba4:	81 e0       	ldi	r24, 0x01	; 1
    2ba6:	f7 01       	movw	r30, r14
    2ba8:	80 83       	st	Z, r24
    2baa:	0d c0       	rjmp	.+26     	; 0x2bc6 <xQueueGenericSendFromISR+0x66>
    2bac:	ff 24       	eor	r15, r15
    2bae:	f3 94       	inc	r15
    2bb0:	f1 0e       	add	r15, r17
    2bb2:	fe 8e       	std	Y+30, r15	; 0x1e
    2bb4:	81 e0       	ldi	r24, 0x01	; 1
    2bb6:	07 c0       	rjmp	.+14     	; 0x2bc6 <xQueueGenericSendFromISR+0x66>
    2bb8:	80 e0       	ldi	r24, 0x00	; 0
    2bba:	05 c0       	rjmp	.+10     	; 0x2bc6 <xQueueGenericSendFromISR+0x66>
    2bbc:	81 e0       	ldi	r24, 0x01	; 1
    2bbe:	03 c0       	rjmp	.+6      	; 0x2bc6 <xQueueGenericSendFromISR+0x66>
    2bc0:	81 e0       	ldi	r24, 0x01	; 1
    2bc2:	01 c0       	rjmp	.+2      	; 0x2bc6 <xQueueGenericSendFromISR+0x66>
    2bc4:	81 e0       	ldi	r24, 0x01	; 1
    2bc6:	df 91       	pop	r29
    2bc8:	cf 91       	pop	r28
    2bca:	1f 91       	pop	r17
    2bcc:	0f 91       	pop	r16
    2bce:	ff 90       	pop	r15
    2bd0:	ef 90       	pop	r14
    2bd2:	08 95       	ret

00002bd4 <xQueueReceive>:
    2bd4:	af 92       	push	r10
    2bd6:	bf 92       	push	r11
    2bd8:	cf 92       	push	r12
    2bda:	df 92       	push	r13
    2bdc:	ef 92       	push	r14
    2bde:	ff 92       	push	r15
    2be0:	0f 93       	push	r16
    2be2:	1f 93       	push	r17
    2be4:	cf 93       	push	r28
    2be6:	df 93       	push	r29
    2be8:	cd b7       	in	r28, 0x3d	; 61
    2bea:	de b7       	in	r29, 0x3e	; 62
    2bec:	25 97       	sbiw	r28, 0x05	; 5
    2bee:	cd bf       	out	0x3d, r28	; 61
    2bf0:	de bf       	out	0x3e, r29	; 62
    2bf2:	8c 01       	movw	r16, r24
    2bf4:	5b 01       	movw	r10, r22
    2bf6:	4c 83       	std	Y+4, r20	; 0x04
    2bf8:	5d 83       	std	Y+5, r21	; 0x05
    2bfa:	e1 2c       	mov	r14, r1
    2bfc:	6c 01       	movw	r12, r24
    2bfe:	81 e1       	ldi	r24, 0x11	; 17
    2c00:	c8 0e       	add	r12, r24
    2c02:	d1 1c       	adc	r13, r1
    2c04:	0f b6       	in	r0, 0x3f	; 63
    2c06:	f8 94       	cli
    2c08:	0f 92       	push	r0
    2c0a:	f8 01       	movw	r30, r16
    2c0c:	f2 8c       	ldd	r15, Z+26	; 0x1a
    2c0e:	ff 20       	and	r15, r15
    2c10:	91 f0       	breq	.+36     	; 0x2c36 <xQueueReceive+0x62>
    2c12:	b5 01       	movw	r22, r10
    2c14:	c8 01       	movw	r24, r16
    2c16:	51 de       	rcall	.-862    	; 0x28ba <prvCopyDataFromQueue>
    2c18:	fa 94       	dec	r15
    2c1a:	f8 01       	movw	r30, r16
    2c1c:	f2 8e       	std	Z+26, r15	; 0x1a
    2c1e:	80 85       	ldd	r24, Z+8	; 0x08
    2c20:	88 23       	and	r24, r24
    2c22:	29 f0       	breq	.+10     	; 0x2c2e <xQueueReceive+0x5a>
    2c24:	c8 01       	movw	r24, r16
    2c26:	08 96       	adiw	r24, 0x08	; 8
    2c28:	62 d4       	rcall	.+2244   	; 0x34ee <xTaskRemoveFromEventList>
    2c2a:	81 11       	cpse	r24, r1
    2c2c:	26 dd       	rcall	.-1460   	; 0x267a <vPortYield>
    2c2e:	0f 90       	pop	r0
    2c30:	0f be       	out	0x3f, r0	; 63
    2c32:	81 e0       	ldi	r24, 0x01	; 1
    2c34:	45 c0       	rjmp	.+138    	; 0x2cc0 <xQueueReceive+0xec>
    2c36:	8c 81       	ldd	r24, Y+4	; 0x04
    2c38:	9d 81       	ldd	r25, Y+5	; 0x05
    2c3a:	89 2b       	or	r24, r25
    2c3c:	21 f4       	brne	.+8      	; 0x2c46 <xQueueReceive+0x72>
    2c3e:	0f 90       	pop	r0
    2c40:	0f be       	out	0x3f, r0	; 63
    2c42:	80 e0       	ldi	r24, 0x00	; 0
    2c44:	3d c0       	rjmp	.+122    	; 0x2cc0 <xQueueReceive+0xec>
    2c46:	e1 10       	cpse	r14, r1
    2c48:	05 c0       	rjmp	.+10     	; 0x2c54 <xQueueReceive+0x80>
    2c4a:	ce 01       	movw	r24, r28
    2c4c:	01 96       	adiw	r24, 0x01	; 1
    2c4e:	97 d4       	rcall	.+2350   	; 0x357e <vTaskInternalSetTimeOutState>
    2c50:	ee 24       	eor	r14, r14
    2c52:	e3 94       	inc	r14
    2c54:	0f 90       	pop	r0
    2c56:	0f be       	out	0x3f, r0	; 63
    2c58:	66 d2       	rcall	.+1228   	; 0x3126 <vTaskSuspendAll>
    2c5a:	0f b6       	in	r0, 0x3f	; 63
    2c5c:	f8 94       	cli
    2c5e:	0f 92       	push	r0
    2c60:	f8 01       	movw	r30, r16
    2c62:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c64:	8f 3f       	cpi	r24, 0xFF	; 255
    2c66:	09 f4       	brne	.+2      	; 0x2c6a <xQueueReceive+0x96>
    2c68:	15 8e       	std	Z+29, r1	; 0x1d
    2c6a:	f8 01       	movw	r30, r16
    2c6c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c6e:	8f 3f       	cpi	r24, 0xFF	; 255
    2c70:	09 f4       	brne	.+2      	; 0x2c74 <xQueueReceive+0xa0>
    2c72:	16 8e       	std	Z+30, r1	; 0x1e
    2c74:	0f 90       	pop	r0
    2c76:	0f be       	out	0x3f, r0	; 63
    2c78:	be 01       	movw	r22, r28
    2c7a:	6c 5f       	subi	r22, 0xFC	; 252
    2c7c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c7e:	ce 01       	movw	r24, r28
    2c80:	01 96       	adiw	r24, 0x01	; 1
    2c82:	88 d4       	rcall	.+2320   	; 0x3594 <xTaskCheckForTimeOut>
    2c84:	81 11       	cpse	r24, r1
    2c86:	13 c0       	rjmp	.+38     	; 0x2cae <xQueueReceive+0xda>
    2c88:	c8 01       	movw	r24, r16
    2c8a:	c3 dd       	rcall	.-1146   	; 0x2812 <prvIsQueueEmpty>
    2c8c:	88 23       	and	r24, r24
    2c8e:	59 f0       	breq	.+22     	; 0x2ca6 <xQueueReceive+0xd2>
    2c90:	6c 81       	ldd	r22, Y+4	; 0x04
    2c92:	7d 81       	ldd	r23, Y+5	; 0x05
    2c94:	c6 01       	movw	r24, r12
    2c96:	02 d4       	rcall	.+2052   	; 0x349c <vTaskPlaceOnEventList>
    2c98:	c8 01       	movw	r24, r16
    2c9a:	29 de       	rcall	.-942    	; 0x28ee <prvUnlockQueue>
    2c9c:	0c d3       	rcall	.+1560   	; 0x32b6 <xTaskResumeAll>
    2c9e:	81 11       	cpse	r24, r1
    2ca0:	b1 cf       	rjmp	.-158    	; 0x2c04 <xQueueReceive+0x30>
    2ca2:	eb dc       	rcall	.-1578   	; 0x267a <vPortYield>
    2ca4:	af cf       	rjmp	.-162    	; 0x2c04 <xQueueReceive+0x30>
    2ca6:	c8 01       	movw	r24, r16
    2ca8:	22 de       	rcall	.-956    	; 0x28ee <prvUnlockQueue>
    2caa:	05 d3       	rcall	.+1546   	; 0x32b6 <xTaskResumeAll>
    2cac:	ab cf       	rjmp	.-170    	; 0x2c04 <xQueueReceive+0x30>
    2cae:	c8 01       	movw	r24, r16
    2cb0:	1e de       	rcall	.-964    	; 0x28ee <prvUnlockQueue>
    2cb2:	01 d3       	rcall	.+1538   	; 0x32b6 <xTaskResumeAll>
    2cb4:	c8 01       	movw	r24, r16
    2cb6:	ad dd       	rcall	.-1190   	; 0x2812 <prvIsQueueEmpty>
    2cb8:	88 23       	and	r24, r24
    2cba:	09 f4       	brne	.+2      	; 0x2cbe <xQueueReceive+0xea>
    2cbc:	a3 cf       	rjmp	.-186    	; 0x2c04 <xQueueReceive+0x30>
    2cbe:	80 e0       	ldi	r24, 0x00	; 0
    2cc0:	25 96       	adiw	r28, 0x05	; 5
    2cc2:	cd bf       	out	0x3d, r28	; 61
    2cc4:	de bf       	out	0x3e, r29	; 62
    2cc6:	df 91       	pop	r29
    2cc8:	cf 91       	pop	r28
    2cca:	1f 91       	pop	r17
    2ccc:	0f 91       	pop	r16
    2cce:	ff 90       	pop	r15
    2cd0:	ef 90       	pop	r14
    2cd2:	df 90       	pop	r13
    2cd4:	cf 90       	pop	r12
    2cd6:	bf 90       	pop	r11
    2cd8:	af 90       	pop	r10
    2cda:	08 95       	ret

00002cdc <xQueueSemaphoreTake>:
    2cdc:	df 92       	push	r13
    2cde:	ef 92       	push	r14
    2ce0:	ff 92       	push	r15
    2ce2:	0f 93       	push	r16
    2ce4:	1f 93       	push	r17
    2ce6:	cf 93       	push	r28
    2ce8:	df 93       	push	r29
    2cea:	cd b7       	in	r28, 0x3d	; 61
    2cec:	de b7       	in	r29, 0x3e	; 62
    2cee:	25 97       	sbiw	r28, 0x05	; 5
    2cf0:	cd bf       	out	0x3d, r28	; 61
    2cf2:	de bf       	out	0x3e, r29	; 62
    2cf4:	8c 01       	movw	r16, r24
    2cf6:	6c 83       	std	Y+4, r22	; 0x04
    2cf8:	7d 83       	std	Y+5, r23	; 0x05
    2cfa:	d1 2c       	mov	r13, r1
    2cfc:	7c 01       	movw	r14, r24
    2cfe:	81 e1       	ldi	r24, 0x11	; 17
    2d00:	e8 0e       	add	r14, r24
    2d02:	f1 1c       	adc	r15, r1
    2d04:	0f b6       	in	r0, 0x3f	; 63
    2d06:	f8 94       	cli
    2d08:	0f 92       	push	r0
    2d0a:	f8 01       	movw	r30, r16
    2d0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d0e:	88 23       	and	r24, r24
    2d10:	71 f0       	breq	.+28     	; 0x2d2e <xQueueSemaphoreTake+0x52>
    2d12:	81 50       	subi	r24, 0x01	; 1
    2d14:	82 8f       	std	Z+26, r24	; 0x1a
    2d16:	80 85       	ldd	r24, Z+8	; 0x08
    2d18:	88 23       	and	r24, r24
    2d1a:	29 f0       	breq	.+10     	; 0x2d26 <xQueueSemaphoreTake+0x4a>
    2d1c:	c8 01       	movw	r24, r16
    2d1e:	08 96       	adiw	r24, 0x08	; 8
    2d20:	e6 d3       	rcall	.+1996   	; 0x34ee <xTaskRemoveFromEventList>
    2d22:	81 11       	cpse	r24, r1
    2d24:	aa dc       	rcall	.-1708   	; 0x267a <vPortYield>
    2d26:	0f 90       	pop	r0
    2d28:	0f be       	out	0x3f, r0	; 63
    2d2a:	81 e0       	ldi	r24, 0x01	; 1
    2d2c:	45 c0       	rjmp	.+138    	; 0x2db8 <xQueueSemaphoreTake+0xdc>
    2d2e:	8c 81       	ldd	r24, Y+4	; 0x04
    2d30:	9d 81       	ldd	r25, Y+5	; 0x05
    2d32:	89 2b       	or	r24, r25
    2d34:	21 f4       	brne	.+8      	; 0x2d3e <xQueueSemaphoreTake+0x62>
    2d36:	0f 90       	pop	r0
    2d38:	0f be       	out	0x3f, r0	; 63
    2d3a:	80 e0       	ldi	r24, 0x00	; 0
    2d3c:	3d c0       	rjmp	.+122    	; 0x2db8 <xQueueSemaphoreTake+0xdc>
    2d3e:	d1 10       	cpse	r13, r1
    2d40:	05 c0       	rjmp	.+10     	; 0x2d4c <xQueueSemaphoreTake+0x70>
    2d42:	ce 01       	movw	r24, r28
    2d44:	01 96       	adiw	r24, 0x01	; 1
    2d46:	1b d4       	rcall	.+2102   	; 0x357e <vTaskInternalSetTimeOutState>
    2d48:	dd 24       	eor	r13, r13
    2d4a:	d3 94       	inc	r13
    2d4c:	0f 90       	pop	r0
    2d4e:	0f be       	out	0x3f, r0	; 63
    2d50:	ea d1       	rcall	.+980    	; 0x3126 <vTaskSuspendAll>
    2d52:	0f b6       	in	r0, 0x3f	; 63
    2d54:	f8 94       	cli
    2d56:	0f 92       	push	r0
    2d58:	f8 01       	movw	r30, r16
    2d5a:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d5c:	8f 3f       	cpi	r24, 0xFF	; 255
    2d5e:	09 f4       	brne	.+2      	; 0x2d62 <xQueueSemaphoreTake+0x86>
    2d60:	15 8e       	std	Z+29, r1	; 0x1d
    2d62:	f8 01       	movw	r30, r16
    2d64:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d66:	8f 3f       	cpi	r24, 0xFF	; 255
    2d68:	09 f4       	brne	.+2      	; 0x2d6c <xQueueSemaphoreTake+0x90>
    2d6a:	16 8e       	std	Z+30, r1	; 0x1e
    2d6c:	0f 90       	pop	r0
    2d6e:	0f be       	out	0x3f, r0	; 63
    2d70:	be 01       	movw	r22, r28
    2d72:	6c 5f       	subi	r22, 0xFC	; 252
    2d74:	7f 4f       	sbci	r23, 0xFF	; 255
    2d76:	ce 01       	movw	r24, r28
    2d78:	01 96       	adiw	r24, 0x01	; 1
    2d7a:	0c d4       	rcall	.+2072   	; 0x3594 <xTaskCheckForTimeOut>
    2d7c:	81 11       	cpse	r24, r1
    2d7e:	13 c0       	rjmp	.+38     	; 0x2da6 <xQueueSemaphoreTake+0xca>
    2d80:	c8 01       	movw	r24, r16
    2d82:	47 dd       	rcall	.-1394   	; 0x2812 <prvIsQueueEmpty>
    2d84:	88 23       	and	r24, r24
    2d86:	59 f0       	breq	.+22     	; 0x2d9e <xQueueSemaphoreTake+0xc2>
    2d88:	6c 81       	ldd	r22, Y+4	; 0x04
    2d8a:	7d 81       	ldd	r23, Y+5	; 0x05
    2d8c:	c7 01       	movw	r24, r14
    2d8e:	86 d3       	rcall	.+1804   	; 0x349c <vTaskPlaceOnEventList>
    2d90:	c8 01       	movw	r24, r16
    2d92:	ad dd       	rcall	.-1190   	; 0x28ee <prvUnlockQueue>
    2d94:	90 d2       	rcall	.+1312   	; 0x32b6 <xTaskResumeAll>
    2d96:	81 11       	cpse	r24, r1
    2d98:	b5 cf       	rjmp	.-150    	; 0x2d04 <xQueueSemaphoreTake+0x28>
    2d9a:	6f dc       	rcall	.-1826   	; 0x267a <vPortYield>
    2d9c:	b3 cf       	rjmp	.-154    	; 0x2d04 <xQueueSemaphoreTake+0x28>
    2d9e:	c8 01       	movw	r24, r16
    2da0:	a6 dd       	rcall	.-1204   	; 0x28ee <prvUnlockQueue>
    2da2:	89 d2       	rcall	.+1298   	; 0x32b6 <xTaskResumeAll>
    2da4:	af cf       	rjmp	.-162    	; 0x2d04 <xQueueSemaphoreTake+0x28>
    2da6:	c8 01       	movw	r24, r16
    2da8:	a2 dd       	rcall	.-1212   	; 0x28ee <prvUnlockQueue>
    2daa:	85 d2       	rcall	.+1290   	; 0x32b6 <xTaskResumeAll>
    2dac:	c8 01       	movw	r24, r16
    2dae:	31 dd       	rcall	.-1438   	; 0x2812 <prvIsQueueEmpty>
    2db0:	88 23       	and	r24, r24
    2db2:	09 f4       	brne	.+2      	; 0x2db6 <xQueueSemaphoreTake+0xda>
    2db4:	a7 cf       	rjmp	.-178    	; 0x2d04 <xQueueSemaphoreTake+0x28>
    2db6:	80 e0       	ldi	r24, 0x00	; 0
    2db8:	25 96       	adiw	r28, 0x05	; 5
    2dba:	cd bf       	out	0x3d, r28	; 61
    2dbc:	de bf       	out	0x3e, r29	; 62
    2dbe:	df 91       	pop	r29
    2dc0:	cf 91       	pop	r28
    2dc2:	1f 91       	pop	r17
    2dc4:	0f 91       	pop	r16
    2dc6:	ff 90       	pop	r15
    2dc8:	ef 90       	pop	r14
    2dca:	df 90       	pop	r13
    2dcc:	08 95       	ret

00002dce <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    2dce:	cf 93       	push	r28
    2dd0:	df 93       	push	r29
    2dd2:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    2dd4:	0f b6       	in	r0, 0x3f	; 63
    2dd6:	f8 94       	cli
    2dd8:	0f 92       	push	r0
    2dda:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2ddc:	8f 3f       	cpi	r24, 0xFF	; 255
    2dde:	09 f4       	brne	.+2      	; 0x2de2 <vQueueWaitForMessageRestricted+0x14>
    2de0:	1d 8e       	std	Y+29, r1	; 0x1d
    2de2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2de4:	8f 3f       	cpi	r24, 0xFF	; 255
    2de6:	09 f4       	brne	.+2      	; 0x2dea <vQueueWaitForMessageRestricted+0x1c>
    2de8:	1e 8e       	std	Y+30, r1	; 0x1e
    2dea:	0f 90       	pop	r0
    2dec:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2dee:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2df0:	81 11       	cpse	r24, r1
    2df2:	03 c0       	rjmp	.+6      	; 0x2dfa <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2df4:	ce 01       	movw	r24, r28
    2df6:	41 96       	adiw	r24, 0x11	; 17
    2df8:	62 d3       	rcall	.+1732   	; 0x34be <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    2dfa:	ce 01       	movw	r24, r28
    2dfc:	78 dd       	rcall	.-1296   	; 0x28ee <prvUnlockQueue>
	}
    2dfe:	df 91       	pop	r29
    2e00:	cf 91       	pop	r28
    2e02:	08 95       	ret

00002e04 <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
    2e04:	e0 91 18 23 	lds	r30, 0x2318	; 0x802318 <pxDelayedTaskList>
    2e08:	f0 91 19 23 	lds	r31, 0x2319	; 0x802319 <pxDelayedTaskList+0x1>
    2e0c:	80 81       	ld	r24, Z
    2e0e:	81 11       	cpse	r24, r1
    2e10:	07 c0       	rjmp	.+14     	; 0x2e20 <prvResetNextTaskUnblockTime+0x1c>
    2e12:	8f ef       	ldi	r24, 0xFF	; 255
    2e14:	9f ef       	ldi	r25, 0xFF	; 255
    2e16:	80 93 01 23 	sts	0x2301, r24	; 0x802301 <xNextTaskUnblockTime>
    2e1a:	90 93 02 23 	sts	0x2302, r25	; 0x802302 <xNextTaskUnblockTime+0x1>
    2e1e:	08 95       	ret
    2e20:	e0 91 18 23 	lds	r30, 0x2318	; 0x802318 <pxDelayedTaskList>
    2e24:	f0 91 19 23 	lds	r31, 0x2319	; 0x802319 <pxDelayedTaskList+0x1>
    2e28:	05 80       	ldd	r0, Z+5	; 0x05
    2e2a:	f6 81       	ldd	r31, Z+6	; 0x06
    2e2c:	e0 2d       	mov	r30, r0
    2e2e:	06 80       	ldd	r0, Z+6	; 0x06
    2e30:	f7 81       	ldd	r31, Z+7	; 0x07
    2e32:	e0 2d       	mov	r30, r0
    2e34:	82 81       	ldd	r24, Z+2	; 0x02
    2e36:	93 81       	ldd	r25, Z+3	; 0x03
    2e38:	80 93 01 23 	sts	0x2301, r24	; 0x802301 <xNextTaskUnblockTime>
    2e3c:	90 93 02 23 	sts	0x2302, r25	; 0x802302 <xNextTaskUnblockTime+0x1>
    2e40:	08 95       	ret

00002e42 <prvIdleTask>:
    2e42:	cc e2       	ldi	r28, 0x2C	; 44
    2e44:	d3 e2       	ldi	r29, 0x23	; 35
    2e46:	88 81       	ld	r24, Y
    2e48:	82 30       	cpi	r24, 0x02	; 2
    2e4a:	e8 f3       	brcs	.-6      	; 0x2e46 <prvIdleTask+0x4>
    2e4c:	16 dc       	rcall	.-2004   	; 0x267a <vPortYield>
    2e4e:	fb cf       	rjmp	.-10     	; 0x2e46 <prvIdleTask+0x4>

00002e50 <prvAddCurrentTaskToDelayedList>:
    2e50:	0f 93       	push	r16
    2e52:	1f 93       	push	r17
    2e54:	cf 93       	push	r28
    2e56:	df 93       	push	r29
    2e58:	ec 01       	movw	r28, r24
    2e5a:	00 91 0a 23 	lds	r16, 0x230A	; 0x80230a <xTickCount>
    2e5e:	10 91 0b 23 	lds	r17, 0x230B	; 0x80230b <xTickCount+0x1>
    2e62:	80 91 59 23 	lds	r24, 0x2359	; 0x802359 <pxCurrentTCB>
    2e66:	90 91 5a 23 	lds	r25, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    2e6a:	02 96       	adiw	r24, 0x02	; 2
    2e6c:	23 db       	rcall	.-2490   	; 0x24b4 <uxListRemove>
    2e6e:	c0 0f       	add	r28, r16
    2e70:	d1 1f       	adc	r29, r17
    2e72:	e0 91 59 23 	lds	r30, 0x2359	; 0x802359 <pxCurrentTCB>
    2e76:	f0 91 5a 23 	lds	r31, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    2e7a:	c2 83       	std	Z+2, r28	; 0x02
    2e7c:	d3 83       	std	Z+3, r29	; 0x03
    2e7e:	c0 17       	cp	r28, r16
    2e80:	d1 07       	cpc	r29, r17
    2e82:	60 f4       	brcc	.+24     	; 0x2e9c <prvAddCurrentTaskToDelayedList+0x4c>
    2e84:	60 91 59 23 	lds	r22, 0x2359	; 0x802359 <pxCurrentTCB>
    2e88:	70 91 5a 23 	lds	r23, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    2e8c:	80 91 16 23 	lds	r24, 0x2316	; 0x802316 <pxOverflowDelayedTaskList>
    2e90:	90 91 17 23 	lds	r25, 0x2317	; 0x802317 <pxOverflowDelayedTaskList+0x1>
    2e94:	6e 5f       	subi	r22, 0xFE	; 254
    2e96:	7f 4f       	sbci	r23, 0xFF	; 255
    2e98:	dc da       	rcall	.-2632   	; 0x2452 <vListInsert>
    2e9a:	16 c0       	rjmp	.+44     	; 0x2ec8 <prvAddCurrentTaskToDelayedList+0x78>
    2e9c:	60 91 59 23 	lds	r22, 0x2359	; 0x802359 <pxCurrentTCB>
    2ea0:	70 91 5a 23 	lds	r23, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    2ea4:	80 91 18 23 	lds	r24, 0x2318	; 0x802318 <pxDelayedTaskList>
    2ea8:	90 91 19 23 	lds	r25, 0x2319	; 0x802319 <pxDelayedTaskList+0x1>
    2eac:	6e 5f       	subi	r22, 0xFE	; 254
    2eae:	7f 4f       	sbci	r23, 0xFF	; 255
    2eb0:	d0 da       	rcall	.-2656   	; 0x2452 <vListInsert>
    2eb2:	80 91 01 23 	lds	r24, 0x2301	; 0x802301 <xNextTaskUnblockTime>
    2eb6:	90 91 02 23 	lds	r25, 0x2302	; 0x802302 <xNextTaskUnblockTime+0x1>
    2eba:	c8 17       	cp	r28, r24
    2ebc:	d9 07       	cpc	r29, r25
    2ebe:	20 f4       	brcc	.+8      	; 0x2ec8 <prvAddCurrentTaskToDelayedList+0x78>
    2ec0:	c0 93 01 23 	sts	0x2301, r28	; 0x802301 <xNextTaskUnblockTime>
    2ec4:	d0 93 02 23 	sts	0x2302, r29	; 0x802302 <xNextTaskUnblockTime+0x1>
    2ec8:	df 91       	pop	r29
    2eca:	cf 91       	pop	r28
    2ecc:	1f 91       	pop	r17
    2ece:	0f 91       	pop	r16
    2ed0:	08 95       	ret

00002ed2 <xTaskCreate>:
    2ed2:	4f 92       	push	r4
    2ed4:	5f 92       	push	r5
    2ed6:	6f 92       	push	r6
    2ed8:	7f 92       	push	r7
    2eda:	8f 92       	push	r8
    2edc:	9f 92       	push	r9
    2ede:	af 92       	push	r10
    2ee0:	bf 92       	push	r11
    2ee2:	cf 92       	push	r12
    2ee4:	df 92       	push	r13
    2ee6:	ef 92       	push	r14
    2ee8:	ff 92       	push	r15
    2eea:	0f 93       	push	r16
    2eec:	1f 93       	push	r17
    2eee:	cf 93       	push	r28
    2ef0:	df 93       	push	r29
    2ef2:	4c 01       	movw	r8, r24
    2ef4:	6b 01       	movw	r12, r22
    2ef6:	5a 01       	movw	r10, r20
    2ef8:	29 01       	movw	r4, r18
    2efa:	ca 01       	movw	r24, r20
    2efc:	70 dc       	rcall	.-1824   	; 0x27de <pvPortMalloc>
    2efe:	3c 01       	movw	r6, r24
    2f00:	89 2b       	or	r24, r25
    2f02:	09 f4       	brne	.+2      	; 0x2f06 <xTaskCreate+0x34>
    2f04:	d3 c0       	rjmp	.+422    	; 0x30ac <xTaskCreate+0x1da>
    2f06:	86 e2       	ldi	r24, 0x26	; 38
    2f08:	90 e0       	ldi	r25, 0x00	; 0
    2f0a:	69 dc       	rcall	.-1838   	; 0x27de <pvPortMalloc>
    2f0c:	ec 01       	movw	r28, r24
    2f0e:	89 2b       	or	r24, r25
    2f10:	59 f0       	breq	.+22     	; 0x2f28 <xTaskCreate+0x56>
    2f12:	6f 8a       	std	Y+23, r6	; 0x17
    2f14:	78 8e       	std	Y+24, r7	; 0x18
    2f16:	81 e0       	ldi	r24, 0x01	; 1
    2f18:	a8 1a       	sub	r10, r24
    2f1a:	b1 08       	sbc	r11, r1
    2f1c:	a6 0c       	add	r10, r6
    2f1e:	b7 1c       	adc	r11, r7
    2f20:	c1 14       	cp	r12, r1
    2f22:	d1 04       	cpc	r13, r1
    2f24:	21 f4       	brne	.+8      	; 0x2f2e <xTaskCreate+0x5c>
    2f26:	1f c0       	rjmp	.+62     	; 0x2f66 <xTaskCreate+0x94>
    2f28:	c3 01       	movw	r24, r6
    2f2a:	66 dc       	rcall	.-1844   	; 0x27f8 <vPortFree>
    2f2c:	bf c0       	rjmp	.+382    	; 0x30ac <xTaskCreate+0x1da>
    2f2e:	d6 01       	movw	r26, r12
    2f30:	8c 91       	ld	r24, X
    2f32:	89 8f       	std	Y+25, r24	; 0x19
    2f34:	8c 91       	ld	r24, X
    2f36:	88 23       	and	r24, r24
    2f38:	a1 f0       	breq	.+40     	; 0x2f62 <xTaskCreate+0x90>
    2f3a:	ae 01       	movw	r20, r28
    2f3c:	46 5e       	subi	r20, 0xE6	; 230
    2f3e:	5f 4f       	sbci	r21, 0xFF	; 255
    2f40:	f6 01       	movw	r30, r12
    2f42:	31 96       	adiw	r30, 0x01	; 1
    2f44:	b8 e0       	ldi	r27, 0x08	; 8
    2f46:	cb 0e       	add	r12, r27
    2f48:	d1 1c       	adc	r13, r1
    2f4a:	cf 01       	movw	r24, r30
    2f4c:	21 91       	ld	r18, Z+
    2f4e:	da 01       	movw	r26, r20
    2f50:	2d 93       	st	X+, r18
    2f52:	ad 01       	movw	r20, r26
    2f54:	dc 01       	movw	r26, r24
    2f56:	8c 91       	ld	r24, X
    2f58:	88 23       	and	r24, r24
    2f5a:	19 f0       	breq	.+6      	; 0x2f62 <xTaskCreate+0x90>
    2f5c:	ce 16       	cp	r12, r30
    2f5e:	df 06       	cpc	r13, r31
    2f60:	a1 f7       	brne	.-24     	; 0x2f4a <xTaskCreate+0x78>
    2f62:	18 a2       	std	Y+32, r1	; 0x20
    2f64:	01 c0       	rjmp	.+2      	; 0x2f68 <xTaskCreate+0x96>
    2f66:	19 8e       	std	Y+25, r1	; 0x19
    2f68:	05 30       	cpi	r16, 0x05	; 5
    2f6a:	08 f0       	brcs	.+2      	; 0x2f6e <xTaskCreate+0x9c>
    2f6c:	04 e0       	ldi	r16, 0x04	; 4
    2f6e:	0e 8b       	std	Y+22, r16	; 0x16
    2f70:	6e 01       	movw	r12, r28
    2f72:	b2 e0       	ldi	r27, 0x02	; 2
    2f74:	cb 0e       	add	r12, r27
    2f76:	d1 1c       	adc	r13, r1
    2f78:	c6 01       	movw	r24, r12
    2f7a:	46 da       	rcall	.-2932   	; 0x2408 <vListInitialiseItem>
    2f7c:	ce 01       	movw	r24, r28
    2f7e:	0c 96       	adiw	r24, 0x0c	; 12
    2f80:	43 da       	rcall	.-2938   	; 0x2408 <vListInitialiseItem>
    2f82:	c8 87       	std	Y+8, r28	; 0x08
    2f84:	d9 87       	std	Y+9, r29	; 0x09
    2f86:	85 e0       	ldi	r24, 0x05	; 5
    2f88:	90 e0       	ldi	r25, 0x00	; 0
    2f8a:	80 1b       	sub	r24, r16
    2f8c:	91 09       	sbc	r25, r1
    2f8e:	8c 87       	std	Y+12, r24	; 0x0c
    2f90:	9d 87       	std	Y+13, r25	; 0x0d
    2f92:	ca 8b       	std	Y+18, r28	; 0x12
    2f94:	db 8b       	std	Y+19, r29	; 0x13
    2f96:	19 a2       	std	Y+33, r1	; 0x21
    2f98:	1a a2       	std	Y+34, r1	; 0x22
    2f9a:	1b a2       	std	Y+35, r1	; 0x23
    2f9c:	1c a2       	std	Y+36, r1	; 0x24
    2f9e:	1d a2       	std	Y+37, r1	; 0x25
    2fa0:	a2 01       	movw	r20, r4
    2fa2:	b4 01       	movw	r22, r8
    2fa4:	c5 01       	movw	r24, r10
    2fa6:	ad da       	rcall	.-2726   	; 0x2502 <pxPortInitialiseStack>
    2fa8:	88 83       	st	Y, r24
    2faa:	99 83       	std	Y+1, r25	; 0x01
    2fac:	e1 14       	cp	r14, r1
    2fae:	f1 04       	cpc	r15, r1
    2fb0:	19 f0       	breq	.+6      	; 0x2fb8 <xTaskCreate+0xe6>
    2fb2:	f7 01       	movw	r30, r14
    2fb4:	c0 83       	st	Z, r28
    2fb6:	d1 83       	std	Z+1, r29	; 0x01
    2fb8:	0f b6       	in	r0, 0x3f	; 63
    2fba:	f8 94       	cli
    2fbc:	0f 92       	push	r0
    2fbe:	80 91 0c 23 	lds	r24, 0x230C	; 0x80230c <uxCurrentNumberOfTasks>
    2fc2:	8f 5f       	subi	r24, 0xFF	; 255
    2fc4:	80 93 0c 23 	sts	0x230C, r24	; 0x80230c <uxCurrentNumberOfTasks>
    2fc8:	80 91 59 23 	lds	r24, 0x2359	; 0x802359 <pxCurrentTCB>
    2fcc:	90 91 5a 23 	lds	r25, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    2fd0:	89 2b       	or	r24, r25
    2fd2:	69 f5       	brne	.+90     	; 0x302e <xTaskCreate+0x15c>
    2fd4:	c0 93 59 23 	sts	0x2359, r28	; 0x802359 <pxCurrentTCB>
    2fd8:	d0 93 5a 23 	sts	0x235A, r29	; 0x80235a <pxCurrentTCB+0x1>
    2fdc:	80 91 0c 23 	lds	r24, 0x230C	; 0x80230c <uxCurrentNumberOfTasks>
    2fe0:	81 30       	cpi	r24, 0x01	; 1
    2fe2:	a9 f5       	brne	.+106    	; 0x304e <xTaskCreate+0x17c>
    2fe4:	0c e2       	ldi	r16, 0x2C	; 44
    2fe6:	13 e2       	ldi	r17, 0x23	; 35
    2fe8:	0f 2e       	mov	r0, r31
    2fea:	f9 e5       	ldi	r31, 0x59	; 89
    2fec:	ef 2e       	mov	r14, r31
    2fee:	f3 e2       	ldi	r31, 0x23	; 35
    2ff0:	ff 2e       	mov	r15, r31
    2ff2:	f0 2d       	mov	r31, r0
    2ff4:	c8 01       	movw	r24, r16
    2ff6:	fa d9       	rcall	.-3084   	; 0x23ec <vListInitialise>
    2ff8:	07 5f       	subi	r16, 0xF7	; 247
    2ffa:	1f 4f       	sbci	r17, 0xFF	; 255
    2ffc:	0e 15       	cp	r16, r14
    2ffe:	1f 05       	cpc	r17, r15
    3000:	c9 f7       	brne	.-14     	; 0x2ff4 <xTaskCreate+0x122>
    3002:	83 e2       	ldi	r24, 0x23	; 35
    3004:	93 e2       	ldi	r25, 0x23	; 35
    3006:	f2 d9       	rcall	.-3100   	; 0x23ec <vListInitialise>
    3008:	8a e1       	ldi	r24, 0x1A	; 26
    300a:	93 e2       	ldi	r25, 0x23	; 35
    300c:	ef d9       	rcall	.-3106   	; 0x23ec <vListInitialise>
    300e:	8d e0       	ldi	r24, 0x0D	; 13
    3010:	93 e2       	ldi	r25, 0x23	; 35
    3012:	ec d9       	rcall	.-3112   	; 0x23ec <vListInitialise>
    3014:	83 e2       	ldi	r24, 0x23	; 35
    3016:	93 e2       	ldi	r25, 0x23	; 35
    3018:	80 93 18 23 	sts	0x2318, r24	; 0x802318 <pxDelayedTaskList>
    301c:	90 93 19 23 	sts	0x2319, r25	; 0x802319 <pxDelayedTaskList+0x1>
    3020:	8a e1       	ldi	r24, 0x1A	; 26
    3022:	93 e2       	ldi	r25, 0x23	; 35
    3024:	80 93 16 23 	sts	0x2316, r24	; 0x802316 <pxOverflowDelayedTaskList>
    3028:	90 93 17 23 	sts	0x2317, r25	; 0x802317 <pxOverflowDelayedTaskList+0x1>
    302c:	10 c0       	rjmp	.+32     	; 0x304e <xTaskCreate+0x17c>
    302e:	80 91 08 23 	lds	r24, 0x2308	; 0x802308 <xSchedulerRunning>
    3032:	81 11       	cpse	r24, r1
    3034:	0c c0       	rjmp	.+24     	; 0x304e <xTaskCreate+0x17c>
    3036:	e0 91 59 23 	lds	r30, 0x2359	; 0x802359 <pxCurrentTCB>
    303a:	f0 91 5a 23 	lds	r31, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    303e:	96 89       	ldd	r25, Z+22	; 0x16
    3040:	8e 89       	ldd	r24, Y+22	; 0x16
    3042:	89 17       	cp	r24, r25
    3044:	20 f0       	brcs	.+8      	; 0x304e <xTaskCreate+0x17c>
    3046:	c0 93 59 23 	sts	0x2359, r28	; 0x802359 <pxCurrentTCB>
    304a:	d0 93 5a 23 	sts	0x235A, r29	; 0x80235a <pxCurrentTCB+0x1>
    304e:	80 91 03 23 	lds	r24, 0x2303	; 0x802303 <uxTaskNumber>
    3052:	8f 5f       	subi	r24, 0xFF	; 255
    3054:	80 93 03 23 	sts	0x2303, r24	; 0x802303 <uxTaskNumber>
    3058:	8e 89       	ldd	r24, Y+22	; 0x16
    305a:	90 91 09 23 	lds	r25, 0x2309	; 0x802309 <uxTopReadyPriority>
    305e:	98 17       	cp	r25, r24
    3060:	10 f4       	brcc	.+4      	; 0x3066 <xTaskCreate+0x194>
    3062:	80 93 09 23 	sts	0x2309, r24	; 0x802309 <uxTopReadyPriority>
    3066:	90 e0       	ldi	r25, 0x00	; 0
    3068:	9c 01       	movw	r18, r24
    306a:	22 0f       	add	r18, r18
    306c:	33 1f       	adc	r19, r19
    306e:	22 0f       	add	r18, r18
    3070:	33 1f       	adc	r19, r19
    3072:	22 0f       	add	r18, r18
    3074:	33 1f       	adc	r19, r19
    3076:	82 0f       	add	r24, r18
    3078:	93 1f       	adc	r25, r19
    307a:	b6 01       	movw	r22, r12
    307c:	84 5d       	subi	r24, 0xD4	; 212
    307e:	9c 4d       	sbci	r25, 0xDC	; 220
    3080:	c7 d9       	rcall	.-3186   	; 0x2410 <vListInsertEnd>
    3082:	0f 90       	pop	r0
    3084:	0f be       	out	0x3f, r0	; 63
    3086:	80 91 08 23 	lds	r24, 0x2308	; 0x802308 <xSchedulerRunning>
    308a:	88 23       	and	r24, r24
    308c:	59 f0       	breq	.+22     	; 0x30a4 <xTaskCreate+0x1d2>
    308e:	e0 91 59 23 	lds	r30, 0x2359	; 0x802359 <pxCurrentTCB>
    3092:	f0 91 5a 23 	lds	r31, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    3096:	96 89       	ldd	r25, Z+22	; 0x16
    3098:	8e 89       	ldd	r24, Y+22	; 0x16
    309a:	98 17       	cp	r25, r24
    309c:	28 f4       	brcc	.+10     	; 0x30a8 <xTaskCreate+0x1d6>
    309e:	ed da       	rcall	.-2598   	; 0x267a <vPortYield>
    30a0:	81 e0       	ldi	r24, 0x01	; 1
    30a2:	05 c0       	rjmp	.+10     	; 0x30ae <xTaskCreate+0x1dc>
    30a4:	81 e0       	ldi	r24, 0x01	; 1
    30a6:	03 c0       	rjmp	.+6      	; 0x30ae <xTaskCreate+0x1dc>
    30a8:	81 e0       	ldi	r24, 0x01	; 1
    30aa:	01 c0       	rjmp	.+2      	; 0x30ae <xTaskCreate+0x1dc>
    30ac:	8f ef       	ldi	r24, 0xFF	; 255
    30ae:	df 91       	pop	r29
    30b0:	cf 91       	pop	r28
    30b2:	1f 91       	pop	r17
    30b4:	0f 91       	pop	r16
    30b6:	ff 90       	pop	r15
    30b8:	ef 90       	pop	r14
    30ba:	df 90       	pop	r13
    30bc:	cf 90       	pop	r12
    30be:	bf 90       	pop	r11
    30c0:	af 90       	pop	r10
    30c2:	9f 90       	pop	r9
    30c4:	8f 90       	pop	r8
    30c6:	7f 90       	pop	r7
    30c8:	6f 90       	pop	r6
    30ca:	5f 90       	pop	r5
    30cc:	4f 90       	pop	r4
    30ce:	08 95       	ret

000030d0 <vTaskStartScheduler>:
    30d0:	ef 92       	push	r14
    30d2:	ff 92       	push	r15
    30d4:	0f 93       	push	r16
    30d6:	0f 2e       	mov	r0, r31
    30d8:	ff ef       	ldi	r31, 0xFF	; 255
    30da:	ef 2e       	mov	r14, r31
    30dc:	f2 e2       	ldi	r31, 0x22	; 34
    30de:	ff 2e       	mov	r15, r31
    30e0:	f0 2d       	mov	r31, r0
    30e2:	00 e0       	ldi	r16, 0x00	; 0
    30e4:	20 e0       	ldi	r18, 0x00	; 0
    30e6:	30 e0       	ldi	r19, 0x00	; 0
    30e8:	45 e5       	ldi	r20, 0x55	; 85
    30ea:	50 e0       	ldi	r21, 0x00	; 0
    30ec:	6d e0       	ldi	r22, 0x0D	; 13
    30ee:	70 e2       	ldi	r23, 0x20	; 32
    30f0:	81 e2       	ldi	r24, 0x21	; 33
    30f2:	97 e1       	ldi	r25, 0x17	; 23
    30f4:	ee de       	rcall	.-548    	; 0x2ed2 <xTaskCreate>
    30f6:	81 30       	cpi	r24, 0x01	; 1
    30f8:	91 f4       	brne	.+36     	; 0x311e <vTaskStartScheduler+0x4e>
    30fa:	e0 d2       	rcall	.+1472   	; 0x36bc <xTimerCreateTimerTask>
    30fc:	81 30       	cpi	r24, 0x01	; 1
    30fe:	79 f4       	brne	.+30     	; 0x311e <vTaskStartScheduler+0x4e>
    3100:	f8 94       	cli
    3102:	8f ef       	ldi	r24, 0xFF	; 255
    3104:	9f ef       	ldi	r25, 0xFF	; 255
    3106:	80 93 01 23 	sts	0x2301, r24	; 0x802301 <xNextTaskUnblockTime>
    310a:	90 93 02 23 	sts	0x2302, r25	; 0x802302 <xNextTaskUnblockTime+0x1>
    310e:	81 e0       	ldi	r24, 0x01	; 1
    3110:	80 93 08 23 	sts	0x2308, r24	; 0x802308 <xSchedulerRunning>
    3114:	10 92 0a 23 	sts	0x230A, r1	; 0x80230a <xTickCount>
    3118:	10 92 0b 23 	sts	0x230B, r1	; 0x80230b <xTickCount+0x1>
    311c:	69 da       	rcall	.-2862   	; 0x25f0 <xPortStartScheduler>
    311e:	0f 91       	pop	r16
    3120:	ff 90       	pop	r15
    3122:	ef 90       	pop	r14
    3124:	08 95       	ret

00003126 <vTaskSuspendAll>:
    3126:	80 91 fe 22 	lds	r24, 0x22FE	; 0x8022fe <uxSchedulerSuspended>
    312a:	8f 5f       	subi	r24, 0xFF	; 255
    312c:	80 93 fe 22 	sts	0x22FE, r24	; 0x8022fe <uxSchedulerSuspended>
    3130:	08 95       	ret

00003132 <xTaskGetTickCount>:
    3132:	0f b6       	in	r0, 0x3f	; 63
    3134:	f8 94       	cli
    3136:	0f 92       	push	r0
    3138:	80 91 0a 23 	lds	r24, 0x230A	; 0x80230a <xTickCount>
    313c:	90 91 0b 23 	lds	r25, 0x230B	; 0x80230b <xTickCount+0x1>
    3140:	0f 90       	pop	r0
    3142:	0f be       	out	0x3f, r0	; 63
    3144:	08 95       	ret

00003146 <xTaskIncrementTick>:
    3146:	df 92       	push	r13
    3148:	ef 92       	push	r14
    314a:	ff 92       	push	r15
    314c:	0f 93       	push	r16
    314e:	1f 93       	push	r17
    3150:	cf 93       	push	r28
    3152:	df 93       	push	r29
    3154:	80 91 fe 22 	lds	r24, 0x22FE	; 0x8022fe <uxSchedulerSuspended>
    3158:	81 11       	cpse	r24, r1
    315a:	9a c0       	rjmp	.+308    	; 0x3290 <xTaskIncrementTick+0x14a>
    315c:	e0 90 0a 23 	lds	r14, 0x230A	; 0x80230a <xTickCount>
    3160:	f0 90 0b 23 	lds	r15, 0x230B	; 0x80230b <xTickCount+0x1>
    3164:	8f ef       	ldi	r24, 0xFF	; 255
    3166:	e8 1a       	sub	r14, r24
    3168:	f8 0a       	sbc	r15, r24
    316a:	e0 92 0a 23 	sts	0x230A, r14	; 0x80230a <xTickCount>
    316e:	f0 92 0b 23 	sts	0x230B, r15	; 0x80230b <xTickCount+0x1>
    3172:	e1 14       	cp	r14, r1
    3174:	f1 04       	cpc	r15, r1
    3176:	b1 f4       	brne	.+44     	; 0x31a4 <xTaskIncrementTick+0x5e>
    3178:	80 91 18 23 	lds	r24, 0x2318	; 0x802318 <pxDelayedTaskList>
    317c:	90 91 19 23 	lds	r25, 0x2319	; 0x802319 <pxDelayedTaskList+0x1>
    3180:	20 91 16 23 	lds	r18, 0x2316	; 0x802316 <pxOverflowDelayedTaskList>
    3184:	30 91 17 23 	lds	r19, 0x2317	; 0x802317 <pxOverflowDelayedTaskList+0x1>
    3188:	20 93 18 23 	sts	0x2318, r18	; 0x802318 <pxDelayedTaskList>
    318c:	30 93 19 23 	sts	0x2319, r19	; 0x802319 <pxDelayedTaskList+0x1>
    3190:	80 93 16 23 	sts	0x2316, r24	; 0x802316 <pxOverflowDelayedTaskList>
    3194:	90 93 17 23 	sts	0x2317, r25	; 0x802317 <pxOverflowDelayedTaskList+0x1>
    3198:	80 91 04 23 	lds	r24, 0x2304	; 0x802304 <xNumOfOverflows>
    319c:	8f 5f       	subi	r24, 0xFF	; 255
    319e:	80 93 04 23 	sts	0x2304, r24	; 0x802304 <xNumOfOverflows>
    31a2:	30 de       	rcall	.-928    	; 0x2e04 <prvResetNextTaskUnblockTime>
    31a4:	80 91 01 23 	lds	r24, 0x2301	; 0x802301 <xNextTaskUnblockTime>
    31a8:	90 91 02 23 	lds	r25, 0x2302	; 0x802302 <xNextTaskUnblockTime+0x1>
    31ac:	e8 16       	cp	r14, r24
    31ae:	f9 06       	cpc	r15, r25
    31b0:	10 f4       	brcc	.+4      	; 0x31b6 <xTaskIncrementTick+0x70>
    31b2:	d1 2c       	mov	r13, r1
    31b4:	4f c0       	rjmp	.+158    	; 0x3254 <xTaskIncrementTick+0x10e>
    31b6:	d1 2c       	mov	r13, r1
    31b8:	e0 91 18 23 	lds	r30, 0x2318	; 0x802318 <pxDelayedTaskList>
    31bc:	f0 91 19 23 	lds	r31, 0x2319	; 0x802319 <pxDelayedTaskList+0x1>
    31c0:	80 81       	ld	r24, Z
    31c2:	81 11       	cpse	r24, r1
    31c4:	07 c0       	rjmp	.+14     	; 0x31d4 <xTaskIncrementTick+0x8e>
    31c6:	8f ef       	ldi	r24, 0xFF	; 255
    31c8:	9f ef       	ldi	r25, 0xFF	; 255
    31ca:	80 93 01 23 	sts	0x2301, r24	; 0x802301 <xNextTaskUnblockTime>
    31ce:	90 93 02 23 	sts	0x2302, r25	; 0x802302 <xNextTaskUnblockTime+0x1>
    31d2:	40 c0       	rjmp	.+128    	; 0x3254 <xTaskIncrementTick+0x10e>
    31d4:	e0 91 18 23 	lds	r30, 0x2318	; 0x802318 <pxDelayedTaskList>
    31d8:	f0 91 19 23 	lds	r31, 0x2319	; 0x802319 <pxDelayedTaskList+0x1>
    31dc:	05 80       	ldd	r0, Z+5	; 0x05
    31de:	f6 81       	ldd	r31, Z+6	; 0x06
    31e0:	e0 2d       	mov	r30, r0
    31e2:	c6 81       	ldd	r28, Z+6	; 0x06
    31e4:	d7 81       	ldd	r29, Z+7	; 0x07
    31e6:	8a 81       	ldd	r24, Y+2	; 0x02
    31e8:	9b 81       	ldd	r25, Y+3	; 0x03
    31ea:	e8 16       	cp	r14, r24
    31ec:	f9 06       	cpc	r15, r25
    31ee:	28 f4       	brcc	.+10     	; 0x31fa <xTaskIncrementTick+0xb4>
    31f0:	80 93 01 23 	sts	0x2301, r24	; 0x802301 <xNextTaskUnblockTime>
    31f4:	90 93 02 23 	sts	0x2302, r25	; 0x802302 <xNextTaskUnblockTime+0x1>
    31f8:	2d c0       	rjmp	.+90     	; 0x3254 <xTaskIncrementTick+0x10e>
    31fa:	8e 01       	movw	r16, r28
    31fc:	0e 5f       	subi	r16, 0xFE	; 254
    31fe:	1f 4f       	sbci	r17, 0xFF	; 255
    3200:	c8 01       	movw	r24, r16
    3202:	58 d9       	rcall	.-3408   	; 0x24b4 <uxListRemove>
    3204:	8c 89       	ldd	r24, Y+20	; 0x14
    3206:	9d 89       	ldd	r25, Y+21	; 0x15
    3208:	89 2b       	or	r24, r25
    320a:	19 f0       	breq	.+6      	; 0x3212 <xTaskIncrementTick+0xcc>
    320c:	ce 01       	movw	r24, r28
    320e:	0c 96       	adiw	r24, 0x0c	; 12
    3210:	51 d9       	rcall	.-3422   	; 0x24b4 <uxListRemove>
    3212:	8e 89       	ldd	r24, Y+22	; 0x16
    3214:	90 91 09 23 	lds	r25, 0x2309	; 0x802309 <uxTopReadyPriority>
    3218:	98 17       	cp	r25, r24
    321a:	10 f4       	brcc	.+4      	; 0x3220 <xTaskIncrementTick+0xda>
    321c:	80 93 09 23 	sts	0x2309, r24	; 0x802309 <uxTopReadyPriority>
    3220:	90 e0       	ldi	r25, 0x00	; 0
    3222:	9c 01       	movw	r18, r24
    3224:	22 0f       	add	r18, r18
    3226:	33 1f       	adc	r19, r19
    3228:	22 0f       	add	r18, r18
    322a:	33 1f       	adc	r19, r19
    322c:	22 0f       	add	r18, r18
    322e:	33 1f       	adc	r19, r19
    3230:	82 0f       	add	r24, r18
    3232:	93 1f       	adc	r25, r19
    3234:	b8 01       	movw	r22, r16
    3236:	84 5d       	subi	r24, 0xD4	; 212
    3238:	9c 4d       	sbci	r25, 0xDC	; 220
    323a:	ea d8       	rcall	.-3628   	; 0x2410 <vListInsertEnd>
    323c:	e0 91 59 23 	lds	r30, 0x2359	; 0x802359 <pxCurrentTCB>
    3240:	f0 91 5a 23 	lds	r31, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    3244:	9e 89       	ldd	r25, Y+22	; 0x16
    3246:	86 89       	ldd	r24, Z+22	; 0x16
    3248:	98 17       	cp	r25, r24
    324a:	08 f4       	brcc	.+2      	; 0x324e <xTaskIncrementTick+0x108>
    324c:	b5 cf       	rjmp	.-150    	; 0x31b8 <xTaskIncrementTick+0x72>
    324e:	dd 24       	eor	r13, r13
    3250:	d3 94       	inc	r13
    3252:	b2 cf       	rjmp	.-156    	; 0x31b8 <xTaskIncrementTick+0x72>
    3254:	e0 91 59 23 	lds	r30, 0x2359	; 0x802359 <pxCurrentTCB>
    3258:	f0 91 5a 23 	lds	r31, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    325c:	86 89       	ldd	r24, Z+22	; 0x16
    325e:	90 e0       	ldi	r25, 0x00	; 0
    3260:	fc 01       	movw	r30, r24
    3262:	ee 0f       	add	r30, r30
    3264:	ff 1f       	adc	r31, r31
    3266:	ee 0f       	add	r30, r30
    3268:	ff 1f       	adc	r31, r31
    326a:	ee 0f       	add	r30, r30
    326c:	ff 1f       	adc	r31, r31
    326e:	8e 0f       	add	r24, r30
    3270:	9f 1f       	adc	r25, r31
    3272:	fc 01       	movw	r30, r24
    3274:	e4 5d       	subi	r30, 0xD4	; 212
    3276:	fc 4d       	sbci	r31, 0xDC	; 220
    3278:	80 81       	ld	r24, Z
    327a:	82 30       	cpi	r24, 0x02	; 2
    327c:	10 f0       	brcs	.+4      	; 0x3282 <xTaskIncrementTick+0x13c>
    327e:	dd 24       	eor	r13, r13
    3280:	d3 94       	inc	r13
    3282:	80 91 05 23 	lds	r24, 0x2305	; 0x802305 <xYieldPending>
    3286:	88 23       	and	r24, r24
    3288:	69 f0       	breq	.+26     	; 0x32a4 <xTaskIncrementTick+0x15e>
    328a:	dd 24       	eor	r13, r13
    328c:	d3 94       	inc	r13
    328e:	0a c0       	rjmp	.+20     	; 0x32a4 <xTaskIncrementTick+0x15e>
    3290:	80 91 06 23 	lds	r24, 0x2306	; 0x802306 <xPendedTicks>
    3294:	90 91 07 23 	lds	r25, 0x2307	; 0x802307 <xPendedTicks+0x1>
    3298:	01 96       	adiw	r24, 0x01	; 1
    329a:	80 93 06 23 	sts	0x2306, r24	; 0x802306 <xPendedTicks>
    329e:	90 93 07 23 	sts	0x2307, r25	; 0x802307 <xPendedTicks+0x1>
    32a2:	d1 2c       	mov	r13, r1
    32a4:	8d 2d       	mov	r24, r13
    32a6:	df 91       	pop	r29
    32a8:	cf 91       	pop	r28
    32aa:	1f 91       	pop	r17
    32ac:	0f 91       	pop	r16
    32ae:	ff 90       	pop	r15
    32b0:	ef 90       	pop	r14
    32b2:	df 90       	pop	r13
    32b4:	08 95       	ret

000032b6 <xTaskResumeAll>:
    32b6:	df 92       	push	r13
    32b8:	ef 92       	push	r14
    32ba:	ff 92       	push	r15
    32bc:	0f 93       	push	r16
    32be:	1f 93       	push	r17
    32c0:	cf 93       	push	r28
    32c2:	df 93       	push	r29
    32c4:	0f b6       	in	r0, 0x3f	; 63
    32c6:	f8 94       	cli
    32c8:	0f 92       	push	r0
    32ca:	80 91 fe 22 	lds	r24, 0x22FE	; 0x8022fe <uxSchedulerSuspended>
    32ce:	81 50       	subi	r24, 0x01	; 1
    32d0:	80 93 fe 22 	sts	0x22FE, r24	; 0x8022fe <uxSchedulerSuspended>
    32d4:	80 91 fe 22 	lds	r24, 0x22FE	; 0x8022fe <uxSchedulerSuspended>
    32d8:	81 11       	cpse	r24, r1
    32da:	5d c0       	rjmp	.+186    	; 0x3396 <xTaskResumeAll+0xe0>
    32dc:	80 91 0c 23 	lds	r24, 0x230C	; 0x80230c <uxCurrentNumberOfTasks>
    32e0:	81 11       	cpse	r24, r1
    32e2:	30 c0       	rjmp	.+96     	; 0x3344 <xTaskResumeAll+0x8e>
    32e4:	5b c0       	rjmp	.+182    	; 0x339c <xTaskResumeAll+0xe6>
    32e6:	d7 01       	movw	r26, r14
    32e8:	15 96       	adiw	r26, 0x05	; 5
    32ea:	ed 91       	ld	r30, X+
    32ec:	fc 91       	ld	r31, X
    32ee:	16 97       	sbiw	r26, 0x06	; 6
    32f0:	c6 81       	ldd	r28, Z+6	; 0x06
    32f2:	d7 81       	ldd	r29, Z+7	; 0x07
    32f4:	ce 01       	movw	r24, r28
    32f6:	0c 96       	adiw	r24, 0x0c	; 12
    32f8:	dd d8       	rcall	.-3654   	; 0x24b4 <uxListRemove>
    32fa:	8e 01       	movw	r16, r28
    32fc:	0e 5f       	subi	r16, 0xFE	; 254
    32fe:	1f 4f       	sbci	r17, 0xFF	; 255
    3300:	c8 01       	movw	r24, r16
    3302:	d8 d8       	rcall	.-3664   	; 0x24b4 <uxListRemove>
    3304:	8e 89       	ldd	r24, Y+22	; 0x16
    3306:	90 91 09 23 	lds	r25, 0x2309	; 0x802309 <uxTopReadyPriority>
    330a:	98 17       	cp	r25, r24
    330c:	10 f4       	brcc	.+4      	; 0x3312 <xTaskResumeAll+0x5c>
    330e:	80 93 09 23 	sts	0x2309, r24	; 0x802309 <uxTopReadyPriority>
    3312:	90 e0       	ldi	r25, 0x00	; 0
    3314:	9c 01       	movw	r18, r24
    3316:	22 0f       	add	r18, r18
    3318:	33 1f       	adc	r19, r19
    331a:	22 0f       	add	r18, r18
    331c:	33 1f       	adc	r19, r19
    331e:	22 0f       	add	r18, r18
    3320:	33 1f       	adc	r19, r19
    3322:	82 0f       	add	r24, r18
    3324:	93 1f       	adc	r25, r19
    3326:	b8 01       	movw	r22, r16
    3328:	84 5d       	subi	r24, 0xD4	; 212
    332a:	9c 4d       	sbci	r25, 0xDC	; 220
    332c:	71 d8       	rcall	.-3870   	; 0x2410 <vListInsertEnd>
    332e:	e0 91 59 23 	lds	r30, 0x2359	; 0x802359 <pxCurrentTCB>
    3332:	f0 91 5a 23 	lds	r31, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    3336:	9e 89       	ldd	r25, Y+22	; 0x16
    3338:	86 89       	ldd	r24, Z+22	; 0x16
    333a:	98 17       	cp	r25, r24
    333c:	68 f0       	brcs	.+26     	; 0x3358 <xTaskResumeAll+0xa2>
    333e:	d0 92 05 23 	sts	0x2305, r13	; 0x802305 <xYieldPending>
    3342:	0a c0       	rjmp	.+20     	; 0x3358 <xTaskResumeAll+0xa2>
    3344:	c0 e0       	ldi	r28, 0x00	; 0
    3346:	d0 e0       	ldi	r29, 0x00	; 0
    3348:	0f 2e       	mov	r0, r31
    334a:	fd e0       	ldi	r31, 0x0D	; 13
    334c:	ef 2e       	mov	r14, r31
    334e:	f3 e2       	ldi	r31, 0x23	; 35
    3350:	ff 2e       	mov	r15, r31
    3352:	f0 2d       	mov	r31, r0
    3354:	dd 24       	eor	r13, r13
    3356:	d3 94       	inc	r13
    3358:	f7 01       	movw	r30, r14
    335a:	80 81       	ld	r24, Z
    335c:	81 11       	cpse	r24, r1
    335e:	c3 cf       	rjmp	.-122    	; 0x32e6 <xTaskResumeAll+0x30>
    3360:	cd 2b       	or	r28, r29
    3362:	09 f0       	breq	.+2      	; 0x3366 <xTaskResumeAll+0xb0>
    3364:	4f dd       	rcall	.-1378   	; 0x2e04 <prvResetNextTaskUnblockTime>
    3366:	c0 91 06 23 	lds	r28, 0x2306	; 0x802306 <xPendedTicks>
    336a:	d0 91 07 23 	lds	r29, 0x2307	; 0x802307 <xPendedTicks+0x1>
    336e:	20 97       	sbiw	r28, 0x00	; 0
    3370:	59 f0       	breq	.+22     	; 0x3388 <xTaskResumeAll+0xd2>
    3372:	11 e0       	ldi	r17, 0x01	; 1
    3374:	e8 de       	rcall	.-560    	; 0x3146 <xTaskIncrementTick>
    3376:	81 11       	cpse	r24, r1
    3378:	10 93 05 23 	sts	0x2305, r17	; 0x802305 <xYieldPending>
    337c:	21 97       	sbiw	r28, 0x01	; 1
    337e:	d1 f7       	brne	.-12     	; 0x3374 <xTaskResumeAll+0xbe>
    3380:	10 92 06 23 	sts	0x2306, r1	; 0x802306 <xPendedTicks>
    3384:	10 92 07 23 	sts	0x2307, r1	; 0x802307 <xPendedTicks+0x1>
    3388:	80 91 05 23 	lds	r24, 0x2305	; 0x802305 <xYieldPending>
    338c:	88 23       	and	r24, r24
    338e:	29 f0       	breq	.+10     	; 0x339a <xTaskResumeAll+0xe4>
    3390:	74 d9       	rcall	.-3352   	; 0x267a <vPortYield>
    3392:	81 e0       	ldi	r24, 0x01	; 1
    3394:	03 c0       	rjmp	.+6      	; 0x339c <xTaskResumeAll+0xe6>
    3396:	80 e0       	ldi	r24, 0x00	; 0
    3398:	01 c0       	rjmp	.+2      	; 0x339c <xTaskResumeAll+0xe6>
    339a:	80 e0       	ldi	r24, 0x00	; 0
    339c:	0f 90       	pop	r0
    339e:	0f be       	out	0x3f, r0	; 63
    33a0:	df 91       	pop	r29
    33a2:	cf 91       	pop	r28
    33a4:	1f 91       	pop	r17
    33a6:	0f 91       	pop	r16
    33a8:	ff 90       	pop	r15
    33aa:	ef 90       	pop	r14
    33ac:	df 90       	pop	r13
    33ae:	08 95       	ret

000033b0 <vTaskDelay>:
    33b0:	cf 93       	push	r28
    33b2:	df 93       	push	r29
    33b4:	ec 01       	movw	r28, r24
    33b6:	89 2b       	or	r24, r25
    33b8:	39 f0       	breq	.+14     	; 0x33c8 <vTaskDelay+0x18>
    33ba:	b5 de       	rcall	.-662    	; 0x3126 <vTaskSuspendAll>
    33bc:	60 e0       	ldi	r22, 0x00	; 0
    33be:	ce 01       	movw	r24, r28
    33c0:	47 dd       	rcall	.-1394   	; 0x2e50 <prvAddCurrentTaskToDelayedList>
    33c2:	79 df       	rcall	.-270    	; 0x32b6 <xTaskResumeAll>
    33c4:	81 11       	cpse	r24, r1
    33c6:	01 c0       	rjmp	.+2      	; 0x33ca <vTaskDelay+0x1a>
    33c8:	58 d9       	rcall	.-3408   	; 0x267a <vPortYield>
    33ca:	df 91       	pop	r29
    33cc:	cf 91       	pop	r28
    33ce:	08 95       	ret

000033d0 <vTaskSwitchContext>:
    33d0:	80 91 fe 22 	lds	r24, 0x22FE	; 0x8022fe <uxSchedulerSuspended>
    33d4:	88 23       	and	r24, r24
    33d6:	21 f0       	breq	.+8      	; 0x33e0 <vTaskSwitchContext+0x10>
    33d8:	81 e0       	ldi	r24, 0x01	; 1
    33da:	80 93 05 23 	sts	0x2305, r24	; 0x802305 <xYieldPending>
    33de:	08 95       	ret
    33e0:	10 92 05 23 	sts	0x2305, r1	; 0x802305 <xYieldPending>
    33e4:	20 91 09 23 	lds	r18, 0x2309	; 0x802309 <uxTopReadyPriority>
    33e8:	82 2f       	mov	r24, r18
    33ea:	90 e0       	ldi	r25, 0x00	; 0
    33ec:	fc 01       	movw	r30, r24
    33ee:	ee 0f       	add	r30, r30
    33f0:	ff 1f       	adc	r31, r31
    33f2:	ee 0f       	add	r30, r30
    33f4:	ff 1f       	adc	r31, r31
    33f6:	ee 0f       	add	r30, r30
    33f8:	ff 1f       	adc	r31, r31
    33fa:	e8 0f       	add	r30, r24
    33fc:	f9 1f       	adc	r31, r25
    33fe:	e4 5d       	subi	r30, 0xD4	; 212
    3400:	fc 4d       	sbci	r31, 0xDC	; 220
    3402:	30 81       	ld	r19, Z
    3404:	31 11       	cpse	r19, r1
    3406:	11 c0       	rjmp	.+34     	; 0x342a <vTaskSwitchContext+0x5a>
    3408:	21 50       	subi	r18, 0x01	; 1
    340a:	82 2f       	mov	r24, r18
    340c:	90 e0       	ldi	r25, 0x00	; 0
    340e:	fc 01       	movw	r30, r24
    3410:	ee 0f       	add	r30, r30
    3412:	ff 1f       	adc	r31, r31
    3414:	ee 0f       	add	r30, r30
    3416:	ff 1f       	adc	r31, r31
    3418:	ee 0f       	add	r30, r30
    341a:	ff 1f       	adc	r31, r31
    341c:	e8 0f       	add	r30, r24
    341e:	f9 1f       	adc	r31, r25
    3420:	e4 5d       	subi	r30, 0xD4	; 212
    3422:	fc 4d       	sbci	r31, 0xDC	; 220
    3424:	30 81       	ld	r19, Z
    3426:	33 23       	and	r19, r19
    3428:	79 f3       	breq	.-34     	; 0x3408 <vTaskSwitchContext+0x38>
    342a:	ac 01       	movw	r20, r24
    342c:	44 0f       	add	r20, r20
    342e:	55 1f       	adc	r21, r21
    3430:	44 0f       	add	r20, r20
    3432:	55 1f       	adc	r21, r21
    3434:	44 0f       	add	r20, r20
    3436:	55 1f       	adc	r21, r21
    3438:	48 0f       	add	r20, r24
    343a:	59 1f       	adc	r21, r25
    343c:	da 01       	movw	r26, r20
    343e:	a4 5d       	subi	r26, 0xD4	; 212
    3440:	bc 4d       	sbci	r27, 0xDC	; 220
    3442:	11 96       	adiw	r26, 0x01	; 1
    3444:	ed 91       	ld	r30, X+
    3446:	fc 91       	ld	r31, X
    3448:	12 97       	sbiw	r26, 0x02	; 2
    344a:	02 80       	ldd	r0, Z+2	; 0x02
    344c:	f3 81       	ldd	r31, Z+3	; 0x03
    344e:	e0 2d       	mov	r30, r0
    3450:	11 96       	adiw	r26, 0x01	; 1
    3452:	ed 93       	st	X+, r30
    3454:	fc 93       	st	X, r31
    3456:	12 97       	sbiw	r26, 0x02	; 2
    3458:	41 5d       	subi	r20, 0xD1	; 209
    345a:	5c 4d       	sbci	r21, 0xDC	; 220
    345c:	e4 17       	cp	r30, r20
    345e:	f5 07       	cpc	r31, r21
    3460:	29 f4       	brne	.+10     	; 0x346c <vTaskSwitchContext+0x9c>
    3462:	42 81       	ldd	r20, Z+2	; 0x02
    3464:	53 81       	ldd	r21, Z+3	; 0x03
    3466:	fd 01       	movw	r30, r26
    3468:	41 83       	std	Z+1, r20	; 0x01
    346a:	52 83       	std	Z+2, r21	; 0x02
    346c:	fc 01       	movw	r30, r24
    346e:	ee 0f       	add	r30, r30
    3470:	ff 1f       	adc	r31, r31
    3472:	ee 0f       	add	r30, r30
    3474:	ff 1f       	adc	r31, r31
    3476:	ee 0f       	add	r30, r30
    3478:	ff 1f       	adc	r31, r31
    347a:	8e 0f       	add	r24, r30
    347c:	9f 1f       	adc	r25, r31
    347e:	fc 01       	movw	r30, r24
    3480:	e4 5d       	subi	r30, 0xD4	; 212
    3482:	fc 4d       	sbci	r31, 0xDC	; 220
    3484:	01 80       	ldd	r0, Z+1	; 0x01
    3486:	f2 81       	ldd	r31, Z+2	; 0x02
    3488:	e0 2d       	mov	r30, r0
    348a:	86 81       	ldd	r24, Z+6	; 0x06
    348c:	97 81       	ldd	r25, Z+7	; 0x07
    348e:	80 93 59 23 	sts	0x2359, r24	; 0x802359 <pxCurrentTCB>
    3492:	90 93 5a 23 	sts	0x235A, r25	; 0x80235a <pxCurrentTCB+0x1>
    3496:	20 93 09 23 	sts	0x2309, r18	; 0x802309 <uxTopReadyPriority>
    349a:	08 95       	ret

0000349c <vTaskPlaceOnEventList>:
    349c:	cf 93       	push	r28
    349e:	df 93       	push	r29
    34a0:	eb 01       	movw	r28, r22
    34a2:	60 91 59 23 	lds	r22, 0x2359	; 0x802359 <pxCurrentTCB>
    34a6:	70 91 5a 23 	lds	r23, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    34aa:	64 5f       	subi	r22, 0xF4	; 244
    34ac:	7f 4f       	sbci	r23, 0xFF	; 255
    34ae:	0e 94 29 12 	call	0x2452	; 0x2452 <vListInsert>
    34b2:	61 e0       	ldi	r22, 0x01	; 1
    34b4:	ce 01       	movw	r24, r28
    34b6:	cc dc       	rcall	.-1640   	; 0x2e50 <prvAddCurrentTaskToDelayedList>
    34b8:	df 91       	pop	r29
    34ba:	cf 91       	pop	r28
    34bc:	08 95       	ret

000034be <vTaskPlaceOnEventListRestricted>:
    34be:	0f 93       	push	r16
    34c0:	1f 93       	push	r17
    34c2:	cf 93       	push	r28
    34c4:	8b 01       	movw	r16, r22
    34c6:	c4 2f       	mov	r28, r20
    34c8:	60 91 59 23 	lds	r22, 0x2359	; 0x802359 <pxCurrentTCB>
    34cc:	70 91 5a 23 	lds	r23, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    34d0:	64 5f       	subi	r22, 0xF4	; 244
    34d2:	7f 4f       	sbci	r23, 0xFF	; 255
    34d4:	0e 94 08 12 	call	0x2410	; 0x2410 <vListInsertEnd>
    34d8:	cc 23       	and	r28, r28
    34da:	11 f0       	breq	.+4      	; 0x34e0 <vTaskPlaceOnEventListRestricted+0x22>
    34dc:	0f ef       	ldi	r16, 0xFF	; 255
    34de:	1f ef       	ldi	r17, 0xFF	; 255
    34e0:	6c 2f       	mov	r22, r28
    34e2:	c8 01       	movw	r24, r16
    34e4:	b5 dc       	rcall	.-1686   	; 0x2e50 <prvAddCurrentTaskToDelayedList>
    34e6:	cf 91       	pop	r28
    34e8:	1f 91       	pop	r17
    34ea:	0f 91       	pop	r16
    34ec:	08 95       	ret

000034ee <xTaskRemoveFromEventList>:
    34ee:	0f 93       	push	r16
    34f0:	1f 93       	push	r17
    34f2:	cf 93       	push	r28
    34f4:	df 93       	push	r29
    34f6:	dc 01       	movw	r26, r24
    34f8:	15 96       	adiw	r26, 0x05	; 5
    34fa:	ed 91       	ld	r30, X+
    34fc:	fc 91       	ld	r31, X
    34fe:	16 97       	sbiw	r26, 0x06	; 6
    3500:	c6 81       	ldd	r28, Z+6	; 0x06
    3502:	d7 81       	ldd	r29, Z+7	; 0x07
    3504:	8e 01       	movw	r16, r28
    3506:	04 5f       	subi	r16, 0xF4	; 244
    3508:	1f 4f       	sbci	r17, 0xFF	; 255
    350a:	c8 01       	movw	r24, r16
    350c:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <uxListRemove>
    3510:	80 91 fe 22 	lds	r24, 0x22FE	; 0x8022fe <uxSchedulerSuspended>
    3514:	81 11       	cpse	r24, r1
    3516:	1c c0       	rjmp	.+56     	; 0x3550 <xTaskRemoveFromEventList+0x62>
    3518:	0a 50       	subi	r16, 0x0A	; 10
    351a:	11 09       	sbc	r17, r1
    351c:	c8 01       	movw	r24, r16
    351e:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <uxListRemove>
    3522:	8e 89       	ldd	r24, Y+22	; 0x16
    3524:	90 91 09 23 	lds	r25, 0x2309	; 0x802309 <uxTopReadyPriority>
    3528:	98 17       	cp	r25, r24
    352a:	10 f4       	brcc	.+4      	; 0x3530 <xTaskRemoveFromEventList+0x42>
    352c:	80 93 09 23 	sts	0x2309, r24	; 0x802309 <uxTopReadyPriority>
    3530:	90 e0       	ldi	r25, 0x00	; 0
    3532:	9c 01       	movw	r18, r24
    3534:	22 0f       	add	r18, r18
    3536:	33 1f       	adc	r19, r19
    3538:	22 0f       	add	r18, r18
    353a:	33 1f       	adc	r19, r19
    353c:	22 0f       	add	r18, r18
    353e:	33 1f       	adc	r19, r19
    3540:	82 0f       	add	r24, r18
    3542:	93 1f       	adc	r25, r19
    3544:	b8 01       	movw	r22, r16
    3546:	84 5d       	subi	r24, 0xD4	; 212
    3548:	9c 4d       	sbci	r25, 0xDC	; 220
    354a:	0e 94 08 12 	call	0x2410	; 0x2410 <vListInsertEnd>
    354e:	05 c0       	rjmp	.+10     	; 0x355a <xTaskRemoveFromEventList+0x6c>
    3550:	b8 01       	movw	r22, r16
    3552:	8d e0       	ldi	r24, 0x0D	; 13
    3554:	93 e2       	ldi	r25, 0x23	; 35
    3556:	0e 94 08 12 	call	0x2410	; 0x2410 <vListInsertEnd>
    355a:	e0 91 59 23 	lds	r30, 0x2359	; 0x802359 <pxCurrentTCB>
    355e:	f0 91 5a 23 	lds	r31, 0x235A	; 0x80235a <pxCurrentTCB+0x1>
    3562:	9e 89       	ldd	r25, Y+22	; 0x16
    3564:	86 89       	ldd	r24, Z+22	; 0x16
    3566:	89 17       	cp	r24, r25
    3568:	20 f4       	brcc	.+8      	; 0x3572 <xTaskRemoveFromEventList+0x84>
    356a:	81 e0       	ldi	r24, 0x01	; 1
    356c:	80 93 05 23 	sts	0x2305, r24	; 0x802305 <xYieldPending>
    3570:	01 c0       	rjmp	.+2      	; 0x3574 <xTaskRemoveFromEventList+0x86>
    3572:	80 e0       	ldi	r24, 0x00	; 0
    3574:	df 91       	pop	r29
    3576:	cf 91       	pop	r28
    3578:	1f 91       	pop	r17
    357a:	0f 91       	pop	r16
    357c:	08 95       	ret

0000357e <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    357e:	20 91 04 23 	lds	r18, 0x2304	; 0x802304 <xNumOfOverflows>
    3582:	fc 01       	movw	r30, r24
    3584:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    3586:	20 91 0a 23 	lds	r18, 0x230A	; 0x80230a <xTickCount>
    358a:	30 91 0b 23 	lds	r19, 0x230B	; 0x80230b <xTickCount+0x1>
    358e:	21 83       	std	Z+1, r18	; 0x01
    3590:	32 83       	std	Z+2, r19	; 0x02
    3592:	08 95       	ret

00003594 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3594:	0f b6       	in	r0, 0x3f	; 63
    3596:	f8 94       	cli
    3598:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    359a:	20 91 0a 23 	lds	r18, 0x230A	; 0x80230a <xTickCount>
    359e:	30 91 0b 23 	lds	r19, 0x230B	; 0x80230b <xTickCount+0x1>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    35a2:	dc 01       	movw	r26, r24
    35a4:	11 96       	adiw	r26, 0x01	; 1
    35a6:	4d 91       	ld	r20, X+
    35a8:	5c 91       	ld	r21, X
    35aa:	12 97       	sbiw	r26, 0x02	; 2
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    35ac:	e0 91 04 23 	lds	r30, 0x2304	; 0x802304 <xNumOfOverflows>
    35b0:	fc 91       	ld	r31, X
    35b2:	fe 17       	cp	r31, r30
    35b4:	19 f0       	breq	.+6      	; 0x35bc <xTaskCheckForTimeOut+0x28>
    35b6:	24 17       	cp	r18, r20
    35b8:	35 07       	cpc	r19, r21
    35ba:	98 f4       	brcc	.+38     	; 0x35e2 <xTaskCheckForTimeOut+0x4e>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    35bc:	24 1b       	sub	r18, r20
    35be:	35 0b       	sbc	r19, r21
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    35c0:	fb 01       	movw	r30, r22
    35c2:	40 81       	ld	r20, Z
    35c4:	51 81       	ldd	r21, Z+1	; 0x01
    35c6:	24 17       	cp	r18, r20
    35c8:	35 07       	cpc	r19, r21
    35ca:	38 f4       	brcc	.+14     	; 0x35da <xTaskCheckForTimeOut+0x46>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    35cc:	42 1b       	sub	r20, r18
    35ce:	53 0b       	sbc	r21, r19
    35d0:	40 83       	st	Z, r20
    35d2:	51 83       	std	Z+1, r21	; 0x01
			vTaskInternalSetTimeOutState( pxTimeOut );
    35d4:	d4 df       	rcall	.-88     	; 0x357e <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    35d6:	80 e0       	ldi	r24, 0x00	; 0
    35d8:	05 c0       	rjmp	.+10     	; 0x35e4 <xTaskCheckForTimeOut+0x50>
		}
		else
		{
			*pxTicksToWait = 0;
    35da:	10 82       	st	Z, r1
    35dc:	11 82       	std	Z+1, r1	; 0x01
			xReturn = pdTRUE;
    35de:	81 e0       	ldi	r24, 0x01	; 1
    35e0:	01 c0       	rjmp	.+2      	; 0x35e4 <xTaskCheckForTimeOut+0x50>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    35e2:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    35e4:	0f 90       	pop	r0
    35e6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    35e8:	08 95       	ret

000035ea <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    35ea:	81 e0       	ldi	r24, 0x01	; 1
    35ec:	80 93 05 23 	sts	0x2305, r24	; 0x802305 <xYieldPending>
    35f0:	08 95       	ret

000035f2 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    35f2:	80 91 08 23 	lds	r24, 0x2308	; 0x802308 <xSchedulerRunning>
    35f6:	88 23       	and	r24, r24
    35f8:	31 f0       	breq	.+12     	; 0x3606 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    35fa:	80 91 fe 22 	lds	r24, 0x22FE	; 0x8022fe <uxSchedulerSuspended>
    35fe:	88 23       	and	r24, r24
    3600:	21 f0       	breq	.+8      	; 0x360a <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    3602:	80 e0       	ldi	r24, 0x00	; 0
    3604:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    3606:	81 e0       	ldi	r24, 0x01	; 1
    3608:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    360a:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    360c:	08 95       	ret

0000360e <prvInsertTimerInActiveList>:
			pxNewTimer->ucStatus = 0x00;
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
		}

		return pxNewTimer;
	}
    360e:	fc 01       	movw	r30, r24
    3610:	62 83       	std	Z+2, r22	; 0x02
    3612:	73 83       	std	Z+3, r23	; 0x03
    3614:	80 87       	std	Z+8, r24	; 0x08
    3616:	91 87       	std	Z+9, r25	; 0x09
    3618:	46 17       	cp	r20, r22
    361a:	57 07       	cpc	r21, r23
    361c:	90 f0       	brcs	.+36     	; 0x3642 <prvInsertTimerInActiveList+0x34>
    361e:	42 1b       	sub	r20, r18
    3620:	53 0b       	sbc	r21, r19
    3622:	84 85       	ldd	r24, Z+12	; 0x0c
    3624:	95 85       	ldd	r25, Z+13	; 0x0d
    3626:	48 17       	cp	r20, r24
    3628:	59 07       	cpc	r21, r25
    362a:	e0 f4       	brcc	.+56     	; 0x3664 <prvInsertTimerInActiveList+0x56>
    362c:	bf 01       	movw	r22, r30
    362e:	6e 5f       	subi	r22, 0xFE	; 254
    3630:	7f 4f       	sbci	r23, 0xFF	; 255
    3632:	80 91 61 23 	lds	r24, 0x2361	; 0x802361 <pxOverflowTimerList>
    3636:	90 91 62 23 	lds	r25, 0x2362	; 0x802362 <pxOverflowTimerList+0x1>
    363a:	0e 94 29 12 	call	0x2452	; 0x2452 <vListInsert>
    363e:	80 e0       	ldi	r24, 0x00	; 0
    3640:	08 95       	ret
    3642:	42 17       	cp	r20, r18
    3644:	53 07       	cpc	r21, r19
    3646:	18 f4       	brcc	.+6      	; 0x364e <prvInsertTimerInActiveList+0x40>
    3648:	62 17       	cp	r22, r18
    364a:	73 07       	cpc	r23, r19
    364c:	68 f4       	brcc	.+26     	; 0x3668 <prvInsertTimerInActiveList+0x5a>
    364e:	bf 01       	movw	r22, r30
    3650:	6e 5f       	subi	r22, 0xFE	; 254
    3652:	7f 4f       	sbci	r23, 0xFF	; 255
    3654:	80 91 63 23 	lds	r24, 0x2363	; 0x802363 <pxCurrentTimerList>
    3658:	90 91 64 23 	lds	r25, 0x2364	; 0x802364 <pxCurrentTimerList+0x1>
    365c:	0e 94 29 12 	call	0x2452	; 0x2452 <vListInsert>
    3660:	80 e0       	ldi	r24, 0x00	; 0
    3662:	08 95       	ret
    3664:	81 e0       	ldi	r24, 0x01	; 1
    3666:	08 95       	ret
    3668:	81 e0       	ldi	r24, 0x01	; 1
    366a:	08 95       	ret

0000366c <prvCheckForValidListAndQueue>:
    366c:	0f b6       	in	r0, 0x3f	; 63
    366e:	f8 94       	cli
    3670:	0f 92       	push	r0
    3672:	80 91 5f 23 	lds	r24, 0x235F	; 0x80235f <xTimerQueue>
    3676:	90 91 60 23 	lds	r25, 0x2360	; 0x802360 <xTimerQueue+0x1>
    367a:	89 2b       	or	r24, r25
    367c:	e1 f4       	brne	.+56     	; 0x36b6 <prvCheckForValidListAndQueue+0x4a>
    367e:	8e e6       	ldi	r24, 0x6E	; 110
    3680:	93 e2       	ldi	r25, 0x23	; 35
    3682:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInitialise>
    3686:	85 e6       	ldi	r24, 0x65	; 101
    3688:	93 e2       	ldi	r25, 0x23	; 35
    368a:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vListInitialise>
    368e:	8e e6       	ldi	r24, 0x6E	; 110
    3690:	93 e2       	ldi	r25, 0x23	; 35
    3692:	80 93 63 23 	sts	0x2363, r24	; 0x802363 <pxCurrentTimerList>
    3696:	90 93 64 23 	sts	0x2364, r25	; 0x802364 <pxCurrentTimerList+0x1>
    369a:	85 e6       	ldi	r24, 0x65	; 101
    369c:	93 e2       	ldi	r25, 0x23	; 35
    369e:	80 93 61 23 	sts	0x2361, r24	; 0x802361 <pxOverflowTimerList>
    36a2:	90 93 62 23 	sts	0x2362, r25	; 0x802362 <pxOverflowTimerList+0x1>
    36a6:	40 e0       	ldi	r20, 0x00	; 0
    36a8:	65 e0       	ldi	r22, 0x05	; 5
    36aa:	8a e0       	ldi	r24, 0x0A	; 10
    36ac:	ab d9       	rcall	.-3242   	; 0x2a04 <xQueueGenericCreate>
    36ae:	80 93 5f 23 	sts	0x235F, r24	; 0x80235f <xTimerQueue>
    36b2:	90 93 60 23 	sts	0x2360, r25	; 0x802360 <xTimerQueue+0x1>
    36b6:	0f 90       	pop	r0
    36b8:	0f be       	out	0x3f, r0	; 63
    36ba:	08 95       	ret

000036bc <xTimerCreateTimerTask>:
    36bc:	ef 92       	push	r14
    36be:	ff 92       	push	r15
    36c0:	0f 93       	push	r16
    36c2:	d4 df       	rcall	.-88     	; 0x366c <prvCheckForValidListAndQueue>
    36c4:	80 91 5f 23 	lds	r24, 0x235F	; 0x80235f <xTimerQueue>
    36c8:	90 91 60 23 	lds	r25, 0x2360	; 0x802360 <xTimerQueue+0x1>
    36cc:	89 2b       	or	r24, r25
    36ce:	89 f0       	breq	.+34     	; 0x36f2 <xTimerCreateTimerTask+0x36>
    36d0:	0f 2e       	mov	r0, r31
    36d2:	fd e5       	ldi	r31, 0x5D	; 93
    36d4:	ef 2e       	mov	r14, r31
    36d6:	f3 e2       	ldi	r31, 0x23	; 35
    36d8:	ff 2e       	mov	r15, r31
    36da:	f0 2d       	mov	r31, r0
    36dc:	03 e0       	ldi	r16, 0x03	; 3
    36de:	20 e0       	ldi	r18, 0x00	; 0
    36e0:	30 e0       	ldi	r19, 0x00	; 0
    36e2:	45 e5       	ldi	r20, 0x55	; 85
    36e4:	50 e0       	ldi	r21, 0x00	; 0
    36e6:	62 e1       	ldi	r22, 0x12	; 18
    36e8:	70 e2       	ldi	r23, 0x20	; 32
    36ea:	8e e2       	ldi	r24, 0x2E	; 46
    36ec:	9c e1       	ldi	r25, 0x1C	; 28
    36ee:	f1 db       	rcall	.-2078   	; 0x2ed2 <xTaskCreate>
    36f0:	01 c0       	rjmp	.+2      	; 0x36f4 <xTimerCreateTimerTask+0x38>
    36f2:	80 e0       	ldi	r24, 0x00	; 0
    36f4:	0f 91       	pop	r16
    36f6:	ff 90       	pop	r15
    36f8:	ef 90       	pop	r14
    36fa:	08 95       	ret

000036fc <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    36fc:	0f 93       	push	r16
    36fe:	1f 93       	push	r17
    3700:	cf 93       	push	r28
    3702:	df 93       	push	r29
    3704:	cd b7       	in	r28, 0x3d	; 61
    3706:	de b7       	in	r29, 0x3e	; 62
    3708:	25 97       	sbiw	r28, 0x05	; 5
    370a:	cd bf       	out	0x3d, r28	; 61
    370c:	de bf       	out	0x3e, r29	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    370e:	e0 91 5f 23 	lds	r30, 0x235F	; 0x80235f <xTimerQueue>
    3712:	f0 91 60 23 	lds	r31, 0x2360	; 0x802360 <xTimerQueue+0x1>
    3716:	30 97       	sbiw	r30, 0x00	; 0
    3718:	51 f1       	breq	.+84     	; 0x376e <xTimerGenericCommand+0x72>
    371a:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    371c:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    371e:	4a 83       	std	Y+2, r20	; 0x02
    3720:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    3722:	8c 83       	std	Y+4, r24	; 0x04
    3724:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    3726:	66 30       	cpi	r22, 0x06	; 6
    3728:	d4 f4       	brge	.+52     	; 0x375e <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    372a:	63 df       	rcall	.-314    	; 0x35f2 <xTaskGetSchedulerState>
    372c:	82 30       	cpi	r24, 0x02	; 2
    372e:	59 f4       	brne	.+22     	; 0x3746 <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    3730:	20 e0       	ldi	r18, 0x00	; 0
    3732:	a8 01       	movw	r20, r16
    3734:	be 01       	movw	r22, r28
    3736:	6f 5f       	subi	r22, 0xFF	; 255
    3738:	7f 4f       	sbci	r23, 0xFF	; 255
    373a:	80 91 5f 23 	lds	r24, 0x235F	; 0x80235f <xTimerQueue>
    373e:	90 91 60 23 	lds	r25, 0x2360	; 0x802360 <xTimerQueue+0x1>
    3742:	81 d9       	rcall	.-3326   	; 0x2a46 <xQueueGenericSend>
    3744:	15 c0       	rjmp	.+42     	; 0x3770 <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    3746:	20 e0       	ldi	r18, 0x00	; 0
    3748:	40 e0       	ldi	r20, 0x00	; 0
    374a:	50 e0       	ldi	r21, 0x00	; 0
    374c:	be 01       	movw	r22, r28
    374e:	6f 5f       	subi	r22, 0xFF	; 255
    3750:	7f 4f       	sbci	r23, 0xFF	; 255
    3752:	80 91 5f 23 	lds	r24, 0x235F	; 0x80235f <xTimerQueue>
    3756:	90 91 60 23 	lds	r25, 0x2360	; 0x802360 <xTimerQueue+0x1>
    375a:	75 d9       	rcall	.-3350   	; 0x2a46 <xQueueGenericSend>
    375c:	09 c0       	rjmp	.+18     	; 0x3770 <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    375e:	20 e0       	ldi	r18, 0x00	; 0
    3760:	ad 01       	movw	r20, r26
    3762:	be 01       	movw	r22, r28
    3764:	6f 5f       	subi	r22, 0xFF	; 255
    3766:	7f 4f       	sbci	r23, 0xFF	; 255
    3768:	cf 01       	movw	r24, r30
    376a:	fa d9       	rcall	.-3084   	; 0x2b60 <xQueueGenericSendFromISR>
    376c:	01 c0       	rjmp	.+2      	; 0x3770 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    376e:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    3770:	25 96       	adiw	r28, 0x05	; 5
    3772:	cd bf       	out	0x3d, r28	; 61
    3774:	de bf       	out	0x3e, r29	; 62
    3776:	df 91       	pop	r29
    3778:	cf 91       	pop	r28
    377a:	1f 91       	pop	r17
    377c:	0f 91       	pop	r16
    377e:	08 95       	ret

00003780 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    3780:	af 92       	push	r10
    3782:	bf 92       	push	r11
    3784:	cf 92       	push	r12
    3786:	df 92       	push	r13
    3788:	ef 92       	push	r14
    378a:	ff 92       	push	r15
    378c:	0f 93       	push	r16
    378e:	1f 93       	push	r17
    3790:	cf 93       	push	r28
    3792:	df 93       	push	r29
    3794:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    3796:	cd dc       	rcall	.-1638   	; 0x3132 <xTaskGetTickCount>
    3798:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    379a:	80 91 5b 23 	lds	r24, 0x235B	; 0x80235b <xLastTime.4598>
    379e:	90 91 5c 23 	lds	r25, 0x235C	; 0x80235c <xLastTime.4598+0x1>
    37a2:	e8 16       	cp	r14, r24
    37a4:	f9 06       	cpc	r15, r25
    37a6:	08 f0       	brcs	.+2      	; 0x37aa <prvSampleTimeNow+0x2a>
    37a8:	47 c0       	rjmp	.+142    	; 0x3838 <prvSampleTimeNow+0xb8>
    37aa:	2f c0       	rjmp	.+94     	; 0x380a <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    37ac:	05 80       	ldd	r0, Z+5	; 0x05
    37ae:	f6 81       	ldd	r31, Z+6	; 0x06
    37b0:	e0 2d       	mov	r30, r0
    37b2:	a0 80       	ld	r10, Z
    37b4:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    37b6:	c6 81       	ldd	r28, Z+6	; 0x06
    37b8:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    37ba:	8e 01       	movw	r16, r28
    37bc:	0e 5f       	subi	r16, 0xFE	; 254
    37be:	1f 4f       	sbci	r17, 0xFF	; 255
    37c0:	c8 01       	movw	r24, r16
    37c2:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    37c6:	e8 89       	ldd	r30, Y+16	; 0x10
    37c8:	f9 89       	ldd	r31, Y+17	; 0x11
    37ca:	ce 01       	movw	r24, r28
    37cc:	19 95       	eicall

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    37ce:	8a 89       	ldd	r24, Y+18	; 0x12
    37d0:	82 ff       	sbrs	r24, 2
    37d2:	1b c0       	rjmp	.+54     	; 0x380a <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    37d4:	8c 85       	ldd	r24, Y+12	; 0x0c
    37d6:	9d 85       	ldd	r25, Y+13	; 0x0d
    37d8:	8a 0d       	add	r24, r10
    37da:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    37dc:	a8 16       	cp	r10, r24
    37de:	b9 06       	cpc	r11, r25
    37e0:	60 f4       	brcc	.+24     	; 0x37fa <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    37e2:	8a 83       	std	Y+2, r24	; 0x02
    37e4:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    37e6:	c8 87       	std	Y+8, r28	; 0x08
    37e8:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    37ea:	b8 01       	movw	r22, r16
    37ec:	80 91 63 23 	lds	r24, 0x2363	; 0x802363 <pxCurrentTimerList>
    37f0:	90 91 64 23 	lds	r25, 0x2364	; 0x802364 <pxCurrentTimerList+0x1>
    37f4:	0e 94 29 12 	call	0x2452	; 0x2452 <vListInsert>
    37f8:	08 c0       	rjmp	.+16     	; 0x380a <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    37fa:	00 e0       	ldi	r16, 0x00	; 0
    37fc:	10 e0       	ldi	r17, 0x00	; 0
    37fe:	20 e0       	ldi	r18, 0x00	; 0
    3800:	30 e0       	ldi	r19, 0x00	; 0
    3802:	a5 01       	movw	r20, r10
    3804:	60 e0       	ldi	r22, 0x00	; 0
    3806:	ce 01       	movw	r24, r28
    3808:	79 df       	rcall	.-270    	; 0x36fc <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    380a:	e0 91 63 23 	lds	r30, 0x2363	; 0x802363 <pxCurrentTimerList>
    380e:	f0 91 64 23 	lds	r31, 0x2364	; 0x802364 <pxCurrentTimerList+0x1>
    3812:	80 81       	ld	r24, Z
    3814:	81 11       	cpse	r24, r1
    3816:	ca cf       	rjmp	.-108    	; 0x37ac <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    3818:	80 91 61 23 	lds	r24, 0x2361	; 0x802361 <pxOverflowTimerList>
    381c:	90 91 62 23 	lds	r25, 0x2362	; 0x802362 <pxOverflowTimerList+0x1>
    3820:	80 93 63 23 	sts	0x2363, r24	; 0x802363 <pxCurrentTimerList>
    3824:	90 93 64 23 	sts	0x2364, r25	; 0x802364 <pxCurrentTimerList+0x1>
	pxOverflowTimerList = pxTemp;
    3828:	e0 93 61 23 	sts	0x2361, r30	; 0x802361 <pxOverflowTimerList>
    382c:	f0 93 62 23 	sts	0x2362, r31	; 0x802362 <pxOverflowTimerList+0x1>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    3830:	81 e0       	ldi	r24, 0x01	; 1
    3832:	f6 01       	movw	r30, r12
    3834:	80 83       	st	Z, r24
    3836:	02 c0       	rjmp	.+4      	; 0x383c <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    3838:	f6 01       	movw	r30, r12
    383a:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    383c:	e0 92 5b 23 	sts	0x235B, r14	; 0x80235b <xLastTime.4598>
    3840:	f0 92 5c 23 	sts	0x235C, r15	; 0x80235c <xLastTime.4598+0x1>

	return xTimeNow;
}
    3844:	c7 01       	movw	r24, r14
    3846:	df 91       	pop	r29
    3848:	cf 91       	pop	r28
    384a:	1f 91       	pop	r17
    384c:	0f 91       	pop	r16
    384e:	ff 90       	pop	r15
    3850:	ef 90       	pop	r14
    3852:	df 90       	pop	r13
    3854:	cf 90       	pop	r12
    3856:	bf 90       	pop	r11
    3858:	af 90       	pop	r10
    385a:	08 95       	ret

0000385c <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    385c:	cf 93       	push	r28
    385e:	df 93       	push	r29
    3860:	00 d0       	rcall	.+0      	; 0x3862 <prvTimerTask+0x6>
    3862:	00 d0       	rcall	.+0      	; 0x3864 <prvTimerTask+0x8>
    3864:	cd b7       	in	r28, 0x3d	; 61
    3866:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3868:	ce 01       	movw	r24, r28
    386a:	01 96       	adiw	r24, 0x01	; 1
    386c:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    386e:	e8 2e       	mov	r14, r24
    3870:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    3872:	e0 91 63 23 	lds	r30, 0x2363	; 0x802363 <pxCurrentTimerList>
    3876:	f0 91 64 23 	lds	r31, 0x2364	; 0x802364 <pxCurrentTimerList+0x1>
    387a:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    387c:	88 23       	and	r24, r24
    387e:	09 f4       	brne	.+2      	; 0x3882 <prvTimerTask+0x26>
    3880:	cf c0       	rjmp	.+414    	; 0x3a20 <prvTimerTask+0x1c4>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3882:	05 80       	ldd	r0, Z+5	; 0x05
    3884:	f6 81       	ldd	r31, Z+6	; 0x06
    3886:	e0 2d       	mov	r30, r0
    3888:	c0 80       	ld	r12, Z
    388a:	d1 80       	ldd	r13, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    388c:	4c dc       	rcall	.-1896   	; 0x3126 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    388e:	c5 01       	movw	r24, r10
    3890:	77 df       	rcall	.-274    	; 0x3780 <prvSampleTimeNow>
    3892:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    3894:	89 81       	ldd	r24, Y+1	; 0x01
    3896:	81 11       	cpse	r24, r1
    3898:	46 c0       	rjmp	.+140    	; 0x3926 <prvTimerTask+0xca>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    389a:	0c 15       	cp	r16, r12
    389c:	1d 05       	cpc	r17, r13
			{
				( void ) xTaskResumeAll();
    389e:	a0 f1       	brcs	.+104    	; 0x3908 <prvTimerTask+0xac>
    38a0:	0a dd       	rcall	.-1516   	; 0x32b6 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    38a2:	e0 91 63 23 	lds	r30, 0x2363	; 0x802363 <pxCurrentTimerList>
    38a6:	f0 91 64 23 	lds	r31, 0x2364	; 0x802364 <pxCurrentTimerList+0x1>
    38aa:	05 80       	ldd	r0, Z+5	; 0x05
    38ac:	f6 81       	ldd	r31, Z+6	; 0x06
    38ae:	e0 2d       	mov	r30, r0
    38b0:	86 80       	ldd	r8, Z+6	; 0x06
    38b2:	97 80       	ldd	r9, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    38b4:	c4 01       	movw	r24, r8
    38b6:	02 96       	adiw	r24, 0x02	; 2
    38b8:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto-reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    38bc:	d4 01       	movw	r26, r8
    38be:	52 96       	adiw	r26, 0x12	; 18
    38c0:	8c 91       	ld	r24, X
    38c2:	52 97       	sbiw	r26, 0x12	; 18
    38c4:	82 ff       	sbrs	r24, 2
    38c6:	15 c0       	rjmp	.+42     	; 0x38f2 <prvTimerTask+0x96>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    38c8:	1c 96       	adiw	r26, 0x0c	; 12
    38ca:	6d 91       	ld	r22, X+
    38cc:	7c 91       	ld	r23, X
    38ce:	1d 97       	sbiw	r26, 0x0d	; 13
    38d0:	6c 0d       	add	r22, r12
    38d2:	7d 1d       	adc	r23, r13
    38d4:	96 01       	movw	r18, r12
    38d6:	a8 01       	movw	r20, r16
    38d8:	c4 01       	movw	r24, r8
    38da:	99 de       	rcall	.-718    	; 0x360e <prvInsertTimerInActiveList>
    38dc:	88 23       	and	r24, r24
    38de:	61 f0       	breq	.+24     	; 0x38f8 <prvTimerTask+0x9c>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    38e0:	00 e0       	ldi	r16, 0x00	; 0
    38e2:	10 e0       	ldi	r17, 0x00	; 0
    38e4:	20 e0       	ldi	r18, 0x00	; 0
    38e6:	30 e0       	ldi	r19, 0x00	; 0
    38e8:	a6 01       	movw	r20, r12
    38ea:	60 e0       	ldi	r22, 0x00	; 0
    38ec:	c4 01       	movw	r24, r8
    38ee:	06 df       	rcall	.-500    	; 0x36fc <xTimerGenericCommand>
    38f0:	03 c0       	rjmp	.+6      	; 0x38f8 <prvTimerTask+0x9c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    38f2:	8e 7f       	andi	r24, 0xFE	; 254
    38f4:	f4 01       	movw	r30, r8
    38f6:	82 8b       	std	Z+18, r24	; 0x12
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    38f8:	d4 01       	movw	r26, r8
    38fa:	50 96       	adiw	r26, 0x10	; 16
    38fc:	ed 91       	ld	r30, X+
    38fe:	fc 91       	ld	r31, X
    3900:	51 97       	sbiw	r26, 0x11	; 17
    3902:	c4 01       	movw	r24, r8
    3904:	19 95       	eicall
    3906:	80 c0       	rjmp	.+256    	; 0x3a08 <prvTimerTask+0x1ac>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3908:	40 e0       	ldi	r20, 0x00	; 0
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    390a:	b6 01       	movw	r22, r12
    390c:	60 1b       	sub	r22, r16
    390e:	71 0b       	sbc	r23, r17
    3910:	80 91 5f 23 	lds	r24, 0x235F	; 0x80235f <xTimerQueue>
    3914:	90 91 60 23 	lds	r25, 0x2360	; 0x802360 <xTimerQueue+0x1>

				if( xTaskResumeAll() == pdFALSE )
    3918:	5a da       	rcall	.-2892   	; 0x2dce <vQueueWaitForMessageRestricted>
    391a:	cd dc       	rcall	.-1638   	; 0x32b6 <xTaskResumeAll>
    391c:	81 11       	cpse	r24, r1
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    391e:	74 c0       	rjmp	.+232    	; 0x3a08 <prvTimerTask+0x1ac>
    3920:	0e 94 3d 13 	call	0x267a	; 0x267a <vPortYield>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    3924:	71 c0       	rjmp	.+226    	; 0x3a08 <prvTimerTask+0x1ac>
    3926:	c7 dc       	rcall	.-1650   	; 0x32b6 <xTaskResumeAll>
    3928:	6f c0       	rjmp	.+222    	; 0x3a08 <prvTimerTask+0x1ac>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    392a:	89 81       	ldd	r24, Y+1	; 0x01
    392c:	88 23       	and	r24, r24
    392e:	0c f4       	brge	.+2      	; 0x3932 <prvTimerTask+0xd6>
    3930:	6b c0       	rjmp	.+214    	; 0x3a08 <prvTimerTask+0x1ac>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    3932:	cc 80       	ldd	r12, Y+4	; 0x04
    3934:	dd 80       	ldd	r13, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    3936:	f6 01       	movw	r30, r12
    3938:	82 85       	ldd	r24, Z+10	; 0x0a
    393a:	93 85       	ldd	r25, Z+11	; 0x0b
    393c:	89 2b       	or	r24, r25
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    393e:	21 f0       	breq	.+8      	; 0x3948 <prvTimerTask+0xec>
    3940:	c6 01       	movw	r24, r12
    3942:	02 96       	adiw	r24, 0x02	; 2
    3944:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3948:	ce 01       	movw	r24, r28
    394a:	06 96       	adiw	r24, 0x06	; 6
    394c:	19 df       	rcall	.-462    	; 0x3780 <prvSampleTimeNow>
    394e:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    3950:	e9 81       	ldd	r30, Y+1	; 0x01
    3952:	0e 2e       	mov	r0, r30
    3954:	00 0c       	add	r0, r0
    3956:	ff 0b       	sbc	r31, r31
    3958:	ea 30       	cpi	r30, 0x0A	; 10
    395a:	f1 05       	cpc	r31, r1
    395c:	08 f0       	brcs	.+2      	; 0x3960 <prvTimerTask+0x104>
    395e:	54 c0       	rjmp	.+168    	; 0x3a08 <prvTimerTask+0x1ac>
    3960:	88 27       	eor	r24, r24
    3962:	e2 50       	subi	r30, 0x02	; 2
    3964:	ff 4f       	sbci	r31, 0xFF	; 255
    3966:	8f 4f       	sbci	r24, 0xFF	; 255
    3968:	87 c6       	rjmp	.+3342   	; 0x4678 <__tablejump2__>
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    396a:	d6 01       	movw	r26, r12
    396c:	52 96       	adiw	r26, 0x12	; 18
    396e:	8c 91       	ld	r24, X
    3970:	52 97       	sbiw	r26, 0x12	; 18
    3972:	81 60       	ori	r24, 0x01	; 1
    3974:	52 96       	adiw	r26, 0x12	; 18
    3976:	8c 93       	st	X, r24
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    3978:	52 97       	sbiw	r26, 0x12	; 18
    397a:	2a 81       	ldd	r18, Y+2	; 0x02
    397c:	3b 81       	ldd	r19, Y+3	; 0x03
    397e:	1c 96       	adiw	r26, 0x0c	; 12
    3980:	6d 91       	ld	r22, X+
    3982:	7c 91       	ld	r23, X
    3984:	1d 97       	sbiw	r26, 0x0d	; 13
    3986:	62 0f       	add	r22, r18
    3988:	73 1f       	adc	r23, r19
    398a:	c6 01       	movw	r24, r12
    398c:	40 de       	rcall	.-896    	; 0x360e <prvInsertTimerInActiveList>
    398e:	88 23       	and	r24, r24
    3990:	d9 f1       	breq	.+118    	; 0x3a08 <prvTimerTask+0x1ac>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3992:	d6 01       	movw	r26, r12
    3994:	50 96       	adiw	r26, 0x10	; 16
    3996:	ed 91       	ld	r30, X+
    3998:	fc 91       	ld	r31, X
    399a:	51 97       	sbiw	r26, 0x11	; 17
    399c:	c6 01       	movw	r24, r12
    399e:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    39a0:	f6 01       	movw	r30, r12
    39a2:	82 89       	ldd	r24, Z+18	; 0x12
    39a4:	82 ff       	sbrs	r24, 2
    39a6:	30 c0       	rjmp	.+96     	; 0x3a08 <prvTimerTask+0x1ac>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    39a8:	4a 81       	ldd	r20, Y+2	; 0x02
    39aa:	5b 81       	ldd	r21, Y+3	; 0x03
    39ac:	84 85       	ldd	r24, Z+12	; 0x0c
    39ae:	95 85       	ldd	r25, Z+13	; 0x0d
    39b0:	48 0f       	add	r20, r24
    39b2:	59 1f       	adc	r21, r25
    39b4:	00 e0       	ldi	r16, 0x00	; 0
    39b6:	10 e0       	ldi	r17, 0x00	; 0
    39b8:	20 e0       	ldi	r18, 0x00	; 0
    39ba:	30 e0       	ldi	r19, 0x00	; 0
    39bc:	60 e0       	ldi	r22, 0x00	; 0
    39be:	c6 01       	movw	r24, r12
    39c0:	9d de       	rcall	.-710    	; 0x36fc <xTimerGenericCommand>
    39c2:	22 c0       	rjmp	.+68     	; 0x3a08 <prvTimerTask+0x1ac>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    39c4:	d6 01       	movw	r26, r12
    39c6:	52 96       	adiw	r26, 0x12	; 18
    39c8:	8c 91       	ld	r24, X
    39ca:	52 97       	sbiw	r26, 0x12	; 18
    39cc:	8e 7f       	andi	r24, 0xFE	; 254
    39ce:	52 96       	adiw	r26, 0x12	; 18
    39d0:	8c 93       	st	X, r24
    39d2:	1a c0       	rjmp	.+52     	; 0x3a08 <prvTimerTask+0x1ac>
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    39d4:	f6 01       	movw	r30, r12
    39d6:	82 89       	ldd	r24, Z+18	; 0x12
    39d8:	81 60       	ori	r24, 0x01	; 1
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    39da:	82 8b       	std	Z+18, r24	; 0x12
    39dc:	6a 81       	ldd	r22, Y+2	; 0x02
    39de:	7b 81       	ldd	r23, Y+3	; 0x03
    39e0:	64 87       	std	Z+12, r22	; 0x0c
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    39e2:	75 87       	std	Z+13, r23	; 0x0d
    39e4:	64 0f       	add	r22, r20
    39e6:	75 1f       	adc	r23, r21
    39e8:	9a 01       	movw	r18, r20
    39ea:	c6 01       	movw	r24, r12
    39ec:	10 de       	rcall	.-992    	; 0x360e <prvInsertTimerInActiveList>
    39ee:	0c c0       	rjmp	.+24     	; 0x3a08 <prvTimerTask+0x1ac>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    39f0:	d6 01       	movw	r26, r12
    39f2:	52 96       	adiw	r26, 0x12	; 18
    39f4:	8c 91       	ld	r24, X
    39f6:	81 fd       	sbrc	r24, 1
    39f8:	04 c0       	rjmp	.+8      	; 0x3a02 <prvTimerTask+0x1a6>
						{
							vPortFree( pxTimer );
    39fa:	c6 01       	movw	r24, r12
    39fc:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <vPortFree>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    3a00:	03 c0       	rjmp	.+6      	; 0x3a08 <prvTimerTask+0x1ac>
    3a02:	8e 7f       	andi	r24, 0xFE	; 254
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3a04:	f6 01       	movw	r30, r12
    3a06:	82 8b       	std	Z+18, r24	; 0x12
    3a08:	40 e0       	ldi	r20, 0x00	; 0
    3a0a:	50 e0       	ldi	r21, 0x00	; 0
    3a0c:	6e 2d       	mov	r22, r14
    3a0e:	7f 2d       	mov	r23, r15
    3a10:	80 91 5f 23 	lds	r24, 0x235F	; 0x80235f <xTimerQueue>
    3a14:	90 91 60 23 	lds	r25, 0x2360	; 0x802360 <xTimerQueue+0x1>
    3a18:	dd d8       	rcall	.-3654   	; 0x2bd4 <xQueueReceive>
    3a1a:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    3a1c:	86 cf       	rjmp	.-244    	; 0x392a <prvTimerTask+0xce>
    3a1e:	29 cf       	rjmp	.-430    	; 0x3872 <prvTimerTask+0x16>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3a20:	82 db       	rcall	.-2300   	; 0x3126 <vTaskSuspendAll>
    3a22:	c5 01       	movw	r24, r10
    3a24:	ad de       	rcall	.-678    	; 0x3780 <prvSampleTimeNow>
    3a26:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    3a28:	89 81       	ldd	r24, Y+1	; 0x01
    3a2a:	81 11       	cpse	r24, r1
    3a2c:	7c cf       	rjmp	.-264    	; 0x3926 <prvTimerTask+0xca>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3a2e:	e0 91 61 23 	lds	r30, 0x2361	; 0x802361 <pxOverflowTimerList>
    3a32:	f0 91 62 23 	lds	r31, 0x2362	; 0x802362 <pxOverflowTimerList+0x1>
    3a36:	80 81       	ld	r24, Z
    3a38:	41 e0       	ldi	r20, 0x01	; 1
    3a3a:	81 11       	cpse	r24, r1
    3a3c:	40 e0       	ldi	r20, 0x00	; 0
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    3a3e:	c1 2c       	mov	r12, r1
    3a40:	d1 2c       	mov	r13, r1
    3a42:	63 cf       	rjmp	.-314    	; 0x390a <prvTimerTask+0xae>

00003a44 <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
    3a44:	80 3a       	cpi	r24, 0xA0	; 160
    3a46:	28 e0       	ldi	r18, 0x08	; 8
    3a48:	92 07       	cpc	r25, r18
    3a4a:	21 f4       	brne	.+8      	; 0x3a54 <usart_spi_init+0x10>
    3a4c:	60 e1       	ldi	r22, 0x10	; 16
    3a4e:	83 e0       	ldi	r24, 0x03	; 3
    3a50:	22 c1       	rjmp	.+580    	; 0x3c96 <sysclk_enable_module>
    3a52:	08 95       	ret
    3a54:	80 3b       	cpi	r24, 0xB0	; 176
    3a56:	28 e0       	ldi	r18, 0x08	; 8
    3a58:	92 07       	cpc	r25, r18
    3a5a:	21 f4       	brne	.+8      	; 0x3a64 <usart_spi_init+0x20>
    3a5c:	60 e2       	ldi	r22, 0x20	; 32
    3a5e:	83 e0       	ldi	r24, 0x03	; 3
    3a60:	1a c1       	rjmp	.+564    	; 0x3c96 <sysclk_enable_module>
    3a62:	08 95       	ret
    3a64:	80 3a       	cpi	r24, 0xA0	; 160
    3a66:	29 e0       	ldi	r18, 0x09	; 9
    3a68:	92 07       	cpc	r25, r18
    3a6a:	21 f4       	brne	.+8      	; 0x3a74 <usart_spi_init+0x30>
    3a6c:	60 e1       	ldi	r22, 0x10	; 16
    3a6e:	84 e0       	ldi	r24, 0x04	; 4
    3a70:	12 c1       	rjmp	.+548    	; 0x3c96 <sysclk_enable_module>
    3a72:	08 95       	ret
    3a74:	80 3b       	cpi	r24, 0xB0	; 176
    3a76:	29 e0       	ldi	r18, 0x09	; 9
    3a78:	92 07       	cpc	r25, r18
    3a7a:	21 f4       	brne	.+8      	; 0x3a84 <usart_spi_init+0x40>
    3a7c:	60 e2       	ldi	r22, 0x20	; 32
    3a7e:	84 e0       	ldi	r24, 0x04	; 4
    3a80:	0a c1       	rjmp	.+532    	; 0x3c96 <sysclk_enable_module>
    3a82:	08 95       	ret
    3a84:	80 3a       	cpi	r24, 0xA0	; 160
    3a86:	2a e0       	ldi	r18, 0x0A	; 10
    3a88:	92 07       	cpc	r25, r18
    3a8a:	21 f4       	brne	.+8      	; 0x3a94 <usart_spi_init+0x50>
    3a8c:	60 e1       	ldi	r22, 0x10	; 16
    3a8e:	85 e0       	ldi	r24, 0x05	; 5
    3a90:	02 c1       	rjmp	.+516    	; 0x3c96 <sysclk_enable_module>
    3a92:	08 95       	ret
    3a94:	80 3a       	cpi	r24, 0xA0	; 160
    3a96:	9b 40       	sbci	r25, 0x0B	; 11
    3a98:	19 f4       	brne	.+6      	; 0x3aa0 <usart_spi_init+0x5c>
    3a9a:	60 e1       	ldi	r22, 0x10	; 16
    3a9c:	86 e0       	ldi	r24, 0x06	; 6
    3a9e:	fb c0       	rjmp	.+502    	; 0x3c96 <sysclk_enable_module>
    3aa0:	08 95       	ret

00003aa2 <usart_spi_setup_device>:
    3aa2:	0f 93       	push	r16
    3aa4:	1f 93       	push	r17
    3aa6:	cf 93       	push	r28
    3aa8:	df 93       	push	r29
    3aaa:	00 d0       	rcall	.+0      	; 0x3aac <usart_spi_setup_device+0xa>
    3aac:	00 d0       	rcall	.+0      	; 0x3aae <usart_spi_setup_device+0xc>
    3aae:	cd b7       	in	r28, 0x3d	; 61
    3ab0:	de b7       	in	r29, 0x3e	; 62
    3ab2:	09 83       	std	Y+1, r16	; 0x01
    3ab4:	1a 83       	std	Y+2, r17	; 0x02
    3ab6:	2b 83       	std	Y+3, r18	; 0x03
    3ab8:	3c 83       	std	Y+4, r19	; 0x04
    3aba:	4d 83       	std	Y+5, r20	; 0x05
    3abc:	1e 82       	std	Y+6, r1	; 0x06
    3abe:	be 01       	movw	r22, r28
    3ac0:	6f 5f       	subi	r22, 0xFF	; 255
    3ac2:	7f 4f       	sbci	r23, 0xFF	; 255
    3ac4:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <usart_init_spi>
    3ac8:	26 96       	adiw	r28, 0x06	; 6
    3aca:	cd bf       	out	0x3d, r28	; 61
    3acc:	de bf       	out	0x3e, r29	; 62
    3ace:	df 91       	pop	r29
    3ad0:	cf 91       	pop	r28
    3ad2:	1f 91       	pop	r17
    3ad4:	0f 91       	pop	r16
    3ad6:	08 95       	ret

00003ad8 <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
    3ad8:	fb 01       	movw	r30, r22
    3ada:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    3adc:	e8 2f       	mov	r30, r24
    3ade:	e6 95       	lsr	r30
    3ae0:	e6 95       	lsr	r30
    3ae2:	e6 95       	lsr	r30
    3ae4:	40 e2       	ldi	r20, 0x20	; 32
    3ae6:	e4 9f       	mul	r30, r20
    3ae8:	f0 01       	movw	r30, r0
    3aea:	11 24       	eor	r1, r1
    3aec:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    3aee:	87 70       	andi	r24, 0x07	; 7
    3af0:	21 e0       	ldi	r18, 0x01	; 1
    3af2:	30 e0       	ldi	r19, 0x00	; 0
    3af4:	a9 01       	movw	r20, r18
    3af6:	02 c0       	rjmp	.+4      	; 0x3afc <usart_spi_select_device+0x24>
    3af8:	44 0f       	add	r20, r20
    3afa:	55 1f       	adc	r21, r21
    3afc:	8a 95       	dec	r24
    3afe:	e2 f7       	brpl	.-8      	; 0x3af8 <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    3b00:	46 83       	std	Z+6, r20	; 0x06
    3b02:	08 95       	ret

00003b04 <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
    3b04:	fb 01       	movw	r30, r22
    3b06:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    3b08:	e8 2f       	mov	r30, r24
    3b0a:	e6 95       	lsr	r30
    3b0c:	e6 95       	lsr	r30
    3b0e:	e6 95       	lsr	r30
    3b10:	40 e2       	ldi	r20, 0x20	; 32
    3b12:	e4 9f       	mul	r30, r20
    3b14:	f0 01       	movw	r30, r0
    3b16:	11 24       	eor	r1, r1
    3b18:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    3b1a:	87 70       	andi	r24, 0x07	; 7
    3b1c:	21 e0       	ldi	r18, 0x01	; 1
    3b1e:	30 e0       	ldi	r19, 0x00	; 0
    3b20:	a9 01       	movw	r20, r18
    3b22:	02 c0       	rjmp	.+4      	; 0x3b28 <usart_spi_deselect_device+0x24>
    3b24:	44 0f       	add	r20, r20
    3b26:	55 1f       	adc	r21, r21
    3b28:	8a 95       	dec	r24
    3b2a:	e2 f7       	brpl	.-8      	; 0x3b24 <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3b2c:	45 83       	std	Z+5, r20	; 0x05
    3b2e:	08 95       	ret

00003b30 <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
    3b30:	80 93 77 23 	sts	0x2377, r24	; 0x802377 <fbpointer>
    3b34:	90 93 78 23 	sts	0x2378, r25	; 0x802378 <fbpointer+0x1>
    3b38:	08 95       	ret

00003b3a <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
    3b3a:	20 91 77 23 	lds	r18, 0x2377	; 0x802377 <fbpointer>
    3b3e:	30 91 78 23 	lds	r19, 0x2378	; 0x802378 <fbpointer+0x1>
    3b42:	90 e8       	ldi	r25, 0x80	; 128
    3b44:	89 9f       	mul	r24, r25
    3b46:	20 0d       	add	r18, r0
    3b48:	31 1d       	adc	r19, r1
    3b4a:	11 24       	eor	r1, r1
    3b4c:	f9 01       	movw	r30, r18
    3b4e:	e6 0f       	add	r30, r22
    3b50:	f1 1d       	adc	r31, r1
    3b52:	40 83       	st	Z, r20
    3b54:	08 95       	ret

00003b56 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
    3b56:	20 91 77 23 	lds	r18, 0x2377	; 0x802377 <fbpointer>
    3b5a:	30 91 78 23 	lds	r19, 0x2378	; 0x802378 <fbpointer+0x1>
    3b5e:	90 e8       	ldi	r25, 0x80	; 128
    3b60:	89 9f       	mul	r24, r25
    3b62:	20 0d       	add	r18, r0
    3b64:	31 1d       	adc	r19, r1
    3b66:	11 24       	eor	r1, r1
    3b68:	f9 01       	movw	r30, r18
    3b6a:	e6 0f       	add	r30, r22
    3b6c:	f1 1d       	adc	r31, r1
}
    3b6e:	80 81       	ld	r24, Z
    3b70:	08 95       	ret

00003b72 <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
    3b72:	ff 92       	push	r15
    3b74:	0f 93       	push	r16
    3b76:	1f 93       	push	r17
    3b78:	cf 93       	push	r28
    3b7a:	df 93       	push	r29
    3b7c:	e4 2f       	mov	r30, r20
    3b7e:	f0 e0       	ldi	r31, 0x00	; 0
    3b80:	e8 0f       	add	r30, r24
    3b82:	f1 1d       	adc	r31, r1
    3b84:	e1 38       	cpi	r30, 0x81	; 129
    3b86:	f1 05       	cpc	r31, r1
    3b88:	1c f0       	brlt	.+6      	; 0x3b90 <gfx_mono_generic_draw_horizontal_line+0x1e>
    3b8a:	c0 e8       	ldi	r28, 0x80	; 128
    3b8c:	4c 2f       	mov	r20, r28
    3b8e:	48 1b       	sub	r20, r24
    3b90:	44 23       	and	r20, r20
    3b92:	09 f4       	brne	.+2      	; 0x3b96 <gfx_mono_generic_draw_horizontal_line+0x24>
    3b94:	50 c0       	rjmp	.+160    	; 0x3c36 <gfx_mono_generic_draw_horizontal_line+0xc4>
    3b96:	d6 2f       	mov	r29, r22
    3b98:	d6 95       	lsr	r29
    3b9a:	d6 95       	lsr	r29
    3b9c:	d6 95       	lsr	r29
    3b9e:	70 e0       	ldi	r23, 0x00	; 0
    3ba0:	98 e0       	ldi	r25, 0x08	; 8
    3ba2:	d9 9f       	mul	r29, r25
    3ba4:	60 19       	sub	r22, r0
    3ba6:	71 09       	sbc	r23, r1
    3ba8:	11 24       	eor	r1, r1
    3baa:	e1 e0       	ldi	r30, 0x01	; 1
    3bac:	f0 e0       	ldi	r31, 0x00	; 0
    3bae:	df 01       	movw	r26, r30
    3bb0:	02 c0       	rjmp	.+4      	; 0x3bb6 <gfx_mono_generic_draw_horizontal_line+0x44>
    3bb2:	aa 0f       	add	r26, r26
    3bb4:	bb 1f       	adc	r27, r27
    3bb6:	6a 95       	dec	r22
    3bb8:	e2 f7       	brpl	.-8      	; 0x3bb2 <gfx_mono_generic_draw_horizontal_line+0x40>
    3bba:	fa 2e       	mov	r15, r26
    3bbc:	21 30       	cpi	r18, 0x01	; 1
    3bbe:	21 f0       	breq	.+8      	; 0x3bc8 <gfx_mono_generic_draw_horizontal_line+0x56>
    3bc0:	a8 f0       	brcs	.+42     	; 0x3bec <gfx_mono_generic_draw_horizontal_line+0x7a>
    3bc2:	22 30       	cpi	r18, 0x02	; 2
    3bc4:	39 f1       	breq	.+78     	; 0x3c14 <gfx_mono_generic_draw_horizontal_line+0xa2>
    3bc6:	37 c0       	rjmp	.+110    	; 0x3c36 <gfx_mono_generic_draw_horizontal_line+0xc4>
    3bc8:	c4 2f       	mov	r28, r20
    3bca:	1f ef       	ldi	r17, 0xFF	; 255
    3bcc:	18 0f       	add	r17, r24
    3bce:	01 2f       	mov	r16, r17
    3bd0:	0c 0f       	add	r16, r28
    3bd2:	60 2f       	mov	r22, r16
    3bd4:	8d 2f       	mov	r24, r29
    3bd6:	0e 94 86 05 	call	0xb0c	; 0xb0c <gfx_mono_st7565r_get_byte>
    3bda:	4f 2d       	mov	r20, r15
    3bdc:	48 2b       	or	r20, r24
    3bde:	60 2f       	mov	r22, r16
    3be0:	8d 2f       	mov	r24, r29
    3be2:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <gfx_mono_st7565r_put_byte>
    3be6:	c1 50       	subi	r28, 0x01	; 1
    3be8:	91 f7       	brne	.-28     	; 0x3bce <gfx_mono_generic_draw_horizontal_line+0x5c>
    3bea:	25 c0       	rjmp	.+74     	; 0x3c36 <gfx_mono_generic_draw_horizontal_line+0xc4>
    3bec:	c4 2f       	mov	r28, r20
    3bee:	1f ef       	ldi	r17, 0xFF	; 255
    3bf0:	18 0f       	add	r17, r24
    3bf2:	fa 2e       	mov	r15, r26
    3bf4:	f0 94       	com	r15
    3bf6:	01 2f       	mov	r16, r17
    3bf8:	0c 0f       	add	r16, r28
    3bfa:	60 2f       	mov	r22, r16
    3bfc:	8d 2f       	mov	r24, r29
    3bfe:	0e 94 86 05 	call	0xb0c	; 0xb0c <gfx_mono_st7565r_get_byte>
    3c02:	4f 2d       	mov	r20, r15
    3c04:	48 23       	and	r20, r24
    3c06:	60 2f       	mov	r22, r16
    3c08:	8d 2f       	mov	r24, r29
    3c0a:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <gfx_mono_st7565r_put_byte>
    3c0e:	c1 50       	subi	r28, 0x01	; 1
    3c10:	91 f7       	brne	.-28     	; 0x3bf6 <gfx_mono_generic_draw_horizontal_line+0x84>
    3c12:	11 c0       	rjmp	.+34     	; 0x3c36 <gfx_mono_generic_draw_horizontal_line+0xc4>
    3c14:	c4 2f       	mov	r28, r20
    3c16:	1f ef       	ldi	r17, 0xFF	; 255
    3c18:	18 0f       	add	r17, r24
    3c1a:	01 2f       	mov	r16, r17
    3c1c:	0c 0f       	add	r16, r28
    3c1e:	60 2f       	mov	r22, r16
    3c20:	8d 2f       	mov	r24, r29
    3c22:	0e 94 86 05 	call	0xb0c	; 0xb0c <gfx_mono_st7565r_get_byte>
    3c26:	4f 2d       	mov	r20, r15
    3c28:	48 27       	eor	r20, r24
    3c2a:	60 2f       	mov	r22, r16
    3c2c:	8d 2f       	mov	r24, r29
    3c2e:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <gfx_mono_st7565r_put_byte>
    3c32:	c1 50       	subi	r28, 0x01	; 1
    3c34:	91 f7       	brne	.-28     	; 0x3c1a <gfx_mono_generic_draw_horizontal_line+0xa8>
    3c36:	df 91       	pop	r29
    3c38:	cf 91       	pop	r28
    3c3a:	1f 91       	pop	r17
    3c3c:	0f 91       	pop	r16
    3c3e:	ff 90       	pop	r15
    3c40:	08 95       	ret

00003c42 <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
    3c42:	ff 92       	push	r15
    3c44:	0f 93       	push	r16
    3c46:	1f 93       	push	r17
    3c48:	cf 93       	push	r28
    3c4a:	df 93       	push	r29
	if (height == 0) {
    3c4c:	22 23       	and	r18, r18
    3c4e:	69 f0       	breq	.+26     	; 0x3c6a <gfx_mono_generic_draw_filled_rect+0x28>
    3c50:	f4 2e       	mov	r15, r20
    3c52:	18 2f       	mov	r17, r24
    3c54:	c2 2f       	mov	r28, r18
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
    3c56:	df ef       	ldi	r29, 0xFF	; 255
    3c58:	d6 0f       	add	r29, r22
    3c5a:	6d 2f       	mov	r22, r29
    3c5c:	6c 0f       	add	r22, r28
    3c5e:	20 2f       	mov	r18, r16
    3c60:	4f 2d       	mov	r20, r15
    3c62:	81 2f       	mov	r24, r17
    3c64:	86 df       	rcall	.-244    	; 0x3b72 <gfx_mono_generic_draw_horizontal_line>
    3c66:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
    3c68:	c1 f7       	brne	.-16     	; 0x3c5a <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
    3c6a:	df 91       	pop	r29
    3c6c:	cf 91       	pop	r28
    3c6e:	1f 91       	pop	r17
    3c70:	0f 91       	pop	r16
    3c72:	ff 90       	pop	r15
    3c74:	08 95       	ret

00003c76 <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
    3c76:	8f ef       	ldi	r24, 0xFF	; 255
    3c78:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x700070>
    3c7c:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
    3c80:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
    3c84:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x700073>
    3c88:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x700074>
    3c8c:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <__TEXT_REGION_LENGTH__+0x700075>
    3c90:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <__TEXT_REGION_LENGTH__+0x700076>
    3c94:	08 95       	ret

00003c96 <sysclk_enable_module>:
	sysclk_rtcsrc_enable(CONFIG_RTC_SOURCE);
#endif
}

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
    3c96:	cf 93       	push	r28
    3c98:	df 93       	push	r29
    3c9a:	1f 92       	push	r1
    3c9c:	cd b7       	in	r28, 0x3d	; 61
    3c9e:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    3ca0:	9f b7       	in	r25, 0x3f	; 63
    3ca2:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
    3ca4:	f8 94       	cli
	return flags;
    3ca6:	99 81       	ldd	r25, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
    3ca8:	e8 2f       	mov	r30, r24
    3caa:	f0 e0       	ldi	r31, 0x00	; 0
    3cac:	e0 59       	subi	r30, 0x90	; 144
    3cae:	ff 4f       	sbci	r31, 0xFF	; 255
    3cb0:	60 95       	com	r22
    3cb2:	80 81       	ld	r24, Z
    3cb4:	68 23       	and	r22, r24
    3cb6:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    3cb8:	9f bf       	out	0x3f, r25	; 63

	cpu_irq_restore(flags);
}
    3cba:	0f 90       	pop	r0
    3cbc:	df 91       	pop	r29
    3cbe:	cf 91       	pop	r28
    3cc0:	08 95       	ret

00003cc2 <sysclk_disable_module>:

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
    3cc2:	cf 93       	push	r28
    3cc4:	df 93       	push	r29
    3cc6:	1f 92       	push	r1
    3cc8:	cd b7       	in	r28, 0x3d	; 61
    3cca:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    3ccc:	9f b7       	in	r25, 0x3f	; 63
    3cce:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
    3cd0:	f8 94       	cli
	return flags;
    3cd2:	99 81       	ldd	r25, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
    3cd4:	e8 2f       	mov	r30, r24
    3cd6:	f0 e0       	ldi	r31, 0x00	; 0
    3cd8:	e0 59       	subi	r30, 0x90	; 144
    3cda:	ff 4f       	sbci	r31, 0xFF	; 255
    3cdc:	80 81       	ld	r24, Z
    3cde:	68 2b       	or	r22, r24
    3ce0:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    3ce2:	9f bf       	out	0x3f, r25	; 63

	cpu_irq_restore(flags);
}
    3ce4:	0f 90       	pop	r0
    3ce6:	df 91       	pop	r29
    3ce8:	cf 91       	pop	r28
    3cea:	08 95       	ret

00003cec <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    3cec:	40 91 ca 01 	lds	r20, 0x01CA	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	mov ZL, r22               ; Load byte index into low byte of Z.
    3cf0:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    3cf2:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    3cf4:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm r24, Z                ; Perform an LPM to read out byte
    3cf8:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    3cfa:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    3cfe:	08 95       	ret

00003d00 <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
    3d00:	af 92       	push	r10
    3d02:	bf 92       	push	r11
    3d04:	cf 92       	push	r12
    3d06:	df 92       	push	r13
    3d08:	ef 92       	push	r14
    3d0a:	ff 92       	push	r15
    3d0c:	0f 93       	push	r16
    3d0e:	1f 93       	push	r17
    3d10:	cf 93       	push	r28
    3d12:	df 93       	push	r29
    3d14:	c8 2f       	mov	r28, r24
    3d16:	e6 2e       	mov	r14, r22
    3d18:	b4 2e       	mov	r11, r20
    3d1a:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
    3d1c:	00 e0       	ldi	r16, 0x00	; 0
    3d1e:	f9 01       	movw	r30, r18
    3d20:	24 81       	ldd	r18, Z+4	; 0x04
    3d22:	43 81       	ldd	r20, Z+3	; 0x03
    3d24:	6b 2d       	mov	r22, r11
    3d26:	8e 2d       	mov	r24, r14
    3d28:	8c df       	rcall	.-232    	; 0x3c42 <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
    3d2a:	f6 01       	movw	r30, r12
    3d2c:	80 81       	ld	r24, Z
    3d2e:	81 11       	cpse	r24, r1
    3d30:	3a c0       	rjmp	.+116    	; 0x3da6 <gfx_mono_draw_char+0xa6>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
    3d32:	83 81       	ldd	r24, Z+3	; 0x03
    3d34:	28 2f       	mov	r18, r24
    3d36:	26 95       	lsr	r18
    3d38:	26 95       	lsr	r18
    3d3a:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
    3d3c:	87 70       	andi	r24, 0x07	; 7
    3d3e:	09 f0       	breq	.+2      	; 0x3d42 <gfx_mono_draw_char+0x42>
		char_row_size++;
    3d40:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
    3d42:	f6 01       	movw	r30, r12
    3d44:	a4 80       	ldd	r10, Z+4	; 0x04
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
    3d46:	8c 2f       	mov	r24, r28
    3d48:	90 e0       	ldi	r25, 0x00	; 0
    3d4a:	35 81       	ldd	r19, Z+5	; 0x05
    3d4c:	83 1b       	sub	r24, r19
    3d4e:	91 09       	sbc	r25, r1
    3d50:	2a 9d       	mul	r18, r10
    3d52:	90 01       	movw	r18, r0
    3d54:	11 24       	eor	r1, r1
    3d56:	82 9f       	mul	r24, r18
    3d58:	a0 01       	movw	r20, r0
    3d5a:	83 9f       	mul	r24, r19
    3d5c:	50 0d       	add	r21, r0
    3d5e:	92 9f       	mul	r25, r18
    3d60:	50 0d       	add	r21, r0
    3d62:	11 24       	eor	r1, r1
    3d64:	01 81       	ldd	r16, Z+1	; 0x01
    3d66:	12 81       	ldd	r17, Z+2	; 0x02
    3d68:	04 0f       	add	r16, r20
    3d6a:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
    3d6c:	f6 01       	movw	r30, r12
    3d6e:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
    3d70:	ff 20       	and	r15, r15
    3d72:	a9 f0       	breq	.+42     	; 0x3d9e <gfx_mono_draw_char+0x9e>
    3d74:	d0 e0       	ldi	r29, 0x00	; 0
    3d76:	c0 e0       	ldi	r28, 0x00	; 0
    3d78:	8e 2d       	mov	r24, r14
    3d7a:	8c 0f       	add	r24, r28
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
    3d7c:	9c 2f       	mov	r25, r28
    3d7e:	97 70       	andi	r25, 0x07	; 7
    3d80:	21 f4       	brne	.+8      	; 0x3d8a <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
    3d82:	f8 01       	movw	r30, r16
    3d84:	d4 91       	lpm	r29, Z
				glyph_data++;
    3d86:	0f 5f       	subi	r16, 0xFF	; 255
    3d88:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
    3d8a:	dd 23       	and	r29, r29
    3d8c:	24 f4       	brge	.+8      	; 0x3d96 <gfx_mono_draw_char+0x96>
				gfx_mono_draw_pixel(inc_x, inc_y,
    3d8e:	41 e0       	ldi	r20, 0x01	; 1
    3d90:	6b 2d       	mov	r22, r11
    3d92:	0e 94 4f 05 	call	0xa9e	; 0xa9e <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
    3d96:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
    3d98:	cf 5f       	subi	r28, 0xFF	; 255
    3d9a:	fc 12       	cpse	r15, r28
    3d9c:	ed cf       	rjmp	.-38     	; 0x3d78 <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
    3d9e:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
    3da0:	aa 94       	dec	r10
	} while (rows_left > 0);
    3da2:	a1 10       	cpse	r10, r1
    3da4:	e3 cf       	rjmp	.-58     	; 0x3d6c <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
    3da6:	df 91       	pop	r29
    3da8:	cf 91       	pop	r28
    3daa:	1f 91       	pop	r17
    3dac:	0f 91       	pop	r16
    3dae:	ff 90       	pop	r15
    3db0:	ef 90       	pop	r14
    3db2:	df 90       	pop	r13
    3db4:	cf 90       	pop	r12
    3db6:	bf 90       	pop	r11
    3db8:	af 90       	pop	r10
    3dba:	08 95       	ret

00003dbc <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
    3dbc:	df 92       	push	r13
    3dbe:	ef 92       	push	r14
    3dc0:	ff 92       	push	r15
    3dc2:	0f 93       	push	r16
    3dc4:	1f 93       	push	r17
    3dc6:	cf 93       	push	r28
    3dc8:	df 93       	push	r29
    3dca:	d6 2e       	mov	r13, r22
    3dcc:	04 2f       	mov	r16, r20
    3dce:	79 01       	movw	r14, r18
    3dd0:	ec 01       	movw	r28, r24
    3dd2:	16 2f       	mov	r17, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
    3dd4:	89 91       	ld	r24, Y+
    3dd6:	8a 30       	cpi	r24, 0x0A	; 10
    3dd8:	31 f4       	brne	.+12     	; 0x3de6 <gfx_mono_draw_string+0x2a>
			x = start_of_string_position_x;
			y += font->height + 1;
    3dda:	f7 01       	movw	r30, r14
    3ddc:	84 81       	ldd	r24, Z+4	; 0x04
    3dde:	8f 5f       	subi	r24, 0xFF	; 255
    3de0:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
    3de2:	1d 2d       	mov	r17, r13
    3de4:	09 c0       	rjmp	.+18     	; 0x3df8 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
    3de6:	8d 30       	cpi	r24, 0x0D	; 13
    3de8:	39 f0       	breq	.+14     	; 0x3df8 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
    3dea:	97 01       	movw	r18, r14
    3dec:	40 2f       	mov	r20, r16
    3dee:	61 2f       	mov	r22, r17
    3df0:	87 df       	rcall	.-242    	; 0x3d00 <gfx_mono_draw_char>
			x += font->width;
    3df2:	f7 01       	movw	r30, r14
    3df4:	83 81       	ldd	r24, Z+3	; 0x03
    3df6:	18 0f       	add	r17, r24
		}
	} while (*(++str));
    3df8:	88 81       	ld	r24, Y
    3dfa:	81 11       	cpse	r24, r1
    3dfc:	eb cf       	rjmp	.-42     	; 0x3dd4 <gfx_mono_draw_string+0x18>
}
    3dfe:	df 91       	pop	r29
    3e00:	cf 91       	pop	r28
    3e02:	1f 91       	pop	r17
    3e04:	0f 91       	pop	r16
    3e06:	ff 90       	pop	r15
    3e08:	ef 90       	pop	r14
    3e0a:	df 90       	pop	r13
    3e0c:	08 95       	ret

00003e0e <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    3e0e:	cf 93       	push	r28
    3e10:	df 93       	push	r29
    3e12:	fc 01       	movw	r30, r24
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3e14:	20 e0       	ldi	r18, 0x00	; 0
    3e16:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    3e18:	c6 2f       	mov	r28, r22
    3e1a:	d0 e0       	ldi	r29, 0x00	; 0
    3e1c:	de 01       	movw	r26, r28
    3e1e:	02 2e       	mov	r0, r18
    3e20:	02 c0       	rjmp	.+4      	; 0x3e26 <ioport_configure_port_pin+0x18>
    3e22:	b5 95       	asr	r27
    3e24:	a7 95       	ror	r26
    3e26:	0a 94       	dec	r0
    3e28:	e2 f7       	brpl	.-8      	; 0x3e22 <ioport_configure_port_pin+0x14>
    3e2a:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3e2c:	50 8b       	std	Z+16, r21	; 0x10
    3e2e:	2f 5f       	subi	r18, 0xFF	; 255
    3e30:	3f 4f       	sbci	r19, 0xFF	; 255
    3e32:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    3e34:	28 30       	cpi	r18, 0x08	; 8
    3e36:	31 05       	cpc	r19, r1
    3e38:	89 f7       	brne	.-30     	; 0x3e1c <ioport_configure_port_pin+0xe>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    3e3a:	40 ff       	sbrs	r20, 0
    3e3c:	0a c0       	rjmp	.+20     	; 0x3e52 <ioport_configure_port_pin+0x44>
		if (flags & IOPORT_INIT_HIGH) {
    3e3e:	41 ff       	sbrs	r20, 1
    3e40:	03 c0       	rjmp	.+6      	; 0x3e48 <ioport_configure_port_pin+0x3a>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    3e42:	fc 01       	movw	r30, r24
    3e44:	65 83       	std	Z+5, r22	; 0x05
    3e46:	02 c0       	rjmp	.+4      	; 0x3e4c <ioport_configure_port_pin+0x3e>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    3e48:	fc 01       	movw	r30, r24
    3e4a:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    3e4c:	fc 01       	movw	r30, r24
    3e4e:	61 83       	std	Z+1, r22	; 0x01
    3e50:	02 c0       	rjmp	.+4      	; 0x3e56 <ioport_configure_port_pin+0x48>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    3e52:	fc 01       	movw	r30, r24
    3e54:	62 83       	std	Z+2, r22	; 0x02
	}
}
    3e56:	df 91       	pop	r29
    3e58:	cf 91       	pop	r28
    3e5a:	08 95       	ret

00003e5c <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    3e5c:	43 e0       	ldi	r20, 0x03	; 3
    3e5e:	50 e0       	ldi	r21, 0x00	; 0
    3e60:	61 e0       	ldi	r22, 0x01	; 1
    3e62:	80 ee       	ldi	r24, 0xE0	; 224
    3e64:	97 e0       	ldi	r25, 0x07	; 7
    3e66:	d3 df       	rcall	.-90     	; 0x3e0e <ioport_configure_port_pin>
    3e68:	43 e0       	ldi	r20, 0x03	; 3
    3e6a:	50 e0       	ldi	r21, 0x00	; 0
    3e6c:	62 e0       	ldi	r22, 0x02	; 2
    3e6e:	80 ee       	ldi	r24, 0xE0	; 224
    3e70:	97 e0       	ldi	r25, 0x07	; 7
    3e72:	cd df       	rcall	.-102    	; 0x3e0e <ioport_configure_port_pin>
    3e74:	43 e0       	ldi	r20, 0x03	; 3
    3e76:	50 e0       	ldi	r21, 0x00	; 0
    3e78:	60 e1       	ldi	r22, 0x10	; 16
    3e7a:	80 e6       	ldi	r24, 0x60	; 96
    3e7c:	96 e0       	ldi	r25, 0x06	; 6
    3e7e:	c7 df       	rcall	.-114    	; 0x3e0e <ioport_configure_port_pin>
    3e80:	41 e0       	ldi	r20, 0x01	; 1
    3e82:	50 e4       	ldi	r21, 0x40	; 64
    3e84:	60 e2       	ldi	r22, 0x20	; 32
    3e86:	80 e6       	ldi	r24, 0x60	; 96
    3e88:	96 e0       	ldi	r25, 0x06	; 6
    3e8a:	c1 df       	rcall	.-126    	; 0x3e0e <ioport_configure_port_pin>
    3e8c:	40 e0       	ldi	r20, 0x00	; 0
    3e8e:	5b e1       	ldi	r21, 0x1B	; 27
    3e90:	60 e2       	ldi	r22, 0x20	; 32
    3e92:	80 e8       	ldi	r24, 0x80	; 128
    3e94:	96 e0       	ldi	r25, 0x06	; 6
    3e96:	bb df       	rcall	.-138    	; 0x3e0e <ioport_configure_port_pin>
    3e98:	40 e0       	ldi	r20, 0x00	; 0
    3e9a:	5b e1       	ldi	r21, 0x1B	; 27
    3e9c:	62 e0       	ldi	r22, 0x02	; 2
    3e9e:	80 ea       	ldi	r24, 0xA0	; 160
    3ea0:	96 e0       	ldi	r25, 0x06	; 6
    3ea2:	b5 df       	rcall	.-150    	; 0x3e0e <ioport_configure_port_pin>
    3ea4:	40 e0       	ldi	r20, 0x00	; 0
    3ea6:	5b e1       	ldi	r21, 0x1B	; 27
    3ea8:	64 e0       	ldi	r22, 0x04	; 4
    3eaa:	80 ea       	ldi	r24, 0xA0	; 160
    3eac:	96 e0       	ldi	r25, 0x06	; 6
    3eae:	af df       	rcall	.-162    	; 0x3e0e <ioport_configure_port_pin>
    3eb0:	43 e0       	ldi	r20, 0x03	; 3
    3eb2:	50 e0       	ldi	r21, 0x00	; 0
    3eb4:	62 e0       	ldi	r22, 0x02	; 2
    3eb6:	80 e6       	ldi	r24, 0x60	; 96
    3eb8:	96 e0       	ldi	r25, 0x06	; 6
    3eba:	a9 df       	rcall	.-174    	; 0x3e0e <ioport_configure_port_pin>
    3ebc:	43 e0       	ldi	r20, 0x03	; 3
    3ebe:	50 e0       	ldi	r21, 0x00	; 0
    3ec0:	68 e0       	ldi	r22, 0x08	; 8
    3ec2:	80 e6       	ldi	r24, 0x60	; 96
    3ec4:	96 e0       	ldi	r25, 0x06	; 6
    3ec6:	a3 df       	rcall	.-186    	; 0x3e0e <ioport_configure_port_pin>
    3ec8:	43 e0       	ldi	r20, 0x03	; 3
    3eca:	50 e0       	ldi	r21, 0x00	; 0
    3ecc:	68 e0       	ldi	r22, 0x08	; 8
    3ece:	80 ea       	ldi	r24, 0xA0	; 160
    3ed0:	96 e0       	ldi	r25, 0x06	; 6
    3ed2:	9d df       	rcall	.-198    	; 0x3e0e <ioport_configure_port_pin>
    3ed4:	43 e0       	ldi	r20, 0x03	; 3
    3ed6:	50 e0       	ldi	r21, 0x00	; 0
    3ed8:	61 e0       	ldi	r22, 0x01	; 1
    3eda:	80 e6       	ldi	r24, 0x60	; 96
    3edc:	96 e0       	ldi	r25, 0x06	; 6
    3ede:	97 df       	rcall	.-210    	; 0x3e0e <ioport_configure_port_pin>
    3ee0:	43 e0       	ldi	r20, 0x03	; 3
    3ee2:	50 e0       	ldi	r21, 0x00	; 0
    3ee4:	68 e0       	ldi	r22, 0x08	; 8
    3ee6:	80 e0       	ldi	r24, 0x00	; 0
    3ee8:	96 e0       	ldi	r25, 0x06	; 6
    3eea:	91 df       	rcall	.-222    	; 0x3e0e <ioport_configure_port_pin>
    3eec:	41 e0       	ldi	r20, 0x01	; 1
    3eee:	50 e0       	ldi	r21, 0x00	; 0
    3ef0:	60 e1       	ldi	r22, 0x10	; 16
    3ef2:	80 e8       	ldi	r24, 0x80	; 128
    3ef4:	96 e0       	ldi	r25, 0x06	; 6
    3ef6:	8b df       	rcall	.-234    	; 0x3e0e <ioport_configure_port_pin>
    3ef8:	43 e0       	ldi	r20, 0x03	; 3
    3efa:	50 e0       	ldi	r21, 0x00	; 0
    3efc:	62 e0       	ldi	r22, 0x02	; 2
    3efe:	80 e6       	ldi	r24, 0x60	; 96
    3f00:	96 e0       	ldi	r25, 0x06	; 6
    3f02:	85 df       	rcall	.-246    	; 0x3e0e <ioport_configure_port_pin>
    3f04:	43 e0       	ldi	r20, 0x03	; 3
    3f06:	50 e0       	ldi	r21, 0x00	; 0
    3f08:	68 e0       	ldi	r22, 0x08	; 8
    3f0a:	80 e6       	ldi	r24, 0x60	; 96
    3f0c:	96 e0       	ldi	r25, 0x06	; 6
    3f0e:	7f df       	rcall	.-258    	; 0x3e0e <ioport_configure_port_pin>
    3f10:	40 e0       	ldi	r20, 0x00	; 0
    3f12:	50 e0       	ldi	r21, 0x00	; 0
    3f14:	64 e0       	ldi	r22, 0x04	; 4
    3f16:	80 e6       	ldi	r24, 0x60	; 96
    3f18:	96 e0       	ldi	r25, 0x06	; 6
    3f1a:	79 df       	rcall	.-270    	; 0x3e0e <ioport_configure_port_pin>
    3f1c:	43 e0       	ldi	r20, 0x03	; 3
    3f1e:	50 e0       	ldi	r21, 0x00	; 0
    3f20:	60 e1       	ldi	r22, 0x10	; 16
    3f22:	80 ea       	ldi	r24, 0xA0	; 160
    3f24:	96 e0       	ldi	r25, 0x06	; 6
    3f26:	73 df       	rcall	.-282    	; 0x3e0e <ioport_configure_port_pin>
    3f28:	40 e0       	ldi	r20, 0x00	; 0
    3f2a:	50 e0       	ldi	r21, 0x00	; 0
    3f2c:	61 e0       	ldi	r22, 0x01	; 1
    3f2e:	80 e0       	ldi	r24, 0x00	; 0
    3f30:	96 e0       	ldi	r25, 0x06	; 6
    3f32:	6d df       	rcall	.-294    	; 0x3e0e <ioport_configure_port_pin>
    3f34:	40 e0       	ldi	r20, 0x00	; 0
    3f36:	50 e0       	ldi	r21, 0x00	; 0
    3f38:	64 e0       	ldi	r22, 0x04	; 4
    3f3a:	80 e0       	ldi	r24, 0x00	; 0
    3f3c:	96 e0       	ldi	r25, 0x06	; 6
    3f3e:	67 df       	rcall	.-306    	; 0x3e0e <ioport_configure_port_pin>
    3f40:	40 e0       	ldi	r20, 0x00	; 0
    3f42:	50 e0       	ldi	r21, 0x00	; 0
    3f44:	62 e0       	ldi	r22, 0x02	; 2
    3f46:	80 e2       	ldi	r24, 0x20	; 32
    3f48:	96 e0       	ldi	r25, 0x06	; 6
    3f4a:	61 df       	rcall	.-318    	; 0x3e0e <ioport_configure_port_pin>
    3f4c:	43 e0       	ldi	r20, 0x03	; 3
    3f4e:	50 e0       	ldi	r21, 0x00	; 0
    3f50:	68 e0       	ldi	r22, 0x08	; 8
    3f52:	80 e4       	ldi	r24, 0x40	; 64
    3f54:	96 e0       	ldi	r25, 0x06	; 6
    3f56:	5b df       	rcall	.-330    	; 0x3e0e <ioport_configure_port_pin>
    3f58:	40 e0       	ldi	r20, 0x00	; 0
    3f5a:	50 e0       	ldi	r21, 0x00	; 0
    3f5c:	64 e0       	ldi	r22, 0x04	; 4
    3f5e:	80 e4       	ldi	r24, 0x40	; 64
    3f60:	96 e0       	ldi	r25, 0x06	; 6
    3f62:	55 df       	rcall	.-342    	; 0x3e0e <ioport_configure_port_pin>
    3f64:	43 e0       	ldi	r20, 0x03	; 3
    3f66:	50 e0       	ldi	r21, 0x00	; 0
    3f68:	68 e0       	ldi	r22, 0x08	; 8
    3f6a:	80 e6       	ldi	r24, 0x60	; 96
    3f6c:	96 e0       	ldi	r25, 0x06	; 6
    3f6e:	4f df       	rcall	.-354    	; 0x3e0e <ioport_configure_port_pin>
    3f70:	40 e0       	ldi	r20, 0x00	; 0
    3f72:	50 e0       	ldi	r21, 0x00	; 0
    3f74:	64 e0       	ldi	r22, 0x04	; 4
    3f76:	80 e6       	ldi	r24, 0x60	; 96
    3f78:	96 e0       	ldi	r25, 0x06	; 6
    3f7a:	49 df       	rcall	.-366    	; 0x3e0e <ioport_configure_port_pin>
    3f7c:	43 e0       	ldi	r20, 0x03	; 3
    3f7e:	50 e0       	ldi	r21, 0x00	; 0
    3f80:	68 e0       	ldi	r22, 0x08	; 8
    3f82:	80 e8       	ldi	r24, 0x80	; 128
    3f84:	96 e0       	ldi	r25, 0x06	; 6
    3f86:	43 df       	rcall	.-378    	; 0x3e0e <ioport_configure_port_pin>
    3f88:	40 e0       	ldi	r20, 0x00	; 0
    3f8a:	50 e0       	ldi	r21, 0x00	; 0
    3f8c:	64 e0       	ldi	r22, 0x04	; 4
    3f8e:	80 e8       	ldi	r24, 0x80	; 128
    3f90:	96 e0       	ldi	r25, 0x06	; 6
    3f92:	3d cf       	rjmp	.-390    	; 0x3e0e <ioport_configure_port_pin>
    3f94:	08 95       	ret

00003f96 <__portable_avr_delay_cycles>:
static char lightResult[128];

/* Functions for Photosensitive Sensor*/
// Setup PB3 as input
void setup_photosensitive_sensor(void) {
	PORTB.DIRCLR = PIN3_bm; // Set PB0 (connected to D0 pin of the sensor) as input
    3f96:	04 c0       	rjmp	.+8      	; 0x3fa0 <__portable_avr_delay_cycles+0xa>
    3f98:	61 50       	subi	r22, 0x01	; 1
    3f9a:	71 09       	sbc	r23, r1
    3f9c:	81 09       	sbc	r24, r1
    3f9e:	91 09       	sbc	r25, r1
    3fa0:	61 15       	cp	r22, r1
    3fa2:	71 05       	cpc	r23, r1
    3fa4:	81 05       	cpc	r24, r1
    3fa6:	91 05       	cpc	r25, r1
    3fa8:	b9 f7       	brne	.-18     	; 0x3f98 <__portable_avr_delay_cycles+0x2>
    3faa:	08 95       	ret

00003fac <increment_distance>:
    3fac:	80 91 7d 23 	lds	r24, 0x237D	; 0x80237d <incremental>
    3fb0:	90 91 7e 23 	lds	r25, 0x237E	; 0x80237e <incremental+0x1>
    3fb4:	01 96       	adiw	r24, 0x01	; 1
    3fb6:	80 93 7d 23 	sts	0x237D, r24	; 0x80237d <incremental>
    3fba:	90 93 7e 23 	sts	0x237E, r25	; 0x80237e <incremental+0x1>
    3fbe:	08 95       	ret

00003fc0 <vCounter>:
    3fc0:	cf 93       	push	r28
    3fc2:	df 93       	push	r29
    3fc4:	cd b7       	in	r28, 0x3d	; 61
    3fc6:	de b7       	in	r29, 0x3e	; 62
    3fc8:	c0 58       	subi	r28, 0x80	; 128
    3fca:	d1 09       	sbc	r29, r1
    3fcc:	cd bf       	out	0x3d, r28	; 61
    3fce:	de bf       	out	0x3e, r29	; 62
    3fd0:	0f 2e       	mov	r0, r31
    3fd2:	fa e1       	ldi	r31, 0x1A	; 26
    3fd4:	ef 2e       	mov	r14, r31
    3fd6:	f0 e2       	ldi	r31, 0x20	; 32
    3fd8:	ff 2e       	mov	r15, r31
    3fda:	f0 2d       	mov	r31, r0
    3fdc:	68 94       	set
    3fde:	dd 24       	eor	r13, r13
    3fe0:	d7 f8       	bld	r13, 7
    3fe2:	8e 01       	movw	r16, r28
    3fe4:	0f 5f       	subi	r16, 0xFF	; 255
    3fe6:	1f 4f       	sbci	r17, 0xFF	; 255
    3fe8:	6a e0       	ldi	r22, 0x0A	; 10
    3fea:	70 e0       	ldi	r23, 0x00	; 0
    3fec:	80 91 8b 24 	lds	r24, 0x248B	; 0x80248b <xSemaphore>
    3ff0:	90 91 8c 24 	lds	r25, 0x248C	; 0x80248c <xSemaphore+0x1>
    3ff4:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <xQueueSemaphoreTake>
    3ff8:	81 30       	cpi	r24, 0x01	; 1
    3ffa:	29 f5       	brne	.+74     	; 0x4046 <vCounter+0x86>
    3ffc:	80 91 7f 24 	lds	r24, 0x247F	; 0x80247f <counter>
    4000:	90 91 80 24 	lds	r25, 0x2480	; 0x802480 <counter+0x1>
    4004:	01 96       	adiw	r24, 0x01	; 1
    4006:	80 93 7f 24 	sts	0x247F, r24	; 0x80247f <counter>
    400a:	90 93 80 24 	sts	0x2480, r25	; 0x802480 <counter+0x1>
    400e:	9f 93       	push	r25
    4010:	8f 93       	push	r24
    4012:	ff 92       	push	r15
    4014:	ef 92       	push	r14
    4016:	1f 92       	push	r1
    4018:	df 92       	push	r13
    401a:	1f 93       	push	r17
    401c:	0f 93       	push	r16
    401e:	6d d4       	rcall	.+2266   	; 0x48fa <snprintf>
    4020:	26 e0       	ldi	r18, 0x06	; 6
    4022:	30 e2       	ldi	r19, 0x20	; 32
    4024:	48 e0       	ldi	r20, 0x08	; 8
    4026:	60 e0       	ldi	r22, 0x00	; 0
    4028:	c8 01       	movw	r24, r16
    402a:	c8 de       	rcall	.-624    	; 0x3dbc <gfx_mono_draw_string>
    402c:	20 e0       	ldi	r18, 0x00	; 0
    402e:	40 e0       	ldi	r20, 0x00	; 0
    4030:	50 e0       	ldi	r21, 0x00	; 0
    4032:	60 e0       	ldi	r22, 0x00	; 0
    4034:	70 e0       	ldi	r23, 0x00	; 0
    4036:	80 91 8b 24 	lds	r24, 0x248B	; 0x80248b <xSemaphore>
    403a:	90 91 8c 24 	lds	r25, 0x248C	; 0x80248c <xSemaphore+0x1>
    403e:	0e 94 23 15 	call	0x2a46	; 0x2a46 <xQueueGenericSend>
    4042:	cd bf       	out	0x3d, r28	; 61
    4044:	de bf       	out	0x3e, r29	; 62
    4046:	82 e3       	ldi	r24, 0x32	; 50
    4048:	90 e0       	ldi	r25, 0x00	; 0
    404a:	b2 d9       	rcall	.-3228   	; 0x33b0 <vTaskDelay>
    404c:	cd cf       	rjmp	.-102    	; 0x3fe8 <vCounter+0x28>

0000404e <vPushButton1>:
    404e:	cf 93       	push	r28
    4050:	df 93       	push	r29
    4052:	cd b7       	in	r28, 0x3d	; 61
    4054:	de b7       	in	r29, 0x3e	; 62
    4056:	c0 58       	subi	r28, 0x80	; 128
    4058:	d1 09       	sbc	r29, r1
    405a:	cd bf       	out	0x3d, r28	; 61
    405c:	de bf       	out	0x3e, r29	; 62
    405e:	00 ea       	ldi	r16, 0xA0	; 160
    4060:	16 e0       	ldi	r17, 0x06	; 6
    4062:	0f 2e       	mov	r0, r31
    4064:	fa e1       	ldi	r31, 0x1A	; 26
    4066:	cf 2e       	mov	r12, r31
    4068:	f0 e2       	ldi	r31, 0x20	; 32
    406a:	df 2e       	mov	r13, r31
    406c:	f0 2d       	mov	r31, r0
    406e:	68 94       	set
    4070:	bb 24       	eor	r11, r11
    4072:	b7 f8       	bld	r11, 7
    4074:	ce 01       	movw	r24, r28
    4076:	01 96       	adiw	r24, 0x01	; 1
    4078:	7c 01       	movw	r14, r24
    407a:	f8 01       	movw	r30, r16
    407c:	80 85       	ldd	r24, Z+8	; 0x08
    407e:	81 fd       	sbrc	r24, 1
    4080:	2f c0       	rjmp	.+94     	; 0x40e0 <vPushButton1+0x92>
    4082:	6a e0       	ldi	r22, 0x0A	; 10
    4084:	70 e0       	ldi	r23, 0x00	; 0
    4086:	80 91 8b 24 	lds	r24, 0x248B	; 0x80248b <xSemaphore>
    408a:	90 91 8c 24 	lds	r25, 0x248C	; 0x80248c <xSemaphore+0x1>
    408e:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <xQueueSemaphoreTake>
    4092:	81 30       	cpi	r24, 0x01	; 1
    4094:	29 f5       	brne	.+74     	; 0x40e0 <vPushButton1+0x92>
    4096:	80 91 7f 24 	lds	r24, 0x247F	; 0x80247f <counter>
    409a:	90 91 80 24 	lds	r25, 0x2480	; 0x802480 <counter+0x1>
    409e:	01 96       	adiw	r24, 0x01	; 1
    40a0:	80 93 7f 24 	sts	0x247F, r24	; 0x80247f <counter>
    40a4:	90 93 80 24 	sts	0x2480, r25	; 0x802480 <counter+0x1>
    40a8:	9f 93       	push	r25
    40aa:	8f 93       	push	r24
    40ac:	df 92       	push	r13
    40ae:	cf 92       	push	r12
    40b0:	1f 92       	push	r1
    40b2:	bf 92       	push	r11
    40b4:	ff 92       	push	r15
    40b6:	ef 92       	push	r14
    40b8:	20 d4       	rcall	.+2112   	; 0x48fa <snprintf>
    40ba:	26 e0       	ldi	r18, 0x06	; 6
    40bc:	30 e2       	ldi	r19, 0x20	; 32
    40be:	48 e0       	ldi	r20, 0x08	; 8
    40c0:	60 e0       	ldi	r22, 0x00	; 0
    40c2:	c7 01       	movw	r24, r14
    40c4:	7b de       	rcall	.-778    	; 0x3dbc <gfx_mono_draw_string>
    40c6:	20 e0       	ldi	r18, 0x00	; 0
    40c8:	40 e0       	ldi	r20, 0x00	; 0
    40ca:	50 e0       	ldi	r21, 0x00	; 0
    40cc:	60 e0       	ldi	r22, 0x00	; 0
    40ce:	70 e0       	ldi	r23, 0x00	; 0
    40d0:	80 91 8b 24 	lds	r24, 0x248B	; 0x80248b <xSemaphore>
    40d4:	90 91 8c 24 	lds	r25, 0x248C	; 0x80248c <xSemaphore+0x1>
    40d8:	0e 94 23 15 	call	0x2a46	; 0x2a46 <xQueueGenericSend>
    40dc:	cd bf       	out	0x3d, r28	; 61
    40de:	de bf       	out	0x3e, r29	; 62
    40e0:	85 e0       	ldi	r24, 0x05	; 5
    40e2:	90 e0       	ldi	r25, 0x00	; 0
    40e4:	65 d9       	rcall	.-3382   	; 0x33b0 <vTaskDelay>
    40e6:	c9 cf       	rjmp	.-110    	; 0x407a <vPushButton1+0x2c>

000040e8 <vSoilSensor>:
    40e8:	cf 93       	push	r28
    40ea:	df 93       	push	r29
    40ec:	cd b7       	in	r28, 0x3d	; 61
    40ee:	de b7       	in	r29, 0x3e	; 62
    40f0:	c1 58       	subi	r28, 0x81	; 129
    40f2:	d1 09       	sbc	r29, r1
    40f4:	cd bf       	out	0x3d, r28	; 61
    40f6:	de bf       	out	0x3e, r29	; 62
    40f8:	e0 e4       	ldi	r30, 0x40	; 64
    40fa:	f6 e0       	ldi	r31, 0x06	; 6
    40fc:	81 e0       	ldi	r24, 0x01	; 1
    40fe:	81 83       	std	Z+1, r24	; 0x01
    4100:	85 83       	std	Z+5, r24	; 0x05
    4102:	00 e0       	ldi	r16, 0x00	; 0
    4104:	12 e0       	ldi	r17, 0x02	; 2
    4106:	22 24       	eor	r2, r2
    4108:	23 94       	inc	r2
    410a:	0f 2e       	mov	r0, r31
    410c:	f7 e2       	ldi	r31, 0x27	; 39
    410e:	af 2e       	mov	r10, r31
    4110:	f0 e2       	ldi	r31, 0x20	; 32
    4112:	bf 2e       	mov	r11, r31
    4114:	f0 2d       	mov	r31, r0
    4116:	68 94       	set
    4118:	33 24       	eor	r3, r3
    411a:	37 f8       	bld	r3, 7
    411c:	ce 01       	movw	r24, r28
    411e:	01 96       	adiw	r24, 0x01	; 1
    4120:	6c 01       	movw	r12, r24
    4122:	0f 2e       	mov	r0, r31
    4124:	ff e7       	ldi	r31, 0x7F	; 127
    4126:	8f 2e       	mov	r8, r31
    4128:	f3 e2       	ldi	r31, 0x23	; 35
    412a:	9f 2e       	mov	r9, r31
    412c:	f0 2d       	mov	r31, r0
    412e:	0f 2e       	mov	r0, r31
    4130:	f0 e4       	ldi	r31, 0x40	; 64
    4132:	4f 2e       	mov	r4, r31
    4134:	f6 e0       	ldi	r31, 0x06	; 6
    4136:	5f 2e       	mov	r5, r31
    4138:	f0 2d       	mov	r31, r0
    413a:	0f 2e       	mov	r0, r31
    413c:	fa e3       	ldi	r31, 0x3A	; 58
    413e:	6f 2e       	mov	r6, r31
    4140:	f0 e2       	ldi	r31, 0x20	; 32
    4142:	7f 2e       	mov	r7, r31
    4144:	f0 2d       	mov	r31, r0
    4146:	6a e0       	ldi	r22, 0x0A	; 10
    4148:	70 e0       	ldi	r23, 0x00	; 0
    414a:	80 91 8b 24 	lds	r24, 0x248B	; 0x80248b <xSemaphore>
    414e:	90 91 8c 24 	lds	r25, 0x248C	; 0x80248c <xSemaphore+0x1>
    4152:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <xQueueSemaphoreTake>
    4156:	81 30       	cpi	r24, 0x01	; 1
    4158:	09 f0       	breq	.+2      	; 0x415c <vSoilSensor+0x74>
    415a:	72 c0       	rjmp	.+228    	; 0x4240 <vSoilSensor+0x158>
    415c:	c8 01       	movw	r24, r16
    415e:	0e 94 c9 05 	call	0xb92	; 0xb92 <adc_enable>
    4162:	8f b7       	in	r24, 0x3f	; 63
    4164:	cf 57       	subi	r28, 0x7F	; 127
    4166:	df 4f       	sbci	r29, 0xFF	; 255
    4168:	88 83       	st	Y, r24
    416a:	c1 58       	subi	r28, 0x81	; 129
    416c:	d0 40       	sbci	r29, 0x00	; 0
    416e:	f8 94       	cli
    4170:	cf 57       	subi	r28, 0x7F	; 127
    4172:	df 4f       	sbci	r29, 0xFF	; 255
    4174:	98 81       	ld	r25, Y
    4176:	c1 58       	subi	r28, 0x81	; 129
    4178:	d0 40       	sbci	r29, 0x00	; 0
    417a:	f8 01       	movw	r30, r16
    417c:	80 81       	ld	r24, Z
    417e:	84 60       	ori	r24, 0x04	; 4
    4180:	80 83       	st	Z, r24
    4182:	9f bf       	out	0x3f, r25	; 63
    4184:	f8 01       	movw	r30, r16
    4186:	86 81       	ldd	r24, Z+6	; 0x06
    4188:	80 ff       	sbrs	r24, 0
    418a:	fc cf       	rjmp	.-8      	; 0x4184 <vSoilSensor+0x9c>
    418c:	26 82       	std	Z+6, r2	; 0x06
    418e:	e4 a0       	ldd	r14, Z+36	; 0x24
    4190:	f5 a0       	ldd	r15, Z+37	; 0x25
    4192:	c8 01       	movw	r24, r16
    4194:	0e 94 f5 05 	call	0xbea	; 0xbea <adc_disable>
    4198:	ff 92       	push	r15
    419a:	ef 92       	push	r14
    419c:	bf 92       	push	r11
    419e:	af 92       	push	r10
    41a0:	1f 92       	push	r1
    41a2:	3f 92       	push	r3
    41a4:	df 92       	push	r13
    41a6:	cf 92       	push	r12
    41a8:	a8 d3       	rcall	.+1872   	; 0x48fa <snprintf>
    41aa:	26 e0       	ldi	r18, 0x06	; 6
    41ac:	30 e2       	ldi	r19, 0x20	; 32
    41ae:	40 e1       	ldi	r20, 0x10	; 16
    41b0:	60 e0       	ldi	r22, 0x00	; 0
    41b2:	c6 01       	movw	r24, r12
    41b4:	03 de       	rcall	.-1018   	; 0x3dbc <gfx_mono_draw_string>
    41b6:	cd bf       	out	0x3d, r28	; 61
    41b8:	de bf       	out	0x3e, r29	; 62
    41ba:	99 ed       	ldi	r25, 0xD9	; 217
    41bc:	e9 16       	cp	r14, r25
    41be:	9e e0       	ldi	r25, 0x0E	; 14
    41c0:	f9 06       	cpc	r15, r25
    41c2:	b0 f0       	brcs	.+44     	; 0x41f0 <vSoilSensor+0x108>
    41c4:	87 e0       	ldi	r24, 0x07	; 7
    41c6:	e3 e3       	ldi	r30, 0x33	; 51
    41c8:	f0 e2       	ldi	r31, 0x20	; 32
    41ca:	d4 01       	movw	r26, r8
    41cc:	01 90       	ld	r0, Z+
    41ce:	0d 92       	st	X+, r0
    41d0:	8a 95       	dec	r24
    41d2:	e1 f7       	brne	.-8      	; 0x41cc <vSoilSensor+0xe4>
    41d4:	f2 01       	movw	r30, r4
    41d6:	26 82       	std	Z+6, r2	; 0x06
    41d8:	9f 92       	push	r9
    41da:	8f 92       	push	r8
    41dc:	7f 92       	push	r7
    41de:	6f 92       	push	r6
    41e0:	1f 92       	push	r1
    41e2:	3f 92       	push	r3
    41e4:	df 92       	push	r13
    41e6:	cf 92       	push	r12
    41e8:	88 d3       	rcall	.+1808   	; 0x48fa <snprintf>
    41ea:	cd bf       	out	0x3d, r28	; 61
    41ec:	de bf       	out	0x3e, r29	; 62
    41ee:	17 c0       	rjmp	.+46     	; 0x421e <vSoilSensor+0x136>
    41f0:	87 e0       	ldi	r24, 0x07	; 7
    41f2:	eb e4       	ldi	r30, 0x4B	; 75
    41f4:	f0 e2       	ldi	r31, 0x20	; 32
    41f6:	d4 01       	movw	r26, r8
    41f8:	01 90       	ld	r0, Z+
    41fa:	0d 92       	st	X+, r0
    41fc:	8a 95       	dec	r24
    41fe:	e1 f7       	brne	.-8      	; 0x41f8 <vSoilSensor+0x110>
    4200:	f2 01       	movw	r30, r4
    4202:	25 82       	std	Z+5, r2	; 0x05
    4204:	9f 92       	push	r9
    4206:	8f 92       	push	r8
    4208:	82 e5       	ldi	r24, 0x52	; 82
    420a:	90 e2       	ldi	r25, 0x20	; 32
    420c:	9f 93       	push	r25
    420e:	8f 93       	push	r24
    4210:	1f 92       	push	r1
    4212:	3f 92       	push	r3
    4214:	df 92       	push	r13
    4216:	cf 92       	push	r12
    4218:	70 d3       	rcall	.+1760   	; 0x48fa <snprintf>
    421a:	cd bf       	out	0x3d, r28	; 61
    421c:	de bf       	out	0x3e, r29	; 62
    421e:	26 e0       	ldi	r18, 0x06	; 6
    4220:	30 e2       	ldi	r19, 0x20	; 32
    4222:	48 e1       	ldi	r20, 0x18	; 24
    4224:	60 e0       	ldi	r22, 0x00	; 0
    4226:	c6 01       	movw	r24, r12
    4228:	c9 dd       	rcall	.-1134   	; 0x3dbc <gfx_mono_draw_string>
    422a:	20 e0       	ldi	r18, 0x00	; 0
    422c:	40 e0       	ldi	r20, 0x00	; 0
    422e:	50 e0       	ldi	r21, 0x00	; 0
    4230:	60 e0       	ldi	r22, 0x00	; 0
    4232:	70 e0       	ldi	r23, 0x00	; 0
    4234:	80 91 8b 24 	lds	r24, 0x248B	; 0x80248b <xSemaphore>
    4238:	90 91 8c 24 	lds	r25, 0x248C	; 0x80248c <xSemaphore+0x1>
    423c:	0e 94 23 15 	call	0x2a46	; 0x2a46 <xQueueGenericSend>
    4240:	82 e3       	ldi	r24, 0x32	; 50
    4242:	90 e0       	ldi	r25, 0x00	; 0
    4244:	b5 d8       	rcall	.-3734   	; 0x33b0 <vTaskDelay>
    4246:	7f cf       	rjmp	.-258    	; 0x4146 <vSoilSensor+0x5e>

00004248 <vUltrasonicSensor>:
    4248:	cf 93       	push	r28
    424a:	df 93       	push	r29
    424c:	cd b7       	in	r28, 0x3d	; 61
    424e:	de b7       	in	r29, 0x3e	; 62
    4250:	c0 58       	subi	r28, 0x80	; 128
    4252:	d1 09       	sbc	r29, r1
    4254:	cd bf       	out	0x3d, r28	; 61
    4256:	de bf       	out	0x3e, r29	; 62
    4258:	0f 2e       	mov	r0, r31
    425a:	f0 e4       	ldi	r31, 0x40	; 64
    425c:	cf 2e       	mov	r12, r31
    425e:	fa e0       	ldi	r31, 0x0A	; 10
    4260:	df 2e       	mov	r13, r31
    4262:	f0 2d       	mov	r31, r0
    4264:	00 e2       	ldi	r16, 0x20	; 32
    4266:	16 e0       	ldi	r17, 0x06	; 6
    4268:	77 24       	eor	r7, r7
    426a:	73 94       	inc	r7
    426c:	0f 2e       	mov	r0, r31
    426e:	f4 e6       	ldi	r31, 0x64	; 100
    4270:	8f 2e       	mov	r8, r31
    4272:	f0 e2       	ldi	r31, 0x20	; 32
    4274:	9f 2e       	mov	r9, r31
    4276:	f0 2d       	mov	r31, r0
    4278:	68 94       	set
    427a:	66 24       	eor	r6, r6
    427c:	67 f8       	bld	r6, 7
    427e:	ce 01       	movw	r24, r28
    4280:	01 96       	adiw	r24, 0x01	; 1
    4282:	5c 01       	movw	r10, r24
    4284:	0f 2e       	mov	r0, r31
    4286:	f4 e6       	ldi	r31, 0x64	; 100
    4288:	2f 2e       	mov	r2, r31
    428a:	31 2c       	mov	r3, r1
    428c:	f0 2d       	mov	r31, r0
    428e:	0f 2e       	mov	r0, r31
    4290:	fc e2       	ldi	r31, 0x2C	; 44
    4292:	4f 2e       	mov	r4, r31
    4294:	f0 2d       	mov	r31, r0
    4296:	55 24       	eor	r5, r5
    4298:	53 94       	inc	r5
    429a:	6a e0       	ldi	r22, 0x0A	; 10
    429c:	70 e0       	ldi	r23, 0x00	; 0
    429e:	80 91 8b 24 	lds	r24, 0x248B	; 0x80248b <xSemaphore>
    42a2:	90 91 8c 24 	lds	r25, 0x248C	; 0x80248c <xSemaphore+0x1>
    42a6:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <xQueueSemaphoreTake>
    42aa:	81 30       	cpi	r24, 0x01	; 1
    42ac:	09 f0       	breq	.+2      	; 0x42b0 <vUltrasonicSensor+0x68>
    42ae:	82 c0       	rjmp	.+260    	; 0x43b4 <vUltrasonicSensor+0x16c>
    42b0:	f6 01       	movw	r30, r12
    42b2:	80 81       	ld	r24, Z
    42b4:	80 7f       	andi	r24, 0xF0	; 240
    42b6:	81 60       	ori	r24, 0x01	; 1
    42b8:	80 83       	st	Z, r24
    42ba:	f8 01       	movw	r30, r16
    42bc:	71 82       	std	Z+1, r7	; 0x01
    42be:	76 82       	std	Z+6, r7	; 0x06
    42c0:	75 82       	std	Z+5, r7	; 0x05
    42c2:	62 e0       	ldi	r22, 0x02	; 2
    42c4:	70 e0       	ldi	r23, 0x00	; 0
    42c6:	80 e0       	ldi	r24, 0x00	; 0
    42c8:	90 e0       	ldi	r25, 0x00	; 0
    42ca:	65 de       	rcall	.-822    	; 0x3f96 <__portable_avr_delay_cycles>
    42cc:	f8 01       	movw	r30, r16
    42ce:	76 82       	std	Z+6, r7	; 0x06
    42d0:	72 82       	std	Z+2, r7	; 0x02
    42d2:	66 e8       	ldi	r22, 0x86	; 134
    42d4:	70 e0       	ldi	r23, 0x00	; 0
    42d6:	80 e0       	ldi	r24, 0x00	; 0
    42d8:	90 e0       	ldi	r25, 0x00	; 0
    42da:	5d de       	rcall	.-838    	; 0x3f96 <__portable_avr_delay_cycles>
    42dc:	e0 90 7d 23 	lds	r14, 0x237D	; 0x80237d <incremental>
    42e0:	f0 90 7e 23 	lds	r15, 0x237E	; 0x80237e <incremental+0x1>
    42e4:	67 e2       	ldi	r22, 0x27	; 39
    42e6:	70 e0       	ldi	r23, 0x00	; 0
    42e8:	80 e0       	ldi	r24, 0x00	; 0
    42ea:	90 e0       	ldi	r25, 0x00	; 0
    42ec:	54 de       	rcall	.-856    	; 0x3f96 <__portable_avr_delay_cycles>
    42ee:	78 94       	sei
    42f0:	f8 01       	movw	r30, r16
    42f2:	80 85       	ldd	r24, Z+8	; 0x08
    42f4:	80 fd       	sbrc	r24, 0
    42f6:	fc cf       	rjmp	.-8      	; 0x42f0 <vUltrasonicSensor+0xa8>
    42f8:	20 91 7d 23 	lds	r18, 0x237D	; 0x80237d <incremental>
    42fc:	30 91 7e 23 	lds	r19, 0x237E	; 0x80237e <incremental+0x1>
    4300:	f6 01       	movw	r30, r12
    4302:	80 81       	ld	r24, Z
    4304:	80 7f       	andi	r24, 0xF0	; 240
    4306:	80 83       	st	Z, r24
    4308:	f8 94       	cli
    430a:	80 91 7d 23 	lds	r24, 0x237D	; 0x80237d <incremental>
    430e:	90 91 7e 23 	lds	r25, 0x237E	; 0x80237e <incremental+0x1>
    4312:	8d 32       	cpi	r24, 0x2D	; 45
    4314:	91 40       	sbci	r25, 0x01	; 1
    4316:	38 f0       	brcs	.+14     	; 0x4326 <vUltrasonicSensor+0xde>
    4318:	40 92 7b 23 	sts	0x237B, r4	; 0x80237b <distance>
    431c:	50 92 7c 23 	sts	0x237C, r5	; 0x80237c <distance+0x1>
    4320:	e4 2c       	mov	r14, r4
    4322:	f5 2c       	mov	r15, r5
    4324:	1d c0       	rjmp	.+58     	; 0x4360 <vUltrasonicSensor+0x118>
    4326:	2e 19       	sub	r18, r14
    4328:	3f 09       	sbc	r19, r15
    432a:	79 01       	movw	r14, r18
    432c:	1a f4       	brpl	.+6      	; 0x4334 <vUltrasonicSensor+0xec>
    432e:	4f ef       	ldi	r20, 0xFF	; 255
    4330:	e4 1a       	sub	r14, r20
    4332:	f4 0a       	sbc	r15, r20
    4334:	f5 94       	asr	r15
    4336:	e7 94       	ror	r14
    4338:	e0 92 7b 23 	sts	0x237B, r14	; 0x80237b <distance>
    433c:	f0 92 7c 23 	sts	0x237C, r15	; 0x80237c <distance+0x1>
    4340:	97 01       	movw	r18, r14
    4342:	a4 e6       	ldi	r26, 0x64	; 100
    4344:	b0 e0       	ldi	r27, 0x00	; 0
    4346:	a0 d1       	rcall	.+832    	; 0x4688 <__umulhisi3>
    4348:	2f e0       	ldi	r18, 0x0F	; 15
    434a:	30 e0       	ldi	r19, 0x00	; 0
    434c:	40 e0       	ldi	r20, 0x00	; 0
    434e:	50 e0       	ldi	r21, 0x00	; 0
    4350:	71 d1       	rcall	.+738    	; 0x4634 <__udivmodsi4>
    4352:	20 93 79 23 	sts	0x2379, r18	; 0x802379 <distance_percentage>
    4356:	30 93 7a 23 	sts	0x237A, r19	; 0x80237a <distance_percentage+0x1>
    435a:	25 36       	cpi	r18, 0x65	; 101
    435c:	31 05       	cpc	r19, r1
    435e:	20 f0       	brcs	.+8      	; 0x4368 <vUltrasonicSensor+0x120>
    4360:	20 92 79 23 	sts	0x2379, r2	; 0x802379 <distance_percentage>
    4364:	30 92 7a 23 	sts	0x237A, r3	; 0x80237a <distance_percentage+0x1>
    4368:	80 91 7a 23 	lds	r24, 0x237A	; 0x80237a <distance_percentage+0x1>
    436c:	8f 93       	push	r24
    436e:	80 91 79 23 	lds	r24, 0x2379	; 0x802379 <distance_percentage>
    4372:	8f 93       	push	r24
    4374:	ff 92       	push	r15
    4376:	ef 92       	push	r14
    4378:	9f 92       	push	r9
    437a:	8f 92       	push	r8
    437c:	1f 92       	push	r1
    437e:	6f 92       	push	r6
    4380:	bf 92       	push	r11
    4382:	af 92       	push	r10
    4384:	ba d2       	rcall	.+1396   	; 0x48fa <snprintf>
    4386:	26 e0       	ldi	r18, 0x06	; 6
    4388:	30 e2       	ldi	r19, 0x20	; 32
    438a:	40 e0       	ldi	r20, 0x00	; 0
    438c:	60 e0       	ldi	r22, 0x00	; 0
    438e:	c5 01       	movw	r24, r10
    4390:	15 dd       	rcall	.-1494   	; 0x3dbc <gfx_mono_draw_string>
    4392:	10 92 7d 23 	sts	0x237D, r1	; 0x80237d <incremental>
    4396:	10 92 7e 23 	sts	0x237E, r1	; 0x80237e <incremental+0x1>
    439a:	20 e0       	ldi	r18, 0x00	; 0
    439c:	40 e0       	ldi	r20, 0x00	; 0
    439e:	50 e0       	ldi	r21, 0x00	; 0
    43a0:	60 e0       	ldi	r22, 0x00	; 0
    43a2:	70 e0       	ldi	r23, 0x00	; 0
    43a4:	80 91 8b 24 	lds	r24, 0x248B	; 0x80248b <xSemaphore>
    43a8:	90 91 8c 24 	lds	r25, 0x248C	; 0x80248c <xSemaphore+0x1>
    43ac:	0e 94 23 15 	call	0x2a46	; 0x2a46 <xQueueGenericSend>
    43b0:	cd bf       	out	0x3d, r28	; 61
    43b2:	de bf       	out	0x3e, r29	; 62
    43b4:	8b e4       	ldi	r24, 0x4B	; 75
    43b6:	90 e0       	ldi	r25, 0x00	; 0
    43b8:	0e 94 d8 19 	call	0x33b0	; 0x33b0 <vTaskDelay>
    43bc:	6e cf       	rjmp	.-292    	; 0x429a <vUltrasonicSensor+0x52>

000043be <read_photosensitive_sensor>:

// Read sensor as well as save the result
void read_photosensitive_sensor(void) {
	static char strbuf[128];

	if (!(PORTB.IN & PIN3_bm)) {
    43be:	80 91 28 06 	lds	r24, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
    43c2:	83 fd       	sbrc	r24, 3
    43c4:	0d c0       	rjmp	.+26     	; 0x43e0 <read_photosensitive_sensor+0x22>
		// D0 is HIGH, light intensity is above the threshold
		strcpy(lightResult, "Light detected");
    43c6:	8f e0       	ldi	r24, 0x0F	; 15
    43c8:	ea e7       	ldi	r30, 0x7A	; 122
    43ca:	f0 e2       	ldi	r31, 0x20	; 32
    43cc:	af ef       	ldi	r26, 0xFF	; 255
    43ce:	b3 e2       	ldi	r27, 0x23	; 35
    43d0:	01 90       	ld	r0, Z+
    43d2:	0d 92       	st	X+, r0
    43d4:	8a 95       	dec	r24
    43d6:	e1 f7       	brne	.-8      	; 0x43d0 <read_photosensitive_sensor+0x12>
		PORTC.OUTCLR = PIN1_bm;  // Turn off LED (set PA1 low)
    43d8:	82 e0       	ldi	r24, 0x02	; 2
    43da:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
    43de:	08 95       	ret
		} else {
		// D0 is LOW, light intensity is below the threshold
		strcpy(lightResult, "No light detected");
    43e0:	82 e1       	ldi	r24, 0x12	; 18
    43e2:	e9 e8       	ldi	r30, 0x89	; 137
    43e4:	f0 e2       	ldi	r31, 0x20	; 32
    43e6:	af ef       	ldi	r26, 0xFF	; 255
    43e8:	b3 e2       	ldi	r27, 0x23	; 35
    43ea:	01 90       	ld	r0, Z+
    43ec:	0d 92       	st	X+, r0
    43ee:	8a 95       	dec	r24
    43f0:	e1 f7       	brne	.-8      	; 0x43ea <read_photosensitive_sensor+0x2c>
		PORTC.OUTSET = PIN1_bm;  // Turn on LED (set PA1 high)
    43f2:	82 e0       	ldi	r24, 0x02	; 2
    43f4:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
    43f8:	08 95       	ret

000043fa <vPhotosensitiveSensor>:
		}
		vTaskDelay(100/portTICK_PERIOD_MS);
	}
}

static portTASK_FUNCTION(vPhotosensitiveSensor, r_) {
    43fa:	cf 93       	push	r28
    43fc:	df 93       	push	r29
    43fe:	cd b7       	in	r28, 0x3d	; 61
    4400:	de b7       	in	r29, 0x3e	; 62
    4402:	c0 58       	subi	r28, 0x80	; 128
    4404:	d1 09       	sbc	r29, r1
    4406:	cd bf       	out	0x3d, r28	; 61
    4408:	de bf       	out	0x3e, r29	; 62
	char strbuf[128];
	
	while(1) {
		if (xSemaphoreTake(xSemaphore, (TickType_t)10) == pdTRUE) {
			// Configure PORTC pin 1 (LED) as output
			PORTC.DIRSET = PIN1_bm;  // Set PA1 as output
    440a:	0f 2e       	mov	r0, r31
    440c:	f0 e4       	ldi	r31, 0x40	; 64
    440e:	8f 2e       	mov	r8, r31
    4410:	f6 e0       	ldi	r31, 0x06	; 6
    4412:	9f 2e       	mov	r9, r31
    4414:	f0 2d       	mov	r31, r0
    4416:	68 94       	set
    4418:	aa 24       	eor	r10, r10
    441a:	a1 f8       	bld	r10, 1
			
			read_photosensitive_sensor();
			snprintf(strbuf, sizeof(strbuf), "%s   ", lightResult);
    441c:	0f 2e       	mov	r0, r31
    441e:	ff ef       	ldi	r31, 0xFF	; 255
    4420:	cf 2e       	mov	r12, r31
    4422:	f3 e2       	ldi	r31, 0x23	; 35
    4424:	df 2e       	mov	r13, r31
    4426:	f0 2d       	mov	r31, r0
    4428:	0f 2e       	mov	r0, r31
    442a:	fb e9       	ldi	r31, 0x9B	; 155
    442c:	ef 2e       	mov	r14, r31
    442e:	f0 e2       	ldi	r31, 0x20	; 32
    4430:	ff 2e       	mov	r15, r31
    4432:	f0 2d       	mov	r31, r0
    4434:	68 94       	set
    4436:	bb 24       	eor	r11, r11
    4438:	b7 f8       	bld	r11, 7
    443a:	8e 01       	movw	r16, r28
    443c:	0f 5f       	subi	r16, 0xFF	; 255
    443e:	1f 4f       	sbci	r17, 0xFF	; 255

static portTASK_FUNCTION(vPhotosensitiveSensor, r_) {
	char strbuf[128];
	
	while(1) {
		if (xSemaphoreTake(xSemaphore, (TickType_t)10) == pdTRUE) {
    4440:	6a e0       	ldi	r22, 0x0A	; 10
    4442:	70 e0       	ldi	r23, 0x00	; 0
    4444:	80 91 8b 24 	lds	r24, 0x248B	; 0x80248b <xSemaphore>
    4448:	90 91 8c 24 	lds	r25, 0x248C	; 0x80248c <xSemaphore+0x1>
    444c:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <xQueueSemaphoreTake>
    4450:	81 30       	cpi	r24, 0x01	; 1
    4452:	f9 f4       	brne	.+62     	; 0x4492 <vPhotosensitiveSensor+0x98>
			// Configure PORTC pin 1 (LED) as output
			PORTC.DIRSET = PIN1_bm;  // Set PA1 as output
    4454:	f4 01       	movw	r30, r8
    4456:	a1 82       	std	Z+1, r10	; 0x01
			
			read_photosensitive_sensor();
    4458:	b2 df       	rcall	.-156    	; 0x43be <read_photosensitive_sensor>
			snprintf(strbuf, sizeof(strbuf), "%s   ", lightResult);
    445a:	df 92       	push	r13
    445c:	cf 92       	push	r12
    445e:	ff 92       	push	r15
    4460:	ef 92       	push	r14
    4462:	1f 92       	push	r1
    4464:	bf 92       	push	r11
    4466:	1f 93       	push	r17
    4468:	0f 93       	push	r16
    446a:	47 d2       	rcall	.+1166   	; 0x48fa <snprintf>
			gfx_mono_draw_string(strbuf, 0, 16, &sysfont);
    446c:	26 e0       	ldi	r18, 0x06	; 6
    446e:	30 e2       	ldi	r19, 0x20	; 32
    4470:	40 e1       	ldi	r20, 0x10	; 16
    4472:	60 e0       	ldi	r22, 0x00	; 0
    4474:	c8 01       	movw	r24, r16
    4476:	a2 dc       	rcall	.-1724   	; 0x3dbc <gfx_mono_draw_string>
			
			xSemaphoreGive(xSemaphore);
    4478:	20 e0       	ldi	r18, 0x00	; 0
    447a:	40 e0       	ldi	r20, 0x00	; 0
    447c:	50 e0       	ldi	r21, 0x00	; 0
    447e:	60 e0       	ldi	r22, 0x00	; 0
    4480:	70 e0       	ldi	r23, 0x00	; 0
    4482:	80 91 8b 24 	lds	r24, 0x248B	; 0x80248b <xSemaphore>
    4486:	90 91 8c 24 	lds	r25, 0x248C	; 0x80248c <xSemaphore+0x1>
    448a:	0e 94 23 15 	call	0x2a46	; 0x2a46 <xQueueGenericSend>
    448e:	cd bf       	out	0x3d, r28	; 61
    4490:	de bf       	out	0x3e, r29	; 62
		}
		
		vTaskDelay(100/portTICK_PERIOD_MS);
    4492:	82 e3       	ldi	r24, 0x32	; 50
    4494:	90 e0       	ldi	r25, 0x00	; 0
    4496:	0e 94 d8 19 	call	0x33b0	; 0x33b0 <vTaskDelay>
	}
    449a:	d2 cf       	rjmp	.-92     	; 0x4440 <vPhotosensitiveSensor+0x46>

0000449c <setup_timer>:
*/

// OPTION 2: THIS IS THE TIMER USING TC LIBRARY FROM ATMEL STUDIO
//Fungsi setup timer
void setup_timer(void){
	tc_enable(&TCE1);
    449c:	80 e4       	ldi	r24, 0x40	; 64
    449e:	9a e0       	ldi	r25, 0x0A	; 10
    44a0:	0e 94 0b 0f 	call	0x1e16	; 0x1e16 <tc_enable>
	tc_set_overflow_interrupt_callback(&TCE1,increment_distance);
    44a4:	66 ed       	ldi	r22, 0xD6	; 214
    44a6:	7f e1       	ldi	r23, 0x1F	; 31
    44a8:	80 e4       	ldi	r24, 0x40	; 64
    44aa:	9a e0       	ldi	r25, 0x0A	; 10
    44ac:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <tc_set_overflow_interrupt_callback>
 * \param tc Pointer to TC module.
 * \param wgm : waveform generator
 */
static inline void tc_set_wgm(volatile void *tc, enum tc_wg_mode_t wgm)
{
	((TC0_t *)tc)->CTRLB = (((TC0_t *)tc)->CTRLB & ~TC0_WGMODE_gm) | wgm;
    44b0:	e0 e4       	ldi	r30, 0x40	; 64
    44b2:	fa e0       	ldi	r31, 0x0A	; 10
    44b4:	81 81       	ldd	r24, Z+1	; 0x01
    44b6:	88 7f       	andi	r24, 0xF8	; 248
    44b8:	81 83       	std	Z+1, r24	; 0x01
 * \param tc Pointer to TC module.
 * \param per_value Period value : PER
 */
static inline void tc_write_period(volatile void *tc, uint16_t per_value)
{
	((TC0_t *)tc)->PER = per_value;
    44ba:	8a e3       	ldi	r24, 0x3A	; 58
    44bc:	90 e0       	ldi	r25, 0x00	; 0
    44be:	86 a3       	std	Z+38, r24	; 0x26
    44c0:	97 a3       	std	Z+39, r25	; 0x27
 * \note  Configures OVFINTLVL in INTCTRLA
 */
static inline void tc_set_overflow_interrupt_level(volatile void *tc,
		enum TC_INT_LEVEL_t level)
{
	((TC0_t *)tc)->INTCTRLA = ((TC0_t *)tc)->INTCTRLA & ~TC0_OVFINTLVL_gm;
    44c2:	86 81       	ldd	r24, Z+6	; 0x06
    44c4:	8c 7f       	andi	r24, 0xFC	; 252
    44c6:	86 83       	std	Z+6, r24	; 0x06
	((TC0_t *)tc)->INTCTRLA =
			((TC0_t *)tc)->INTCTRLA | (level << TC0_OVFINTLVL_gp);
    44c8:	86 81       	ldd	r24, Z+6	; 0x06
 */
static inline void tc_set_overflow_interrupt_level(volatile void *tc,
		enum TC_INT_LEVEL_t level)
{
	((TC0_t *)tc)->INTCTRLA = ((TC0_t *)tc)->INTCTRLA & ~TC0_OVFINTLVL_gm;
	((TC0_t *)tc)->INTCTRLA =
    44ca:	83 60       	ori	r24, 0x03	; 3
    44cc:	86 83       	std	Z+6, r24	; 0x06
 */
static inline void tc_write_clock_source(volatile void *tc,
		TC_CLKSEL_t TC_CLKSEL_enum)
{
	((TC0_t *)tc)->CTRLA =
			(((TC0_t *)tc)->CTRLA & ~TC0_CLKSEL_gm) |
    44ce:	80 81       	ld	r24, Z
 * \note Configuring the clock also starts the timer
 */
static inline void tc_write_clock_source(volatile void *tc,
		TC_CLKSEL_t TC_CLKSEL_enum)
{
	((TC0_t *)tc)->CTRLA =
    44d0:	80 7f       	andi	r24, 0xF0	; 240
    44d2:	80 83       	st	Z, r24
    44d4:	08 95       	ret

000044d6 <main>:



/* MAIN FUNCTION */
int main (void)
{
    44d6:	ef 92       	push	r14
    44d8:	ff 92       	push	r15
    44da:	0f 93       	push	r16
    44dc:	cf 93       	push	r28
    44de:	df 93       	push	r29
    44e0:	cd b7       	in	r28, 0x3d	; 61
    44e2:	de b7       	in	r29, 0x3e	; 62
    44e4:	2b 97       	sbiw	r28, 0x0b	; 11
    44e6:	cd bf       	out	0x3d, r28	; 61
    44e8:	de bf       	out	0x3e, r29	; 62
	/* Insert system clock initialization code here (sysclk_init()). */
	sysclk_init();
    44ea:	c5 db       	rcall	.-2166   	; 0x3c76 <sysclk_init>
	board_init();
    44ec:	b7 dc       	rcall	.-1682   	; 0x3e5c <board_init>
    44ee:	87 e0       	ldi	r24, 0x07	; 7
 * Enables all interrupt levels, with vectors located in the application section
 * and fixed priority scheduling.
 */
static inline void pmic_init(void)
{
	PMIC.CTRL = PMIC_LVL_LOW | PMIC_LVL_MEDIUM |
    44f0:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    44f4:	0e 94 0a 05 	call	0xa14	; 0xa14 <gfx_mono_st7565r_init>
	pmic_init();
	gfx_mono_init();
    44f8:	80 e1       	ldi	r24, 0x10	; 16
    44fa:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
    44fe:	26 e0       	ldi	r18, 0x06	; 6
	
	gpio_set_pin_high(LCD_BACKLIGHT_ENABLE_PIN);
	gfx_mono_draw_string("Proyek UAS Sinambos", 0, 0, &sysfont);
    4500:	30 e2       	ldi	r19, 0x20	; 32
    4502:	40 e0       	ldi	r20, 0x00	; 0
    4504:	60 e0       	ldi	r22, 0x00	; 0
    4506:	81 ea       	ldi	r24, 0xA1	; 161
    4508:	90 e2       	ldi	r25, 0x20	; 32
    450a:	58 dc       	rcall	.-1872   	; 0x3dbc <gfx_mono_draw_string>
    450c:	64 e0       	ldi	r22, 0x04	; 4
	
	// Workaround for known issue: Enable RTC32 sysclk
	sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
    450e:	80 e0       	ldi	r24, 0x00	; 0
    4510:	c2 db       	rcall	.-2172   	; 0x3c96 <sysclk_enable_module>
    4512:	e0 e2       	ldi	r30, 0x20	; 32
    4514:	f4 e0       	ldi	r31, 0x04	; 4
	while (RTC32.SYNCCTRL & RTC32_SYNCBUSY_bm) {
    4516:	81 81       	ldd	r24, Z+1	; 0x01
    4518:	80 fd       	sbrc	r24, 0
    451a:	fd cf       	rjmp	.-6      	; 0x4516 <main+0x40>
    451c:	66 e1       	ldi	r22, 0x16	; 22
    451e:	76 e1       	ldi	r23, 0x16	; 22
		// Wait for RTC32 sysclk to become stable
	}
	
	delay_ms(1000);
    4520:	85 e0       	ldi	r24, 0x05	; 5
    4522:	90 e0       	ldi	r25, 0x00	; 0
    4524:	38 dd       	rcall	.-1424   	; 0x3f96 <__portable_avr_delay_cycles>
    4526:	ba df       	rcall	.-140    	; 0x449c <setup_timer>

	// Setup
	setup_timer();
    4528:	be 01       	movw	r22, r28
    452a:	6f 5f       	subi	r22, 0xFF	; 255
static void adc_init_soil(void) {
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	// Read current ADC configuration
	adc_read_configuration(&MY_ADC, &adc_conf);
    452c:	7f 4f       	sbci	r23, 0xFF	; 255
    452e:	80 e0       	ldi	r24, 0x00	; 0
    4530:	92 e0       	ldi	r25, 0x02	; 2
    4532:	0e 94 15 08 	call	0x102a	; 0x102a <adc_read_configuration>
    4536:	ae 01       	movw	r20, r28
    4538:	48 5f       	subi	r20, 0xF8	; 248
	adcch_read_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    453a:	5f 4f       	sbci	r21, 0xFF	; 255
    453c:	61 e0       	ldi	r22, 0x01	; 1
    453e:	80 e0       	ldi	r24, 0x00	; 0
    4540:	92 e0       	ldi	r25, 0x02	; 2
    4542:	0e 94 99 08 	call	0x1132	; 0x1132 <adcch_read_configuration>
    4546:	9a 81       	ldd	r25, Y+2	; 0x02
    4548:	8b 81       	ldd	r24, Y+3	; 0x03
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    454a:	8f 78       	andi	r24, 0x8F	; 143
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
	conf->refctrl |= ref;
    454c:	80 61       	ori	r24, 0x10	; 16
    454e:	8b 83       	std	Y+3, r24	; 0x03
    4550:	89 2f       	mov	r24, r25
    4552:	81 7e       	andi	r24, 0xE1	; 225
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    4554:	8a 83       	std	Y+2, r24	; 0x02
    4556:	1c 82       	std	Y+4, r1	; 0x04
    4558:	82 e0       	ldi	r24, 0x02	; 2
		conf->evctrl = ADC_EVACT_NONE_gc;
    455a:	8d 83       	std	Y+5, r24	; 0x05
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    455c:	81 e0       	ldi	r24, 0x01	; 1
    455e:	88 87       	std	Y+8, r24	; 0x08
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    4560:	80 e2       	ldi	r24, 0x20	; 32
    4562:	89 87       	std	Y+9, r24	; 0x09
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    4564:	be 01       	movw	r22, r28
    4566:	6f 5f       	subi	r22, 0xFF	; 255
	adc_set_clock_rate(&adc_conf, 200000UL); // Clock rate for ADC

	// PA4 (ADC4) as the input channel
	adcch_set_input(&adcch_conf, ADCCH_POS_PIN4, ADCCH_NEG_NONE, 1); // ADC4 is PA4 (J2_PIN0)
	
	adc_write_configuration(&MY_ADC, &adc_conf);
    4568:	7f 4f       	sbci	r23, 0xFF	; 255
    456a:	80 e0       	ldi	r24, 0x00	; 0
    456c:	92 e0       	ldi	r25, 0x02	; 2
    456e:	0e 94 ab 07 	call	0xf56	; 0xf56 <adc_write_configuration>
    4572:	ae 01       	movw	r20, r28
    4574:	48 5f       	subi	r20, 0xF8	; 248
	adcch_write_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    4576:	5f 4f       	sbci	r21, 0xFF	; 255
    4578:	61 e0       	ldi	r22, 0x01	; 1
    457a:	80 e0       	ldi	r24, 0x00	; 0
    457c:	92 e0       	ldi	r25, 0x02	; 2
    457e:	0e 94 4e 08 	call	0x109c	; 0x109c <adcch_write_configuration>
    4582:	88 e0       	ldi	r24, 0x08	; 8
    4584:	80 93 22 06 	sts	0x0622, r24	; 0x800622 <__TEXT_REGION_LENGTH__+0x700622>
static char lightResult[128];

/* Functions for Photosensitive Sensor*/
// Setup PB3 as input
void setup_photosensitive_sensor(void) {
	PORTB.DIRCLR = PIN3_bm; // Set PB0 (connected to D0 pin of the sensor) as input
    4588:	e1 2c       	mov	r14, r1
    458a:	f1 2c       	mov	r15, r1
	setup_timer();
	adc_init_soil();
	setup_photosensitive_sensor();
	
	/* Create the task */
	xTaskCreate(vUltrasonicSensor, "", 1000, NULL, tskIDLE_PRIORITY + 1, NULL);
    458c:	01 e0       	ldi	r16, 0x01	; 1
    458e:	20 e0       	ldi	r18, 0x00	; 0
    4590:	30 e0       	ldi	r19, 0x00	; 0
    4592:	48 ee       	ldi	r20, 0xE8	; 232
    4594:	53 e0       	ldi	r21, 0x03	; 3
    4596:	60 ea       	ldi	r22, 0xA0	; 160
    4598:	70 e2       	ldi	r23, 0x20	; 32
    459a:	84 e2       	ldi	r24, 0x24	; 36
    459c:	91 e2       	ldi	r25, 0x21	; 33
    459e:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <xTaskCreate>
    45a2:	03 e0       	ldi	r16, 0x03	; 3
    45a4:	20 e0       	ldi	r18, 0x00	; 0
	xTaskCreate(vSoilSensor, "", 1000, NULL, tskIDLE_PRIORITY + 3, NULL);
    45a6:	30 e0       	ldi	r19, 0x00	; 0
    45a8:	48 ee       	ldi	r20, 0xE8	; 232
    45aa:	53 e0       	ldi	r21, 0x03	; 3
    45ac:	60 ea       	ldi	r22, 0xA0	; 160
    45ae:	70 e2       	ldi	r23, 0x20	; 32
    45b0:	84 e7       	ldi	r24, 0x74	; 116
    45b2:	90 e2       	ldi	r25, 0x20	; 32
    45b4:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <xTaskCreate>
    45b8:	02 e0       	ldi	r16, 0x02	; 2
    45ba:	20 e0       	ldi	r18, 0x00	; 0
	xTaskCreate(vPhotosensitiveSensor, "", 1000, NULL, tskIDLE_PRIORITY + 2, NULL);	
    45bc:	30 e0       	ldi	r19, 0x00	; 0
    45be:	48 ee       	ldi	r20, 0xE8	; 232
    45c0:	53 e0       	ldi	r21, 0x03	; 3
    45c2:	60 ea       	ldi	r22, 0xA0	; 160
    45c4:	70 e2       	ldi	r23, 0x20	; 32
    45c6:	8d ef       	ldi	r24, 0xFD	; 253
    45c8:	91 e2       	ldi	r25, 0x21	; 33
    45ca:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <xTaskCreate>
    45ce:	04 e0       	ldi	r16, 0x04	; 4
    45d0:	20 e0       	ldi	r18, 0x00	; 0
	xTaskCreate(vPushButton1, "", 1000, NULL, tskIDLE_PRIORITY + 4, NULL);
    45d2:	30 e0       	ldi	r19, 0x00	; 0
    45d4:	48 ee       	ldi	r20, 0xE8	; 232
    45d6:	53 e0       	ldi	r21, 0x03	; 3
    45d8:	60 ea       	ldi	r22, 0xA0	; 160
    45da:	70 e2       	ldi	r23, 0x20	; 32
    45dc:	87 e2       	ldi	r24, 0x27	; 39
    45de:	90 e2       	ldi	r25, 0x20	; 32
    45e0:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <xTaskCreate>
    45e4:	00 e0       	ldi	r16, 0x00	; 0
    45e6:	20 e0       	ldi	r18, 0x00	; 0
	xTaskCreate(vCounter, "", 1000, NULL, tskIDLE_PRIORITY + 0, NULL);
    45e8:	30 e0       	ldi	r19, 0x00	; 0
    45ea:	48 ee       	ldi	r20, 0xE8	; 232
    45ec:	53 e0       	ldi	r21, 0x03	; 3
    45ee:	60 ea       	ldi	r22, 0xA0	; 160
    45f0:	70 e2       	ldi	r23, 0x20	; 32
    45f2:	80 ee       	ldi	r24, 0xE0	; 224
    45f4:	9f e1       	ldi	r25, 0x1F	; 31
    45f6:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <xTaskCreate>
    45fa:	43 e0       	ldi	r20, 0x03	; 3
    45fc:	60 e0       	ldi	r22, 0x00	; 0
		
	/* Semaphore */
	xSemaphore = xSemaphoreCreateBinary();
    45fe:	81 e0       	ldi	r24, 0x01	; 1
    4600:	0e 94 02 15 	call	0x2a04	; 0x2a04 <xQueueGenericCreate>
    4604:	80 93 8b 24 	sts	0x248B, r24	; 0x80248b <xSemaphore>
    4608:	90 93 8c 24 	sts	0x248C, r25	; 0x80248c <xSemaphore+0x1>
    460c:	20 e0       	ldi	r18, 0x00	; 0
    460e:	40 e0       	ldi	r20, 0x00	; 0
	xSemaphoreGive(xSemaphore);
    4610:	50 e0       	ldi	r21, 0x00	; 0
    4612:	60 e0       	ldi	r22, 0x00	; 0
    4614:	70 e0       	ldi	r23, 0x00	; 0
    4616:	0e 94 23 15 	call	0x2a46	; 0x2a46 <xQueueGenericSend>
    461a:	0e 94 68 18 	call	0x30d0	; 0x30d0 <vTaskStartScheduler>
	
	/* Start the task */
	vTaskStartScheduler();
    461e:	80 e0       	ldi	r24, 0x00	; 0
    4620:	90 e0       	ldi	r25, 0x00	; 0
}
    4622:	2b 96       	adiw	r28, 0x0b	; 11
    4624:	cd bf       	out	0x3d, r28	; 61
    4626:	de bf       	out	0x3e, r29	; 62
    4628:	df 91       	pop	r29
    462a:	cf 91       	pop	r28
    462c:	0f 91       	pop	r16
    462e:	ff 90       	pop	r15
    4630:	ef 90       	pop	r14
    4632:	08 95       	ret

00004634 <__udivmodsi4>:
    4634:	a1 e2       	ldi	r26, 0x21	; 33
    4636:	1a 2e       	mov	r1, r26
    4638:	aa 1b       	sub	r26, r26
    463a:	bb 1b       	sub	r27, r27
    463c:	fd 01       	movw	r30, r26
    463e:	0d c0       	rjmp	.+26     	; 0x465a <__udivmodsi4_ep>

00004640 <__udivmodsi4_loop>:
    4640:	aa 1f       	adc	r26, r26
    4642:	bb 1f       	adc	r27, r27
    4644:	ee 1f       	adc	r30, r30
    4646:	ff 1f       	adc	r31, r31
    4648:	a2 17       	cp	r26, r18
    464a:	b3 07       	cpc	r27, r19
    464c:	e4 07       	cpc	r30, r20
    464e:	f5 07       	cpc	r31, r21
    4650:	20 f0       	brcs	.+8      	; 0x465a <__udivmodsi4_ep>
    4652:	a2 1b       	sub	r26, r18
    4654:	b3 0b       	sbc	r27, r19
    4656:	e4 0b       	sbc	r30, r20
    4658:	f5 0b       	sbc	r31, r21

0000465a <__udivmodsi4_ep>:
    465a:	66 1f       	adc	r22, r22
    465c:	77 1f       	adc	r23, r23
    465e:	88 1f       	adc	r24, r24
    4660:	99 1f       	adc	r25, r25
    4662:	1a 94       	dec	r1
    4664:	69 f7       	brne	.-38     	; 0x4640 <__udivmodsi4_loop>
    4666:	60 95       	com	r22
    4668:	70 95       	com	r23
    466a:	80 95       	com	r24
    466c:	90 95       	com	r25
    466e:	9b 01       	movw	r18, r22
    4670:	ac 01       	movw	r20, r24
    4672:	bd 01       	movw	r22, r26
    4674:	cf 01       	movw	r24, r30
    4676:	08 95       	ret

00004678 <__tablejump2__>:
    4678:	ee 0f       	add	r30, r30
    467a:	ff 1f       	adc	r31, r31
    467c:	88 1f       	adc	r24, r24
    467e:	8b bf       	out	0x3b, r24	; 59
    4680:	07 90       	elpm	r0, Z+
    4682:	f6 91       	elpm	r31, Z
    4684:	e0 2d       	mov	r30, r0
    4686:	19 94       	eijmp

00004688 <__umulhisi3>:
    4688:	a2 9f       	mul	r26, r18
    468a:	b0 01       	movw	r22, r0
    468c:	b3 9f       	mul	r27, r19
    468e:	c0 01       	movw	r24, r0
    4690:	a3 9f       	mul	r26, r19
    4692:	70 0d       	add	r23, r0
    4694:	81 1d       	adc	r24, r1
    4696:	11 24       	eor	r1, r1
    4698:	91 1d       	adc	r25, r1
    469a:	b2 9f       	mul	r27, r18
    469c:	70 0d       	add	r23, r0
    469e:	81 1d       	adc	r24, r1
    46a0:	11 24       	eor	r1, r1
    46a2:	91 1d       	adc	r25, r1
    46a4:	08 95       	ret

000046a6 <malloc>:
    46a6:	0f 93       	push	r16
    46a8:	1f 93       	push	r17
    46aa:	cf 93       	push	r28
    46ac:	df 93       	push	r29
    46ae:	82 30       	cpi	r24, 0x02	; 2
    46b0:	91 05       	cpc	r25, r1
    46b2:	10 f4       	brcc	.+4      	; 0x46b8 <malloc+0x12>
    46b4:	82 e0       	ldi	r24, 0x02	; 2
    46b6:	90 e0       	ldi	r25, 0x00	; 0
    46b8:	e0 91 8f 24 	lds	r30, 0x248F	; 0x80248f <__flp>
    46bc:	f0 91 90 24 	lds	r31, 0x2490	; 0x802490 <__flp+0x1>
    46c0:	20 e0       	ldi	r18, 0x00	; 0
    46c2:	30 e0       	ldi	r19, 0x00	; 0
    46c4:	a0 e0       	ldi	r26, 0x00	; 0
    46c6:	b0 e0       	ldi	r27, 0x00	; 0
    46c8:	30 97       	sbiw	r30, 0x00	; 0
    46ca:	19 f1       	breq	.+70     	; 0x4712 <malloc+0x6c>
    46cc:	40 81       	ld	r20, Z
    46ce:	51 81       	ldd	r21, Z+1	; 0x01
    46d0:	02 81       	ldd	r16, Z+2	; 0x02
    46d2:	13 81       	ldd	r17, Z+3	; 0x03
    46d4:	48 17       	cp	r20, r24
    46d6:	59 07       	cpc	r21, r25
    46d8:	c8 f0       	brcs	.+50     	; 0x470c <malloc+0x66>
    46da:	84 17       	cp	r24, r20
    46dc:	95 07       	cpc	r25, r21
    46de:	69 f4       	brne	.+26     	; 0x46fa <malloc+0x54>
    46e0:	10 97       	sbiw	r26, 0x00	; 0
    46e2:	31 f0       	breq	.+12     	; 0x46f0 <malloc+0x4a>
    46e4:	12 96       	adiw	r26, 0x02	; 2
    46e6:	0c 93       	st	X, r16
    46e8:	12 97       	sbiw	r26, 0x02	; 2
    46ea:	13 96       	adiw	r26, 0x03	; 3
    46ec:	1c 93       	st	X, r17
    46ee:	27 c0       	rjmp	.+78     	; 0x473e <malloc+0x98>
    46f0:	00 93 8f 24 	sts	0x248F, r16	; 0x80248f <__flp>
    46f4:	10 93 90 24 	sts	0x2490, r17	; 0x802490 <__flp+0x1>
    46f8:	22 c0       	rjmp	.+68     	; 0x473e <malloc+0x98>
    46fa:	21 15       	cp	r18, r1
    46fc:	31 05       	cpc	r19, r1
    46fe:	19 f0       	breq	.+6      	; 0x4706 <malloc+0x60>
    4700:	42 17       	cp	r20, r18
    4702:	53 07       	cpc	r21, r19
    4704:	18 f4       	brcc	.+6      	; 0x470c <malloc+0x66>
    4706:	9a 01       	movw	r18, r20
    4708:	bd 01       	movw	r22, r26
    470a:	ef 01       	movw	r28, r30
    470c:	df 01       	movw	r26, r30
    470e:	f8 01       	movw	r30, r16
    4710:	db cf       	rjmp	.-74     	; 0x46c8 <malloc+0x22>
    4712:	21 15       	cp	r18, r1
    4714:	31 05       	cpc	r19, r1
    4716:	f9 f0       	breq	.+62     	; 0x4756 <malloc+0xb0>
    4718:	28 1b       	sub	r18, r24
    471a:	39 0b       	sbc	r19, r25
    471c:	24 30       	cpi	r18, 0x04	; 4
    471e:	31 05       	cpc	r19, r1
    4720:	80 f4       	brcc	.+32     	; 0x4742 <malloc+0x9c>
    4722:	8a 81       	ldd	r24, Y+2	; 0x02
    4724:	9b 81       	ldd	r25, Y+3	; 0x03
    4726:	61 15       	cp	r22, r1
    4728:	71 05       	cpc	r23, r1
    472a:	21 f0       	breq	.+8      	; 0x4734 <malloc+0x8e>
    472c:	fb 01       	movw	r30, r22
    472e:	82 83       	std	Z+2, r24	; 0x02
    4730:	93 83       	std	Z+3, r25	; 0x03
    4732:	04 c0       	rjmp	.+8      	; 0x473c <malloc+0x96>
    4734:	80 93 8f 24 	sts	0x248F, r24	; 0x80248f <__flp>
    4738:	90 93 90 24 	sts	0x2490, r25	; 0x802490 <__flp+0x1>
    473c:	fe 01       	movw	r30, r28
    473e:	32 96       	adiw	r30, 0x02	; 2
    4740:	44 c0       	rjmp	.+136    	; 0x47ca <malloc+0x124>
    4742:	fe 01       	movw	r30, r28
    4744:	e2 0f       	add	r30, r18
    4746:	f3 1f       	adc	r31, r19
    4748:	81 93       	st	Z+, r24
    474a:	91 93       	st	Z+, r25
    474c:	22 50       	subi	r18, 0x02	; 2
    474e:	31 09       	sbc	r19, r1
    4750:	28 83       	st	Y, r18
    4752:	39 83       	std	Y+1, r19	; 0x01
    4754:	3a c0       	rjmp	.+116    	; 0x47ca <malloc+0x124>
    4756:	20 91 8d 24 	lds	r18, 0x248D	; 0x80248d <__brkval>
    475a:	30 91 8e 24 	lds	r19, 0x248E	; 0x80248e <__brkval+0x1>
    475e:	23 2b       	or	r18, r19
    4760:	41 f4       	brne	.+16     	; 0x4772 <malloc+0xcc>
    4762:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    4766:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    476a:	20 93 8d 24 	sts	0x248D, r18	; 0x80248d <__brkval>
    476e:	30 93 8e 24 	sts	0x248E, r19	; 0x80248e <__brkval+0x1>
    4772:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
    4776:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
    477a:	21 15       	cp	r18, r1
    477c:	31 05       	cpc	r19, r1
    477e:	41 f4       	brne	.+16     	; 0x4790 <malloc+0xea>
    4780:	2d b7       	in	r18, 0x3d	; 61
    4782:	3e b7       	in	r19, 0x3e	; 62
    4784:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    4788:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    478c:	24 1b       	sub	r18, r20
    478e:	35 0b       	sbc	r19, r21
    4790:	e0 91 8d 24 	lds	r30, 0x248D	; 0x80248d <__brkval>
    4794:	f0 91 8e 24 	lds	r31, 0x248E	; 0x80248e <__brkval+0x1>
    4798:	e2 17       	cp	r30, r18
    479a:	f3 07       	cpc	r31, r19
    479c:	a0 f4       	brcc	.+40     	; 0x47c6 <malloc+0x120>
    479e:	2e 1b       	sub	r18, r30
    47a0:	3f 0b       	sbc	r19, r31
    47a2:	28 17       	cp	r18, r24
    47a4:	39 07       	cpc	r19, r25
    47a6:	78 f0       	brcs	.+30     	; 0x47c6 <malloc+0x120>
    47a8:	ac 01       	movw	r20, r24
    47aa:	4e 5f       	subi	r20, 0xFE	; 254
    47ac:	5f 4f       	sbci	r21, 0xFF	; 255
    47ae:	24 17       	cp	r18, r20
    47b0:	35 07       	cpc	r19, r21
    47b2:	48 f0       	brcs	.+18     	; 0x47c6 <malloc+0x120>
    47b4:	4e 0f       	add	r20, r30
    47b6:	5f 1f       	adc	r21, r31
    47b8:	40 93 8d 24 	sts	0x248D, r20	; 0x80248d <__brkval>
    47bc:	50 93 8e 24 	sts	0x248E, r21	; 0x80248e <__brkval+0x1>
    47c0:	81 93       	st	Z+, r24
    47c2:	91 93       	st	Z+, r25
    47c4:	02 c0       	rjmp	.+4      	; 0x47ca <malloc+0x124>
    47c6:	e0 e0       	ldi	r30, 0x00	; 0
    47c8:	f0 e0       	ldi	r31, 0x00	; 0
    47ca:	cf 01       	movw	r24, r30
    47cc:	df 91       	pop	r29
    47ce:	cf 91       	pop	r28
    47d0:	1f 91       	pop	r17
    47d2:	0f 91       	pop	r16
    47d4:	08 95       	ret

000047d6 <free>:
    47d6:	cf 93       	push	r28
    47d8:	df 93       	push	r29
    47da:	00 97       	sbiw	r24, 0x00	; 0
    47dc:	09 f4       	brne	.+2      	; 0x47e0 <free+0xa>
    47de:	81 c0       	rjmp	.+258    	; 0x48e2 <free+0x10c>
    47e0:	fc 01       	movw	r30, r24
    47e2:	32 97       	sbiw	r30, 0x02	; 2
    47e4:	12 82       	std	Z+2, r1	; 0x02
    47e6:	13 82       	std	Z+3, r1	; 0x03
    47e8:	a0 91 8f 24 	lds	r26, 0x248F	; 0x80248f <__flp>
    47ec:	b0 91 90 24 	lds	r27, 0x2490	; 0x802490 <__flp+0x1>
    47f0:	10 97       	sbiw	r26, 0x00	; 0
    47f2:	81 f4       	brne	.+32     	; 0x4814 <free+0x3e>
    47f4:	20 81       	ld	r18, Z
    47f6:	31 81       	ldd	r19, Z+1	; 0x01
    47f8:	82 0f       	add	r24, r18
    47fa:	93 1f       	adc	r25, r19
    47fc:	20 91 8d 24 	lds	r18, 0x248D	; 0x80248d <__brkval>
    4800:	30 91 8e 24 	lds	r19, 0x248E	; 0x80248e <__brkval+0x1>
    4804:	28 17       	cp	r18, r24
    4806:	39 07       	cpc	r19, r25
    4808:	51 f5       	brne	.+84     	; 0x485e <free+0x88>
    480a:	e0 93 8d 24 	sts	0x248D, r30	; 0x80248d <__brkval>
    480e:	f0 93 8e 24 	sts	0x248E, r31	; 0x80248e <__brkval+0x1>
    4812:	67 c0       	rjmp	.+206    	; 0x48e2 <free+0x10c>
    4814:	ed 01       	movw	r28, r26
    4816:	20 e0       	ldi	r18, 0x00	; 0
    4818:	30 e0       	ldi	r19, 0x00	; 0
    481a:	ce 17       	cp	r28, r30
    481c:	df 07       	cpc	r29, r31
    481e:	40 f4       	brcc	.+16     	; 0x4830 <free+0x5a>
    4820:	4a 81       	ldd	r20, Y+2	; 0x02
    4822:	5b 81       	ldd	r21, Y+3	; 0x03
    4824:	9e 01       	movw	r18, r28
    4826:	41 15       	cp	r20, r1
    4828:	51 05       	cpc	r21, r1
    482a:	f1 f0       	breq	.+60     	; 0x4868 <free+0x92>
    482c:	ea 01       	movw	r28, r20
    482e:	f5 cf       	rjmp	.-22     	; 0x481a <free+0x44>
    4830:	c2 83       	std	Z+2, r28	; 0x02
    4832:	d3 83       	std	Z+3, r29	; 0x03
    4834:	40 81       	ld	r20, Z
    4836:	51 81       	ldd	r21, Z+1	; 0x01
    4838:	84 0f       	add	r24, r20
    483a:	95 1f       	adc	r25, r21
    483c:	c8 17       	cp	r28, r24
    483e:	d9 07       	cpc	r29, r25
    4840:	59 f4       	brne	.+22     	; 0x4858 <free+0x82>
    4842:	88 81       	ld	r24, Y
    4844:	99 81       	ldd	r25, Y+1	; 0x01
    4846:	84 0f       	add	r24, r20
    4848:	95 1f       	adc	r25, r21
    484a:	02 96       	adiw	r24, 0x02	; 2
    484c:	80 83       	st	Z, r24
    484e:	91 83       	std	Z+1, r25	; 0x01
    4850:	8a 81       	ldd	r24, Y+2	; 0x02
    4852:	9b 81       	ldd	r25, Y+3	; 0x03
    4854:	82 83       	std	Z+2, r24	; 0x02
    4856:	93 83       	std	Z+3, r25	; 0x03
    4858:	21 15       	cp	r18, r1
    485a:	31 05       	cpc	r19, r1
    485c:	29 f4       	brne	.+10     	; 0x4868 <free+0x92>
    485e:	e0 93 8f 24 	sts	0x248F, r30	; 0x80248f <__flp>
    4862:	f0 93 90 24 	sts	0x2490, r31	; 0x802490 <__flp+0x1>
    4866:	3d c0       	rjmp	.+122    	; 0x48e2 <free+0x10c>
    4868:	e9 01       	movw	r28, r18
    486a:	ea 83       	std	Y+2, r30	; 0x02
    486c:	fb 83       	std	Y+3, r31	; 0x03
    486e:	49 91       	ld	r20, Y+
    4870:	59 91       	ld	r21, Y+
    4872:	c4 0f       	add	r28, r20
    4874:	d5 1f       	adc	r29, r21
    4876:	ec 17       	cp	r30, r28
    4878:	fd 07       	cpc	r31, r29
    487a:	61 f4       	brne	.+24     	; 0x4894 <free+0xbe>
    487c:	80 81       	ld	r24, Z
    487e:	91 81       	ldd	r25, Z+1	; 0x01
    4880:	84 0f       	add	r24, r20
    4882:	95 1f       	adc	r25, r21
    4884:	02 96       	adiw	r24, 0x02	; 2
    4886:	e9 01       	movw	r28, r18
    4888:	88 83       	st	Y, r24
    488a:	99 83       	std	Y+1, r25	; 0x01
    488c:	82 81       	ldd	r24, Z+2	; 0x02
    488e:	93 81       	ldd	r25, Z+3	; 0x03
    4890:	8a 83       	std	Y+2, r24	; 0x02
    4892:	9b 83       	std	Y+3, r25	; 0x03
    4894:	e0 e0       	ldi	r30, 0x00	; 0
    4896:	f0 e0       	ldi	r31, 0x00	; 0
    4898:	12 96       	adiw	r26, 0x02	; 2
    489a:	8d 91       	ld	r24, X+
    489c:	9c 91       	ld	r25, X
    489e:	13 97       	sbiw	r26, 0x03	; 3
    48a0:	00 97       	sbiw	r24, 0x00	; 0
    48a2:	19 f0       	breq	.+6      	; 0x48aa <free+0xd4>
    48a4:	fd 01       	movw	r30, r26
    48a6:	dc 01       	movw	r26, r24
    48a8:	f7 cf       	rjmp	.-18     	; 0x4898 <free+0xc2>
    48aa:	8d 91       	ld	r24, X+
    48ac:	9c 91       	ld	r25, X
    48ae:	11 97       	sbiw	r26, 0x01	; 1
    48b0:	9d 01       	movw	r18, r26
    48b2:	2e 5f       	subi	r18, 0xFE	; 254
    48b4:	3f 4f       	sbci	r19, 0xFF	; 255
    48b6:	82 0f       	add	r24, r18
    48b8:	93 1f       	adc	r25, r19
    48ba:	20 91 8d 24 	lds	r18, 0x248D	; 0x80248d <__brkval>
    48be:	30 91 8e 24 	lds	r19, 0x248E	; 0x80248e <__brkval+0x1>
    48c2:	28 17       	cp	r18, r24
    48c4:	39 07       	cpc	r19, r25
    48c6:	69 f4       	brne	.+26     	; 0x48e2 <free+0x10c>
    48c8:	30 97       	sbiw	r30, 0x00	; 0
    48ca:	29 f4       	brne	.+10     	; 0x48d6 <free+0x100>
    48cc:	10 92 8f 24 	sts	0x248F, r1	; 0x80248f <__flp>
    48d0:	10 92 90 24 	sts	0x2490, r1	; 0x802490 <__flp+0x1>
    48d4:	02 c0       	rjmp	.+4      	; 0x48da <free+0x104>
    48d6:	12 82       	std	Z+2, r1	; 0x02
    48d8:	13 82       	std	Z+3, r1	; 0x03
    48da:	a0 93 8d 24 	sts	0x248D, r26	; 0x80248d <__brkval>
    48de:	b0 93 8e 24 	sts	0x248E, r27	; 0x80248e <__brkval+0x1>
    48e2:	df 91       	pop	r29
    48e4:	cf 91       	pop	r28
    48e6:	08 95       	ret

000048e8 <memcpy>:
    48e8:	fb 01       	movw	r30, r22
    48ea:	dc 01       	movw	r26, r24
    48ec:	02 c0       	rjmp	.+4      	; 0x48f2 <memcpy+0xa>
    48ee:	01 90       	ld	r0, Z+
    48f0:	0d 92       	st	X+, r0
    48f2:	41 50       	subi	r20, 0x01	; 1
    48f4:	50 40       	sbci	r21, 0x00	; 0
    48f6:	d8 f7       	brcc	.-10     	; 0x48ee <memcpy+0x6>
    48f8:	08 95       	ret

000048fa <snprintf>:
    48fa:	0f 93       	push	r16
    48fc:	1f 93       	push	r17
    48fe:	cf 93       	push	r28
    4900:	df 93       	push	r29
    4902:	cd b7       	in	r28, 0x3d	; 61
    4904:	de b7       	in	r29, 0x3e	; 62
    4906:	2e 97       	sbiw	r28, 0x0e	; 14
    4908:	cd bf       	out	0x3d, r28	; 61
    490a:	de bf       	out	0x3e, r29	; 62
    490c:	0e 89       	ldd	r16, Y+22	; 0x16
    490e:	1f 89       	ldd	r17, Y+23	; 0x17
    4910:	88 8d       	ldd	r24, Y+24	; 0x18
    4912:	99 8d       	ldd	r25, Y+25	; 0x19
    4914:	26 e0       	ldi	r18, 0x06	; 6
    4916:	2c 83       	std	Y+4, r18	; 0x04
    4918:	09 83       	std	Y+1, r16	; 0x01
    491a:	1a 83       	std	Y+2, r17	; 0x02
    491c:	97 ff       	sbrs	r25, 7
    491e:	02 c0       	rjmp	.+4      	; 0x4924 <snprintf+0x2a>
    4920:	80 e0       	ldi	r24, 0x00	; 0
    4922:	90 e8       	ldi	r25, 0x80	; 128
    4924:	01 97       	sbiw	r24, 0x01	; 1
    4926:	8d 83       	std	Y+5, r24	; 0x05
    4928:	9e 83       	std	Y+6, r25	; 0x06
    492a:	ae 01       	movw	r20, r28
    492c:	44 5e       	subi	r20, 0xE4	; 228
    492e:	5f 4f       	sbci	r21, 0xFF	; 255
    4930:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4932:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4934:	ce 01       	movw	r24, r28
    4936:	01 96       	adiw	r24, 0x01	; 1
    4938:	16 d0       	rcall	.+44     	; 0x4966 <vfprintf>
    493a:	4d 81       	ldd	r20, Y+5	; 0x05
    493c:	5e 81       	ldd	r21, Y+6	; 0x06
    493e:	57 fd       	sbrc	r21, 7
    4940:	0a c0       	rjmp	.+20     	; 0x4956 <snprintf+0x5c>
    4942:	2f 81       	ldd	r18, Y+7	; 0x07
    4944:	38 85       	ldd	r19, Y+8	; 0x08
    4946:	42 17       	cp	r20, r18
    4948:	53 07       	cpc	r21, r19
    494a:	0c f4       	brge	.+2      	; 0x494e <snprintf+0x54>
    494c:	9a 01       	movw	r18, r20
    494e:	f8 01       	movw	r30, r16
    4950:	e2 0f       	add	r30, r18
    4952:	f3 1f       	adc	r31, r19
    4954:	10 82       	st	Z, r1
    4956:	2e 96       	adiw	r28, 0x0e	; 14
    4958:	cd bf       	out	0x3d, r28	; 61
    495a:	de bf       	out	0x3e, r29	; 62
    495c:	df 91       	pop	r29
    495e:	cf 91       	pop	r28
    4960:	1f 91       	pop	r17
    4962:	0f 91       	pop	r16
    4964:	08 95       	ret

00004966 <vfprintf>:
    4966:	2f 92       	push	r2
    4968:	3f 92       	push	r3
    496a:	4f 92       	push	r4
    496c:	5f 92       	push	r5
    496e:	6f 92       	push	r6
    4970:	7f 92       	push	r7
    4972:	8f 92       	push	r8
    4974:	9f 92       	push	r9
    4976:	af 92       	push	r10
    4978:	bf 92       	push	r11
    497a:	cf 92       	push	r12
    497c:	df 92       	push	r13
    497e:	ef 92       	push	r14
    4980:	ff 92       	push	r15
    4982:	0f 93       	push	r16
    4984:	1f 93       	push	r17
    4986:	cf 93       	push	r28
    4988:	df 93       	push	r29
    498a:	cd b7       	in	r28, 0x3d	; 61
    498c:	de b7       	in	r29, 0x3e	; 62
    498e:	2b 97       	sbiw	r28, 0x0b	; 11
    4990:	cd bf       	out	0x3d, r28	; 61
    4992:	de bf       	out	0x3e, r29	; 62
    4994:	6c 01       	movw	r12, r24
    4996:	7b 01       	movw	r14, r22
    4998:	8a 01       	movw	r16, r20
    499a:	fc 01       	movw	r30, r24
    499c:	16 82       	std	Z+6, r1	; 0x06
    499e:	17 82       	std	Z+7, r1	; 0x07
    49a0:	83 81       	ldd	r24, Z+3	; 0x03
    49a2:	81 ff       	sbrs	r24, 1
    49a4:	bf c1       	rjmp	.+894    	; 0x4d24 <vfprintf+0x3be>
    49a6:	ce 01       	movw	r24, r28
    49a8:	01 96       	adiw	r24, 0x01	; 1
    49aa:	3c 01       	movw	r6, r24
    49ac:	f6 01       	movw	r30, r12
    49ae:	93 81       	ldd	r25, Z+3	; 0x03
    49b0:	f7 01       	movw	r30, r14
    49b2:	93 fd       	sbrc	r25, 3
    49b4:	85 91       	lpm	r24, Z+
    49b6:	93 ff       	sbrs	r25, 3
    49b8:	81 91       	ld	r24, Z+
    49ba:	7f 01       	movw	r14, r30
    49bc:	88 23       	and	r24, r24
    49be:	09 f4       	brne	.+2      	; 0x49c2 <vfprintf+0x5c>
    49c0:	ad c1       	rjmp	.+858    	; 0x4d1c <vfprintf+0x3b6>
    49c2:	85 32       	cpi	r24, 0x25	; 37
    49c4:	39 f4       	brne	.+14     	; 0x49d4 <vfprintf+0x6e>
    49c6:	93 fd       	sbrc	r25, 3
    49c8:	85 91       	lpm	r24, Z+
    49ca:	93 ff       	sbrs	r25, 3
    49cc:	81 91       	ld	r24, Z+
    49ce:	7f 01       	movw	r14, r30
    49d0:	85 32       	cpi	r24, 0x25	; 37
    49d2:	21 f4       	brne	.+8      	; 0x49dc <vfprintf+0x76>
    49d4:	b6 01       	movw	r22, r12
    49d6:	90 e0       	ldi	r25, 0x00	; 0
    49d8:	d3 d1       	rcall	.+934    	; 0x4d80 <fputc>
    49da:	e8 cf       	rjmp	.-48     	; 0x49ac <vfprintf+0x46>
    49dc:	91 2c       	mov	r9, r1
    49de:	21 2c       	mov	r2, r1
    49e0:	31 2c       	mov	r3, r1
    49e2:	ff e1       	ldi	r31, 0x1F	; 31
    49e4:	f3 15       	cp	r31, r3
    49e6:	d8 f0       	brcs	.+54     	; 0x4a1e <vfprintf+0xb8>
    49e8:	8b 32       	cpi	r24, 0x2B	; 43
    49ea:	79 f0       	breq	.+30     	; 0x4a0a <vfprintf+0xa4>
    49ec:	38 f4       	brcc	.+14     	; 0x49fc <vfprintf+0x96>
    49ee:	80 32       	cpi	r24, 0x20	; 32
    49f0:	79 f0       	breq	.+30     	; 0x4a10 <vfprintf+0xaa>
    49f2:	83 32       	cpi	r24, 0x23	; 35
    49f4:	a1 f4       	brne	.+40     	; 0x4a1e <vfprintf+0xb8>
    49f6:	23 2d       	mov	r18, r3
    49f8:	20 61       	ori	r18, 0x10	; 16
    49fa:	1d c0       	rjmp	.+58     	; 0x4a36 <vfprintf+0xd0>
    49fc:	8d 32       	cpi	r24, 0x2D	; 45
    49fe:	61 f0       	breq	.+24     	; 0x4a18 <vfprintf+0xb2>
    4a00:	80 33       	cpi	r24, 0x30	; 48
    4a02:	69 f4       	brne	.+26     	; 0x4a1e <vfprintf+0xb8>
    4a04:	23 2d       	mov	r18, r3
    4a06:	21 60       	ori	r18, 0x01	; 1
    4a08:	16 c0       	rjmp	.+44     	; 0x4a36 <vfprintf+0xd0>
    4a0a:	83 2d       	mov	r24, r3
    4a0c:	82 60       	ori	r24, 0x02	; 2
    4a0e:	38 2e       	mov	r3, r24
    4a10:	e3 2d       	mov	r30, r3
    4a12:	e4 60       	ori	r30, 0x04	; 4
    4a14:	3e 2e       	mov	r3, r30
    4a16:	2a c0       	rjmp	.+84     	; 0x4a6c <vfprintf+0x106>
    4a18:	f3 2d       	mov	r31, r3
    4a1a:	f8 60       	ori	r31, 0x08	; 8
    4a1c:	1d c0       	rjmp	.+58     	; 0x4a58 <vfprintf+0xf2>
    4a1e:	37 fc       	sbrc	r3, 7
    4a20:	2d c0       	rjmp	.+90     	; 0x4a7c <vfprintf+0x116>
    4a22:	20 ed       	ldi	r18, 0xD0	; 208
    4a24:	28 0f       	add	r18, r24
    4a26:	2a 30       	cpi	r18, 0x0A	; 10
    4a28:	40 f0       	brcs	.+16     	; 0x4a3a <vfprintf+0xd4>
    4a2a:	8e 32       	cpi	r24, 0x2E	; 46
    4a2c:	b9 f4       	brne	.+46     	; 0x4a5c <vfprintf+0xf6>
    4a2e:	36 fc       	sbrc	r3, 6
    4a30:	75 c1       	rjmp	.+746    	; 0x4d1c <vfprintf+0x3b6>
    4a32:	23 2d       	mov	r18, r3
    4a34:	20 64       	ori	r18, 0x40	; 64
    4a36:	32 2e       	mov	r3, r18
    4a38:	19 c0       	rjmp	.+50     	; 0x4a6c <vfprintf+0x106>
    4a3a:	36 fe       	sbrs	r3, 6
    4a3c:	06 c0       	rjmp	.+12     	; 0x4a4a <vfprintf+0xe4>
    4a3e:	8a e0       	ldi	r24, 0x0A	; 10
    4a40:	98 9e       	mul	r9, r24
    4a42:	20 0d       	add	r18, r0
    4a44:	11 24       	eor	r1, r1
    4a46:	92 2e       	mov	r9, r18
    4a48:	11 c0       	rjmp	.+34     	; 0x4a6c <vfprintf+0x106>
    4a4a:	ea e0       	ldi	r30, 0x0A	; 10
    4a4c:	2e 9e       	mul	r2, r30
    4a4e:	20 0d       	add	r18, r0
    4a50:	11 24       	eor	r1, r1
    4a52:	22 2e       	mov	r2, r18
    4a54:	f3 2d       	mov	r31, r3
    4a56:	f0 62       	ori	r31, 0x20	; 32
    4a58:	3f 2e       	mov	r3, r31
    4a5a:	08 c0       	rjmp	.+16     	; 0x4a6c <vfprintf+0x106>
    4a5c:	8c 36       	cpi	r24, 0x6C	; 108
    4a5e:	21 f4       	brne	.+8      	; 0x4a68 <vfprintf+0x102>
    4a60:	83 2d       	mov	r24, r3
    4a62:	80 68       	ori	r24, 0x80	; 128
    4a64:	38 2e       	mov	r3, r24
    4a66:	02 c0       	rjmp	.+4      	; 0x4a6c <vfprintf+0x106>
    4a68:	88 36       	cpi	r24, 0x68	; 104
    4a6a:	41 f4       	brne	.+16     	; 0x4a7c <vfprintf+0x116>
    4a6c:	f7 01       	movw	r30, r14
    4a6e:	93 fd       	sbrc	r25, 3
    4a70:	85 91       	lpm	r24, Z+
    4a72:	93 ff       	sbrs	r25, 3
    4a74:	81 91       	ld	r24, Z+
    4a76:	7f 01       	movw	r14, r30
    4a78:	81 11       	cpse	r24, r1
    4a7a:	b3 cf       	rjmp	.-154    	; 0x49e2 <vfprintf+0x7c>
    4a7c:	98 2f       	mov	r25, r24
    4a7e:	9f 7d       	andi	r25, 0xDF	; 223
    4a80:	95 54       	subi	r25, 0x45	; 69
    4a82:	93 30       	cpi	r25, 0x03	; 3
    4a84:	28 f4       	brcc	.+10     	; 0x4a90 <vfprintf+0x12a>
    4a86:	0c 5f       	subi	r16, 0xFC	; 252
    4a88:	1f 4f       	sbci	r17, 0xFF	; 255
    4a8a:	9f e3       	ldi	r25, 0x3F	; 63
    4a8c:	99 83       	std	Y+1, r25	; 0x01
    4a8e:	0d c0       	rjmp	.+26     	; 0x4aaa <vfprintf+0x144>
    4a90:	83 36       	cpi	r24, 0x63	; 99
    4a92:	31 f0       	breq	.+12     	; 0x4aa0 <vfprintf+0x13a>
    4a94:	83 37       	cpi	r24, 0x73	; 115
    4a96:	71 f0       	breq	.+28     	; 0x4ab4 <vfprintf+0x14e>
    4a98:	83 35       	cpi	r24, 0x53	; 83
    4a9a:	09 f0       	breq	.+2      	; 0x4a9e <vfprintf+0x138>
    4a9c:	55 c0       	rjmp	.+170    	; 0x4b48 <vfprintf+0x1e2>
    4a9e:	20 c0       	rjmp	.+64     	; 0x4ae0 <vfprintf+0x17a>
    4aa0:	f8 01       	movw	r30, r16
    4aa2:	80 81       	ld	r24, Z
    4aa4:	89 83       	std	Y+1, r24	; 0x01
    4aa6:	0e 5f       	subi	r16, 0xFE	; 254
    4aa8:	1f 4f       	sbci	r17, 0xFF	; 255
    4aaa:	88 24       	eor	r8, r8
    4aac:	83 94       	inc	r8
    4aae:	91 2c       	mov	r9, r1
    4ab0:	53 01       	movw	r10, r6
    4ab2:	12 c0       	rjmp	.+36     	; 0x4ad8 <vfprintf+0x172>
    4ab4:	28 01       	movw	r4, r16
    4ab6:	f2 e0       	ldi	r31, 0x02	; 2
    4ab8:	4f 0e       	add	r4, r31
    4aba:	51 1c       	adc	r5, r1
    4abc:	f8 01       	movw	r30, r16
    4abe:	a0 80       	ld	r10, Z
    4ac0:	b1 80       	ldd	r11, Z+1	; 0x01
    4ac2:	36 fe       	sbrs	r3, 6
    4ac4:	03 c0       	rjmp	.+6      	; 0x4acc <vfprintf+0x166>
    4ac6:	69 2d       	mov	r22, r9
    4ac8:	70 e0       	ldi	r23, 0x00	; 0
    4aca:	02 c0       	rjmp	.+4      	; 0x4ad0 <vfprintf+0x16a>
    4acc:	6f ef       	ldi	r22, 0xFF	; 255
    4ace:	7f ef       	ldi	r23, 0xFF	; 255
    4ad0:	c5 01       	movw	r24, r10
    4ad2:	4b d1       	rcall	.+662    	; 0x4d6a <strnlen>
    4ad4:	4c 01       	movw	r8, r24
    4ad6:	82 01       	movw	r16, r4
    4ad8:	f3 2d       	mov	r31, r3
    4ada:	ff 77       	andi	r31, 0x7F	; 127
    4adc:	3f 2e       	mov	r3, r31
    4ade:	15 c0       	rjmp	.+42     	; 0x4b0a <vfprintf+0x1a4>
    4ae0:	28 01       	movw	r4, r16
    4ae2:	22 e0       	ldi	r18, 0x02	; 2
    4ae4:	42 0e       	add	r4, r18
    4ae6:	51 1c       	adc	r5, r1
    4ae8:	f8 01       	movw	r30, r16
    4aea:	a0 80       	ld	r10, Z
    4aec:	b1 80       	ldd	r11, Z+1	; 0x01
    4aee:	36 fe       	sbrs	r3, 6
    4af0:	03 c0       	rjmp	.+6      	; 0x4af8 <vfprintf+0x192>
    4af2:	69 2d       	mov	r22, r9
    4af4:	70 e0       	ldi	r23, 0x00	; 0
    4af6:	02 c0       	rjmp	.+4      	; 0x4afc <vfprintf+0x196>
    4af8:	6f ef       	ldi	r22, 0xFF	; 255
    4afa:	7f ef       	ldi	r23, 0xFF	; 255
    4afc:	c5 01       	movw	r24, r10
    4afe:	2a d1       	rcall	.+596    	; 0x4d54 <strnlen_P>
    4b00:	4c 01       	movw	r8, r24
    4b02:	f3 2d       	mov	r31, r3
    4b04:	f0 68       	ori	r31, 0x80	; 128
    4b06:	3f 2e       	mov	r3, r31
    4b08:	82 01       	movw	r16, r4
    4b0a:	33 fc       	sbrc	r3, 3
    4b0c:	19 c0       	rjmp	.+50     	; 0x4b40 <vfprintf+0x1da>
    4b0e:	82 2d       	mov	r24, r2
    4b10:	90 e0       	ldi	r25, 0x00	; 0
    4b12:	88 16       	cp	r8, r24
    4b14:	99 06       	cpc	r9, r25
    4b16:	a0 f4       	brcc	.+40     	; 0x4b40 <vfprintf+0x1da>
    4b18:	b6 01       	movw	r22, r12
    4b1a:	80 e2       	ldi	r24, 0x20	; 32
    4b1c:	90 e0       	ldi	r25, 0x00	; 0
    4b1e:	30 d1       	rcall	.+608    	; 0x4d80 <fputc>
    4b20:	2a 94       	dec	r2
    4b22:	f5 cf       	rjmp	.-22     	; 0x4b0e <vfprintf+0x1a8>
    4b24:	f5 01       	movw	r30, r10
    4b26:	37 fc       	sbrc	r3, 7
    4b28:	85 91       	lpm	r24, Z+
    4b2a:	37 fe       	sbrs	r3, 7
    4b2c:	81 91       	ld	r24, Z+
    4b2e:	5f 01       	movw	r10, r30
    4b30:	b6 01       	movw	r22, r12
    4b32:	90 e0       	ldi	r25, 0x00	; 0
    4b34:	25 d1       	rcall	.+586    	; 0x4d80 <fputc>
    4b36:	21 10       	cpse	r2, r1
    4b38:	2a 94       	dec	r2
    4b3a:	21 e0       	ldi	r18, 0x01	; 1
    4b3c:	82 1a       	sub	r8, r18
    4b3e:	91 08       	sbc	r9, r1
    4b40:	81 14       	cp	r8, r1
    4b42:	91 04       	cpc	r9, r1
    4b44:	79 f7       	brne	.-34     	; 0x4b24 <vfprintf+0x1be>
    4b46:	e1 c0       	rjmp	.+450    	; 0x4d0a <vfprintf+0x3a4>
    4b48:	84 36       	cpi	r24, 0x64	; 100
    4b4a:	11 f0       	breq	.+4      	; 0x4b50 <vfprintf+0x1ea>
    4b4c:	89 36       	cpi	r24, 0x69	; 105
    4b4e:	39 f5       	brne	.+78     	; 0x4b9e <vfprintf+0x238>
    4b50:	f8 01       	movw	r30, r16
    4b52:	37 fe       	sbrs	r3, 7
    4b54:	07 c0       	rjmp	.+14     	; 0x4b64 <vfprintf+0x1fe>
    4b56:	60 81       	ld	r22, Z
    4b58:	71 81       	ldd	r23, Z+1	; 0x01
    4b5a:	82 81       	ldd	r24, Z+2	; 0x02
    4b5c:	93 81       	ldd	r25, Z+3	; 0x03
    4b5e:	0c 5f       	subi	r16, 0xFC	; 252
    4b60:	1f 4f       	sbci	r17, 0xFF	; 255
    4b62:	08 c0       	rjmp	.+16     	; 0x4b74 <vfprintf+0x20e>
    4b64:	60 81       	ld	r22, Z
    4b66:	71 81       	ldd	r23, Z+1	; 0x01
    4b68:	07 2e       	mov	r0, r23
    4b6a:	00 0c       	add	r0, r0
    4b6c:	88 0b       	sbc	r24, r24
    4b6e:	99 0b       	sbc	r25, r25
    4b70:	0e 5f       	subi	r16, 0xFE	; 254
    4b72:	1f 4f       	sbci	r17, 0xFF	; 255
    4b74:	f3 2d       	mov	r31, r3
    4b76:	ff 76       	andi	r31, 0x6F	; 111
    4b78:	3f 2e       	mov	r3, r31
    4b7a:	97 ff       	sbrs	r25, 7
    4b7c:	09 c0       	rjmp	.+18     	; 0x4b90 <vfprintf+0x22a>
    4b7e:	90 95       	com	r25
    4b80:	80 95       	com	r24
    4b82:	70 95       	com	r23
    4b84:	61 95       	neg	r22
    4b86:	7f 4f       	sbci	r23, 0xFF	; 255
    4b88:	8f 4f       	sbci	r24, 0xFF	; 255
    4b8a:	9f 4f       	sbci	r25, 0xFF	; 255
    4b8c:	f0 68       	ori	r31, 0x80	; 128
    4b8e:	3f 2e       	mov	r3, r31
    4b90:	2a e0       	ldi	r18, 0x0A	; 10
    4b92:	30 e0       	ldi	r19, 0x00	; 0
    4b94:	a3 01       	movw	r20, r6
    4b96:	30 d1       	rcall	.+608    	; 0x4df8 <__ultoa_invert>
    4b98:	88 2e       	mov	r8, r24
    4b9a:	86 18       	sub	r8, r6
    4b9c:	44 c0       	rjmp	.+136    	; 0x4c26 <vfprintf+0x2c0>
    4b9e:	85 37       	cpi	r24, 0x75	; 117
    4ba0:	31 f4       	brne	.+12     	; 0x4bae <vfprintf+0x248>
    4ba2:	23 2d       	mov	r18, r3
    4ba4:	2f 7e       	andi	r18, 0xEF	; 239
    4ba6:	b2 2e       	mov	r11, r18
    4ba8:	2a e0       	ldi	r18, 0x0A	; 10
    4baa:	30 e0       	ldi	r19, 0x00	; 0
    4bac:	25 c0       	rjmp	.+74     	; 0x4bf8 <vfprintf+0x292>
    4bae:	93 2d       	mov	r25, r3
    4bb0:	99 7f       	andi	r25, 0xF9	; 249
    4bb2:	b9 2e       	mov	r11, r25
    4bb4:	8f 36       	cpi	r24, 0x6F	; 111
    4bb6:	c1 f0       	breq	.+48     	; 0x4be8 <vfprintf+0x282>
    4bb8:	18 f4       	brcc	.+6      	; 0x4bc0 <vfprintf+0x25a>
    4bba:	88 35       	cpi	r24, 0x58	; 88
    4bbc:	79 f0       	breq	.+30     	; 0x4bdc <vfprintf+0x276>
    4bbe:	ae c0       	rjmp	.+348    	; 0x4d1c <vfprintf+0x3b6>
    4bc0:	80 37       	cpi	r24, 0x70	; 112
    4bc2:	19 f0       	breq	.+6      	; 0x4bca <vfprintf+0x264>
    4bc4:	88 37       	cpi	r24, 0x78	; 120
    4bc6:	21 f0       	breq	.+8      	; 0x4bd0 <vfprintf+0x26a>
    4bc8:	a9 c0       	rjmp	.+338    	; 0x4d1c <vfprintf+0x3b6>
    4bca:	e9 2f       	mov	r30, r25
    4bcc:	e0 61       	ori	r30, 0x10	; 16
    4bce:	be 2e       	mov	r11, r30
    4bd0:	b4 fe       	sbrs	r11, 4
    4bd2:	0d c0       	rjmp	.+26     	; 0x4bee <vfprintf+0x288>
    4bd4:	fb 2d       	mov	r31, r11
    4bd6:	f4 60       	ori	r31, 0x04	; 4
    4bd8:	bf 2e       	mov	r11, r31
    4bda:	09 c0       	rjmp	.+18     	; 0x4bee <vfprintf+0x288>
    4bdc:	34 fe       	sbrs	r3, 4
    4bde:	0a c0       	rjmp	.+20     	; 0x4bf4 <vfprintf+0x28e>
    4be0:	29 2f       	mov	r18, r25
    4be2:	26 60       	ori	r18, 0x06	; 6
    4be4:	b2 2e       	mov	r11, r18
    4be6:	06 c0       	rjmp	.+12     	; 0x4bf4 <vfprintf+0x28e>
    4be8:	28 e0       	ldi	r18, 0x08	; 8
    4bea:	30 e0       	ldi	r19, 0x00	; 0
    4bec:	05 c0       	rjmp	.+10     	; 0x4bf8 <vfprintf+0x292>
    4bee:	20 e1       	ldi	r18, 0x10	; 16
    4bf0:	30 e0       	ldi	r19, 0x00	; 0
    4bf2:	02 c0       	rjmp	.+4      	; 0x4bf8 <vfprintf+0x292>
    4bf4:	20 e1       	ldi	r18, 0x10	; 16
    4bf6:	32 e0       	ldi	r19, 0x02	; 2
    4bf8:	f8 01       	movw	r30, r16
    4bfa:	b7 fe       	sbrs	r11, 7
    4bfc:	07 c0       	rjmp	.+14     	; 0x4c0c <vfprintf+0x2a6>
    4bfe:	60 81       	ld	r22, Z
    4c00:	71 81       	ldd	r23, Z+1	; 0x01
    4c02:	82 81       	ldd	r24, Z+2	; 0x02
    4c04:	93 81       	ldd	r25, Z+3	; 0x03
    4c06:	0c 5f       	subi	r16, 0xFC	; 252
    4c08:	1f 4f       	sbci	r17, 0xFF	; 255
    4c0a:	06 c0       	rjmp	.+12     	; 0x4c18 <vfprintf+0x2b2>
    4c0c:	60 81       	ld	r22, Z
    4c0e:	71 81       	ldd	r23, Z+1	; 0x01
    4c10:	80 e0       	ldi	r24, 0x00	; 0
    4c12:	90 e0       	ldi	r25, 0x00	; 0
    4c14:	0e 5f       	subi	r16, 0xFE	; 254
    4c16:	1f 4f       	sbci	r17, 0xFF	; 255
    4c18:	a3 01       	movw	r20, r6
    4c1a:	ee d0       	rcall	.+476    	; 0x4df8 <__ultoa_invert>
    4c1c:	88 2e       	mov	r8, r24
    4c1e:	86 18       	sub	r8, r6
    4c20:	fb 2d       	mov	r31, r11
    4c22:	ff 77       	andi	r31, 0x7F	; 127
    4c24:	3f 2e       	mov	r3, r31
    4c26:	36 fe       	sbrs	r3, 6
    4c28:	0d c0       	rjmp	.+26     	; 0x4c44 <vfprintf+0x2de>
    4c2a:	23 2d       	mov	r18, r3
    4c2c:	2e 7f       	andi	r18, 0xFE	; 254
    4c2e:	a2 2e       	mov	r10, r18
    4c30:	89 14       	cp	r8, r9
    4c32:	58 f4       	brcc	.+22     	; 0x4c4a <vfprintf+0x2e4>
    4c34:	34 fe       	sbrs	r3, 4
    4c36:	0b c0       	rjmp	.+22     	; 0x4c4e <vfprintf+0x2e8>
    4c38:	32 fc       	sbrc	r3, 2
    4c3a:	09 c0       	rjmp	.+18     	; 0x4c4e <vfprintf+0x2e8>
    4c3c:	83 2d       	mov	r24, r3
    4c3e:	8e 7e       	andi	r24, 0xEE	; 238
    4c40:	a8 2e       	mov	r10, r24
    4c42:	05 c0       	rjmp	.+10     	; 0x4c4e <vfprintf+0x2e8>
    4c44:	b8 2c       	mov	r11, r8
    4c46:	a3 2c       	mov	r10, r3
    4c48:	03 c0       	rjmp	.+6      	; 0x4c50 <vfprintf+0x2ea>
    4c4a:	b8 2c       	mov	r11, r8
    4c4c:	01 c0       	rjmp	.+2      	; 0x4c50 <vfprintf+0x2ea>
    4c4e:	b9 2c       	mov	r11, r9
    4c50:	a4 fe       	sbrs	r10, 4
    4c52:	0f c0       	rjmp	.+30     	; 0x4c72 <vfprintf+0x30c>
    4c54:	fe 01       	movw	r30, r28
    4c56:	e8 0d       	add	r30, r8
    4c58:	f1 1d       	adc	r31, r1
    4c5a:	80 81       	ld	r24, Z
    4c5c:	80 33       	cpi	r24, 0x30	; 48
    4c5e:	21 f4       	brne	.+8      	; 0x4c68 <vfprintf+0x302>
    4c60:	9a 2d       	mov	r25, r10
    4c62:	99 7e       	andi	r25, 0xE9	; 233
    4c64:	a9 2e       	mov	r10, r25
    4c66:	09 c0       	rjmp	.+18     	; 0x4c7a <vfprintf+0x314>
    4c68:	a2 fe       	sbrs	r10, 2
    4c6a:	06 c0       	rjmp	.+12     	; 0x4c78 <vfprintf+0x312>
    4c6c:	b3 94       	inc	r11
    4c6e:	b3 94       	inc	r11
    4c70:	04 c0       	rjmp	.+8      	; 0x4c7a <vfprintf+0x314>
    4c72:	8a 2d       	mov	r24, r10
    4c74:	86 78       	andi	r24, 0x86	; 134
    4c76:	09 f0       	breq	.+2      	; 0x4c7a <vfprintf+0x314>
    4c78:	b3 94       	inc	r11
    4c7a:	a3 fc       	sbrc	r10, 3
    4c7c:	10 c0       	rjmp	.+32     	; 0x4c9e <vfprintf+0x338>
    4c7e:	a0 fe       	sbrs	r10, 0
    4c80:	06 c0       	rjmp	.+12     	; 0x4c8e <vfprintf+0x328>
    4c82:	b2 14       	cp	r11, r2
    4c84:	80 f4       	brcc	.+32     	; 0x4ca6 <vfprintf+0x340>
    4c86:	28 0c       	add	r2, r8
    4c88:	92 2c       	mov	r9, r2
    4c8a:	9b 18       	sub	r9, r11
    4c8c:	0d c0       	rjmp	.+26     	; 0x4ca8 <vfprintf+0x342>
    4c8e:	b2 14       	cp	r11, r2
    4c90:	58 f4       	brcc	.+22     	; 0x4ca8 <vfprintf+0x342>
    4c92:	b6 01       	movw	r22, r12
    4c94:	80 e2       	ldi	r24, 0x20	; 32
    4c96:	90 e0       	ldi	r25, 0x00	; 0
    4c98:	73 d0       	rcall	.+230    	; 0x4d80 <fputc>
    4c9a:	b3 94       	inc	r11
    4c9c:	f8 cf       	rjmp	.-16     	; 0x4c8e <vfprintf+0x328>
    4c9e:	b2 14       	cp	r11, r2
    4ca0:	18 f4       	brcc	.+6      	; 0x4ca8 <vfprintf+0x342>
    4ca2:	2b 18       	sub	r2, r11
    4ca4:	02 c0       	rjmp	.+4      	; 0x4caa <vfprintf+0x344>
    4ca6:	98 2c       	mov	r9, r8
    4ca8:	21 2c       	mov	r2, r1
    4caa:	a4 fe       	sbrs	r10, 4
    4cac:	0f c0       	rjmp	.+30     	; 0x4ccc <vfprintf+0x366>
    4cae:	b6 01       	movw	r22, r12
    4cb0:	80 e3       	ldi	r24, 0x30	; 48
    4cb2:	90 e0       	ldi	r25, 0x00	; 0
    4cb4:	65 d0       	rcall	.+202    	; 0x4d80 <fputc>
    4cb6:	a2 fe       	sbrs	r10, 2
    4cb8:	16 c0       	rjmp	.+44     	; 0x4ce6 <vfprintf+0x380>
    4cba:	a1 fc       	sbrc	r10, 1
    4cbc:	03 c0       	rjmp	.+6      	; 0x4cc4 <vfprintf+0x35e>
    4cbe:	88 e7       	ldi	r24, 0x78	; 120
    4cc0:	90 e0       	ldi	r25, 0x00	; 0
    4cc2:	02 c0       	rjmp	.+4      	; 0x4cc8 <vfprintf+0x362>
    4cc4:	88 e5       	ldi	r24, 0x58	; 88
    4cc6:	90 e0       	ldi	r25, 0x00	; 0
    4cc8:	b6 01       	movw	r22, r12
    4cca:	0c c0       	rjmp	.+24     	; 0x4ce4 <vfprintf+0x37e>
    4ccc:	8a 2d       	mov	r24, r10
    4cce:	86 78       	andi	r24, 0x86	; 134
    4cd0:	51 f0       	breq	.+20     	; 0x4ce6 <vfprintf+0x380>
    4cd2:	a1 fe       	sbrs	r10, 1
    4cd4:	02 c0       	rjmp	.+4      	; 0x4cda <vfprintf+0x374>
    4cd6:	8b e2       	ldi	r24, 0x2B	; 43
    4cd8:	01 c0       	rjmp	.+2      	; 0x4cdc <vfprintf+0x376>
    4cda:	80 e2       	ldi	r24, 0x20	; 32
    4cdc:	a7 fc       	sbrc	r10, 7
    4cde:	8d e2       	ldi	r24, 0x2D	; 45
    4ce0:	b6 01       	movw	r22, r12
    4ce2:	90 e0       	ldi	r25, 0x00	; 0
    4ce4:	4d d0       	rcall	.+154    	; 0x4d80 <fputc>
    4ce6:	89 14       	cp	r8, r9
    4ce8:	30 f4       	brcc	.+12     	; 0x4cf6 <vfprintf+0x390>
    4cea:	b6 01       	movw	r22, r12
    4cec:	80 e3       	ldi	r24, 0x30	; 48
    4cee:	90 e0       	ldi	r25, 0x00	; 0
    4cf0:	47 d0       	rcall	.+142    	; 0x4d80 <fputc>
    4cf2:	9a 94       	dec	r9
    4cf4:	f8 cf       	rjmp	.-16     	; 0x4ce6 <vfprintf+0x380>
    4cf6:	8a 94       	dec	r8
    4cf8:	f3 01       	movw	r30, r6
    4cfa:	e8 0d       	add	r30, r8
    4cfc:	f1 1d       	adc	r31, r1
    4cfe:	80 81       	ld	r24, Z
    4d00:	b6 01       	movw	r22, r12
    4d02:	90 e0       	ldi	r25, 0x00	; 0
    4d04:	3d d0       	rcall	.+122    	; 0x4d80 <fputc>
    4d06:	81 10       	cpse	r8, r1
    4d08:	f6 cf       	rjmp	.-20     	; 0x4cf6 <vfprintf+0x390>
    4d0a:	22 20       	and	r2, r2
    4d0c:	09 f4       	brne	.+2      	; 0x4d10 <vfprintf+0x3aa>
    4d0e:	4e ce       	rjmp	.-868    	; 0x49ac <vfprintf+0x46>
    4d10:	b6 01       	movw	r22, r12
    4d12:	80 e2       	ldi	r24, 0x20	; 32
    4d14:	90 e0       	ldi	r25, 0x00	; 0
    4d16:	34 d0       	rcall	.+104    	; 0x4d80 <fputc>
    4d18:	2a 94       	dec	r2
    4d1a:	f7 cf       	rjmp	.-18     	; 0x4d0a <vfprintf+0x3a4>
    4d1c:	f6 01       	movw	r30, r12
    4d1e:	86 81       	ldd	r24, Z+6	; 0x06
    4d20:	97 81       	ldd	r25, Z+7	; 0x07
    4d22:	02 c0       	rjmp	.+4      	; 0x4d28 <vfprintf+0x3c2>
    4d24:	8f ef       	ldi	r24, 0xFF	; 255
    4d26:	9f ef       	ldi	r25, 0xFF	; 255
    4d28:	2b 96       	adiw	r28, 0x0b	; 11
    4d2a:	cd bf       	out	0x3d, r28	; 61
    4d2c:	de bf       	out	0x3e, r29	; 62
    4d2e:	df 91       	pop	r29
    4d30:	cf 91       	pop	r28
    4d32:	1f 91       	pop	r17
    4d34:	0f 91       	pop	r16
    4d36:	ff 90       	pop	r15
    4d38:	ef 90       	pop	r14
    4d3a:	df 90       	pop	r13
    4d3c:	cf 90       	pop	r12
    4d3e:	bf 90       	pop	r11
    4d40:	af 90       	pop	r10
    4d42:	9f 90       	pop	r9
    4d44:	8f 90       	pop	r8
    4d46:	7f 90       	pop	r7
    4d48:	6f 90       	pop	r6
    4d4a:	5f 90       	pop	r5
    4d4c:	4f 90       	pop	r4
    4d4e:	3f 90       	pop	r3
    4d50:	2f 90       	pop	r2
    4d52:	08 95       	ret

00004d54 <strnlen_P>:
    4d54:	fc 01       	movw	r30, r24
    4d56:	05 90       	lpm	r0, Z+
    4d58:	61 50       	subi	r22, 0x01	; 1
    4d5a:	70 40       	sbci	r23, 0x00	; 0
    4d5c:	01 10       	cpse	r0, r1
    4d5e:	d8 f7       	brcc	.-10     	; 0x4d56 <strnlen_P+0x2>
    4d60:	80 95       	com	r24
    4d62:	90 95       	com	r25
    4d64:	8e 0f       	add	r24, r30
    4d66:	9f 1f       	adc	r25, r31
    4d68:	08 95       	ret

00004d6a <strnlen>:
    4d6a:	fc 01       	movw	r30, r24
    4d6c:	61 50       	subi	r22, 0x01	; 1
    4d6e:	70 40       	sbci	r23, 0x00	; 0
    4d70:	01 90       	ld	r0, Z+
    4d72:	01 10       	cpse	r0, r1
    4d74:	d8 f7       	brcc	.-10     	; 0x4d6c <strnlen+0x2>
    4d76:	80 95       	com	r24
    4d78:	90 95       	com	r25
    4d7a:	8e 0f       	add	r24, r30
    4d7c:	9f 1f       	adc	r25, r31
    4d7e:	08 95       	ret

00004d80 <fputc>:
    4d80:	0f 93       	push	r16
    4d82:	1f 93       	push	r17
    4d84:	cf 93       	push	r28
    4d86:	df 93       	push	r29
    4d88:	fb 01       	movw	r30, r22
    4d8a:	23 81       	ldd	r18, Z+3	; 0x03
    4d8c:	21 fd       	sbrc	r18, 1
    4d8e:	03 c0       	rjmp	.+6      	; 0x4d96 <fputc+0x16>
    4d90:	8f ef       	ldi	r24, 0xFF	; 255
    4d92:	9f ef       	ldi	r25, 0xFF	; 255
    4d94:	2c c0       	rjmp	.+88     	; 0x4dee <fputc+0x6e>
    4d96:	22 ff       	sbrs	r18, 2
    4d98:	16 c0       	rjmp	.+44     	; 0x4dc6 <fputc+0x46>
    4d9a:	46 81       	ldd	r20, Z+6	; 0x06
    4d9c:	57 81       	ldd	r21, Z+7	; 0x07
    4d9e:	24 81       	ldd	r18, Z+4	; 0x04
    4da0:	35 81       	ldd	r19, Z+5	; 0x05
    4da2:	42 17       	cp	r20, r18
    4da4:	53 07       	cpc	r21, r19
    4da6:	44 f4       	brge	.+16     	; 0x4db8 <fputc+0x38>
    4da8:	a0 81       	ld	r26, Z
    4daa:	b1 81       	ldd	r27, Z+1	; 0x01
    4dac:	9d 01       	movw	r18, r26
    4dae:	2f 5f       	subi	r18, 0xFF	; 255
    4db0:	3f 4f       	sbci	r19, 0xFF	; 255
    4db2:	20 83       	st	Z, r18
    4db4:	31 83       	std	Z+1, r19	; 0x01
    4db6:	8c 93       	st	X, r24
    4db8:	26 81       	ldd	r18, Z+6	; 0x06
    4dba:	37 81       	ldd	r19, Z+7	; 0x07
    4dbc:	2f 5f       	subi	r18, 0xFF	; 255
    4dbe:	3f 4f       	sbci	r19, 0xFF	; 255
    4dc0:	26 83       	std	Z+6, r18	; 0x06
    4dc2:	37 83       	std	Z+7, r19	; 0x07
    4dc4:	14 c0       	rjmp	.+40     	; 0x4dee <fputc+0x6e>
    4dc6:	8b 01       	movw	r16, r22
    4dc8:	ec 01       	movw	r28, r24
    4dca:	fb 01       	movw	r30, r22
    4dcc:	00 84       	ldd	r0, Z+8	; 0x08
    4dce:	f1 85       	ldd	r31, Z+9	; 0x09
    4dd0:	e0 2d       	mov	r30, r0
    4dd2:	19 95       	eicall
    4dd4:	89 2b       	or	r24, r25
    4dd6:	e1 f6       	brne	.-72     	; 0x4d90 <fputc+0x10>
    4dd8:	d8 01       	movw	r26, r16
    4dda:	16 96       	adiw	r26, 0x06	; 6
    4ddc:	8d 91       	ld	r24, X+
    4dde:	9c 91       	ld	r25, X
    4de0:	17 97       	sbiw	r26, 0x07	; 7
    4de2:	01 96       	adiw	r24, 0x01	; 1
    4de4:	16 96       	adiw	r26, 0x06	; 6
    4de6:	8d 93       	st	X+, r24
    4de8:	9c 93       	st	X, r25
    4dea:	17 97       	sbiw	r26, 0x07	; 7
    4dec:	ce 01       	movw	r24, r28
    4dee:	df 91       	pop	r29
    4df0:	cf 91       	pop	r28
    4df2:	1f 91       	pop	r17
    4df4:	0f 91       	pop	r16
    4df6:	08 95       	ret

00004df8 <__ultoa_invert>:
    4df8:	fa 01       	movw	r30, r20
    4dfa:	aa 27       	eor	r26, r26
    4dfc:	28 30       	cpi	r18, 0x08	; 8
    4dfe:	51 f1       	breq	.+84     	; 0x4e54 <__ultoa_invert+0x5c>
    4e00:	20 31       	cpi	r18, 0x10	; 16
    4e02:	81 f1       	breq	.+96     	; 0x4e64 <__ultoa_invert+0x6c>
    4e04:	e8 94       	clt
    4e06:	6f 93       	push	r22
    4e08:	6e 7f       	andi	r22, 0xFE	; 254
    4e0a:	6e 5f       	subi	r22, 0xFE	; 254
    4e0c:	7f 4f       	sbci	r23, 0xFF	; 255
    4e0e:	8f 4f       	sbci	r24, 0xFF	; 255
    4e10:	9f 4f       	sbci	r25, 0xFF	; 255
    4e12:	af 4f       	sbci	r26, 0xFF	; 255
    4e14:	b1 e0       	ldi	r27, 0x01	; 1
    4e16:	3e d0       	rcall	.+124    	; 0x4e94 <__ultoa_invert+0x9c>
    4e18:	b4 e0       	ldi	r27, 0x04	; 4
    4e1a:	3c d0       	rcall	.+120    	; 0x4e94 <__ultoa_invert+0x9c>
    4e1c:	67 0f       	add	r22, r23
    4e1e:	78 1f       	adc	r23, r24
    4e20:	89 1f       	adc	r24, r25
    4e22:	9a 1f       	adc	r25, r26
    4e24:	a1 1d       	adc	r26, r1
    4e26:	68 0f       	add	r22, r24
    4e28:	79 1f       	adc	r23, r25
    4e2a:	8a 1f       	adc	r24, r26
    4e2c:	91 1d       	adc	r25, r1
    4e2e:	a1 1d       	adc	r26, r1
    4e30:	6a 0f       	add	r22, r26
    4e32:	71 1d       	adc	r23, r1
    4e34:	81 1d       	adc	r24, r1
    4e36:	91 1d       	adc	r25, r1
    4e38:	a1 1d       	adc	r26, r1
    4e3a:	20 d0       	rcall	.+64     	; 0x4e7c <__ultoa_invert+0x84>
    4e3c:	09 f4       	brne	.+2      	; 0x4e40 <__ultoa_invert+0x48>
    4e3e:	68 94       	set
    4e40:	3f 91       	pop	r19
    4e42:	2a e0       	ldi	r18, 0x0A	; 10
    4e44:	26 9f       	mul	r18, r22
    4e46:	11 24       	eor	r1, r1
    4e48:	30 19       	sub	r19, r0
    4e4a:	30 5d       	subi	r19, 0xD0	; 208
    4e4c:	31 93       	st	Z+, r19
    4e4e:	de f6       	brtc	.-74     	; 0x4e06 <__ultoa_invert+0xe>
    4e50:	cf 01       	movw	r24, r30
    4e52:	08 95       	ret
    4e54:	46 2f       	mov	r20, r22
    4e56:	47 70       	andi	r20, 0x07	; 7
    4e58:	40 5d       	subi	r20, 0xD0	; 208
    4e5a:	41 93       	st	Z+, r20
    4e5c:	b3 e0       	ldi	r27, 0x03	; 3
    4e5e:	0f d0       	rcall	.+30     	; 0x4e7e <__ultoa_invert+0x86>
    4e60:	c9 f7       	brne	.-14     	; 0x4e54 <__ultoa_invert+0x5c>
    4e62:	f6 cf       	rjmp	.-20     	; 0x4e50 <__ultoa_invert+0x58>
    4e64:	46 2f       	mov	r20, r22
    4e66:	4f 70       	andi	r20, 0x0F	; 15
    4e68:	40 5d       	subi	r20, 0xD0	; 208
    4e6a:	4a 33       	cpi	r20, 0x3A	; 58
    4e6c:	18 f0       	brcs	.+6      	; 0x4e74 <__ultoa_invert+0x7c>
    4e6e:	49 5d       	subi	r20, 0xD9	; 217
    4e70:	31 fd       	sbrc	r19, 1
    4e72:	40 52       	subi	r20, 0x20	; 32
    4e74:	41 93       	st	Z+, r20
    4e76:	02 d0       	rcall	.+4      	; 0x4e7c <__ultoa_invert+0x84>
    4e78:	a9 f7       	brne	.-22     	; 0x4e64 <__ultoa_invert+0x6c>
    4e7a:	ea cf       	rjmp	.-44     	; 0x4e50 <__ultoa_invert+0x58>
    4e7c:	b4 e0       	ldi	r27, 0x04	; 4
    4e7e:	a6 95       	lsr	r26
    4e80:	97 95       	ror	r25
    4e82:	87 95       	ror	r24
    4e84:	77 95       	ror	r23
    4e86:	67 95       	ror	r22
    4e88:	ba 95       	dec	r27
    4e8a:	c9 f7       	brne	.-14     	; 0x4e7e <__ultoa_invert+0x86>
    4e8c:	00 97       	sbiw	r24, 0x00	; 0
    4e8e:	61 05       	cpc	r22, r1
    4e90:	71 05       	cpc	r23, r1
    4e92:	08 95       	ret
    4e94:	9b 01       	movw	r18, r22
    4e96:	ac 01       	movw	r20, r24
    4e98:	0a 2e       	mov	r0, r26
    4e9a:	06 94       	lsr	r0
    4e9c:	57 95       	ror	r21
    4e9e:	47 95       	ror	r20
    4ea0:	37 95       	ror	r19
    4ea2:	27 95       	ror	r18
    4ea4:	ba 95       	dec	r27
    4ea6:	c9 f7       	brne	.-14     	; 0x4e9a <__ultoa_invert+0xa2>
    4ea8:	62 0f       	add	r22, r18
    4eaa:	73 1f       	adc	r23, r19
    4eac:	84 1f       	adc	r24, r20
    4eae:	95 1f       	adc	r25, r21
    4eb0:	a0 1d       	adc	r26, r0
    4eb2:	08 95       	ret

00004eb4 <_exit>:
    4eb4:	f8 94       	cli

00004eb6 <__stop_program>:
    4eb6:	ff cf       	rjmp	.-2      	; 0x4eb6 <__stop_program>
