
ProjectUAS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004536  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000052  00802000  00004536  000045ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002d3  00802052  00802052  0000461c  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  0000461c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  00004678  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007b8  00000000  00000000  000046bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00015388  00000000  00000000  00004e74  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00005ae6  00000000  00000000  0001a1fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000064a9  00000000  00000000  0001fce2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000020a0  00000000  00000000  0002618c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000060e5  00000000  00000000  0002822c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000bc36  00000000  00000000  0002e311  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000009a8  00000000  00000000  00039f47  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	50 c2       	rjmp	.+1184   	; 0x4a2 <__ctors_end>
       2:	00 00       	nop
       4:	6f c2       	rjmp	.+1246   	; 0x4e4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c2       	rjmp	.+1242   	; 0x4e4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c2       	rjmp	.+1238   	; 0x4e4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c2       	rjmp	.+1234   	; 0x4e4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c2       	rjmp	.+1230   	; 0x4e4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c2       	rjmp	.+1226   	; 0x4e4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c2       	rjmp	.+1222   	; 0x4e4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c2       	rjmp	.+1218   	; 0x4e4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c2       	rjmp	.+1214   	; 0x4e4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c2       	rjmp	.+1210   	; 0x4e4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c2       	rjmp	.+1206   	; 0x4e4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	59 c2       	rjmp	.+1202   	; 0x4e4 <__bad_interrupt>
      32:	00 00       	nop
      34:	57 c2       	rjmp	.+1198   	; 0x4e4 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 3a 10 	jmp	0x2074	; 0x2074 <__vector_14>
      3c:	6a c5       	rjmp	.+2772   	; 0xb12 <__vector_15>
      3e:	00 00       	nop
      40:	95 c5       	rjmp	.+2858   	; 0xb6c <__vector_16>
      42:	00 00       	nop
      44:	c0 c5       	rjmp	.+2944   	; 0xbc6 <__vector_17>
      46:	00 00       	nop
      48:	eb c5       	rjmp	.+3030   	; 0xc20 <__vector_18>
      4a:	00 00       	nop
      4c:	16 c6       	rjmp	.+3116   	; 0xc7a <__vector_19>
      4e:	00 00       	nop
      50:	41 c6       	rjmp	.+3202   	; 0xcd4 <__vector_20>
      52:	00 00       	nop
      54:	6c c6       	rjmp	.+3288   	; 0xd2e <__vector_21>
      56:	00 00       	nop
      58:	97 c6       	rjmp	.+3374   	; 0xd88 <__vector_22>
      5a:	00 00       	nop
      5c:	c2 c6       	rjmp	.+3460   	; 0xde2 <__vector_23>
      5e:	00 00       	nop
      60:	41 c2       	rjmp	.+1154   	; 0x4e4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c2       	rjmp	.+1150   	; 0x4e4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c2       	rjmp	.+1146   	; 0x4e4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c2       	rjmp	.+1142   	; 0x4e4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	39 c2       	rjmp	.+1138   	; 0x4e4 <__bad_interrupt>
      72:	00 00       	nop
      74:	37 c2       	rjmp	.+1134   	; 0x4e4 <__bad_interrupt>
      76:	00 00       	nop
      78:	35 c2       	rjmp	.+1130   	; 0x4e4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	33 c2       	rjmp	.+1126   	; 0x4e4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c2       	rjmp	.+1122   	; 0x4e4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c2       	rjmp	.+1118   	; 0x4e4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c2       	rjmp	.+1114   	; 0x4e4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2b c2       	rjmp	.+1110   	; 0x4e4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	29 c2       	rjmp	.+1106   	; 0x4e4 <__bad_interrupt>
      92:	00 00       	nop
      94:	27 c2       	rjmp	.+1102   	; 0x4e4 <__bad_interrupt>
      96:	00 00       	nop
      98:	25 c2       	rjmp	.+1098   	; 0x4e4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	23 c2       	rjmp	.+1094   	; 0x4e4 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	21 c2       	rjmp	.+1090   	; 0x4e4 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	1f c2       	rjmp	.+1086   	; 0x4e4 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	1d c2       	rjmp	.+1082   	; 0x4e4 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	1b c2       	rjmp	.+1078   	; 0x4e4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	19 c2       	rjmp	.+1074   	; 0x4e4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	17 c2       	rjmp	.+1070   	; 0x4e4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	15 c2       	rjmp	.+1066   	; 0x4e4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 e0 08 	jmp	0x11c0	; 0x11c0 <__vector_47>
      c0:	0c 94 0d 09 	jmp	0x121a	; 0x121a <__vector_48>
      c4:	0c 94 3a 09 	jmp	0x1274	; 0x1274 <__vector_49>
      c8:	0c 94 67 09 	jmp	0x12ce	; 0x12ce <__vector_50>
      cc:	0c 94 94 09 	jmp	0x1328	; 0x1328 <__vector_51>
      d0:	0c 94 c1 09 	jmp	0x1382	; 0x1382 <__vector_52>
      d4:	0c 94 ee 09 	jmp	0x13dc	; 0x13dc <__vector_53>
      d8:	0c 94 1b 0a 	jmp	0x1436	; 0x1436 <__vector_54>
      dc:	0c 94 48 0a 	jmp	0x1490	; 0x1490 <__vector_55>
      e0:	0c 94 75 0a 	jmp	0x14ea	; 0x14ea <__vector_56>
      e4:	ff c1       	rjmp	.+1022   	; 0x4e4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	fd c1       	rjmp	.+1018   	; 0x4e4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	fb c1       	rjmp	.+1014   	; 0x4e4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f9 c1       	rjmp	.+1010   	; 0x4e4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	f7 c1       	rjmp	.+1006   	; 0x4e4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	f5 c1       	rjmp	.+1002   	; 0x4e4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f3 c1       	rjmp	.+998    	; 0x4e4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f1 c1       	rjmp	.+994    	; 0x4e4 <__bad_interrupt>
     102:	00 00       	nop
     104:	ef c1       	rjmp	.+990    	; 0x4e4 <__bad_interrupt>
     106:	00 00       	nop
     108:	ed c1       	rjmp	.+986    	; 0x4e4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	eb c1       	rjmp	.+982    	; 0x4e4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e9 c1       	rjmp	.+978    	; 0x4e4 <__bad_interrupt>
     112:	00 00       	nop
     114:	e7 c1       	rjmp	.+974    	; 0x4e4 <__bad_interrupt>
     116:	00 00       	nop
     118:	e5 c1       	rjmp	.+970    	; 0x4e4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	e3 c1       	rjmp	.+966    	; 0x4e4 <__bad_interrupt>
     11e:	00 00       	nop
     120:	e1 c1       	rjmp	.+962    	; 0x4e4 <__bad_interrupt>
     122:	00 00       	nop
     124:	df c1       	rjmp	.+958    	; 0x4e4 <__bad_interrupt>
     126:	00 00       	nop
     128:	dd c1       	rjmp	.+954    	; 0x4e4 <__bad_interrupt>
     12a:	00 00       	nop
     12c:	db c1       	rjmp	.+950    	; 0x4e4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d9 c1       	rjmp	.+946    	; 0x4e4 <__bad_interrupt>
     132:	00 00       	nop
     134:	83 c6       	rjmp	.+3334   	; 0xe3c <__vector_77>
     136:	00 00       	nop
     138:	ae c6       	rjmp	.+3420   	; 0xe96 <__vector_78>
     13a:	00 00       	nop
     13c:	d9 c6       	rjmp	.+3506   	; 0xef0 <__vector_79>
     13e:	00 00       	nop
     140:	04 c7       	rjmp	.+3592   	; 0xf4a <__vector_80>
     142:	00 00       	nop
     144:	2f c7       	rjmp	.+3678   	; 0xfa4 <__vector_81>
     146:	00 00       	nop
     148:	5a c7       	rjmp	.+3764   	; 0xffe <__vector_82>
     14a:	00 00       	nop
     14c:	85 c7       	rjmp	.+3850   	; 0x1058 <__vector_83>
     14e:	00 00       	nop
     150:	b0 c7       	rjmp	.+3936   	; 0x10b2 <__vector_84>
     152:	00 00       	nop
     154:	db c7       	rjmp	.+4022   	; 0x110c <__vector_85>
     156:	00 00       	nop
     158:	0c 94 b3 08 	jmp	0x1166	; 0x1166 <__vector_86>
     15c:	c3 c1       	rjmp	.+902    	; 0x4e4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c1 c1       	rjmp	.+898    	; 0x4e4 <__bad_interrupt>
     162:	00 00       	nop
     164:	bf c1       	rjmp	.+894    	; 0x4e4 <__bad_interrupt>
     166:	00 00       	nop
     168:	bd c1       	rjmp	.+890    	; 0x4e4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	bb c1       	rjmp	.+886    	; 0x4e4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b9 c1       	rjmp	.+882    	; 0x4e4 <__bad_interrupt>
     172:	00 00       	nop
     174:	b7 c1       	rjmp	.+878    	; 0x4e4 <__bad_interrupt>
     176:	00 00       	nop
     178:	b5 c1       	rjmp	.+874    	; 0x4e4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b3 c1       	rjmp	.+870    	; 0x4e4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b1 c1       	rjmp	.+866    	; 0x4e4 <__bad_interrupt>
     182:	00 00       	nop
     184:	af c1       	rjmp	.+862    	; 0x4e4 <__bad_interrupt>
     186:	00 00       	nop
     188:	ad c1       	rjmp	.+858    	; 0x4e4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	ab c1       	rjmp	.+854    	; 0x4e4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a9 c1       	rjmp	.+850    	; 0x4e4 <__bad_interrupt>
     192:	00 00       	nop
     194:	a7 c1       	rjmp	.+846    	; 0x4e4 <__bad_interrupt>
     196:	00 00       	nop
     198:	a5 c1       	rjmp	.+842    	; 0x4e4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a3 c1       	rjmp	.+838    	; 0x4e4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a1 c1       	rjmp	.+834    	; 0x4e4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	9f c1       	rjmp	.+830    	; 0x4e4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	9d c1       	rjmp	.+826    	; 0x4e4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	9b c1       	rjmp	.+822    	; 0x4e4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	0c 94 a2 0a 	jmp	0x1544	; 0x1544 <__vector_108>
     1b4:	0c 94 cf 0a 	jmp	0x159e	; 0x159e <__vector_109>
     1b8:	0c 94 fc 0a 	jmp	0x15f8	; 0x15f8 <__vector_110>
     1bc:	0c 94 29 0b 	jmp	0x1652	; 0x1652 <__vector_111>
     1c0:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__vector_112>
     1c4:	0c 94 83 0b 	jmp	0x1706	; 0x1706 <__vector_113>
     1c8:	8d c1       	rjmp	.+794    	; 0x4e4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	8b c1       	rjmp	.+790    	; 0x4e4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	89 c1       	rjmp	.+786    	; 0x4e4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	87 c1       	rjmp	.+782    	; 0x4e4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	85 c1       	rjmp	.+778    	; 0x4e4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	83 c1       	rjmp	.+774    	; 0x4e4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	81 c1       	rjmp	.+770    	; 0x4e4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	7f c1       	rjmp	.+766    	; 0x4e4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	7d c1       	rjmp	.+762    	; 0x4e4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	7b c1       	rjmp	.+758    	; 0x4e4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	79 c1       	rjmp	.+754    	; 0x4e4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	77 c1       	rjmp	.+750    	; 0x4e4 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	75 c1       	rjmp	.+746    	; 0x4e4 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	5a 19       	sub	r21, r10
     1fe:	5a 19       	sub	r21, r10
     200:	5a 19       	sub	r21, r10
     202:	87 19       	sub	r24, r7
     204:	8f 19       	sub	r24, r15
     206:	9d 19       	sub	r25, r13
     208:	5a 19       	sub	r21, r10
     20a:	5a 19       	sub	r21, r10
     20c:	87 19       	sub	r24, r7
     20e:	8f 19       	sub	r24, r15

00000210 <__trampolines_end>:
     210:	00 00       	nop
     212:	00 00       	nop
     214:	00 00       	nop
     216:	00 20       	and	r0, r0
     218:	20 20       	and	r2, r0
     21a:	20 20       	and	r2, r0
     21c:	00 20       	and	r0, r0
     21e:	50 50       	subi	r21, 0x00	; 0
     220:	50 00       	.word	0x0050	; ????
     222:	00 00       	nop
     224:	00 50       	subi	r16, 0x00	; 0
     226:	50 f8       	bld	r5, 0
     228:	50 f8       	bld	r5, 0
     22a:	50 50       	subi	r21, 0x00	; 0
     22c:	20 78       	andi	r18, 0x80	; 128
     22e:	a0 70       	andi	r26, 0x00	; 0
     230:	28 f0       	brcs	.+10     	; 0x23c <__trampolines_end+0x2c>
     232:	20 c0       	rjmp	.+64     	; 0x274 <__trampolines_end+0x64>
     234:	c8 10       	cpse	r12, r8
     236:	20 40       	sbci	r18, 0x00	; 0
     238:	98 18       	sub	r9, r8
     23a:	60 90 a0 40 	lds	r6, 0x40A0	; 0x8040a0 <__bss_end+0x1d7b>
     23e:	a8 90       	.word	0x90a8	; ????
     240:	68 60       	ori	r22, 0x08	; 8
     242:	20 40       	sbci	r18, 0x00	; 0
     244:	00 00       	nop
     246:	00 00       	nop
     248:	10 20       	and	r1, r0
     24a:	40 40       	sbci	r20, 0x00	; 0
     24c:	40 20       	and	r4, r0
     24e:	10 40       	sbci	r17, 0x00	; 0
     250:	20 10       	cpse	r2, r0
     252:	10 10       	cpse	r1, r0
     254:	20 40       	sbci	r18, 0x00	; 0
     256:	00 50       	subi	r16, 0x00	; 0
     258:	20 f8       	bld	r2, 0
     25a:	20 50       	subi	r18, 0x00	; 0
     25c:	00 00       	nop
     25e:	20 20       	and	r2, r0
     260:	f8 20       	and	r15, r8
     262:	20 00       	.word	0x0020	; ????
     264:	00 00       	nop
     266:	00 00       	nop
     268:	60 20       	and	r6, r0
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	f8 00       	.word	0x00f8	; ????
     270:	00 00       	nop
     272:	00 00       	nop
     274:	00 00       	nop
     276:	00 60       	ori	r16, 0x00	; 0
     278:	60 00       	.word	0x0060	; ????
     27a:	08 10       	cpse	r0, r8
     27c:	20 40       	sbci	r18, 0x00	; 0
     27e:	80 00       	.word	0x0080	; ????
     280:	70 88       	ldd	r7, Z+16	; 0x10
     282:	98 a8       	ldd	r9, Y+48	; 0x30
     284:	c8 88       	ldd	r12, Y+16	; 0x10
     286:	70 20       	and	r7, r0
     288:	60 20       	and	r6, r0
     28a:	20 20       	and	r2, r0
     28c:	20 70       	andi	r18, 0x00	; 0
     28e:	70 88       	ldd	r7, Z+16	; 0x10
     290:	08 10       	cpse	r0, r8
     292:	20 40       	sbci	r18, 0x00	; 0
     294:	f8 f8       	.word	0xf8f8	; ????
     296:	10 20       	and	r1, r0
     298:	10 08       	sbc	r1, r0
     29a:	88 70       	andi	r24, 0x08	; 8
     29c:	10 30       	cpi	r17, 0x00	; 0
     29e:	50 90 f8 10 	lds	r5, 0x10F8	; 0x8010f8 <__TEXT_REGION_LENGTH__+0x7010f8>
     2a2:	10 f8       	bld	r1, 0
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <__trampolines_end+0xb6>
     2a6:	08 08       	sbc	r0, r8
     2a8:	88 70       	andi	r24, 0x08	; 8
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 f0       	brcs	.+32     	; 0x2ce <__trampolines_end+0xbe>
     2ae:	88 88       	ldd	r8, Y+16	; 0x10
     2b0:	70 f8       	bld	r7, 0
     2b2:	08 10       	cpse	r0, r8
     2b4:	20 40       	sbci	r18, 0x00	; 0
     2b6:	40 40       	sbci	r20, 0x00	; 0
     2b8:	70 88       	ldd	r7, Z+16	; 0x10
     2ba:	88 70       	andi	r24, 0x08	; 8
     2bc:	88 88       	ldd	r8, Y+16	; 0x10
     2be:	70 70       	andi	r23, 0x00	; 0
     2c0:	88 88       	ldd	r8, Y+16	; 0x10
     2c2:	78 08       	sbc	r7, r8
     2c4:	10 60       	ori	r17, 0x00	; 0
     2c6:	00 60       	ori	r16, 0x00	; 0
     2c8:	60 00       	.word	0x0060	; ????
     2ca:	60 60       	ori	r22, 0x00	; 0
     2cc:	00 00       	nop
     2ce:	60 60       	ori	r22, 0x00	; 0
     2d0:	00 60       	ori	r16, 0x00	; 0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	08 10       	cpse	r0, r8
     2d6:	20 40       	sbci	r18, 0x00	; 0
     2d8:	20 10       	cpse	r2, r0
     2da:	08 00       	.word	0x0008	; ????
     2dc:	00 f8       	bld	r0, 0
     2de:	00 f8       	bld	r0, 0
     2e0:	00 00       	nop
     2e2:	80 40       	sbci	r24, 0x00	; 0
     2e4:	20 10       	cpse	r2, r0
     2e6:	20 40       	sbci	r18, 0x00	; 0
     2e8:	80 70       	andi	r24, 0x00	; 0
     2ea:	88 08       	sbc	r8, r8
     2ec:	10 20       	and	r1, r0
     2ee:	00 20       	and	r0, r0
     2f0:	70 88       	ldd	r7, Z+16	; 0x10
     2f2:	08 68       	ori	r16, 0x88	; 136
     2f4:	a8 a8       	ldd	r10, Y+48	; 0x30
     2f6:	70 70       	andi	r23, 0x00	; 0
     2f8:	88 88       	ldd	r8, Y+16	; 0x10
     2fa:	88 f8       	.word	0xf888	; ????
     2fc:	88 88       	ldd	r8, Y+16	; 0x10
     2fe:	f0 88       	ldd	r15, Z+16	; 0x10
     300:	88 f0       	brcs	.+34     	; 0x324 <__trampolines_end+0x114>
     302:	88 88       	ldd	r8, Y+16	; 0x10
     304:	f0 70       	andi	r31, 0x00	; 0
     306:	88 80       	ld	r8, Y
     308:	80 80       	ld	r8, Z
     30a:	88 70       	andi	r24, 0x08	; 8
     30c:	e0 90 88 88 	lds	r14, 0x8888	; 0x808888 <__bss_end+0x6563>
     310:	88 90       	.word	0x9088	; ????
     312:	e0 f8       	bld	r14, 0
     314:	80 80       	ld	r8, Z
     316:	f0 80       	ld	r15, Z
     318:	80 f8       	bld	r8, 0
     31a:	f8 80       	ld	r15, Y
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	80 80       	ld	r8, Z
     320:	80 70       	andi	r24, 0x00	; 0
     322:	88 80       	ld	r8, Y
     324:	80 98       	cbi	0x10, 0	; 16
     326:	88 70       	andi	r24, 0x08	; 8
     328:	88 88       	ldd	r8, Y+16	; 0x10
     32a:	88 f8       	.word	0xf888	; ????
     32c:	88 88       	ldd	r8, Y+16	; 0x10
     32e:	88 70       	andi	r24, 0x08	; 8
     330:	20 20       	and	r2, r0
     332:	20 20       	and	r2, r0
     334:	20 70       	andi	r18, 0x00	; 0
     336:	38 10       	cpse	r3, r8
     338:	10 10       	cpse	r1, r0
     33a:	10 90 60 88 	lds	r1, 0x8860	; 0x808860 <__bss_end+0x653b>
     33e:	90 a0       	ldd	r9, Z+32	; 0x20
     340:	c0 a0       	ldd	r12, Z+32	; 0x20
     342:	90 88       	ldd	r9, Z+16	; 0x10
     344:	80 80       	ld	r8, Z
     346:	80 80       	ld	r8, Z
     348:	80 80       	ld	r8, Z
     34a:	f8 88       	ldd	r15, Y+16	; 0x10
     34c:	d8 a8       	ldd	r13, Y+48	; 0x30
     34e:	88 88       	ldd	r8, Y+16	; 0x10
     350:	88 88       	ldd	r8, Y+16	; 0x10
     352:	88 88       	ldd	r8, Y+16	; 0x10
     354:	c8 a8       	ldd	r12, Y+48	; 0x30
     356:	98 88       	ldd	r9, Y+16	; 0x10
     358:	88 70       	andi	r24, 0x08	; 8
     35a:	88 88       	ldd	r8, Y+16	; 0x10
     35c:	88 88       	ldd	r8, Y+16	; 0x10
     35e:	88 70       	andi	r24, 0x08	; 8
     360:	f0 88       	ldd	r15, Z+16	; 0x10
     362:	88 f0       	brcs	.+34     	; 0x386 <__trampolines_end+0x176>
     364:	80 80       	ld	r8, Z
     366:	80 70       	andi	r24, 0x00	; 0
     368:	88 88       	ldd	r8, Y+16	; 0x10
     36a:	88 a8       	ldd	r8, Y+48	; 0x30
     36c:	90 68       	ori	r25, 0x80	; 128
     36e:	f0 88       	ldd	r15, Z+16	; 0x10
     370:	88 f0       	brcs	.+34     	; 0x394 <__trampolines_end+0x184>
     372:	a0 90 88 78 	lds	r10, 0x7888	; 0x807888 <__bss_end+0x5563>
     376:	80 80       	ld	r8, Z
     378:	70 08       	sbc	r7, r0
     37a:	08 f0       	brcs	.+2      	; 0x37e <__trampolines_end+0x16e>
     37c:	f8 20       	and	r15, r8
     37e:	20 20       	and	r2, r0
     380:	20 20       	and	r2, r0
     382:	20 88       	ldd	r2, Z+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	88 88       	ldd	r8, Y+16	; 0x10
     388:	88 70       	andi	r24, 0x08	; 8
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 88       	ldd	r8, Y+16	; 0x10
     38e:	88 50       	subi	r24, 0x08	; 8
     390:	20 88       	ldd	r2, Z+16	; 0x10
     392:	88 88       	ldd	r8, Y+16	; 0x10
     394:	a8 a8       	ldd	r10, Y+48	; 0x30
     396:	d8 88       	ldd	r13, Y+16	; 0x10
     398:	88 88       	ldd	r8, Y+16	; 0x10
     39a:	50 20       	and	r5, r0
     39c:	50 88       	ldd	r5, Z+16	; 0x10
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 50       	subi	r24, 0x08	; 8
     3a2:	20 20       	and	r2, r0
     3a4:	20 20       	and	r2, r0
     3a6:	f8 08       	sbc	r15, r8
     3a8:	10 20       	and	r1, r0
     3aa:	40 80       	ld	r4, Z
     3ac:	f8 38       	cpi	r31, 0x88	; 136
     3ae:	20 20       	and	r2, r0
     3b0:	20 20       	and	r2, r0
     3b2:	20 38       	cpi	r18, 0x80	; 128
     3b4:	00 80       	ld	r0, Z
     3b6:	40 20       	and	r4, r0
     3b8:	10 08       	sbc	r1, r0
     3ba:	00 e0       	ldi	r16, 0x00	; 0
     3bc:	20 20       	and	r2, r0
     3be:	20 20       	and	r2, r0
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	20 50       	subi	r18, 0x00	; 0
     3c4:	88 00       	.word	0x0088	; ????
	...
     3ce:	00 f8       	bld	r0, 0
     3d0:	40 20       	and	r4, r0
     3d2:	10 00       	.word	0x0010	; ????
     3d4:	00 00       	nop
     3d6:	00 00       	nop
     3d8:	00 70       	andi	r16, 0x00	; 0
     3da:	08 78       	andi	r16, 0x88	; 136
     3dc:	88 78       	andi	r24, 0x88	; 136
     3de:	80 80       	ld	r8, Z
     3e0:	b0 c8       	rjmp	.-3744   	; 0xfffff542 <__eeprom_end+0xff7ef542>
     3e2:	88 88       	ldd	r8, Y+16	; 0x10
     3e4:	f0 00       	.word	0x00f0	; ????
     3e6:	00 70       	andi	r16, 0x00	; 0
     3e8:	80 80       	ld	r8, Z
     3ea:	88 70       	andi	r24, 0x08	; 8
     3ec:	08 08       	sbc	r0, r8
     3ee:	68 98       	cbi	0x0d, 0	; 13
     3f0:	88 88       	ldd	r8, Y+16	; 0x10
     3f2:	78 00       	.word	0x0078	; ????
     3f4:	00 70       	andi	r16, 0x00	; 0
     3f6:	88 f8       	.word	0xf888	; ????
     3f8:	80 70       	andi	r24, 0x00	; 0
     3fa:	30 48       	sbci	r19, 0x80	; 128
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	40 40       	sbci	r20, 0x00	; 0
     400:	40 00       	.word	0x0040	; ????
     402:	00 78       	andi	r16, 0x80	; 128
     404:	88 78       	andi	r24, 0x88	; 136
     406:	08 30       	cpi	r16, 0x08	; 8
     408:	80 80       	ld	r8, Z
     40a:	b0 c8       	rjmp	.-3744   	; 0xfffff56c <__eeprom_end+0xff7ef56c>
     40c:	88 88       	ldd	r8, Y+16	; 0x10
     40e:	88 20       	and	r8, r8
     410:	00 60       	ori	r16, 0x00	; 0
     412:	20 20       	and	r2, r0
     414:	20 70       	andi	r18, 0x00	; 0
     416:	10 00       	.word	0x0010	; ????
     418:	30 10       	cpse	r3, r0
     41a:	10 90 60 40 	lds	r1, 0x4060	; 0x804060 <__bss_end+0x1d3b>
     41e:	40 48       	sbci	r20, 0x80	; 128
     420:	50 60       	ori	r21, 0x00	; 0
     422:	50 48       	sbci	r21, 0x80	; 128
     424:	60 20       	and	r6, r0
     426:	20 20       	and	r2, r0
     428:	20 20       	and	r2, r0
     42a:	70 00       	.word	0x0070	; ????
     42c:	00 d0       	rcall	.+0      	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
     42e:	a8 a8       	ldd	r10, Y+48	; 0x30
     430:	88 88       	ldd	r8, Y+16	; 0x10
     432:	00 00       	nop
     434:	b0 c8       	rjmp	.-3744   	; 0xfffff596 <__eeprom_end+0xff7ef596>
     436:	88 88       	ldd	r8, Y+16	; 0x10
     438:	88 00       	.word	0x0088	; ????
     43a:	00 70       	andi	r16, 0x00	; 0
     43c:	88 88       	ldd	r8, Y+16	; 0x10
     43e:	88 70       	andi	r24, 0x08	; 8
     440:	00 00       	nop
     442:	f0 88       	ldd	r15, Z+16	; 0x10
     444:	f0 80       	ld	r15, Z
     446:	80 00       	.word	0x0080	; ????
     448:	00 68       	ori	r16, 0x80	; 128
     44a:	98 78       	andi	r25, 0x88	; 136
     44c:	08 08       	sbc	r0, r8
     44e:	00 00       	nop
     450:	b0 c8       	rjmp	.-3744   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     452:	80 80       	ld	r8, Z
     454:	80 00       	.word	0x0080	; ????
     456:	00 70       	andi	r16, 0x00	; 0
     458:	80 70       	andi	r24, 0x00	; 0
     45a:	08 f0       	brcs	.+2      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     45c:	40 40       	sbci	r20, 0x00	; 0
     45e:	e0 40       	sbci	r30, 0x00	; 0
     460:	40 48       	sbci	r20, 0x80	; 128
     462:	30 00       	.word	0x0030	; ????
     464:	00 88       	ldd	r0, Z+16	; 0x10
     466:	88 88       	ldd	r8, Y+16	; 0x10
     468:	98 68       	ori	r25, 0x88	; 136
     46a:	00 00       	nop
     46c:	88 88       	ldd	r8, Y+16	; 0x10
     46e:	88 50       	subi	r24, 0x08	; 8
     470:	20 00       	.word	0x0020	; ????
     472:	00 88       	ldd	r0, Z+16	; 0x10
     474:	88 a8       	ldd	r8, Y+48	; 0x30
     476:	a8 50       	subi	r26, 0x08	; 8
     478:	00 00       	nop
     47a:	88 50       	subi	r24, 0x08	; 8
     47c:	20 50       	subi	r18, 0x00	; 0
     47e:	88 00       	.word	0x0088	; ????
     480:	00 88       	ldd	r0, Z+16	; 0x10
     482:	88 78       	andi	r24, 0x88	; 136
     484:	08 70       	andi	r16, 0x08	; 8
     486:	00 00       	nop
     488:	f8 10       	cpse	r15, r8
     48a:	20 40       	sbci	r18, 0x00	; 0
     48c:	f8 10       	cpse	r15, r8
     48e:	20 20       	and	r2, r0
     490:	40 20       	and	r4, r0
     492:	20 10       	cpse	r2, r0
     494:	20 20       	and	r2, r0
     496:	20 20       	and	r2, r0
     498:	20 20       	and	r2, r0
     49a:	20 40       	sbci	r18, 0x00	; 0
     49c:	20 20       	and	r2, r0
     49e:	10 20       	and	r1, r0
     4a0:	20 40       	sbci	r18, 0x00	; 0

000004a2 <__ctors_end>:
     4a2:	11 24       	eor	r1, r1
     4a4:	1f be       	out	0x3f, r1	; 63
     4a6:	cf ef       	ldi	r28, 0xFF	; 255
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	df e5       	ldi	r29, 0x5F	; 95
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	00 e0       	ldi	r16, 0x00	; 0
     4b0:	0c bf       	out	0x3c, r16	; 60

000004b2 <__do_copy_data>:
     4b2:	10 e2       	ldi	r17, 0x20	; 32
     4b4:	a0 e0       	ldi	r26, 0x00	; 0
     4b6:	b0 e2       	ldi	r27, 0x20	; 32
     4b8:	e6 e3       	ldi	r30, 0x36	; 54
     4ba:	f5 e4       	ldi	r31, 0x45	; 69
     4bc:	00 e0       	ldi	r16, 0x00	; 0
     4be:	0b bf       	out	0x3b, r16	; 59
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__do_copy_data+0x14>
     4c2:	07 90       	elpm	r0, Z+
     4c4:	0d 92       	st	X+, r0
     4c6:	a2 35       	cpi	r26, 0x52	; 82
     4c8:	b1 07       	cpc	r27, r17
     4ca:	d9 f7       	brne	.-10     	; 0x4c2 <__do_copy_data+0x10>

000004cc <__do_clear_bss>:
     4cc:	23 e2       	ldi	r18, 0x23	; 35
     4ce:	a2 e5       	ldi	r26, 0x52	; 82
     4d0:	b0 e2       	ldi	r27, 0x20	; 32
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <.do_clear_bss_start>

000004d4 <.do_clear_bss_loop>:
     4d4:	1d 92       	st	X+, r1

000004d6 <.do_clear_bss_start>:
     4d6:	a5 32       	cpi	r26, 0x25	; 37
     4d8:	b2 07       	cpc	r27, r18
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <.do_clear_bss_loop>
     4dc:	0e 94 01 1e 	call	0x3c02	; 0x3c02 <main>
     4e0:	0c 94 99 22 	jmp	0x4532	; 0x4532 <_exit>

000004e4 <__bad_interrupt>:
     4e4:	8d cd       	rjmp	.-1254   	; 0x0 <__vectors>

000004e6 <__portable_avr_delay_cycles>:
 *
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
     4e6:	04 c0       	rjmp	.+8      	; 0x4f0 <__portable_avr_delay_cycles+0xa>
	while (n) {
		barrier();
		n--;
     4e8:	61 50       	subi	r22, 0x01	; 1
     4ea:	71 09       	sbc	r23, r1
     4ec:	81 09       	sbc	r24, r1
     4ee:	91 09       	sbc	r25, r1
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	while (n) {
     4f0:	61 15       	cp	r22, r1
     4f2:	71 05       	cpc	r23, r1
     4f4:	81 05       	cpc	r24, r1
     4f6:	91 05       	cpc	r25, r1
     4f8:	b9 f7       	brne	.-18     	; 0x4e8 <__portable_avr_delay_cycles+0x2>
     4fa:	08 95       	ret

000004fc <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     4fc:	bf 92       	push	r11
     4fe:	cf 92       	push	r12
     500:	df 92       	push	r13
     502:	ef 92       	push	r14
     504:	ff 92       	push	r15
     506:	0f 93       	push	r16
     508:	1f 93       	push	r17
     50a:	cf 93       	push	r28
     50c:	df 93       	push	r29
     50e:	1f 92       	push	r1
     510:	cd b7       	in	r28, 0x3d	; 61
     512:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     514:	00 e0       	ldi	r16, 0x00	; 0
     516:	16 e0       	ldi	r17, 0x06	; 6
     518:	68 94       	set
     51a:	ff 24       	eor	r15, r15
     51c:	f3 f8       	bld	r15, 3
     51e:	f8 01       	movw	r30, r16
     520:	f6 82       	std	Z+6, r15	; 0x06
 * function, this command will control the RST pin.
 */
static inline void st7565r_hard_reset(void)
{
	ioport_set_pin_low(ST7565R_RESET_PIN);
	delay_us(10);
     522:	64 e0       	ldi	r22, 0x04	; 4
     524:	70 e0       	ldi	r23, 0x00	; 0
     526:	80 e0       	ldi	r24, 0x00	; 0
     528:	90 e0       	ldi	r25, 0x00	; 0
     52a:	dd df       	rcall	.-70     	; 0x4e6 <__portable_avr_delay_cycles>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     52c:	f8 01       	movw	r30, r16
     52e:	f5 82       	std	Z+5, r15	; 0x05
	ioport_set_pin_high(ST7565R_RESET_PIN);
	delay_us(10);
     530:	64 e0       	ldi	r22, 0x04	; 4
     532:	70 e0       	ldi	r23, 0x00	; 0
     534:	80 e0       	ldi	r24, 0x00	; 0
     536:	90 e0       	ldi	r25, 0x00	; 0
     538:	d6 df       	rcall	.-84     	; 0x4e6 <__portable_avr_delay_cycles>
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     53a:	0f 2e       	mov	r0, r31
     53c:	fb e2       	ldi	r31, 0x2B	; 43
     53e:	bf 2e       	mov	r11, r31
     540:	f0 2d       	mov	r31, r0
     542:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     544:	80 ea       	ldi	r24, 0xA0	; 160
     546:	99 e0       	ldi	r25, 0x09	; 9
     548:	0e 94 c7 19 	call	0x338e	; 0x338e <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     54c:	c1 2c       	mov	r12, r1
     54e:	d1 2c       	mov	r13, r1
     550:	76 01       	movw	r14, r12
     552:	00 e4       	ldi	r16, 0x40	; 64
     554:	12 e4       	ldi	r17, 0x42	; 66
     556:	2f e0       	ldi	r18, 0x0F	; 15
     558:	30 e0       	ldi	r19, 0x00	; 0
     55a:	43 e0       	ldi	r20, 0x03	; 3
     55c:	be 01       	movw	r22, r28
     55e:	6f 5f       	subi	r22, 0xFF	; 255
     560:	7f 4f       	sbci	r23, 0xFF	; 255
     562:	80 ea       	ldi	r24, 0xA0	; 160
     564:	99 e0       	ldi	r25, 0x09	; 9
     566:	0e 94 f6 19 	call	0x33ec	; 0x33ec <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     56a:	00 e6       	ldi	r16, 0x60	; 96
     56c:	16 e0       	ldi	r17, 0x06	; 6
     56e:	ff 24       	eor	r15, r15
     570:	f3 94       	inc	r15
     572:	f8 01       	movw	r30, r16
     574:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     576:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     578:	be 01       	movw	r22, r28
     57a:	6f 5f       	subi	r22, 0xFF	; 255
     57c:	7f 4f       	sbci	r23, 0xFF	; 255
     57e:	80 ea       	ldi	r24, 0xA0	; 160
     580:	99 e0       	ldi	r25, 0x09	; 9
     582:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     586:	f8 01       	movw	r30, r16
     588:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     58a:	e0 ea       	ldi	r30, 0xA0	; 160
     58c:	f9 e0       	ldi	r31, 0x09	; 9
     58e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     590:	85 ff       	sbrs	r24, 5
     592:	fd cf       	rjmp	.-6      	; 0x58e <st7565r_init+0x92>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     594:	80 ea       	ldi	r24, 0xA0	; 160
     596:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     59a:	e0 ea       	ldi	r30, 0xA0	; 160
     59c:	f9 e0       	ldi	r31, 0x09	; 9
     59e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5a0:	86 ff       	sbrs	r24, 6
     5a2:	fd cf       	rjmp	.-6      	; 0x59e <st7565r_init+0xa2>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5a4:	e0 ea       	ldi	r30, 0xA0	; 160
     5a6:	f9 e0       	ldi	r31, 0x09	; 9
     5a8:	80 e4       	ldi	r24, 0x40	; 64
     5aa:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5ac:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5ae:	be 01       	movw	r22, r28
     5b0:	6f 5f       	subi	r22, 0xFF	; 255
     5b2:	7f 4f       	sbci	r23, 0xFF	; 255
     5b4:	80 ea       	ldi	r24, 0xA0	; 160
     5b6:	99 e0       	ldi	r25, 0x09	; 9
     5b8:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5bc:	8b e2       	ldi	r24, 0x2B	; 43
     5be:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5c0:	be 01       	movw	r22, r28
     5c2:	6f 5f       	subi	r22, 0xFF	; 255
     5c4:	7f 4f       	sbci	r23, 0xFF	; 255
     5c6:	80 ea       	ldi	r24, 0xA0	; 160
     5c8:	99 e0       	ldi	r25, 0x09	; 9
     5ca:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     5ce:	81 e0       	ldi	r24, 0x01	; 1
     5d0:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     5d4:	e0 ea       	ldi	r30, 0xA0	; 160
     5d6:	f9 e0       	ldi	r31, 0x09	; 9
     5d8:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5da:	85 ff       	sbrs	r24, 5
     5dc:	fd cf       	rjmp	.-6      	; 0x5d8 <st7565r_init+0xdc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5de:	86 ea       	ldi	r24, 0xA6	; 166
     5e0:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5e4:	e0 ea       	ldi	r30, 0xA0	; 160
     5e6:	f9 e0       	ldi	r31, 0x09	; 9
     5e8:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5ea:	86 ff       	sbrs	r24, 6
     5ec:	fd cf       	rjmp	.-6      	; 0x5e8 <st7565r_init+0xec>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5ee:	e0 ea       	ldi	r30, 0xA0	; 160
     5f0:	f9 e0       	ldi	r31, 0x09	; 9
     5f2:	80 e4       	ldi	r24, 0x40	; 64
     5f4:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5f6:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5f8:	be 01       	movw	r22, r28
     5fa:	6f 5f       	subi	r22, 0xFF	; 255
     5fc:	7f 4f       	sbci	r23, 0xFF	; 255
     5fe:	80 ea       	ldi	r24, 0xA0	; 160
     600:	99 e0       	ldi	r25, 0x09	; 9
     602:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     606:	8b e2       	ldi	r24, 0x2B	; 43
     608:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     60a:	be 01       	movw	r22, r28
     60c:	6f 5f       	subi	r22, 0xFF	; 255
     60e:	7f 4f       	sbci	r23, 0xFF	; 255
     610:	80 ea       	ldi	r24, 0xA0	; 160
     612:	99 e0       	ldi	r25, 0x09	; 9
     614:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     618:	81 e0       	ldi	r24, 0x01	; 1
     61a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     61e:	e0 ea       	ldi	r30, 0xA0	; 160
     620:	f9 e0       	ldi	r31, 0x09	; 9
     622:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     624:	85 ff       	sbrs	r24, 5
     626:	fd cf       	rjmp	.-6      	; 0x622 <st7565r_init+0x126>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     628:	88 ec       	ldi	r24, 0xC8	; 200
     62a:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     62e:	e0 ea       	ldi	r30, 0xA0	; 160
     630:	f9 e0       	ldi	r31, 0x09	; 9
     632:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     634:	86 ff       	sbrs	r24, 6
     636:	fd cf       	rjmp	.-6      	; 0x632 <st7565r_init+0x136>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     638:	e0 ea       	ldi	r30, 0xA0	; 160
     63a:	f9 e0       	ldi	r31, 0x09	; 9
     63c:	80 e4       	ldi	r24, 0x40	; 64
     63e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     640:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     642:	be 01       	movw	r22, r28
     644:	6f 5f       	subi	r22, 0xFF	; 255
     646:	7f 4f       	sbci	r23, 0xFF	; 255
     648:	80 ea       	ldi	r24, 0xA0	; 160
     64a:	99 e0       	ldi	r25, 0x09	; 9
     64c:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     650:	8b e2       	ldi	r24, 0x2B	; 43
     652:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     654:	be 01       	movw	r22, r28
     656:	6f 5f       	subi	r22, 0xFF	; 255
     658:	7f 4f       	sbci	r23, 0xFF	; 255
     65a:	80 ea       	ldi	r24, 0xA0	; 160
     65c:	99 e0       	ldi	r25, 0x09	; 9
     65e:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     662:	81 e0       	ldi	r24, 0x01	; 1
     664:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     668:	e0 ea       	ldi	r30, 0xA0	; 160
     66a:	f9 e0       	ldi	r31, 0x09	; 9
     66c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     66e:	85 ff       	sbrs	r24, 5
     670:	fd cf       	rjmp	.-6      	; 0x66c <st7565r_init+0x170>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     672:	82 ea       	ldi	r24, 0xA2	; 162
     674:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     678:	e0 ea       	ldi	r30, 0xA0	; 160
     67a:	f9 e0       	ldi	r31, 0x09	; 9
     67c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     67e:	86 ff       	sbrs	r24, 6
     680:	fd cf       	rjmp	.-6      	; 0x67c <st7565r_init+0x180>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     682:	e0 ea       	ldi	r30, 0xA0	; 160
     684:	f9 e0       	ldi	r31, 0x09	; 9
     686:	80 e4       	ldi	r24, 0x40	; 64
     688:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     68a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     68c:	be 01       	movw	r22, r28
     68e:	6f 5f       	subi	r22, 0xFF	; 255
     690:	7f 4f       	sbci	r23, 0xFF	; 255
     692:	80 ea       	ldi	r24, 0xA0	; 160
     694:	99 e0       	ldi	r25, 0x09	; 9
     696:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     69a:	8b e2       	ldi	r24, 0x2B	; 43
     69c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     69e:	be 01       	movw	r22, r28
     6a0:	6f 5f       	subi	r22, 0xFF	; 255
     6a2:	7f 4f       	sbci	r23, 0xFF	; 255
     6a4:	80 ea       	ldi	r24, 0xA0	; 160
     6a6:	99 e0       	ldi	r25, 0x09	; 9
     6a8:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     6ac:	81 e0       	ldi	r24, 0x01	; 1
     6ae:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6b2:	e0 ea       	ldi	r30, 0xA0	; 160
     6b4:	f9 e0       	ldi	r31, 0x09	; 9
     6b6:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6b8:	85 ff       	sbrs	r24, 5
     6ba:	fd cf       	rjmp	.-6      	; 0x6b6 <st7565r_init+0x1ba>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6bc:	8f e2       	ldi	r24, 0x2F	; 47
     6be:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6c2:	e0 ea       	ldi	r30, 0xA0	; 160
     6c4:	f9 e0       	ldi	r31, 0x09	; 9
     6c6:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6c8:	86 ff       	sbrs	r24, 6
     6ca:	fd cf       	rjmp	.-6      	; 0x6c6 <st7565r_init+0x1ca>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6cc:	e0 ea       	ldi	r30, 0xA0	; 160
     6ce:	f9 e0       	ldi	r31, 0x09	; 9
     6d0:	80 e4       	ldi	r24, 0x40	; 64
     6d2:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6d4:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6d6:	be 01       	movw	r22, r28
     6d8:	6f 5f       	subi	r22, 0xFF	; 255
     6da:	7f 4f       	sbci	r23, 0xFF	; 255
     6dc:	80 ea       	ldi	r24, 0xA0	; 160
     6de:	99 e0       	ldi	r25, 0x09	; 9
     6e0:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6e4:	8b e2       	ldi	r24, 0x2B	; 43
     6e6:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6e8:	be 01       	movw	r22, r28
     6ea:	6f 5f       	subi	r22, 0xFF	; 255
     6ec:	7f 4f       	sbci	r23, 0xFF	; 255
     6ee:	80 ea       	ldi	r24, 0xA0	; 160
     6f0:	99 e0       	ldi	r25, 0x09	; 9
     6f2:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     6f6:	81 e0       	ldi	r24, 0x01	; 1
     6f8:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6fc:	e0 ea       	ldi	r30, 0xA0	; 160
     6fe:	f9 e0       	ldi	r31, 0x09	; 9
     700:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     702:	85 ff       	sbrs	r24, 5
     704:	fd cf       	rjmp	.-6      	; 0x700 <st7565r_init+0x204>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     706:	88 ef       	ldi	r24, 0xF8	; 248
     708:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     70c:	e0 ea       	ldi	r30, 0xA0	; 160
     70e:	f9 e0       	ldi	r31, 0x09	; 9
     710:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     712:	86 ff       	sbrs	r24, 6
     714:	fd cf       	rjmp	.-6      	; 0x710 <st7565r_init+0x214>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     716:	e0 ea       	ldi	r30, 0xA0	; 160
     718:	f9 e0       	ldi	r31, 0x09	; 9
     71a:	80 e4       	ldi	r24, 0x40	; 64
     71c:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     71e:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     720:	be 01       	movw	r22, r28
     722:	6f 5f       	subi	r22, 0xFF	; 255
     724:	7f 4f       	sbci	r23, 0xFF	; 255
     726:	80 ea       	ldi	r24, 0xA0	; 160
     728:	99 e0       	ldi	r25, 0x09	; 9
     72a:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     72e:	8b e2       	ldi	r24, 0x2B	; 43
     730:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     732:	be 01       	movw	r22, r28
     734:	6f 5f       	subi	r22, 0xFF	; 255
     736:	7f 4f       	sbci	r23, 0xFF	; 255
     738:	80 ea       	ldi	r24, 0xA0	; 160
     73a:	99 e0       	ldi	r25, 0x09	; 9
     73c:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     740:	81 e0       	ldi	r24, 0x01	; 1
     742:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     746:	e0 ea       	ldi	r30, 0xA0	; 160
     748:	f9 e0       	ldi	r31, 0x09	; 9
     74a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     74c:	85 ff       	sbrs	r24, 5
     74e:	fd cf       	rjmp	.-6      	; 0x74a <st7565r_init+0x24e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     750:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     754:	e0 ea       	ldi	r30, 0xA0	; 160
     756:	f9 e0       	ldi	r31, 0x09	; 9
     758:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     75a:	86 ff       	sbrs	r24, 6
     75c:	fd cf       	rjmp	.-6      	; 0x758 <st7565r_init+0x25c>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     75e:	e0 ea       	ldi	r30, 0xA0	; 160
     760:	f9 e0       	ldi	r31, 0x09	; 9
     762:	80 e4       	ldi	r24, 0x40	; 64
     764:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     766:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     768:	be 01       	movw	r22, r28
     76a:	6f 5f       	subi	r22, 0xFF	; 255
     76c:	7f 4f       	sbci	r23, 0xFF	; 255
     76e:	80 ea       	ldi	r24, 0xA0	; 160
     770:	99 e0       	ldi	r25, 0x09	; 9
     772:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     776:	8b e2       	ldi	r24, 0x2B	; 43
     778:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     77a:	be 01       	movw	r22, r28
     77c:	6f 5f       	subi	r22, 0xFF	; 255
     77e:	7f 4f       	sbci	r23, 0xFF	; 255
     780:	80 ea       	ldi	r24, 0xA0	; 160
     782:	99 e0       	ldi	r25, 0x09	; 9
     784:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     788:	81 e0       	ldi	r24, 0x01	; 1
     78a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     78e:	e0 ea       	ldi	r30, 0xA0	; 160
     790:	f9 e0       	ldi	r31, 0x09	; 9
     792:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     794:	85 ff       	sbrs	r24, 5
     796:	fd cf       	rjmp	.-6      	; 0x792 <st7565r_init+0x296>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     798:	81 e2       	ldi	r24, 0x21	; 33
     79a:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     79e:	e0 ea       	ldi	r30, 0xA0	; 160
     7a0:	f9 e0       	ldi	r31, 0x09	; 9
     7a2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7a4:	86 ff       	sbrs	r24, 6
     7a6:	fd cf       	rjmp	.-6      	; 0x7a2 <st7565r_init+0x2a6>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7a8:	e0 ea       	ldi	r30, 0xA0	; 160
     7aa:	f9 e0       	ldi	r31, 0x09	; 9
     7ac:	80 e4       	ldi	r24, 0x40	; 64
     7ae:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7b0:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7b2:	be 01       	movw	r22, r28
     7b4:	6f 5f       	subi	r22, 0xFF	; 255
     7b6:	7f 4f       	sbci	r23, 0xFF	; 255
     7b8:	80 ea       	ldi	r24, 0xA0	; 160
     7ba:	99 e0       	ldi	r25, 0x09	; 9
     7bc:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7c0:	8b e2       	ldi	r24, 0x2B	; 43
     7c2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7c4:	be 01       	movw	r22, r28
     7c6:	6f 5f       	subi	r22, 0xFF	; 255
     7c8:	7f 4f       	sbci	r23, 0xFF	; 255
     7ca:	80 ea       	ldi	r24, 0xA0	; 160
     7cc:	99 e0       	ldi	r25, 0x09	; 9
     7ce:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     7d2:	81 e0       	ldi	r24, 0x01	; 1
     7d4:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7d8:	e0 ea       	ldi	r30, 0xA0	; 160
     7da:	f9 e0       	ldi	r31, 0x09	; 9
     7dc:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7de:	85 ff       	sbrs	r24, 5
     7e0:	fd cf       	rjmp	.-6      	; 0x7dc <st7565r_init+0x2e0>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7e2:	81 e8       	ldi	r24, 0x81	; 129
     7e4:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7e8:	e0 ea       	ldi	r30, 0xA0	; 160
     7ea:	f9 e0       	ldi	r31, 0x09	; 9
     7ec:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7ee:	86 ff       	sbrs	r24, 6
     7f0:	fd cf       	rjmp	.-6      	; 0x7ec <st7565r_init+0x2f0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7f2:	e0 ea       	ldi	r30, 0xA0	; 160
     7f4:	f9 e0       	ldi	r31, 0x09	; 9
     7f6:	80 e4       	ldi	r24, 0x40	; 64
     7f8:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7fa:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7fc:	be 01       	movw	r22, r28
     7fe:	6f 5f       	subi	r22, 0xFF	; 255
     800:	7f 4f       	sbci	r23, 0xFF	; 255
     802:	80 ea       	ldi	r24, 0xA0	; 160
     804:	99 e0       	ldi	r25, 0x09	; 9
     806:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     80a:	8b e2       	ldi	r24, 0x2B	; 43
     80c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     80e:	be 01       	movw	r22, r28
     810:	6f 5f       	subi	r22, 0xFF	; 255
     812:	7f 4f       	sbci	r23, 0xFF	; 255
     814:	80 ea       	ldi	r24, 0xA0	; 160
     816:	99 e0       	ldi	r25, 0x09	; 9
     818:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     81c:	81 e0       	ldi	r24, 0x01	; 1
     81e:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     822:	e0 ea       	ldi	r30, 0xA0	; 160
     824:	f9 e0       	ldi	r31, 0x09	; 9
     826:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     828:	85 ff       	sbrs	r24, 5
     82a:	fd cf       	rjmp	.-6      	; 0x826 <st7565r_init+0x32a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     82c:	81 e2       	ldi	r24, 0x21	; 33
     82e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     832:	e0 ea       	ldi	r30, 0xA0	; 160
     834:	f9 e0       	ldi	r31, 0x09	; 9
     836:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     838:	86 ff       	sbrs	r24, 6
     83a:	fd cf       	rjmp	.-6      	; 0x836 <st7565r_init+0x33a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     83c:	e0 ea       	ldi	r30, 0xA0	; 160
     83e:	f9 e0       	ldi	r31, 0x09	; 9
     840:	80 e4       	ldi	r24, 0x40	; 64
     842:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     844:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     846:	be 01       	movw	r22, r28
     848:	6f 5f       	subi	r22, 0xFF	; 255
     84a:	7f 4f       	sbci	r23, 0xFF	; 255
     84c:	80 ea       	ldi	r24, 0xA0	; 160
     84e:	99 e0       	ldi	r25, 0x09	; 9
     850:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     854:	8b e2       	ldi	r24, 0x2B	; 43
     856:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     858:	be 01       	movw	r22, r28
     85a:	6f 5f       	subi	r22, 0xFF	; 255
     85c:	7f 4f       	sbci	r23, 0xFF	; 255
     85e:	80 ea       	ldi	r24, 0xA0	; 160
     860:	99 e0       	ldi	r25, 0x09	; 9
     862:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     866:	81 e0       	ldi	r24, 0x01	; 1
     868:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     86c:	e0 ea       	ldi	r30, 0xA0	; 160
     86e:	f9 e0       	ldi	r31, 0x09	; 9
     870:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     872:	85 ff       	sbrs	r24, 5
     874:	fd cf       	rjmp	.-6      	; 0x870 <st7565r_init+0x374>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     876:	8f ea       	ldi	r24, 0xAF	; 175
     878:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     87c:	e0 ea       	ldi	r30, 0xA0	; 160
     87e:	f9 e0       	ldi	r31, 0x09	; 9
     880:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     882:	86 ff       	sbrs	r24, 6
     884:	fd cf       	rjmp	.-6      	; 0x880 <st7565r_init+0x384>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     886:	e0 ea       	ldi	r30, 0xA0	; 160
     888:	f9 e0       	ldi	r31, 0x09	; 9
     88a:	80 e4       	ldi	r24, 0x40	; 64
     88c:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     88e:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     890:	be 01       	movw	r22, r28
     892:	6f 5f       	subi	r22, 0xFF	; 255
     894:	7f 4f       	sbci	r23, 0xFF	; 255
     896:	80 ea       	ldi	r24, 0xA0	; 160
     898:	99 e0       	ldi	r25, 0x09	; 9
     89a:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     89e:	0f 90       	pop	r0
     8a0:	df 91       	pop	r29
     8a2:	cf 91       	pop	r28
     8a4:	1f 91       	pop	r17
     8a6:	0f 91       	pop	r16
     8a8:	ff 90       	pop	r15
     8aa:	ef 90       	pop	r14
     8ac:	df 90       	pop	r13
     8ae:	cf 90       	pop	r12
     8b0:	bf 90       	pop	r11
     8b2:	08 95       	ret

000008b4 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     8b4:	ff 92       	push	r15
     8b6:	0f 93       	push	r16
     8b8:	1f 93       	push	r17
     8ba:	cf 93       	push	r28
     8bc:	df 93       	push	r29
     8be:	1f 92       	push	r1
     8c0:	cd b7       	in	r28, 0x3d	; 61
     8c2:	de b7       	in	r29, 0x3e	; 62
     8c4:	08 2f       	mov	r16, r24
     8c6:	f6 2e       	mov	r15, r22
     8c8:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     8ca:	0e 94 42 1a 	call	0x3484	; 0x3484 <gfx_mono_framebuffer_put_byte>
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     8ce:	0f 70       	andi	r16, 0x0F	; 15
     8d0:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     8d2:	8b e2       	ldi	r24, 0x2B	; 43
     8d4:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8d6:	be 01       	movw	r22, r28
     8d8:	6f 5f       	subi	r22, 0xFF	; 255
     8da:	7f 4f       	sbci	r23, 0xFF	; 255
     8dc:	80 ea       	ldi	r24, 0xA0	; 160
     8de:	99 e0       	ldi	r25, 0x09	; 9
     8e0:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     8e4:	81 e0       	ldi	r24, 0x01	; 1
     8e6:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     8ea:	e0 ea       	ldi	r30, 0xA0	; 160
     8ec:	f9 e0       	ldi	r31, 0x09	; 9
     8ee:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     8f0:	95 ff       	sbrs	r25, 5
     8f2:	fd cf       	rjmp	.-6      	; 0x8ee <gfx_mono_st7565r_put_byte+0x3a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     8f4:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     8f8:	e0 ea       	ldi	r30, 0xA0	; 160
     8fa:	f9 e0       	ldi	r31, 0x09	; 9
     8fc:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     8fe:	86 ff       	sbrs	r24, 6
     900:	fd cf       	rjmp	.-6      	; 0x8fc <gfx_mono_st7565r_put_byte+0x48>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     902:	e0 ea       	ldi	r30, 0xA0	; 160
     904:	f9 e0       	ldi	r31, 0x09	; 9
     906:	80 e4       	ldi	r24, 0x40	; 64
     908:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     90a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     90c:	be 01       	movw	r22, r28
     90e:	6f 5f       	subi	r22, 0xFF	; 255
     910:	7f 4f       	sbci	r23, 0xFF	; 255
     912:	80 ea       	ldi	r24, 0xA0	; 160
     914:	99 e0       	ldi	r25, 0x09	; 9
     916:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     91a:	0f 2d       	mov	r16, r15
     91c:	0f 77       	andi	r16, 0x7F	; 127
     91e:	02 95       	swap	r16
     920:	0f 70       	andi	r16, 0x0F	; 15
     922:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     924:	8b e2       	ldi	r24, 0x2B	; 43
     926:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     928:	be 01       	movw	r22, r28
     92a:	6f 5f       	subi	r22, 0xFF	; 255
     92c:	7f 4f       	sbci	r23, 0xFF	; 255
     92e:	80 ea       	ldi	r24, 0xA0	; 160
     930:	99 e0       	ldi	r25, 0x09	; 9
     932:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     936:	81 e0       	ldi	r24, 0x01	; 1
     938:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     93c:	e0 ea       	ldi	r30, 0xA0	; 160
     93e:	f9 e0       	ldi	r31, 0x09	; 9
     940:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     942:	85 ff       	sbrs	r24, 5
     944:	fd cf       	rjmp	.-6      	; 0x940 <gfx_mono_st7565r_put_byte+0x8c>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     946:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     94a:	e0 ea       	ldi	r30, 0xA0	; 160
     94c:	f9 e0       	ldi	r31, 0x09	; 9
     94e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     950:	86 ff       	sbrs	r24, 6
     952:	fd cf       	rjmp	.-6      	; 0x94e <gfx_mono_st7565r_put_byte+0x9a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     954:	e0 ea       	ldi	r30, 0xA0	; 160
     956:	f9 e0       	ldi	r31, 0x09	; 9
     958:	80 e4       	ldi	r24, 0x40	; 64
     95a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     95c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     95e:	be 01       	movw	r22, r28
     960:	6f 5f       	subi	r22, 0xFF	; 255
     962:	7f 4f       	sbci	r23, 0xFF	; 255
     964:	80 ea       	ldi	r24, 0xA0	; 160
     966:	99 e0       	ldi	r25, 0x09	; 9
     968:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     96c:	0f 2d       	mov	r16, r15
     96e:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     970:	8b e2       	ldi	r24, 0x2B	; 43
     972:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     974:	be 01       	movw	r22, r28
     976:	6f 5f       	subi	r22, 0xFF	; 255
     978:	7f 4f       	sbci	r23, 0xFF	; 255
     97a:	80 ea       	ldi	r24, 0xA0	; 160
     97c:	99 e0       	ldi	r25, 0x09	; 9
     97e:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     988:	e0 ea       	ldi	r30, 0xA0	; 160
     98a:	f9 e0       	ldi	r31, 0x09	; 9
     98c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     98e:	85 ff       	sbrs	r24, 5
     990:	fd cf       	rjmp	.-6      	; 0x98c <gfx_mono_st7565r_put_byte+0xd8>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     992:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     996:	e0 ea       	ldi	r30, 0xA0	; 160
     998:	f9 e0       	ldi	r31, 0x09	; 9
     99a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     99c:	86 ff       	sbrs	r24, 6
     99e:	fd cf       	rjmp	.-6      	; 0x99a <gfx_mono_st7565r_put_byte+0xe6>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9a0:	e0 ea       	ldi	r30, 0xA0	; 160
     9a2:	f9 e0       	ldi	r31, 0x09	; 9
     9a4:	80 e4       	ldi	r24, 0x40	; 64
     9a6:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9a8:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9aa:	be 01       	movw	r22, r28
     9ac:	6f 5f       	subi	r22, 0xFF	; 255
     9ae:	7f 4f       	sbci	r23, 0xFF	; 255
     9b0:	80 ea       	ldi	r24, 0xA0	; 160
     9b2:	99 e0       	ldi	r25, 0x09	; 9
     9b4:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9b8:	8b e2       	ldi	r24, 0x2B	; 43
     9ba:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9bc:	be 01       	movw	r22, r28
     9be:	6f 5f       	subi	r22, 0xFF	; 255
     9c0:	7f 4f       	sbci	r23, 0xFF	; 255
     9c2:	80 ea       	ldi	r24, 0xA0	; 160
     9c4:	99 e0       	ldi	r25, 0x09	; 9
     9c6:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     9ca:	81 e0       	ldi	r24, 0x01	; 1
     9cc:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9d0:	e0 ea       	ldi	r30, 0xA0	; 160
     9d2:	f9 e0       	ldi	r31, 0x09	; 9
     9d4:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     9d6:	85 ff       	sbrs	r24, 5
     9d8:	fd cf       	rjmp	.-6      	; 0x9d4 <gfx_mono_st7565r_put_byte+0x120>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     9da:	10 93 a0 09 	sts	0x09A0, r17	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     9de:	e0 ea       	ldi	r30, 0xA0	; 160
     9e0:	f9 e0       	ldi	r31, 0x09	; 9
     9e2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9e4:	86 ff       	sbrs	r24, 6
     9e6:	fd cf       	rjmp	.-6      	; 0x9e2 <gfx_mono_st7565r_put_byte+0x12e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9e8:	e0 ea       	ldi	r30, 0xA0	; 160
     9ea:	f9 e0       	ldi	r31, 0x09	; 9
     9ec:	80 e4       	ldi	r24, 0x40	; 64
     9ee:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9f0:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     9f2:	81 e0       	ldi	r24, 0x01	; 1
     9f4:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9f8:	be 01       	movw	r22, r28
     9fa:	6f 5f       	subi	r22, 0xFF	; 255
     9fc:	7f 4f       	sbci	r23, 0xFF	; 255
     9fe:	80 ea       	ldi	r24, 0xA0	; 160
     a00:	99 e0       	ldi	r25, 0x09	; 9
     a02:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     a06:	0f 90       	pop	r0
     a08:	df 91       	pop	r29
     a0a:	cf 91       	pop	r28
     a0c:	1f 91       	pop	r17
     a0e:	0f 91       	pop	r16
     a10:	ff 90       	pop	r15
     a12:	08 95       	ret

00000a14 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a14:	0f 93       	push	r16
     a16:	1f 93       	push	r17
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
     a1c:	1f 92       	push	r1
     a1e:	cd b7       	in	r28, 0x3d	; 61
     a20:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     a22:	82 e5       	ldi	r24, 0x52	; 82
     a24:	90 e2       	ldi	r25, 0x20	; 32
     a26:	0e 94 3d 1a 	call	0x347a	; 0x347a <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     a2a:	68 dd       	rcall	.-1328   	; 0x4fc <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     a2c:	8b e2       	ldi	r24, 0x2B	; 43
     a2e:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     a30:	be 01       	movw	r22, r28
     a32:	6f 5f       	subi	r22, 0xFF	; 255
     a34:	7f 4f       	sbci	r23, 0xFF	; 255
     a36:	80 ea       	ldi	r24, 0xA0	; 160
     a38:	99 e0       	ldi	r25, 0x09	; 9
     a3a:	0e 94 11 1a 	call	0x3422	; 0x3422 <usart_spi_select_device>
     a3e:	81 e0       	ldi	r24, 0x01	; 1
     a40:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     a44:	e0 ea       	ldi	r30, 0xA0	; 160
     a46:	f9 e0       	ldi	r31, 0x09	; 9
     a48:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a4a:	85 ff       	sbrs	r24, 5
     a4c:	fd cf       	rjmp	.-6      	; 0xa48 <gfx_mono_st7565r_init+0x34>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a4e:	80 e4       	ldi	r24, 0x40	; 64
     a50:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a54:	e0 ea       	ldi	r30, 0xA0	; 160
     a56:	f9 e0       	ldi	r31, 0x09	; 9
     a58:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a5a:	86 ff       	sbrs	r24, 6
     a5c:	fd cf       	rjmp	.-6      	; 0xa58 <gfx_mono_st7565r_init+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a5e:	e0 ea       	ldi	r30, 0xA0	; 160
     a60:	f9 e0       	ldi	r31, 0x09	; 9
     a62:	80 e4       	ldi	r24, 0x40	; 64
     a64:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a66:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a68:	be 01       	movw	r22, r28
     a6a:	6f 5f       	subi	r22, 0xFF	; 255
     a6c:	7f 4f       	sbci	r23, 0xFF	; 255
     a6e:	80 ea       	ldi	r24, 0xA0	; 160
     a70:	99 e0       	ldi	r25, 0x09	; 9
     a72:	0e 94 27 1a 	call	0x344e	; 0x344e <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a76:	00 e0       	ldi	r16, 0x00	; 0
     a78:	0a c0       	rjmp	.+20     	; 0xa8e <gfx_mono_st7565r_init+0x7a>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     a7a:	40 e0       	ldi	r20, 0x00	; 0
     a7c:	61 2f       	mov	r22, r17
     a7e:	80 2f       	mov	r24, r16
     a80:	19 df       	rcall	.-462    	; 0x8b4 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     a82:	1f 5f       	subi	r17, 0xFF	; 255
     a84:	10 38       	cpi	r17, 0x80	; 128
     a86:	c9 f7       	brne	.-14     	; 0xa7a <gfx_mono_st7565r_init+0x66>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a88:	0f 5f       	subi	r16, 0xFF	; 255
     a8a:	04 30       	cpi	r16, 0x04	; 4
     a8c:	11 f0       	breq	.+4      	; 0xa92 <gfx_mono_st7565r_init+0x7e>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a8e:	10 e0       	ldi	r17, 0x00	; 0
     a90:	f4 cf       	rjmp	.-24     	; 0xa7a <gfx_mono_st7565r_init+0x66>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     a92:	0f 90       	pop	r0
     a94:	df 91       	pop	r29
     a96:	cf 91       	pop	r28
     a98:	1f 91       	pop	r17
     a9a:	0f 91       	pop	r16
     a9c:	08 95       	ret

00000a9e <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     a9e:	ff 92       	push	r15
     aa0:	0f 93       	push	r16
     aa2:	1f 93       	push	r17
     aa4:	cf 93       	push	r28
     aa6:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     aa8:	88 23       	and	r24, r24
     aaa:	54 f1       	brlt	.+84     	; 0xb00 <gfx_mono_st7565r_draw_pixel+0x62>
     aac:	60 32       	cpi	r22, 0x20	; 32
     aae:	40 f5       	brcc	.+80     	; 0xb00 <gfx_mono_st7565r_draw_pixel+0x62>
     ab0:	d4 2f       	mov	r29, r20
     ab2:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     ab4:	f6 2e       	mov	r15, r22
     ab6:	f6 94       	lsr	r15
     ab8:	f6 94       	lsr	r15
     aba:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     abc:	70 e0       	ldi	r23, 0x00	; 0
     abe:	88 e0       	ldi	r24, 0x08	; 8
     ac0:	f8 9e       	mul	r15, r24
     ac2:	60 19       	sub	r22, r0
     ac4:	71 09       	sbc	r23, r1
     ac6:	11 24       	eor	r1, r1
     ac8:	81 e0       	ldi	r24, 0x01	; 1
     aca:	90 e0       	ldi	r25, 0x00	; 0
     acc:	8c 01       	movw	r16, r24
     ace:	02 c0       	rjmp	.+4      	; 0xad4 <gfx_mono_st7565r_draw_pixel+0x36>
     ad0:	00 0f       	add	r16, r16
     ad2:	11 1f       	adc	r17, r17
     ad4:	6a 95       	dec	r22
     ad6:	e2 f7       	brpl	.-8      	; 0xad0 <gfx_mono_st7565r_draw_pixel+0x32>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     ad8:	6c 2f       	mov	r22, r28
     ada:	8f 2d       	mov	r24, r15
     adc:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     ae0:	d1 30       	cpi	r29, 0x01	; 1
     ae2:	21 f0       	breq	.+8      	; 0xaec <gfx_mono_st7565r_draw_pixel+0x4e>
     ae4:	28 f0       	brcs	.+10     	; 0xaf0 <gfx_mono_st7565r_draw_pixel+0x52>
     ae6:	d2 30       	cpi	r29, 0x02	; 2
     ae8:	31 f0       	breq	.+12     	; 0xaf6 <gfx_mono_st7565r_draw_pixel+0x58>
     aea:	06 c0       	rjmp	.+12     	; 0xaf8 <gfx_mono_st7565r_draw_pixel+0x5a>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     aec:	80 2b       	or	r24, r16
		break;
     aee:	04 c0       	rjmp	.+8      	; 0xaf8 <gfx_mono_st7565r_draw_pixel+0x5a>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     af0:	00 95       	com	r16
     af2:	80 23       	and	r24, r16
		break;
     af4:	01 c0       	rjmp	.+2      	; 0xaf8 <gfx_mono_st7565r_draw_pixel+0x5a>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     af6:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     af8:	48 2f       	mov	r20, r24
     afa:	6c 2f       	mov	r22, r28
     afc:	8f 2d       	mov	r24, r15
     afe:	da de       	rcall	.-588    	; 0x8b4 <gfx_mono_st7565r_put_byte>
}
     b00:	df 91       	pop	r29
     b02:	cf 91       	pop	r28
     b04:	1f 91       	pop	r17
     b06:	0f 91       	pop	r16
     b08:	ff 90       	pop	r15
     b0a:	08 95       	ret

00000b0c <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     b0c:	0c 94 50 1a 	jmp	0x34a0	; 0x34a0 <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
     b10:	08 95       	ret

00000b12 <__vector_15>:
	{
		cpu_irq_restore(iflags);
		return;
	}
	cpu_irq_restore(iflags);
}
     b12:	1f 92       	push	r1
     b14:	0f 92       	push	r0
     b16:	0f b6       	in	r0, 0x3f	; 63
     b18:	0f 92       	push	r0
     b1a:	11 24       	eor	r1, r1
     b1c:	0b b6       	in	r0, 0x3b	; 59
     b1e:	0f 92       	push	r0
     b20:	2f 93       	push	r18
     b22:	3f 93       	push	r19
     b24:	4f 93       	push	r20
     b26:	5f 93       	push	r21
     b28:	6f 93       	push	r22
     b2a:	7f 93       	push	r23
     b2c:	8f 93       	push	r24
     b2e:	9f 93       	push	r25
     b30:	af 93       	push	r26
     b32:	bf 93       	push	r27
     b34:	ef 93       	push	r30
     b36:	ff 93       	push	r31
     b38:	e0 91 96 22 	lds	r30, 0x2296	; 0x802296 <tc_tcc0_err_callback>
     b3c:	f0 91 97 22 	lds	r31, 0x2297	; 0x802297 <tc_tcc0_err_callback+0x1>
     b40:	30 97       	sbiw	r30, 0x00	; 0
     b42:	09 f0       	breq	.+2      	; 0xb46 <__vector_15+0x34>
     b44:	19 95       	eicall
     b46:	ff 91       	pop	r31
     b48:	ef 91       	pop	r30
     b4a:	bf 91       	pop	r27
     b4c:	af 91       	pop	r26
     b4e:	9f 91       	pop	r25
     b50:	8f 91       	pop	r24
     b52:	7f 91       	pop	r23
     b54:	6f 91       	pop	r22
     b56:	5f 91       	pop	r21
     b58:	4f 91       	pop	r20
     b5a:	3f 91       	pop	r19
     b5c:	2f 91       	pop	r18
     b5e:	0f 90       	pop	r0
     b60:	0b be       	out	0x3b, r0	; 59
     b62:	0f 90       	pop	r0
     b64:	0f be       	out	0x3f, r0	; 63
     b66:	0f 90       	pop	r0
     b68:	1f 90       	pop	r1
     b6a:	18 95       	reti

00000b6c <__vector_16>:
     b6c:	1f 92       	push	r1
     b6e:	0f 92       	push	r0
     b70:	0f b6       	in	r0, 0x3f	; 63
     b72:	0f 92       	push	r0
     b74:	11 24       	eor	r1, r1
     b76:	0b b6       	in	r0, 0x3b	; 59
     b78:	0f 92       	push	r0
     b7a:	2f 93       	push	r18
     b7c:	3f 93       	push	r19
     b7e:	4f 93       	push	r20
     b80:	5f 93       	push	r21
     b82:	6f 93       	push	r22
     b84:	7f 93       	push	r23
     b86:	8f 93       	push	r24
     b88:	9f 93       	push	r25
     b8a:	af 93       	push	r26
     b8c:	bf 93       	push	r27
     b8e:	ef 93       	push	r30
     b90:	ff 93       	push	r31
     b92:	e0 91 94 22 	lds	r30, 0x2294	; 0x802294 <tc_tcc0_cca_callback>
     b96:	f0 91 95 22 	lds	r31, 0x2295	; 0x802295 <tc_tcc0_cca_callback+0x1>
     b9a:	30 97       	sbiw	r30, 0x00	; 0
     b9c:	09 f0       	breq	.+2      	; 0xba0 <__vector_16+0x34>
     b9e:	19 95       	eicall
     ba0:	ff 91       	pop	r31
     ba2:	ef 91       	pop	r30
     ba4:	bf 91       	pop	r27
     ba6:	af 91       	pop	r26
     ba8:	9f 91       	pop	r25
     baa:	8f 91       	pop	r24
     bac:	7f 91       	pop	r23
     bae:	6f 91       	pop	r22
     bb0:	5f 91       	pop	r21
     bb2:	4f 91       	pop	r20
     bb4:	3f 91       	pop	r19
     bb6:	2f 91       	pop	r18
     bb8:	0f 90       	pop	r0
     bba:	0b be       	out	0x3b, r0	; 59
     bbc:	0f 90       	pop	r0
     bbe:	0f be       	out	0x3f, r0	; 63
     bc0:	0f 90       	pop	r0
     bc2:	1f 90       	pop	r1
     bc4:	18 95       	reti

00000bc6 <__vector_17>:
     bc6:	1f 92       	push	r1
     bc8:	0f 92       	push	r0
     bca:	0f b6       	in	r0, 0x3f	; 63
     bcc:	0f 92       	push	r0
     bce:	11 24       	eor	r1, r1
     bd0:	0b b6       	in	r0, 0x3b	; 59
     bd2:	0f 92       	push	r0
     bd4:	2f 93       	push	r18
     bd6:	3f 93       	push	r19
     bd8:	4f 93       	push	r20
     bda:	5f 93       	push	r21
     bdc:	6f 93       	push	r22
     bde:	7f 93       	push	r23
     be0:	8f 93       	push	r24
     be2:	9f 93       	push	r25
     be4:	af 93       	push	r26
     be6:	bf 93       	push	r27
     be8:	ef 93       	push	r30
     bea:	ff 93       	push	r31
     bec:	e0 91 92 22 	lds	r30, 0x2292	; 0x802292 <tc_tcc0_ccb_callback>
     bf0:	f0 91 93 22 	lds	r31, 0x2293	; 0x802293 <tc_tcc0_ccb_callback+0x1>
     bf4:	30 97       	sbiw	r30, 0x00	; 0
     bf6:	09 f0       	breq	.+2      	; 0xbfa <__vector_17+0x34>
     bf8:	19 95       	eicall
     bfa:	ff 91       	pop	r31
     bfc:	ef 91       	pop	r30
     bfe:	bf 91       	pop	r27
     c00:	af 91       	pop	r26
     c02:	9f 91       	pop	r25
     c04:	8f 91       	pop	r24
     c06:	7f 91       	pop	r23
     c08:	6f 91       	pop	r22
     c0a:	5f 91       	pop	r21
     c0c:	4f 91       	pop	r20
     c0e:	3f 91       	pop	r19
     c10:	2f 91       	pop	r18
     c12:	0f 90       	pop	r0
     c14:	0b be       	out	0x3b, r0	; 59
     c16:	0f 90       	pop	r0
     c18:	0f be       	out	0x3f, r0	; 63
     c1a:	0f 90       	pop	r0
     c1c:	1f 90       	pop	r1
     c1e:	18 95       	reti

00000c20 <__vector_18>:
     c20:	1f 92       	push	r1
     c22:	0f 92       	push	r0
     c24:	0f b6       	in	r0, 0x3f	; 63
     c26:	0f 92       	push	r0
     c28:	11 24       	eor	r1, r1
     c2a:	0b b6       	in	r0, 0x3b	; 59
     c2c:	0f 92       	push	r0
     c2e:	2f 93       	push	r18
     c30:	3f 93       	push	r19
     c32:	4f 93       	push	r20
     c34:	5f 93       	push	r21
     c36:	6f 93       	push	r22
     c38:	7f 93       	push	r23
     c3a:	8f 93       	push	r24
     c3c:	9f 93       	push	r25
     c3e:	af 93       	push	r26
     c40:	bf 93       	push	r27
     c42:	ef 93       	push	r30
     c44:	ff 93       	push	r31
     c46:	e0 91 90 22 	lds	r30, 0x2290	; 0x802290 <tc_tcc0_ccc_callback>
     c4a:	f0 91 91 22 	lds	r31, 0x2291	; 0x802291 <tc_tcc0_ccc_callback+0x1>
     c4e:	30 97       	sbiw	r30, 0x00	; 0
     c50:	09 f0       	breq	.+2      	; 0xc54 <__vector_18+0x34>
     c52:	19 95       	eicall
     c54:	ff 91       	pop	r31
     c56:	ef 91       	pop	r30
     c58:	bf 91       	pop	r27
     c5a:	af 91       	pop	r26
     c5c:	9f 91       	pop	r25
     c5e:	8f 91       	pop	r24
     c60:	7f 91       	pop	r23
     c62:	6f 91       	pop	r22
     c64:	5f 91       	pop	r21
     c66:	4f 91       	pop	r20
     c68:	3f 91       	pop	r19
     c6a:	2f 91       	pop	r18
     c6c:	0f 90       	pop	r0
     c6e:	0b be       	out	0x3b, r0	; 59
     c70:	0f 90       	pop	r0
     c72:	0f be       	out	0x3f, r0	; 63
     c74:	0f 90       	pop	r0
     c76:	1f 90       	pop	r1
     c78:	18 95       	reti

00000c7a <__vector_19>:
     c7a:	1f 92       	push	r1
     c7c:	0f 92       	push	r0
     c7e:	0f b6       	in	r0, 0x3f	; 63
     c80:	0f 92       	push	r0
     c82:	11 24       	eor	r1, r1
     c84:	0b b6       	in	r0, 0x3b	; 59
     c86:	0f 92       	push	r0
     c88:	2f 93       	push	r18
     c8a:	3f 93       	push	r19
     c8c:	4f 93       	push	r20
     c8e:	5f 93       	push	r21
     c90:	6f 93       	push	r22
     c92:	7f 93       	push	r23
     c94:	8f 93       	push	r24
     c96:	9f 93       	push	r25
     c98:	af 93       	push	r26
     c9a:	bf 93       	push	r27
     c9c:	ef 93       	push	r30
     c9e:	ff 93       	push	r31
     ca0:	e0 91 8e 22 	lds	r30, 0x228E	; 0x80228e <tc_tcc0_ccd_callback>
     ca4:	f0 91 8f 22 	lds	r31, 0x228F	; 0x80228f <tc_tcc0_ccd_callback+0x1>
     ca8:	30 97       	sbiw	r30, 0x00	; 0
     caa:	09 f0       	breq	.+2      	; 0xcae <__vector_19+0x34>
     cac:	19 95       	eicall
     cae:	ff 91       	pop	r31
     cb0:	ef 91       	pop	r30
     cb2:	bf 91       	pop	r27
     cb4:	af 91       	pop	r26
     cb6:	9f 91       	pop	r25
     cb8:	8f 91       	pop	r24
     cba:	7f 91       	pop	r23
     cbc:	6f 91       	pop	r22
     cbe:	5f 91       	pop	r21
     cc0:	4f 91       	pop	r20
     cc2:	3f 91       	pop	r19
     cc4:	2f 91       	pop	r18
     cc6:	0f 90       	pop	r0
     cc8:	0b be       	out	0x3b, r0	; 59
     cca:	0f 90       	pop	r0
     ccc:	0f be       	out	0x3f, r0	; 63
     cce:	0f 90       	pop	r0
     cd0:	1f 90       	pop	r1
     cd2:	18 95       	reti

00000cd4 <__vector_20>:
     cd4:	1f 92       	push	r1
     cd6:	0f 92       	push	r0
     cd8:	0f b6       	in	r0, 0x3f	; 63
     cda:	0f 92       	push	r0
     cdc:	11 24       	eor	r1, r1
     cde:	0b b6       	in	r0, 0x3b	; 59
     ce0:	0f 92       	push	r0
     ce2:	2f 93       	push	r18
     ce4:	3f 93       	push	r19
     ce6:	4f 93       	push	r20
     ce8:	5f 93       	push	r21
     cea:	6f 93       	push	r22
     cec:	7f 93       	push	r23
     cee:	8f 93       	push	r24
     cf0:	9f 93       	push	r25
     cf2:	af 93       	push	r26
     cf4:	bf 93       	push	r27
     cf6:	ef 93       	push	r30
     cf8:	ff 93       	push	r31
     cfa:	e0 91 8c 22 	lds	r30, 0x228C	; 0x80228c <tc_tcc1_ovf_callback>
     cfe:	f0 91 8d 22 	lds	r31, 0x228D	; 0x80228d <tc_tcc1_ovf_callback+0x1>
     d02:	30 97       	sbiw	r30, 0x00	; 0
     d04:	09 f0       	breq	.+2      	; 0xd08 <__vector_20+0x34>
     d06:	19 95       	eicall
     d08:	ff 91       	pop	r31
     d0a:	ef 91       	pop	r30
     d0c:	bf 91       	pop	r27
     d0e:	af 91       	pop	r26
     d10:	9f 91       	pop	r25
     d12:	8f 91       	pop	r24
     d14:	7f 91       	pop	r23
     d16:	6f 91       	pop	r22
     d18:	5f 91       	pop	r21
     d1a:	4f 91       	pop	r20
     d1c:	3f 91       	pop	r19
     d1e:	2f 91       	pop	r18
     d20:	0f 90       	pop	r0
     d22:	0b be       	out	0x3b, r0	; 59
     d24:	0f 90       	pop	r0
     d26:	0f be       	out	0x3f, r0	; 63
     d28:	0f 90       	pop	r0
     d2a:	1f 90       	pop	r1
     d2c:	18 95       	reti

00000d2e <__vector_21>:
     d2e:	1f 92       	push	r1
     d30:	0f 92       	push	r0
     d32:	0f b6       	in	r0, 0x3f	; 63
     d34:	0f 92       	push	r0
     d36:	11 24       	eor	r1, r1
     d38:	0b b6       	in	r0, 0x3b	; 59
     d3a:	0f 92       	push	r0
     d3c:	2f 93       	push	r18
     d3e:	3f 93       	push	r19
     d40:	4f 93       	push	r20
     d42:	5f 93       	push	r21
     d44:	6f 93       	push	r22
     d46:	7f 93       	push	r23
     d48:	8f 93       	push	r24
     d4a:	9f 93       	push	r25
     d4c:	af 93       	push	r26
     d4e:	bf 93       	push	r27
     d50:	ef 93       	push	r30
     d52:	ff 93       	push	r31
     d54:	e0 91 8a 22 	lds	r30, 0x228A	; 0x80228a <tc_tcc1_err_callback>
     d58:	f0 91 8b 22 	lds	r31, 0x228B	; 0x80228b <tc_tcc1_err_callback+0x1>
     d5c:	30 97       	sbiw	r30, 0x00	; 0
     d5e:	09 f0       	breq	.+2      	; 0xd62 <__vector_21+0x34>
     d60:	19 95       	eicall
     d62:	ff 91       	pop	r31
     d64:	ef 91       	pop	r30
     d66:	bf 91       	pop	r27
     d68:	af 91       	pop	r26
     d6a:	9f 91       	pop	r25
     d6c:	8f 91       	pop	r24
     d6e:	7f 91       	pop	r23
     d70:	6f 91       	pop	r22
     d72:	5f 91       	pop	r21
     d74:	4f 91       	pop	r20
     d76:	3f 91       	pop	r19
     d78:	2f 91       	pop	r18
     d7a:	0f 90       	pop	r0
     d7c:	0b be       	out	0x3b, r0	; 59
     d7e:	0f 90       	pop	r0
     d80:	0f be       	out	0x3f, r0	; 63
     d82:	0f 90       	pop	r0
     d84:	1f 90       	pop	r1
     d86:	18 95       	reti

00000d88 <__vector_22>:
     d88:	1f 92       	push	r1
     d8a:	0f 92       	push	r0
     d8c:	0f b6       	in	r0, 0x3f	; 63
     d8e:	0f 92       	push	r0
     d90:	11 24       	eor	r1, r1
     d92:	0b b6       	in	r0, 0x3b	; 59
     d94:	0f 92       	push	r0
     d96:	2f 93       	push	r18
     d98:	3f 93       	push	r19
     d9a:	4f 93       	push	r20
     d9c:	5f 93       	push	r21
     d9e:	6f 93       	push	r22
     da0:	7f 93       	push	r23
     da2:	8f 93       	push	r24
     da4:	9f 93       	push	r25
     da6:	af 93       	push	r26
     da8:	bf 93       	push	r27
     daa:	ef 93       	push	r30
     dac:	ff 93       	push	r31
     dae:	e0 91 88 22 	lds	r30, 0x2288	; 0x802288 <tc_tcc1_cca_callback>
     db2:	f0 91 89 22 	lds	r31, 0x2289	; 0x802289 <tc_tcc1_cca_callback+0x1>
     db6:	30 97       	sbiw	r30, 0x00	; 0
     db8:	09 f0       	breq	.+2      	; 0xdbc <__vector_22+0x34>
     dba:	19 95       	eicall
     dbc:	ff 91       	pop	r31
     dbe:	ef 91       	pop	r30
     dc0:	bf 91       	pop	r27
     dc2:	af 91       	pop	r26
     dc4:	9f 91       	pop	r25
     dc6:	8f 91       	pop	r24
     dc8:	7f 91       	pop	r23
     dca:	6f 91       	pop	r22
     dcc:	5f 91       	pop	r21
     dce:	4f 91       	pop	r20
     dd0:	3f 91       	pop	r19
     dd2:	2f 91       	pop	r18
     dd4:	0f 90       	pop	r0
     dd6:	0b be       	out	0x3b, r0	; 59
     dd8:	0f 90       	pop	r0
     dda:	0f be       	out	0x3f, r0	; 63
     ddc:	0f 90       	pop	r0
     dde:	1f 90       	pop	r1
     de0:	18 95       	reti

00000de2 <__vector_23>:
     de2:	1f 92       	push	r1
     de4:	0f 92       	push	r0
     de6:	0f b6       	in	r0, 0x3f	; 63
     de8:	0f 92       	push	r0
     dea:	11 24       	eor	r1, r1
     dec:	0b b6       	in	r0, 0x3b	; 59
     dee:	0f 92       	push	r0
     df0:	2f 93       	push	r18
     df2:	3f 93       	push	r19
     df4:	4f 93       	push	r20
     df6:	5f 93       	push	r21
     df8:	6f 93       	push	r22
     dfa:	7f 93       	push	r23
     dfc:	8f 93       	push	r24
     dfe:	9f 93       	push	r25
     e00:	af 93       	push	r26
     e02:	bf 93       	push	r27
     e04:	ef 93       	push	r30
     e06:	ff 93       	push	r31
     e08:	e0 91 86 22 	lds	r30, 0x2286	; 0x802286 <tc_tcc1_ccb_callback>
     e0c:	f0 91 87 22 	lds	r31, 0x2287	; 0x802287 <tc_tcc1_ccb_callback+0x1>
     e10:	30 97       	sbiw	r30, 0x00	; 0
     e12:	09 f0       	breq	.+2      	; 0xe16 <__vector_23+0x34>
     e14:	19 95       	eicall
     e16:	ff 91       	pop	r31
     e18:	ef 91       	pop	r30
     e1a:	bf 91       	pop	r27
     e1c:	af 91       	pop	r26
     e1e:	9f 91       	pop	r25
     e20:	8f 91       	pop	r24
     e22:	7f 91       	pop	r23
     e24:	6f 91       	pop	r22
     e26:	5f 91       	pop	r21
     e28:	4f 91       	pop	r20
     e2a:	3f 91       	pop	r19
     e2c:	2f 91       	pop	r18
     e2e:	0f 90       	pop	r0
     e30:	0b be       	out	0x3b, r0	; 59
     e32:	0f 90       	pop	r0
     e34:	0f be       	out	0x3f, r0	; 63
     e36:	0f 90       	pop	r0
     e38:	1f 90       	pop	r1
     e3a:	18 95       	reti

00000e3c <__vector_77>:
     e3c:	1f 92       	push	r1
     e3e:	0f 92       	push	r0
     e40:	0f b6       	in	r0, 0x3f	; 63
     e42:	0f 92       	push	r0
     e44:	11 24       	eor	r1, r1
     e46:	0b b6       	in	r0, 0x3b	; 59
     e48:	0f 92       	push	r0
     e4a:	2f 93       	push	r18
     e4c:	3f 93       	push	r19
     e4e:	4f 93       	push	r20
     e50:	5f 93       	push	r21
     e52:	6f 93       	push	r22
     e54:	7f 93       	push	r23
     e56:	8f 93       	push	r24
     e58:	9f 93       	push	r25
     e5a:	af 93       	push	r26
     e5c:	bf 93       	push	r27
     e5e:	ef 93       	push	r30
     e60:	ff 93       	push	r31
     e62:	e0 91 84 22 	lds	r30, 0x2284	; 0x802284 <tc_tcd0_ovf_callback>
     e66:	f0 91 85 22 	lds	r31, 0x2285	; 0x802285 <tc_tcd0_ovf_callback+0x1>
     e6a:	30 97       	sbiw	r30, 0x00	; 0
     e6c:	09 f0       	breq	.+2      	; 0xe70 <__vector_77+0x34>
     e6e:	19 95       	eicall
     e70:	ff 91       	pop	r31
     e72:	ef 91       	pop	r30
     e74:	bf 91       	pop	r27
     e76:	af 91       	pop	r26
     e78:	9f 91       	pop	r25
     e7a:	8f 91       	pop	r24
     e7c:	7f 91       	pop	r23
     e7e:	6f 91       	pop	r22
     e80:	5f 91       	pop	r21
     e82:	4f 91       	pop	r20
     e84:	3f 91       	pop	r19
     e86:	2f 91       	pop	r18
     e88:	0f 90       	pop	r0
     e8a:	0b be       	out	0x3b, r0	; 59
     e8c:	0f 90       	pop	r0
     e8e:	0f be       	out	0x3f, r0	; 63
     e90:	0f 90       	pop	r0
     e92:	1f 90       	pop	r1
     e94:	18 95       	reti

00000e96 <__vector_78>:
     e96:	1f 92       	push	r1
     e98:	0f 92       	push	r0
     e9a:	0f b6       	in	r0, 0x3f	; 63
     e9c:	0f 92       	push	r0
     e9e:	11 24       	eor	r1, r1
     ea0:	0b b6       	in	r0, 0x3b	; 59
     ea2:	0f 92       	push	r0
     ea4:	2f 93       	push	r18
     ea6:	3f 93       	push	r19
     ea8:	4f 93       	push	r20
     eaa:	5f 93       	push	r21
     eac:	6f 93       	push	r22
     eae:	7f 93       	push	r23
     eb0:	8f 93       	push	r24
     eb2:	9f 93       	push	r25
     eb4:	af 93       	push	r26
     eb6:	bf 93       	push	r27
     eb8:	ef 93       	push	r30
     eba:	ff 93       	push	r31
     ebc:	e0 91 82 22 	lds	r30, 0x2282	; 0x802282 <tc_tcd0_err_callback>
     ec0:	f0 91 83 22 	lds	r31, 0x2283	; 0x802283 <tc_tcd0_err_callback+0x1>
     ec4:	30 97       	sbiw	r30, 0x00	; 0
     ec6:	09 f0       	breq	.+2      	; 0xeca <__vector_78+0x34>
     ec8:	19 95       	eicall
     eca:	ff 91       	pop	r31
     ecc:	ef 91       	pop	r30
     ece:	bf 91       	pop	r27
     ed0:	af 91       	pop	r26
     ed2:	9f 91       	pop	r25
     ed4:	8f 91       	pop	r24
     ed6:	7f 91       	pop	r23
     ed8:	6f 91       	pop	r22
     eda:	5f 91       	pop	r21
     edc:	4f 91       	pop	r20
     ede:	3f 91       	pop	r19
     ee0:	2f 91       	pop	r18
     ee2:	0f 90       	pop	r0
     ee4:	0b be       	out	0x3b, r0	; 59
     ee6:	0f 90       	pop	r0
     ee8:	0f be       	out	0x3f, r0	; 63
     eea:	0f 90       	pop	r0
     eec:	1f 90       	pop	r1
     eee:	18 95       	reti

00000ef0 <__vector_79>:
     ef0:	1f 92       	push	r1
     ef2:	0f 92       	push	r0
     ef4:	0f b6       	in	r0, 0x3f	; 63
     ef6:	0f 92       	push	r0
     ef8:	11 24       	eor	r1, r1
     efa:	0b b6       	in	r0, 0x3b	; 59
     efc:	0f 92       	push	r0
     efe:	2f 93       	push	r18
     f00:	3f 93       	push	r19
     f02:	4f 93       	push	r20
     f04:	5f 93       	push	r21
     f06:	6f 93       	push	r22
     f08:	7f 93       	push	r23
     f0a:	8f 93       	push	r24
     f0c:	9f 93       	push	r25
     f0e:	af 93       	push	r26
     f10:	bf 93       	push	r27
     f12:	ef 93       	push	r30
     f14:	ff 93       	push	r31
     f16:	e0 91 80 22 	lds	r30, 0x2280	; 0x802280 <tc_tcd0_cca_callback>
     f1a:	f0 91 81 22 	lds	r31, 0x2281	; 0x802281 <tc_tcd0_cca_callback+0x1>
     f1e:	30 97       	sbiw	r30, 0x00	; 0
     f20:	09 f0       	breq	.+2      	; 0xf24 <__vector_79+0x34>
     f22:	19 95       	eicall
     f24:	ff 91       	pop	r31
     f26:	ef 91       	pop	r30
     f28:	bf 91       	pop	r27
     f2a:	af 91       	pop	r26
     f2c:	9f 91       	pop	r25
     f2e:	8f 91       	pop	r24
     f30:	7f 91       	pop	r23
     f32:	6f 91       	pop	r22
     f34:	5f 91       	pop	r21
     f36:	4f 91       	pop	r20
     f38:	3f 91       	pop	r19
     f3a:	2f 91       	pop	r18
     f3c:	0f 90       	pop	r0
     f3e:	0b be       	out	0x3b, r0	; 59
     f40:	0f 90       	pop	r0
     f42:	0f be       	out	0x3f, r0	; 63
     f44:	0f 90       	pop	r0
     f46:	1f 90       	pop	r1
     f48:	18 95       	reti

00000f4a <__vector_80>:
     f4a:	1f 92       	push	r1
     f4c:	0f 92       	push	r0
     f4e:	0f b6       	in	r0, 0x3f	; 63
     f50:	0f 92       	push	r0
     f52:	11 24       	eor	r1, r1
     f54:	0b b6       	in	r0, 0x3b	; 59
     f56:	0f 92       	push	r0
     f58:	2f 93       	push	r18
     f5a:	3f 93       	push	r19
     f5c:	4f 93       	push	r20
     f5e:	5f 93       	push	r21
     f60:	6f 93       	push	r22
     f62:	7f 93       	push	r23
     f64:	8f 93       	push	r24
     f66:	9f 93       	push	r25
     f68:	af 93       	push	r26
     f6a:	bf 93       	push	r27
     f6c:	ef 93       	push	r30
     f6e:	ff 93       	push	r31
     f70:	e0 91 7e 22 	lds	r30, 0x227E	; 0x80227e <tc_tcd0_ccb_callback>
     f74:	f0 91 7f 22 	lds	r31, 0x227F	; 0x80227f <tc_tcd0_ccb_callback+0x1>
     f78:	30 97       	sbiw	r30, 0x00	; 0
     f7a:	09 f0       	breq	.+2      	; 0xf7e <__vector_80+0x34>
     f7c:	19 95       	eicall
     f7e:	ff 91       	pop	r31
     f80:	ef 91       	pop	r30
     f82:	bf 91       	pop	r27
     f84:	af 91       	pop	r26
     f86:	9f 91       	pop	r25
     f88:	8f 91       	pop	r24
     f8a:	7f 91       	pop	r23
     f8c:	6f 91       	pop	r22
     f8e:	5f 91       	pop	r21
     f90:	4f 91       	pop	r20
     f92:	3f 91       	pop	r19
     f94:	2f 91       	pop	r18
     f96:	0f 90       	pop	r0
     f98:	0b be       	out	0x3b, r0	; 59
     f9a:	0f 90       	pop	r0
     f9c:	0f be       	out	0x3f, r0	; 63
     f9e:	0f 90       	pop	r0
     fa0:	1f 90       	pop	r1
     fa2:	18 95       	reti

00000fa4 <__vector_81>:
     fa4:	1f 92       	push	r1
     fa6:	0f 92       	push	r0
     fa8:	0f b6       	in	r0, 0x3f	; 63
     faa:	0f 92       	push	r0
     fac:	11 24       	eor	r1, r1
     fae:	0b b6       	in	r0, 0x3b	; 59
     fb0:	0f 92       	push	r0
     fb2:	2f 93       	push	r18
     fb4:	3f 93       	push	r19
     fb6:	4f 93       	push	r20
     fb8:	5f 93       	push	r21
     fba:	6f 93       	push	r22
     fbc:	7f 93       	push	r23
     fbe:	8f 93       	push	r24
     fc0:	9f 93       	push	r25
     fc2:	af 93       	push	r26
     fc4:	bf 93       	push	r27
     fc6:	ef 93       	push	r30
     fc8:	ff 93       	push	r31
     fca:	e0 91 7c 22 	lds	r30, 0x227C	; 0x80227c <tc_tcd0_ccc_callback>
     fce:	f0 91 7d 22 	lds	r31, 0x227D	; 0x80227d <tc_tcd0_ccc_callback+0x1>
     fd2:	30 97       	sbiw	r30, 0x00	; 0
     fd4:	09 f0       	breq	.+2      	; 0xfd8 <__vector_81+0x34>
     fd6:	19 95       	eicall
     fd8:	ff 91       	pop	r31
     fda:	ef 91       	pop	r30
     fdc:	bf 91       	pop	r27
     fde:	af 91       	pop	r26
     fe0:	9f 91       	pop	r25
     fe2:	8f 91       	pop	r24
     fe4:	7f 91       	pop	r23
     fe6:	6f 91       	pop	r22
     fe8:	5f 91       	pop	r21
     fea:	4f 91       	pop	r20
     fec:	3f 91       	pop	r19
     fee:	2f 91       	pop	r18
     ff0:	0f 90       	pop	r0
     ff2:	0b be       	out	0x3b, r0	; 59
     ff4:	0f 90       	pop	r0
     ff6:	0f be       	out	0x3f, r0	; 63
     ff8:	0f 90       	pop	r0
     ffa:	1f 90       	pop	r1
     ffc:	18 95       	reti

00000ffe <__vector_82>:
     ffe:	1f 92       	push	r1
    1000:	0f 92       	push	r0
    1002:	0f b6       	in	r0, 0x3f	; 63
    1004:	0f 92       	push	r0
    1006:	11 24       	eor	r1, r1
    1008:	0b b6       	in	r0, 0x3b	; 59
    100a:	0f 92       	push	r0
    100c:	2f 93       	push	r18
    100e:	3f 93       	push	r19
    1010:	4f 93       	push	r20
    1012:	5f 93       	push	r21
    1014:	6f 93       	push	r22
    1016:	7f 93       	push	r23
    1018:	8f 93       	push	r24
    101a:	9f 93       	push	r25
    101c:	af 93       	push	r26
    101e:	bf 93       	push	r27
    1020:	ef 93       	push	r30
    1022:	ff 93       	push	r31
    1024:	e0 91 7a 22 	lds	r30, 0x227A	; 0x80227a <tc_tcd0_ccd_callback>
    1028:	f0 91 7b 22 	lds	r31, 0x227B	; 0x80227b <tc_tcd0_ccd_callback+0x1>
    102c:	30 97       	sbiw	r30, 0x00	; 0
    102e:	09 f0       	breq	.+2      	; 0x1032 <__vector_82+0x34>
    1030:	19 95       	eicall
    1032:	ff 91       	pop	r31
    1034:	ef 91       	pop	r30
    1036:	bf 91       	pop	r27
    1038:	af 91       	pop	r26
    103a:	9f 91       	pop	r25
    103c:	8f 91       	pop	r24
    103e:	7f 91       	pop	r23
    1040:	6f 91       	pop	r22
    1042:	5f 91       	pop	r21
    1044:	4f 91       	pop	r20
    1046:	3f 91       	pop	r19
    1048:	2f 91       	pop	r18
    104a:	0f 90       	pop	r0
    104c:	0b be       	out	0x3b, r0	; 59
    104e:	0f 90       	pop	r0
    1050:	0f be       	out	0x3f, r0	; 63
    1052:	0f 90       	pop	r0
    1054:	1f 90       	pop	r1
    1056:	18 95       	reti

00001058 <__vector_83>:
    1058:	1f 92       	push	r1
    105a:	0f 92       	push	r0
    105c:	0f b6       	in	r0, 0x3f	; 63
    105e:	0f 92       	push	r0
    1060:	11 24       	eor	r1, r1
    1062:	0b b6       	in	r0, 0x3b	; 59
    1064:	0f 92       	push	r0
    1066:	2f 93       	push	r18
    1068:	3f 93       	push	r19
    106a:	4f 93       	push	r20
    106c:	5f 93       	push	r21
    106e:	6f 93       	push	r22
    1070:	7f 93       	push	r23
    1072:	8f 93       	push	r24
    1074:	9f 93       	push	r25
    1076:	af 93       	push	r26
    1078:	bf 93       	push	r27
    107a:	ef 93       	push	r30
    107c:	ff 93       	push	r31
    107e:	e0 91 78 22 	lds	r30, 0x2278	; 0x802278 <tc_tcd1_ovf_callback>
    1082:	f0 91 79 22 	lds	r31, 0x2279	; 0x802279 <tc_tcd1_ovf_callback+0x1>
    1086:	30 97       	sbiw	r30, 0x00	; 0
    1088:	09 f0       	breq	.+2      	; 0x108c <__vector_83+0x34>
    108a:	19 95       	eicall
    108c:	ff 91       	pop	r31
    108e:	ef 91       	pop	r30
    1090:	bf 91       	pop	r27
    1092:	af 91       	pop	r26
    1094:	9f 91       	pop	r25
    1096:	8f 91       	pop	r24
    1098:	7f 91       	pop	r23
    109a:	6f 91       	pop	r22
    109c:	5f 91       	pop	r21
    109e:	4f 91       	pop	r20
    10a0:	3f 91       	pop	r19
    10a2:	2f 91       	pop	r18
    10a4:	0f 90       	pop	r0
    10a6:	0b be       	out	0x3b, r0	; 59
    10a8:	0f 90       	pop	r0
    10aa:	0f be       	out	0x3f, r0	; 63
    10ac:	0f 90       	pop	r0
    10ae:	1f 90       	pop	r1
    10b0:	18 95       	reti

000010b2 <__vector_84>:
    10b2:	1f 92       	push	r1
    10b4:	0f 92       	push	r0
    10b6:	0f b6       	in	r0, 0x3f	; 63
    10b8:	0f 92       	push	r0
    10ba:	11 24       	eor	r1, r1
    10bc:	0b b6       	in	r0, 0x3b	; 59
    10be:	0f 92       	push	r0
    10c0:	2f 93       	push	r18
    10c2:	3f 93       	push	r19
    10c4:	4f 93       	push	r20
    10c6:	5f 93       	push	r21
    10c8:	6f 93       	push	r22
    10ca:	7f 93       	push	r23
    10cc:	8f 93       	push	r24
    10ce:	9f 93       	push	r25
    10d0:	af 93       	push	r26
    10d2:	bf 93       	push	r27
    10d4:	ef 93       	push	r30
    10d6:	ff 93       	push	r31
    10d8:	e0 91 76 22 	lds	r30, 0x2276	; 0x802276 <tc_tcd1_err_callback>
    10dc:	f0 91 77 22 	lds	r31, 0x2277	; 0x802277 <tc_tcd1_err_callback+0x1>
    10e0:	30 97       	sbiw	r30, 0x00	; 0
    10e2:	09 f0       	breq	.+2      	; 0x10e6 <__vector_84+0x34>
    10e4:	19 95       	eicall
    10e6:	ff 91       	pop	r31
    10e8:	ef 91       	pop	r30
    10ea:	bf 91       	pop	r27
    10ec:	af 91       	pop	r26
    10ee:	9f 91       	pop	r25
    10f0:	8f 91       	pop	r24
    10f2:	7f 91       	pop	r23
    10f4:	6f 91       	pop	r22
    10f6:	5f 91       	pop	r21
    10f8:	4f 91       	pop	r20
    10fa:	3f 91       	pop	r19
    10fc:	2f 91       	pop	r18
    10fe:	0f 90       	pop	r0
    1100:	0b be       	out	0x3b, r0	; 59
    1102:	0f 90       	pop	r0
    1104:	0f be       	out	0x3f, r0	; 63
    1106:	0f 90       	pop	r0
    1108:	1f 90       	pop	r1
    110a:	18 95       	reti

0000110c <__vector_85>:
    110c:	1f 92       	push	r1
    110e:	0f 92       	push	r0
    1110:	0f b6       	in	r0, 0x3f	; 63
    1112:	0f 92       	push	r0
    1114:	11 24       	eor	r1, r1
    1116:	0b b6       	in	r0, 0x3b	; 59
    1118:	0f 92       	push	r0
    111a:	2f 93       	push	r18
    111c:	3f 93       	push	r19
    111e:	4f 93       	push	r20
    1120:	5f 93       	push	r21
    1122:	6f 93       	push	r22
    1124:	7f 93       	push	r23
    1126:	8f 93       	push	r24
    1128:	9f 93       	push	r25
    112a:	af 93       	push	r26
    112c:	bf 93       	push	r27
    112e:	ef 93       	push	r30
    1130:	ff 93       	push	r31
    1132:	e0 91 74 22 	lds	r30, 0x2274	; 0x802274 <tc_tcd1_cca_callback>
    1136:	f0 91 75 22 	lds	r31, 0x2275	; 0x802275 <tc_tcd1_cca_callback+0x1>
    113a:	30 97       	sbiw	r30, 0x00	; 0
    113c:	09 f0       	breq	.+2      	; 0x1140 <__vector_85+0x34>
    113e:	19 95       	eicall
    1140:	ff 91       	pop	r31
    1142:	ef 91       	pop	r30
    1144:	bf 91       	pop	r27
    1146:	af 91       	pop	r26
    1148:	9f 91       	pop	r25
    114a:	8f 91       	pop	r24
    114c:	7f 91       	pop	r23
    114e:	6f 91       	pop	r22
    1150:	5f 91       	pop	r21
    1152:	4f 91       	pop	r20
    1154:	3f 91       	pop	r19
    1156:	2f 91       	pop	r18
    1158:	0f 90       	pop	r0
    115a:	0b be       	out	0x3b, r0	; 59
    115c:	0f 90       	pop	r0
    115e:	0f be       	out	0x3f, r0	; 63
    1160:	0f 90       	pop	r0
    1162:	1f 90       	pop	r1
    1164:	18 95       	reti

00001166 <__vector_86>:
    1166:	1f 92       	push	r1
    1168:	0f 92       	push	r0
    116a:	0f b6       	in	r0, 0x3f	; 63
    116c:	0f 92       	push	r0
    116e:	11 24       	eor	r1, r1
    1170:	0b b6       	in	r0, 0x3b	; 59
    1172:	0f 92       	push	r0
    1174:	2f 93       	push	r18
    1176:	3f 93       	push	r19
    1178:	4f 93       	push	r20
    117a:	5f 93       	push	r21
    117c:	6f 93       	push	r22
    117e:	7f 93       	push	r23
    1180:	8f 93       	push	r24
    1182:	9f 93       	push	r25
    1184:	af 93       	push	r26
    1186:	bf 93       	push	r27
    1188:	ef 93       	push	r30
    118a:	ff 93       	push	r31
    118c:	e0 91 72 22 	lds	r30, 0x2272	; 0x802272 <tc_tcd1_ccb_callback>
    1190:	f0 91 73 22 	lds	r31, 0x2273	; 0x802273 <tc_tcd1_ccb_callback+0x1>
    1194:	30 97       	sbiw	r30, 0x00	; 0
    1196:	09 f0       	breq	.+2      	; 0x119a <__vector_86+0x34>
    1198:	19 95       	eicall
    119a:	ff 91       	pop	r31
    119c:	ef 91       	pop	r30
    119e:	bf 91       	pop	r27
    11a0:	af 91       	pop	r26
    11a2:	9f 91       	pop	r25
    11a4:	8f 91       	pop	r24
    11a6:	7f 91       	pop	r23
    11a8:	6f 91       	pop	r22
    11aa:	5f 91       	pop	r21
    11ac:	4f 91       	pop	r20
    11ae:	3f 91       	pop	r19
    11b0:	2f 91       	pop	r18
    11b2:	0f 90       	pop	r0
    11b4:	0b be       	out	0x3b, r0	; 59
    11b6:	0f 90       	pop	r0
    11b8:	0f be       	out	0x3f, r0	; 63
    11ba:	0f 90       	pop	r0
    11bc:	1f 90       	pop	r1
    11be:	18 95       	reti

000011c0 <__vector_47>:
    11c0:	1f 92       	push	r1
    11c2:	0f 92       	push	r0
    11c4:	0f b6       	in	r0, 0x3f	; 63
    11c6:	0f 92       	push	r0
    11c8:	11 24       	eor	r1, r1
    11ca:	0b b6       	in	r0, 0x3b	; 59
    11cc:	0f 92       	push	r0
    11ce:	2f 93       	push	r18
    11d0:	3f 93       	push	r19
    11d2:	4f 93       	push	r20
    11d4:	5f 93       	push	r21
    11d6:	6f 93       	push	r22
    11d8:	7f 93       	push	r23
    11da:	8f 93       	push	r24
    11dc:	9f 93       	push	r25
    11de:	af 93       	push	r26
    11e0:	bf 93       	push	r27
    11e2:	ef 93       	push	r30
    11e4:	ff 93       	push	r31
    11e6:	e0 91 70 22 	lds	r30, 0x2270	; 0x802270 <tc_tce0_ovf_callback>
    11ea:	f0 91 71 22 	lds	r31, 0x2271	; 0x802271 <tc_tce0_ovf_callback+0x1>
    11ee:	30 97       	sbiw	r30, 0x00	; 0
    11f0:	09 f0       	breq	.+2      	; 0x11f4 <__vector_47+0x34>
    11f2:	19 95       	eicall
    11f4:	ff 91       	pop	r31
    11f6:	ef 91       	pop	r30
    11f8:	bf 91       	pop	r27
    11fa:	af 91       	pop	r26
    11fc:	9f 91       	pop	r25
    11fe:	8f 91       	pop	r24
    1200:	7f 91       	pop	r23
    1202:	6f 91       	pop	r22
    1204:	5f 91       	pop	r21
    1206:	4f 91       	pop	r20
    1208:	3f 91       	pop	r19
    120a:	2f 91       	pop	r18
    120c:	0f 90       	pop	r0
    120e:	0b be       	out	0x3b, r0	; 59
    1210:	0f 90       	pop	r0
    1212:	0f be       	out	0x3f, r0	; 63
    1214:	0f 90       	pop	r0
    1216:	1f 90       	pop	r1
    1218:	18 95       	reti

0000121a <__vector_48>:
    121a:	1f 92       	push	r1
    121c:	0f 92       	push	r0
    121e:	0f b6       	in	r0, 0x3f	; 63
    1220:	0f 92       	push	r0
    1222:	11 24       	eor	r1, r1
    1224:	0b b6       	in	r0, 0x3b	; 59
    1226:	0f 92       	push	r0
    1228:	2f 93       	push	r18
    122a:	3f 93       	push	r19
    122c:	4f 93       	push	r20
    122e:	5f 93       	push	r21
    1230:	6f 93       	push	r22
    1232:	7f 93       	push	r23
    1234:	8f 93       	push	r24
    1236:	9f 93       	push	r25
    1238:	af 93       	push	r26
    123a:	bf 93       	push	r27
    123c:	ef 93       	push	r30
    123e:	ff 93       	push	r31
    1240:	e0 91 6e 22 	lds	r30, 0x226E	; 0x80226e <tc_tce0_err_callback>
    1244:	f0 91 6f 22 	lds	r31, 0x226F	; 0x80226f <tc_tce0_err_callback+0x1>
    1248:	30 97       	sbiw	r30, 0x00	; 0
    124a:	09 f0       	breq	.+2      	; 0x124e <__vector_48+0x34>
    124c:	19 95       	eicall
    124e:	ff 91       	pop	r31
    1250:	ef 91       	pop	r30
    1252:	bf 91       	pop	r27
    1254:	af 91       	pop	r26
    1256:	9f 91       	pop	r25
    1258:	8f 91       	pop	r24
    125a:	7f 91       	pop	r23
    125c:	6f 91       	pop	r22
    125e:	5f 91       	pop	r21
    1260:	4f 91       	pop	r20
    1262:	3f 91       	pop	r19
    1264:	2f 91       	pop	r18
    1266:	0f 90       	pop	r0
    1268:	0b be       	out	0x3b, r0	; 59
    126a:	0f 90       	pop	r0
    126c:	0f be       	out	0x3f, r0	; 63
    126e:	0f 90       	pop	r0
    1270:	1f 90       	pop	r1
    1272:	18 95       	reti

00001274 <__vector_49>:
    1274:	1f 92       	push	r1
    1276:	0f 92       	push	r0
    1278:	0f b6       	in	r0, 0x3f	; 63
    127a:	0f 92       	push	r0
    127c:	11 24       	eor	r1, r1
    127e:	0b b6       	in	r0, 0x3b	; 59
    1280:	0f 92       	push	r0
    1282:	2f 93       	push	r18
    1284:	3f 93       	push	r19
    1286:	4f 93       	push	r20
    1288:	5f 93       	push	r21
    128a:	6f 93       	push	r22
    128c:	7f 93       	push	r23
    128e:	8f 93       	push	r24
    1290:	9f 93       	push	r25
    1292:	af 93       	push	r26
    1294:	bf 93       	push	r27
    1296:	ef 93       	push	r30
    1298:	ff 93       	push	r31
    129a:	e0 91 6c 22 	lds	r30, 0x226C	; 0x80226c <tc_tce0_cca_callback>
    129e:	f0 91 6d 22 	lds	r31, 0x226D	; 0x80226d <tc_tce0_cca_callback+0x1>
    12a2:	30 97       	sbiw	r30, 0x00	; 0
    12a4:	09 f0       	breq	.+2      	; 0x12a8 <__vector_49+0x34>
    12a6:	19 95       	eicall
    12a8:	ff 91       	pop	r31
    12aa:	ef 91       	pop	r30
    12ac:	bf 91       	pop	r27
    12ae:	af 91       	pop	r26
    12b0:	9f 91       	pop	r25
    12b2:	8f 91       	pop	r24
    12b4:	7f 91       	pop	r23
    12b6:	6f 91       	pop	r22
    12b8:	5f 91       	pop	r21
    12ba:	4f 91       	pop	r20
    12bc:	3f 91       	pop	r19
    12be:	2f 91       	pop	r18
    12c0:	0f 90       	pop	r0
    12c2:	0b be       	out	0x3b, r0	; 59
    12c4:	0f 90       	pop	r0
    12c6:	0f be       	out	0x3f, r0	; 63
    12c8:	0f 90       	pop	r0
    12ca:	1f 90       	pop	r1
    12cc:	18 95       	reti

000012ce <__vector_50>:
    12ce:	1f 92       	push	r1
    12d0:	0f 92       	push	r0
    12d2:	0f b6       	in	r0, 0x3f	; 63
    12d4:	0f 92       	push	r0
    12d6:	11 24       	eor	r1, r1
    12d8:	0b b6       	in	r0, 0x3b	; 59
    12da:	0f 92       	push	r0
    12dc:	2f 93       	push	r18
    12de:	3f 93       	push	r19
    12e0:	4f 93       	push	r20
    12e2:	5f 93       	push	r21
    12e4:	6f 93       	push	r22
    12e6:	7f 93       	push	r23
    12e8:	8f 93       	push	r24
    12ea:	9f 93       	push	r25
    12ec:	af 93       	push	r26
    12ee:	bf 93       	push	r27
    12f0:	ef 93       	push	r30
    12f2:	ff 93       	push	r31
    12f4:	e0 91 6a 22 	lds	r30, 0x226A	; 0x80226a <tc_tce0_ccb_callback>
    12f8:	f0 91 6b 22 	lds	r31, 0x226B	; 0x80226b <tc_tce0_ccb_callback+0x1>
    12fc:	30 97       	sbiw	r30, 0x00	; 0
    12fe:	09 f0       	breq	.+2      	; 0x1302 <__vector_50+0x34>
    1300:	19 95       	eicall
    1302:	ff 91       	pop	r31
    1304:	ef 91       	pop	r30
    1306:	bf 91       	pop	r27
    1308:	af 91       	pop	r26
    130a:	9f 91       	pop	r25
    130c:	8f 91       	pop	r24
    130e:	7f 91       	pop	r23
    1310:	6f 91       	pop	r22
    1312:	5f 91       	pop	r21
    1314:	4f 91       	pop	r20
    1316:	3f 91       	pop	r19
    1318:	2f 91       	pop	r18
    131a:	0f 90       	pop	r0
    131c:	0b be       	out	0x3b, r0	; 59
    131e:	0f 90       	pop	r0
    1320:	0f be       	out	0x3f, r0	; 63
    1322:	0f 90       	pop	r0
    1324:	1f 90       	pop	r1
    1326:	18 95       	reti

00001328 <__vector_51>:
    1328:	1f 92       	push	r1
    132a:	0f 92       	push	r0
    132c:	0f b6       	in	r0, 0x3f	; 63
    132e:	0f 92       	push	r0
    1330:	11 24       	eor	r1, r1
    1332:	0b b6       	in	r0, 0x3b	; 59
    1334:	0f 92       	push	r0
    1336:	2f 93       	push	r18
    1338:	3f 93       	push	r19
    133a:	4f 93       	push	r20
    133c:	5f 93       	push	r21
    133e:	6f 93       	push	r22
    1340:	7f 93       	push	r23
    1342:	8f 93       	push	r24
    1344:	9f 93       	push	r25
    1346:	af 93       	push	r26
    1348:	bf 93       	push	r27
    134a:	ef 93       	push	r30
    134c:	ff 93       	push	r31
    134e:	e0 91 68 22 	lds	r30, 0x2268	; 0x802268 <tc_tce0_ccc_callback>
    1352:	f0 91 69 22 	lds	r31, 0x2269	; 0x802269 <tc_tce0_ccc_callback+0x1>
    1356:	30 97       	sbiw	r30, 0x00	; 0
    1358:	09 f0       	breq	.+2      	; 0x135c <__vector_51+0x34>
    135a:	19 95       	eicall
    135c:	ff 91       	pop	r31
    135e:	ef 91       	pop	r30
    1360:	bf 91       	pop	r27
    1362:	af 91       	pop	r26
    1364:	9f 91       	pop	r25
    1366:	8f 91       	pop	r24
    1368:	7f 91       	pop	r23
    136a:	6f 91       	pop	r22
    136c:	5f 91       	pop	r21
    136e:	4f 91       	pop	r20
    1370:	3f 91       	pop	r19
    1372:	2f 91       	pop	r18
    1374:	0f 90       	pop	r0
    1376:	0b be       	out	0x3b, r0	; 59
    1378:	0f 90       	pop	r0
    137a:	0f be       	out	0x3f, r0	; 63
    137c:	0f 90       	pop	r0
    137e:	1f 90       	pop	r1
    1380:	18 95       	reti

00001382 <__vector_52>:
    1382:	1f 92       	push	r1
    1384:	0f 92       	push	r0
    1386:	0f b6       	in	r0, 0x3f	; 63
    1388:	0f 92       	push	r0
    138a:	11 24       	eor	r1, r1
    138c:	0b b6       	in	r0, 0x3b	; 59
    138e:	0f 92       	push	r0
    1390:	2f 93       	push	r18
    1392:	3f 93       	push	r19
    1394:	4f 93       	push	r20
    1396:	5f 93       	push	r21
    1398:	6f 93       	push	r22
    139a:	7f 93       	push	r23
    139c:	8f 93       	push	r24
    139e:	9f 93       	push	r25
    13a0:	af 93       	push	r26
    13a2:	bf 93       	push	r27
    13a4:	ef 93       	push	r30
    13a6:	ff 93       	push	r31
    13a8:	e0 91 66 22 	lds	r30, 0x2266	; 0x802266 <tc_tce0_ccd_callback>
    13ac:	f0 91 67 22 	lds	r31, 0x2267	; 0x802267 <tc_tce0_ccd_callback+0x1>
    13b0:	30 97       	sbiw	r30, 0x00	; 0
    13b2:	09 f0       	breq	.+2      	; 0x13b6 <__vector_52+0x34>
    13b4:	19 95       	eicall
    13b6:	ff 91       	pop	r31
    13b8:	ef 91       	pop	r30
    13ba:	bf 91       	pop	r27
    13bc:	af 91       	pop	r26
    13be:	9f 91       	pop	r25
    13c0:	8f 91       	pop	r24
    13c2:	7f 91       	pop	r23
    13c4:	6f 91       	pop	r22
    13c6:	5f 91       	pop	r21
    13c8:	4f 91       	pop	r20
    13ca:	3f 91       	pop	r19
    13cc:	2f 91       	pop	r18
    13ce:	0f 90       	pop	r0
    13d0:	0b be       	out	0x3b, r0	; 59
    13d2:	0f 90       	pop	r0
    13d4:	0f be       	out	0x3f, r0	; 63
    13d6:	0f 90       	pop	r0
    13d8:	1f 90       	pop	r1
    13da:	18 95       	reti

000013dc <__vector_53>:
    13dc:	1f 92       	push	r1
    13de:	0f 92       	push	r0
    13e0:	0f b6       	in	r0, 0x3f	; 63
    13e2:	0f 92       	push	r0
    13e4:	11 24       	eor	r1, r1
    13e6:	0b b6       	in	r0, 0x3b	; 59
    13e8:	0f 92       	push	r0
    13ea:	2f 93       	push	r18
    13ec:	3f 93       	push	r19
    13ee:	4f 93       	push	r20
    13f0:	5f 93       	push	r21
    13f2:	6f 93       	push	r22
    13f4:	7f 93       	push	r23
    13f6:	8f 93       	push	r24
    13f8:	9f 93       	push	r25
    13fa:	af 93       	push	r26
    13fc:	bf 93       	push	r27
    13fe:	ef 93       	push	r30
    1400:	ff 93       	push	r31
    1402:	e0 91 64 22 	lds	r30, 0x2264	; 0x802264 <tc_tce1_ovf_callback>
    1406:	f0 91 65 22 	lds	r31, 0x2265	; 0x802265 <tc_tce1_ovf_callback+0x1>
    140a:	30 97       	sbiw	r30, 0x00	; 0
    140c:	09 f0       	breq	.+2      	; 0x1410 <__vector_53+0x34>
    140e:	19 95       	eicall
    1410:	ff 91       	pop	r31
    1412:	ef 91       	pop	r30
    1414:	bf 91       	pop	r27
    1416:	af 91       	pop	r26
    1418:	9f 91       	pop	r25
    141a:	8f 91       	pop	r24
    141c:	7f 91       	pop	r23
    141e:	6f 91       	pop	r22
    1420:	5f 91       	pop	r21
    1422:	4f 91       	pop	r20
    1424:	3f 91       	pop	r19
    1426:	2f 91       	pop	r18
    1428:	0f 90       	pop	r0
    142a:	0b be       	out	0x3b, r0	; 59
    142c:	0f 90       	pop	r0
    142e:	0f be       	out	0x3f, r0	; 63
    1430:	0f 90       	pop	r0
    1432:	1f 90       	pop	r1
    1434:	18 95       	reti

00001436 <__vector_54>:
    1436:	1f 92       	push	r1
    1438:	0f 92       	push	r0
    143a:	0f b6       	in	r0, 0x3f	; 63
    143c:	0f 92       	push	r0
    143e:	11 24       	eor	r1, r1
    1440:	0b b6       	in	r0, 0x3b	; 59
    1442:	0f 92       	push	r0
    1444:	2f 93       	push	r18
    1446:	3f 93       	push	r19
    1448:	4f 93       	push	r20
    144a:	5f 93       	push	r21
    144c:	6f 93       	push	r22
    144e:	7f 93       	push	r23
    1450:	8f 93       	push	r24
    1452:	9f 93       	push	r25
    1454:	af 93       	push	r26
    1456:	bf 93       	push	r27
    1458:	ef 93       	push	r30
    145a:	ff 93       	push	r31
    145c:	e0 91 62 22 	lds	r30, 0x2262	; 0x802262 <tc_tce1_err_callback>
    1460:	f0 91 63 22 	lds	r31, 0x2263	; 0x802263 <tc_tce1_err_callback+0x1>
    1464:	30 97       	sbiw	r30, 0x00	; 0
    1466:	09 f0       	breq	.+2      	; 0x146a <__vector_54+0x34>
    1468:	19 95       	eicall
    146a:	ff 91       	pop	r31
    146c:	ef 91       	pop	r30
    146e:	bf 91       	pop	r27
    1470:	af 91       	pop	r26
    1472:	9f 91       	pop	r25
    1474:	8f 91       	pop	r24
    1476:	7f 91       	pop	r23
    1478:	6f 91       	pop	r22
    147a:	5f 91       	pop	r21
    147c:	4f 91       	pop	r20
    147e:	3f 91       	pop	r19
    1480:	2f 91       	pop	r18
    1482:	0f 90       	pop	r0
    1484:	0b be       	out	0x3b, r0	; 59
    1486:	0f 90       	pop	r0
    1488:	0f be       	out	0x3f, r0	; 63
    148a:	0f 90       	pop	r0
    148c:	1f 90       	pop	r1
    148e:	18 95       	reti

00001490 <__vector_55>:
    1490:	1f 92       	push	r1
    1492:	0f 92       	push	r0
    1494:	0f b6       	in	r0, 0x3f	; 63
    1496:	0f 92       	push	r0
    1498:	11 24       	eor	r1, r1
    149a:	0b b6       	in	r0, 0x3b	; 59
    149c:	0f 92       	push	r0
    149e:	2f 93       	push	r18
    14a0:	3f 93       	push	r19
    14a2:	4f 93       	push	r20
    14a4:	5f 93       	push	r21
    14a6:	6f 93       	push	r22
    14a8:	7f 93       	push	r23
    14aa:	8f 93       	push	r24
    14ac:	9f 93       	push	r25
    14ae:	af 93       	push	r26
    14b0:	bf 93       	push	r27
    14b2:	ef 93       	push	r30
    14b4:	ff 93       	push	r31
    14b6:	e0 91 60 22 	lds	r30, 0x2260	; 0x802260 <tc_tce1_cca_callback>
    14ba:	f0 91 61 22 	lds	r31, 0x2261	; 0x802261 <tc_tce1_cca_callback+0x1>
    14be:	30 97       	sbiw	r30, 0x00	; 0
    14c0:	09 f0       	breq	.+2      	; 0x14c4 <__vector_55+0x34>
    14c2:	19 95       	eicall
    14c4:	ff 91       	pop	r31
    14c6:	ef 91       	pop	r30
    14c8:	bf 91       	pop	r27
    14ca:	af 91       	pop	r26
    14cc:	9f 91       	pop	r25
    14ce:	8f 91       	pop	r24
    14d0:	7f 91       	pop	r23
    14d2:	6f 91       	pop	r22
    14d4:	5f 91       	pop	r21
    14d6:	4f 91       	pop	r20
    14d8:	3f 91       	pop	r19
    14da:	2f 91       	pop	r18
    14dc:	0f 90       	pop	r0
    14de:	0b be       	out	0x3b, r0	; 59
    14e0:	0f 90       	pop	r0
    14e2:	0f be       	out	0x3f, r0	; 63
    14e4:	0f 90       	pop	r0
    14e6:	1f 90       	pop	r1
    14e8:	18 95       	reti

000014ea <__vector_56>:
    14ea:	1f 92       	push	r1
    14ec:	0f 92       	push	r0
    14ee:	0f b6       	in	r0, 0x3f	; 63
    14f0:	0f 92       	push	r0
    14f2:	11 24       	eor	r1, r1
    14f4:	0b b6       	in	r0, 0x3b	; 59
    14f6:	0f 92       	push	r0
    14f8:	2f 93       	push	r18
    14fa:	3f 93       	push	r19
    14fc:	4f 93       	push	r20
    14fe:	5f 93       	push	r21
    1500:	6f 93       	push	r22
    1502:	7f 93       	push	r23
    1504:	8f 93       	push	r24
    1506:	9f 93       	push	r25
    1508:	af 93       	push	r26
    150a:	bf 93       	push	r27
    150c:	ef 93       	push	r30
    150e:	ff 93       	push	r31
    1510:	e0 91 5e 22 	lds	r30, 0x225E	; 0x80225e <tc_tce1_ccb_callback>
    1514:	f0 91 5f 22 	lds	r31, 0x225F	; 0x80225f <tc_tce1_ccb_callback+0x1>
    1518:	30 97       	sbiw	r30, 0x00	; 0
    151a:	09 f0       	breq	.+2      	; 0x151e <__vector_56+0x34>
    151c:	19 95       	eicall
    151e:	ff 91       	pop	r31
    1520:	ef 91       	pop	r30
    1522:	bf 91       	pop	r27
    1524:	af 91       	pop	r26
    1526:	9f 91       	pop	r25
    1528:	8f 91       	pop	r24
    152a:	7f 91       	pop	r23
    152c:	6f 91       	pop	r22
    152e:	5f 91       	pop	r21
    1530:	4f 91       	pop	r20
    1532:	3f 91       	pop	r19
    1534:	2f 91       	pop	r18
    1536:	0f 90       	pop	r0
    1538:	0b be       	out	0x3b, r0	; 59
    153a:	0f 90       	pop	r0
    153c:	0f be       	out	0x3f, r0	; 63
    153e:	0f 90       	pop	r0
    1540:	1f 90       	pop	r1
    1542:	18 95       	reti

00001544 <__vector_108>:
    1544:	1f 92       	push	r1
    1546:	0f 92       	push	r0
    1548:	0f b6       	in	r0, 0x3f	; 63
    154a:	0f 92       	push	r0
    154c:	11 24       	eor	r1, r1
    154e:	0b b6       	in	r0, 0x3b	; 59
    1550:	0f 92       	push	r0
    1552:	2f 93       	push	r18
    1554:	3f 93       	push	r19
    1556:	4f 93       	push	r20
    1558:	5f 93       	push	r21
    155a:	6f 93       	push	r22
    155c:	7f 93       	push	r23
    155e:	8f 93       	push	r24
    1560:	9f 93       	push	r25
    1562:	af 93       	push	r26
    1564:	bf 93       	push	r27
    1566:	ef 93       	push	r30
    1568:	ff 93       	push	r31
    156a:	e0 91 5c 22 	lds	r30, 0x225C	; 0x80225c <tc_tcf0_ovf_callback>
    156e:	f0 91 5d 22 	lds	r31, 0x225D	; 0x80225d <tc_tcf0_ovf_callback+0x1>
    1572:	30 97       	sbiw	r30, 0x00	; 0
    1574:	09 f0       	breq	.+2      	; 0x1578 <__vector_108+0x34>
    1576:	19 95       	eicall
    1578:	ff 91       	pop	r31
    157a:	ef 91       	pop	r30
    157c:	bf 91       	pop	r27
    157e:	af 91       	pop	r26
    1580:	9f 91       	pop	r25
    1582:	8f 91       	pop	r24
    1584:	7f 91       	pop	r23
    1586:	6f 91       	pop	r22
    1588:	5f 91       	pop	r21
    158a:	4f 91       	pop	r20
    158c:	3f 91       	pop	r19
    158e:	2f 91       	pop	r18
    1590:	0f 90       	pop	r0
    1592:	0b be       	out	0x3b, r0	; 59
    1594:	0f 90       	pop	r0
    1596:	0f be       	out	0x3f, r0	; 63
    1598:	0f 90       	pop	r0
    159a:	1f 90       	pop	r1
    159c:	18 95       	reti

0000159e <__vector_109>:
    159e:	1f 92       	push	r1
    15a0:	0f 92       	push	r0
    15a2:	0f b6       	in	r0, 0x3f	; 63
    15a4:	0f 92       	push	r0
    15a6:	11 24       	eor	r1, r1
    15a8:	0b b6       	in	r0, 0x3b	; 59
    15aa:	0f 92       	push	r0
    15ac:	2f 93       	push	r18
    15ae:	3f 93       	push	r19
    15b0:	4f 93       	push	r20
    15b2:	5f 93       	push	r21
    15b4:	6f 93       	push	r22
    15b6:	7f 93       	push	r23
    15b8:	8f 93       	push	r24
    15ba:	9f 93       	push	r25
    15bc:	af 93       	push	r26
    15be:	bf 93       	push	r27
    15c0:	ef 93       	push	r30
    15c2:	ff 93       	push	r31
    15c4:	e0 91 5a 22 	lds	r30, 0x225A	; 0x80225a <tc_tcf0_err_callback>
    15c8:	f0 91 5b 22 	lds	r31, 0x225B	; 0x80225b <tc_tcf0_err_callback+0x1>
    15cc:	30 97       	sbiw	r30, 0x00	; 0
    15ce:	09 f0       	breq	.+2      	; 0x15d2 <__vector_109+0x34>
    15d0:	19 95       	eicall
    15d2:	ff 91       	pop	r31
    15d4:	ef 91       	pop	r30
    15d6:	bf 91       	pop	r27
    15d8:	af 91       	pop	r26
    15da:	9f 91       	pop	r25
    15dc:	8f 91       	pop	r24
    15de:	7f 91       	pop	r23
    15e0:	6f 91       	pop	r22
    15e2:	5f 91       	pop	r21
    15e4:	4f 91       	pop	r20
    15e6:	3f 91       	pop	r19
    15e8:	2f 91       	pop	r18
    15ea:	0f 90       	pop	r0
    15ec:	0b be       	out	0x3b, r0	; 59
    15ee:	0f 90       	pop	r0
    15f0:	0f be       	out	0x3f, r0	; 63
    15f2:	0f 90       	pop	r0
    15f4:	1f 90       	pop	r1
    15f6:	18 95       	reti

000015f8 <__vector_110>:
    15f8:	1f 92       	push	r1
    15fa:	0f 92       	push	r0
    15fc:	0f b6       	in	r0, 0x3f	; 63
    15fe:	0f 92       	push	r0
    1600:	11 24       	eor	r1, r1
    1602:	0b b6       	in	r0, 0x3b	; 59
    1604:	0f 92       	push	r0
    1606:	2f 93       	push	r18
    1608:	3f 93       	push	r19
    160a:	4f 93       	push	r20
    160c:	5f 93       	push	r21
    160e:	6f 93       	push	r22
    1610:	7f 93       	push	r23
    1612:	8f 93       	push	r24
    1614:	9f 93       	push	r25
    1616:	af 93       	push	r26
    1618:	bf 93       	push	r27
    161a:	ef 93       	push	r30
    161c:	ff 93       	push	r31
    161e:	e0 91 58 22 	lds	r30, 0x2258	; 0x802258 <tc_tcf0_cca_callback>
    1622:	f0 91 59 22 	lds	r31, 0x2259	; 0x802259 <tc_tcf0_cca_callback+0x1>
    1626:	30 97       	sbiw	r30, 0x00	; 0
    1628:	09 f0       	breq	.+2      	; 0x162c <__vector_110+0x34>
    162a:	19 95       	eicall
    162c:	ff 91       	pop	r31
    162e:	ef 91       	pop	r30
    1630:	bf 91       	pop	r27
    1632:	af 91       	pop	r26
    1634:	9f 91       	pop	r25
    1636:	8f 91       	pop	r24
    1638:	7f 91       	pop	r23
    163a:	6f 91       	pop	r22
    163c:	5f 91       	pop	r21
    163e:	4f 91       	pop	r20
    1640:	3f 91       	pop	r19
    1642:	2f 91       	pop	r18
    1644:	0f 90       	pop	r0
    1646:	0b be       	out	0x3b, r0	; 59
    1648:	0f 90       	pop	r0
    164a:	0f be       	out	0x3f, r0	; 63
    164c:	0f 90       	pop	r0
    164e:	1f 90       	pop	r1
    1650:	18 95       	reti

00001652 <__vector_111>:
    1652:	1f 92       	push	r1
    1654:	0f 92       	push	r0
    1656:	0f b6       	in	r0, 0x3f	; 63
    1658:	0f 92       	push	r0
    165a:	11 24       	eor	r1, r1
    165c:	0b b6       	in	r0, 0x3b	; 59
    165e:	0f 92       	push	r0
    1660:	2f 93       	push	r18
    1662:	3f 93       	push	r19
    1664:	4f 93       	push	r20
    1666:	5f 93       	push	r21
    1668:	6f 93       	push	r22
    166a:	7f 93       	push	r23
    166c:	8f 93       	push	r24
    166e:	9f 93       	push	r25
    1670:	af 93       	push	r26
    1672:	bf 93       	push	r27
    1674:	ef 93       	push	r30
    1676:	ff 93       	push	r31
    1678:	e0 91 56 22 	lds	r30, 0x2256	; 0x802256 <tc_tcf0_ccb_callback>
    167c:	f0 91 57 22 	lds	r31, 0x2257	; 0x802257 <tc_tcf0_ccb_callback+0x1>
    1680:	30 97       	sbiw	r30, 0x00	; 0
    1682:	09 f0       	breq	.+2      	; 0x1686 <__vector_111+0x34>
    1684:	19 95       	eicall
    1686:	ff 91       	pop	r31
    1688:	ef 91       	pop	r30
    168a:	bf 91       	pop	r27
    168c:	af 91       	pop	r26
    168e:	9f 91       	pop	r25
    1690:	8f 91       	pop	r24
    1692:	7f 91       	pop	r23
    1694:	6f 91       	pop	r22
    1696:	5f 91       	pop	r21
    1698:	4f 91       	pop	r20
    169a:	3f 91       	pop	r19
    169c:	2f 91       	pop	r18
    169e:	0f 90       	pop	r0
    16a0:	0b be       	out	0x3b, r0	; 59
    16a2:	0f 90       	pop	r0
    16a4:	0f be       	out	0x3f, r0	; 63
    16a6:	0f 90       	pop	r0
    16a8:	1f 90       	pop	r1
    16aa:	18 95       	reti

000016ac <__vector_112>:
    16ac:	1f 92       	push	r1
    16ae:	0f 92       	push	r0
    16b0:	0f b6       	in	r0, 0x3f	; 63
    16b2:	0f 92       	push	r0
    16b4:	11 24       	eor	r1, r1
    16b6:	0b b6       	in	r0, 0x3b	; 59
    16b8:	0f 92       	push	r0
    16ba:	2f 93       	push	r18
    16bc:	3f 93       	push	r19
    16be:	4f 93       	push	r20
    16c0:	5f 93       	push	r21
    16c2:	6f 93       	push	r22
    16c4:	7f 93       	push	r23
    16c6:	8f 93       	push	r24
    16c8:	9f 93       	push	r25
    16ca:	af 93       	push	r26
    16cc:	bf 93       	push	r27
    16ce:	ef 93       	push	r30
    16d0:	ff 93       	push	r31
    16d2:	e0 91 54 22 	lds	r30, 0x2254	; 0x802254 <tc_tcf0_ccc_callback>
    16d6:	f0 91 55 22 	lds	r31, 0x2255	; 0x802255 <tc_tcf0_ccc_callback+0x1>
    16da:	30 97       	sbiw	r30, 0x00	; 0
    16dc:	09 f0       	breq	.+2      	; 0x16e0 <__vector_112+0x34>
    16de:	19 95       	eicall
    16e0:	ff 91       	pop	r31
    16e2:	ef 91       	pop	r30
    16e4:	bf 91       	pop	r27
    16e6:	af 91       	pop	r26
    16e8:	9f 91       	pop	r25
    16ea:	8f 91       	pop	r24
    16ec:	7f 91       	pop	r23
    16ee:	6f 91       	pop	r22
    16f0:	5f 91       	pop	r21
    16f2:	4f 91       	pop	r20
    16f4:	3f 91       	pop	r19
    16f6:	2f 91       	pop	r18
    16f8:	0f 90       	pop	r0
    16fa:	0b be       	out	0x3b, r0	; 59
    16fc:	0f 90       	pop	r0
    16fe:	0f be       	out	0x3f, r0	; 63
    1700:	0f 90       	pop	r0
    1702:	1f 90       	pop	r1
    1704:	18 95       	reti

00001706 <__vector_113>:
    1706:	1f 92       	push	r1
    1708:	0f 92       	push	r0
    170a:	0f b6       	in	r0, 0x3f	; 63
    170c:	0f 92       	push	r0
    170e:	11 24       	eor	r1, r1
    1710:	0b b6       	in	r0, 0x3b	; 59
    1712:	0f 92       	push	r0
    1714:	2f 93       	push	r18
    1716:	3f 93       	push	r19
    1718:	4f 93       	push	r20
    171a:	5f 93       	push	r21
    171c:	6f 93       	push	r22
    171e:	7f 93       	push	r23
    1720:	8f 93       	push	r24
    1722:	9f 93       	push	r25
    1724:	af 93       	push	r26
    1726:	bf 93       	push	r27
    1728:	ef 93       	push	r30
    172a:	ff 93       	push	r31
    172c:	e0 91 52 22 	lds	r30, 0x2252	; 0x802252 <tc_tcf0_ccd_callback>
    1730:	f0 91 53 22 	lds	r31, 0x2253	; 0x802253 <tc_tcf0_ccd_callback+0x1>
    1734:	30 97       	sbiw	r30, 0x00	; 0
    1736:	09 f0       	breq	.+2      	; 0x173a <__vector_113+0x34>
    1738:	19 95       	eicall
    173a:	ff 91       	pop	r31
    173c:	ef 91       	pop	r30
    173e:	bf 91       	pop	r27
    1740:	af 91       	pop	r26
    1742:	9f 91       	pop	r25
    1744:	8f 91       	pop	r24
    1746:	7f 91       	pop	r23
    1748:	6f 91       	pop	r22
    174a:	5f 91       	pop	r21
    174c:	4f 91       	pop	r20
    174e:	3f 91       	pop	r19
    1750:	2f 91       	pop	r18
    1752:	0f 90       	pop	r0
    1754:	0b be       	out	0x3b, r0	; 59
    1756:	0f 90       	pop	r0
    1758:	0f be       	out	0x3f, r0	; 63
    175a:	0f 90       	pop	r0
    175c:	1f 90       	pop	r1
    175e:	18 95       	reti

00001760 <tc_enable>:
    1760:	1f 93       	push	r17
    1762:	cf 93       	push	r28
    1764:	df 93       	push	r29
    1766:	1f 92       	push	r1
    1768:	1f 92       	push	r1
    176a:	cd b7       	in	r28, 0x3d	; 61
    176c:	de b7       	in	r29, 0x3e	; 62
    176e:	2f b7       	in	r18, 0x3f	; 63
    1770:	2a 83       	std	Y+2, r18	; 0x02
    1772:	f8 94       	cli
    1774:	1a 81       	ldd	r17, Y+2	; 0x02
    1776:	28 2f       	mov	r18, r24
    1778:	39 2f       	mov	r19, r25
    177a:	21 15       	cp	r18, r1
    177c:	88 e0       	ldi	r24, 0x08	; 8
    177e:	38 07       	cpc	r19, r24
    1780:	49 f4       	brne	.+18     	; 0x1794 <tc_enable+0x34>
    1782:	61 e0       	ldi	r22, 0x01	; 1
    1784:	83 e0       	ldi	r24, 0x03	; 3
    1786:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    178a:	64 e0       	ldi	r22, 0x04	; 4
    178c:	83 e0       	ldi	r24, 0x03	; 3
    178e:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1792:	4f c0       	rjmp	.+158    	; 0x1832 <tc_enable+0xd2>
    1794:	20 34       	cpi	r18, 0x40	; 64
    1796:	88 e0       	ldi	r24, 0x08	; 8
    1798:	38 07       	cpc	r19, r24
    179a:	49 f4       	brne	.+18     	; 0x17ae <tc_enable+0x4e>
    179c:	62 e0       	ldi	r22, 0x02	; 2
    179e:	83 e0       	ldi	r24, 0x03	; 3
    17a0:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    17a4:	64 e0       	ldi	r22, 0x04	; 4
    17a6:	83 e0       	ldi	r24, 0x03	; 3
    17a8:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    17ac:	42 c0       	rjmp	.+132    	; 0x1832 <tc_enable+0xd2>
    17ae:	21 15       	cp	r18, r1
    17b0:	89 e0       	ldi	r24, 0x09	; 9
    17b2:	38 07       	cpc	r19, r24
    17b4:	49 f4       	brne	.+18     	; 0x17c8 <tc_enable+0x68>
    17b6:	61 e0       	ldi	r22, 0x01	; 1
    17b8:	84 e0       	ldi	r24, 0x04	; 4
    17ba:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    17be:	64 e0       	ldi	r22, 0x04	; 4
    17c0:	84 e0       	ldi	r24, 0x04	; 4
    17c2:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    17c6:	35 c0       	rjmp	.+106    	; 0x1832 <tc_enable+0xd2>
    17c8:	20 34       	cpi	r18, 0x40	; 64
    17ca:	89 e0       	ldi	r24, 0x09	; 9
    17cc:	38 07       	cpc	r19, r24
    17ce:	49 f4       	brne	.+18     	; 0x17e2 <tc_enable+0x82>
    17d0:	62 e0       	ldi	r22, 0x02	; 2
    17d2:	84 e0       	ldi	r24, 0x04	; 4
    17d4:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    17d8:	64 e0       	ldi	r22, 0x04	; 4
    17da:	84 e0       	ldi	r24, 0x04	; 4
    17dc:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    17e0:	28 c0       	rjmp	.+80     	; 0x1832 <tc_enable+0xd2>
    17e2:	21 15       	cp	r18, r1
    17e4:	8a e0       	ldi	r24, 0x0A	; 10
    17e6:	38 07       	cpc	r19, r24
    17e8:	49 f4       	brne	.+18     	; 0x17fc <tc_enable+0x9c>
    17ea:	61 e0       	ldi	r22, 0x01	; 1
    17ec:	85 e0       	ldi	r24, 0x05	; 5
    17ee:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    17f2:	64 e0       	ldi	r22, 0x04	; 4
    17f4:	85 e0       	ldi	r24, 0x05	; 5
    17f6:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    17fa:	1b c0       	rjmp	.+54     	; 0x1832 <tc_enable+0xd2>
    17fc:	20 34       	cpi	r18, 0x40	; 64
    17fe:	8a e0       	ldi	r24, 0x0A	; 10
    1800:	38 07       	cpc	r19, r24
    1802:	49 f4       	brne	.+18     	; 0x1816 <tc_enable+0xb6>
    1804:	62 e0       	ldi	r22, 0x02	; 2
    1806:	85 e0       	ldi	r24, 0x05	; 5
    1808:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    180c:	64 e0       	ldi	r22, 0x04	; 4
    180e:	85 e0       	ldi	r24, 0x05	; 5
    1810:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1814:	0e c0       	rjmp	.+28     	; 0x1832 <tc_enable+0xd2>
    1816:	21 15       	cp	r18, r1
    1818:	3b 40       	sbci	r19, 0x0B	; 11
    181a:	49 f4       	brne	.+18     	; 0x182e <tc_enable+0xce>
    181c:	61 e0       	ldi	r22, 0x01	; 1
    181e:	86 e0       	ldi	r24, 0x06	; 6
    1820:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1824:	64 e0       	ldi	r22, 0x04	; 4
    1826:	86 e0       	ldi	r24, 0x06	; 6
    1828:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    182c:	02 c0       	rjmp	.+4      	; 0x1832 <tc_enable+0xd2>
    182e:	1f bf       	out	0x3f, r17	; 63
    1830:	10 c0       	rjmp	.+32     	; 0x1852 <tc_enable+0xf2>
    1832:	80 91 1a 23 	lds	r24, 0x231A	; 0x80231a <sleepmgr_locks+0x1>
    1836:	8f 3f       	cpi	r24, 0xFF	; 255
    1838:	09 f4       	brne	.+2      	; 0x183c <tc_enable+0xdc>
    183a:	ff cf       	rjmp	.-2      	; 0x183a <tc_enable+0xda>
    183c:	8f b7       	in	r24, 0x3f	; 63
    183e:	89 83       	std	Y+1, r24	; 0x01
    1840:	f8 94       	cli
    1842:	99 81       	ldd	r25, Y+1	; 0x01
    1844:	e9 e1       	ldi	r30, 0x19	; 25
    1846:	f3 e2       	ldi	r31, 0x23	; 35
    1848:	81 81       	ldd	r24, Z+1	; 0x01
    184a:	8f 5f       	subi	r24, 0xFF	; 255
    184c:	81 83       	std	Z+1, r24	; 0x01
    184e:	9f bf       	out	0x3f, r25	; 63
    1850:	1f bf       	out	0x3f, r17	; 63
    1852:	0f 90       	pop	r0
    1854:	0f 90       	pop	r0
    1856:	df 91       	pop	r29
    1858:	cf 91       	pop	r28
    185a:	1f 91       	pop	r17
    185c:	08 95       	ret

0000185e <tc_set_overflow_interrupt_callback>:

void tc_set_overflow_interrupt_callback(volatile void *tc,
		tc_callback_t callback)
{
#ifdef TCC0
	if ((uintptr_t) tc == (uintptr_t) & TCC0) {
    185e:	81 15       	cp	r24, r1
    1860:	28 e0       	ldi	r18, 0x08	; 8
    1862:	92 07       	cpc	r25, r18
    1864:	a1 f1       	breq	.+104    	; 0x18ce <tc_set_overflow_interrupt_callback+0x70>
		tc_tcc0_ovf_callback = callback;
	} else
#endif
#ifdef TCC1
	if ((uintptr_t) tc == (uintptr_t) & TCC1) {
    1866:	80 34       	cpi	r24, 0x40	; 64
    1868:	28 e0       	ldi	r18, 0x08	; 8
    186a:	92 07       	cpc	r25, r18
    186c:	29 f4       	brne	.+10     	; 0x1878 <tc_set_overflow_interrupt_callback+0x1a>
		tc_tcc1_ovf_callback = callback;
    186e:	60 93 8c 22 	sts	0x228C, r22	; 0x80228c <tc_tcc1_ovf_callback>
    1872:	70 93 8d 22 	sts	0x228D, r23	; 0x80228d <tc_tcc1_ovf_callback+0x1>
    1876:	08 95       	ret
	} else
#endif
#ifdef TCD0
	if ((uintptr_t) tc == (uintptr_t) & TCD0) {
    1878:	81 15       	cp	r24, r1
    187a:	29 e0       	ldi	r18, 0x09	; 9
    187c:	92 07       	cpc	r25, r18
    187e:	29 f4       	brne	.+10     	; 0x188a <tc_set_overflow_interrupt_callback+0x2c>
		tc_tcd0_ovf_callback = callback;
    1880:	60 93 84 22 	sts	0x2284, r22	; 0x802284 <tc_tcd0_ovf_callback>
    1884:	70 93 85 22 	sts	0x2285, r23	; 0x802285 <tc_tcd0_ovf_callback+0x1>
    1888:	08 95       	ret
	} else
#endif
#ifdef TCD1
	if ((uintptr_t) tc == (uintptr_t) & TCD1) {
    188a:	80 34       	cpi	r24, 0x40	; 64
    188c:	29 e0       	ldi	r18, 0x09	; 9
    188e:	92 07       	cpc	r25, r18
    1890:	29 f4       	brne	.+10     	; 0x189c <tc_set_overflow_interrupt_callback+0x3e>
		tc_tcd1_ovf_callback = callback;
    1892:	60 93 78 22 	sts	0x2278, r22	; 0x802278 <tc_tcd1_ovf_callback>
    1896:	70 93 79 22 	sts	0x2279, r23	; 0x802279 <tc_tcd1_ovf_callback+0x1>
    189a:	08 95       	ret
	} else
#endif
#ifdef TCE0
	if ((uintptr_t) tc == (uintptr_t) & TCE0) {
    189c:	81 15       	cp	r24, r1
    189e:	2a e0       	ldi	r18, 0x0A	; 10
    18a0:	92 07       	cpc	r25, r18
    18a2:	29 f4       	brne	.+10     	; 0x18ae <tc_set_overflow_interrupt_callback+0x50>
		tc_tce0_ovf_callback = callback;
    18a4:	60 93 70 22 	sts	0x2270, r22	; 0x802270 <tc_tce0_ovf_callback>
    18a8:	70 93 71 22 	sts	0x2271, r23	; 0x802271 <tc_tce0_ovf_callback+0x1>
    18ac:	08 95       	ret
	} else
#endif
#ifdef TCE1
	if ((uintptr_t) tc == (uintptr_t) & TCE1) {
    18ae:	80 34       	cpi	r24, 0x40	; 64
    18b0:	2a e0       	ldi	r18, 0x0A	; 10
    18b2:	92 07       	cpc	r25, r18
    18b4:	29 f4       	brne	.+10     	; 0x18c0 <tc_set_overflow_interrupt_callback+0x62>
		tc_tce1_ovf_callback = callback;
    18b6:	60 93 64 22 	sts	0x2264, r22	; 0x802264 <tc_tce1_ovf_callback>
    18ba:	70 93 65 22 	sts	0x2265, r23	; 0x802265 <tc_tce1_ovf_callback+0x1>
    18be:	08 95       	ret
	} else
#endif
#ifdef TCF0
	if ((uintptr_t) tc == (uintptr_t) & TCF0) {
    18c0:	81 15       	cp	r24, r1
    18c2:	9b 40       	sbci	r25, 0x0B	; 11
    18c4:	21 f4       	brne	.+8      	; 0x18ce <tc_set_overflow_interrupt_callback+0x70>
		tc_tcf0_ovf_callback = callback;
    18c6:	60 93 5c 22 	sts	0x225C, r22	; 0x80225c <tc_tcf0_ovf_callback>
    18ca:	70 93 5d 22 	sts	0x225D, r23	; 0x80225d <tc_tcf0_ovf_callback+0x1>
    18ce:	08 95       	ret

000018d0 <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    18d0:	cf 92       	push	r12
    18d2:	df 92       	push	r13
    18d4:	ef 92       	push	r14
    18d6:	ff 92       	push	r15
    18d8:	0f 93       	push	r16
    18da:	1f 93       	push	r17
    18dc:	cf 93       	push	r28
    18de:	df 93       	push	r29
    18e0:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    18e2:	d9 01       	movw	r26, r18
    18e4:	c8 01       	movw	r24, r16
    18e6:	b6 95       	lsr	r27
    18e8:	a7 95       	ror	r26
    18ea:	97 95       	ror	r25
    18ec:	87 95       	ror	r24
    18ee:	48 17       	cp	r20, r24
    18f0:	59 07       	cpc	r21, r25
    18f2:	6a 07       	cpc	r22, r26
    18f4:	7b 07       	cpc	r23, r27
    18f6:	78 f4       	brcc	.+30     	; 0x1916 <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    18f8:	6a 01       	movw	r12, r20
    18fa:	7b 01       	movw	r14, r22
    18fc:	cc 0c       	add	r12, r12
    18fe:	dd 1c       	adc	r13, r13
    1900:	ee 1c       	adc	r14, r14
    1902:	ff 1c       	adc	r15, r15
    1904:	c9 01       	movw	r24, r18
    1906:	b8 01       	movw	r22, r16
    1908:	a7 01       	movw	r20, r14
    190a:	96 01       	movw	r18, r12
    190c:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <__udivmodsi4>
    1910:	21 50       	subi	r18, 0x01	; 1
    1912:	31 09       	sbc	r19, r1
    1914:	02 c0       	rjmp	.+4      	; 0x191a <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    1916:	20 e0       	ldi	r18, 0x00	; 0
    1918:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    191a:	83 2f       	mov	r24, r19
    191c:	8f 70       	andi	r24, 0x0F	; 15
    191e:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    1920:	2e 83       	std	Y+6, r18	; 0x06
}
    1922:	df 91       	pop	r29
    1924:	cf 91       	pop	r28
    1926:	1f 91       	pop	r17
    1928:	0f 91       	pop	r16
    192a:	ff 90       	pop	r15
    192c:	ef 90       	pop	r14
    192e:	df 90       	pop	r13
    1930:	cf 90       	pop	r12
    1932:	08 95       	ret

00001934 <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1934:	df 92       	push	r13
    1936:	ef 92       	push	r14
    1938:	ff 92       	push	r15
    193a:	0f 93       	push	r16
    193c:	1f 93       	push	r17
    193e:	cf 93       	push	r28
    1940:	df 93       	push	r29
    1942:	1f 92       	push	r1
    1944:	cd b7       	in	r28, 0x3d	; 61
    1946:	de b7       	in	r29, 0x3e	; 62
    1948:	7c 01       	movw	r14, r24
    194a:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    194c:	00 97       	sbiw	r24, 0x00	; 0
    194e:	09 f4       	brne	.+2      	; 0x1952 <usart_init_spi+0x1e>
    1950:	cf c1       	rjmp	.+926    	; 0x1cf0 <usart_init_spi+0x3bc>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1952:	80 3c       	cpi	r24, 0xC0	; 192
    1954:	91 05       	cpc	r25, r1
    1956:	29 f4       	brne	.+10     	; 0x1962 <usart_init_spi+0x2e>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1958:	60 e1       	ldi	r22, 0x10	; 16
    195a:	80 e0       	ldi	r24, 0x00	; 0
    195c:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1960:	c7 c1       	rjmp	.+910    	; 0x1cf0 <usart_init_spi+0x3bc>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1962:	80 e8       	ldi	r24, 0x80	; 128
    1964:	e8 16       	cp	r14, r24
    1966:	81 e0       	ldi	r24, 0x01	; 1
    1968:	f8 06       	cpc	r15, r24
    196a:	29 f4       	brne	.+10     	; 0x1976 <usart_init_spi+0x42>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    196c:	62 e0       	ldi	r22, 0x02	; 2
    196e:	80 e0       	ldi	r24, 0x00	; 0
    1970:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1974:	bd c1       	rjmp	.+890    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    1976:	e1 14       	cp	r14, r1
    1978:	e1 e0       	ldi	r30, 0x01	; 1
    197a:	fe 06       	cpc	r15, r30
    197c:	29 f4       	brne	.+10     	; 0x1988 <usart_init_spi+0x54>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    197e:	61 e0       	ldi	r22, 0x01	; 1
    1980:	80 e0       	ldi	r24, 0x00	; 0
    1982:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1986:	b4 c1       	rjmp	.+872    	; 0x1cf0 <usart_init_spi+0x3bc>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    1988:	f0 e8       	ldi	r31, 0x80	; 128
    198a:	ef 16       	cp	r14, r31
    198c:	f3 e0       	ldi	r31, 0x03	; 3
    198e:	ff 06       	cpc	r15, r31
    1990:	29 f4       	brne	.+10     	; 0x199c <usart_init_spi+0x68>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1992:	61 e0       	ldi	r22, 0x01	; 1
    1994:	81 e0       	ldi	r24, 0x01	; 1
    1996:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    199a:	aa c1       	rjmp	.+852    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    199c:	30 e9       	ldi	r19, 0x90	; 144
    199e:	e3 16       	cp	r14, r19
    19a0:	33 e0       	ldi	r19, 0x03	; 3
    19a2:	f3 06       	cpc	r15, r19
    19a4:	29 f4       	brne	.+10     	; 0x19b0 <usart_init_spi+0x7c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    19a6:	61 e0       	ldi	r22, 0x01	; 1
    19a8:	82 e0       	ldi	r24, 0x02	; 2
    19aa:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    19ae:	a0 c1       	rjmp	.+832    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    19b0:	e1 14       	cp	r14, r1
    19b2:	82 e0       	ldi	r24, 0x02	; 2
    19b4:	f8 06       	cpc	r15, r24
    19b6:	29 f4       	brne	.+10     	; 0x19c2 <usart_init_spi+0x8e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    19b8:	62 e0       	ldi	r22, 0x02	; 2
    19ba:	81 e0       	ldi	r24, 0x01	; 1
    19bc:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    19c0:	97 c1       	rjmp	.+814    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    19c2:	e0 e4       	ldi	r30, 0x40	; 64
    19c4:	ee 16       	cp	r14, r30
    19c6:	e2 e0       	ldi	r30, 0x02	; 2
    19c8:	fe 06       	cpc	r15, r30
    19ca:	29 f4       	brne	.+10     	; 0x19d6 <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    19cc:	62 e0       	ldi	r22, 0x02	; 2
    19ce:	82 e0       	ldi	r24, 0x02	; 2
    19d0:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    19d4:	8d c1       	rjmp	.+794    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    19d6:	f0 e2       	ldi	r31, 0x20	; 32
    19d8:	ef 16       	cp	r14, r31
    19da:	f3 e0       	ldi	r31, 0x03	; 3
    19dc:	ff 06       	cpc	r15, r31
    19de:	29 f4       	brne	.+10     	; 0x19ea <usart_init_spi+0xb6>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    19e0:	64 e0       	ldi	r22, 0x04	; 4
    19e2:	82 e0       	ldi	r24, 0x02	; 2
    19e4:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    19e8:	83 c1       	rjmp	.+774    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    19ea:	e1 14       	cp	r14, r1
    19ec:	38 e0       	ldi	r19, 0x08	; 8
    19ee:	f3 06       	cpc	r15, r19
    19f0:	29 f4       	brne	.+10     	; 0x19fc <usart_init_spi+0xc8>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    19f2:	61 e0       	ldi	r22, 0x01	; 1
    19f4:	83 e0       	ldi	r24, 0x03	; 3
    19f6:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    19fa:	7a c1       	rjmp	.+756    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    19fc:	e1 14       	cp	r14, r1
    19fe:	89 e0       	ldi	r24, 0x09	; 9
    1a00:	f8 06       	cpc	r15, r24
    1a02:	29 f4       	brne	.+10     	; 0x1a0e <usart_init_spi+0xda>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    1a04:	61 e0       	ldi	r22, 0x01	; 1
    1a06:	84 e0       	ldi	r24, 0x04	; 4
    1a08:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1a0c:	71 c1       	rjmp	.+738    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    1a0e:	e1 14       	cp	r14, r1
    1a10:	ea e0       	ldi	r30, 0x0A	; 10
    1a12:	fe 06       	cpc	r15, r30
    1a14:	29 f4       	brne	.+10     	; 0x1a20 <usart_init_spi+0xec>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    1a16:	61 e0       	ldi	r22, 0x01	; 1
    1a18:	85 e0       	ldi	r24, 0x05	; 5
    1a1a:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1a1e:	68 c1       	rjmp	.+720    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1a20:	e1 14       	cp	r14, r1
    1a22:	fb e0       	ldi	r31, 0x0B	; 11
    1a24:	ff 06       	cpc	r15, r31
    1a26:	29 f4       	brne	.+10     	; 0x1a32 <usart_init_spi+0xfe>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    1a28:	61 e0       	ldi	r22, 0x01	; 1
    1a2a:	86 e0       	ldi	r24, 0x06	; 6
    1a2c:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1a30:	5f c1       	rjmp	.+702    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    1a32:	30 e4       	ldi	r19, 0x40	; 64
    1a34:	e3 16       	cp	r14, r19
    1a36:	38 e0       	ldi	r19, 0x08	; 8
    1a38:	f3 06       	cpc	r15, r19
    1a3a:	29 f4       	brne	.+10     	; 0x1a46 <usart_init_spi+0x112>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    1a3c:	62 e0       	ldi	r22, 0x02	; 2
    1a3e:	83 e0       	ldi	r24, 0x03	; 3
    1a40:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1a44:	55 c1       	rjmp	.+682    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    1a46:	80 e4       	ldi	r24, 0x40	; 64
    1a48:	e8 16       	cp	r14, r24
    1a4a:	89 e0       	ldi	r24, 0x09	; 9
    1a4c:	f8 06       	cpc	r15, r24
    1a4e:	29 f4       	brne	.+10     	; 0x1a5a <usart_init_spi+0x126>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    1a50:	62 e0       	ldi	r22, 0x02	; 2
    1a52:	84 e0       	ldi	r24, 0x04	; 4
    1a54:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1a58:	4b c1       	rjmp	.+662    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    1a5a:	e0 e4       	ldi	r30, 0x40	; 64
    1a5c:	ee 16       	cp	r14, r30
    1a5e:	ea e0       	ldi	r30, 0x0A	; 10
    1a60:	fe 06       	cpc	r15, r30
    1a62:	29 f4       	brne	.+10     	; 0x1a6e <usart_init_spi+0x13a>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    1a64:	62 e0       	ldi	r22, 0x02	; 2
    1a66:	85 e0       	ldi	r24, 0x05	; 5
    1a68:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1a6c:	41 c1       	rjmp	.+642    	; 0x1cf0 <usart_init_spi+0x3bc>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    1a6e:	f0 e9       	ldi	r31, 0x90	; 144
    1a70:	ef 16       	cp	r14, r31
    1a72:	f8 e0       	ldi	r31, 0x08	; 8
    1a74:	ff 06       	cpc	r15, r31
    1a76:	29 f4       	brne	.+10     	; 0x1a82 <usart_init_spi+0x14e>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    1a78:	64 e0       	ldi	r22, 0x04	; 4
    1a7a:	83 e0       	ldi	r24, 0x03	; 3
    1a7c:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1a80:	37 c1       	rjmp	.+622    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    1a82:	30 e9       	ldi	r19, 0x90	; 144
    1a84:	e3 16       	cp	r14, r19
    1a86:	39 e0       	ldi	r19, 0x09	; 9
    1a88:	f3 06       	cpc	r15, r19
    1a8a:	29 f4       	brne	.+10     	; 0x1a96 <usart_init_spi+0x162>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    1a8c:	64 e0       	ldi	r22, 0x04	; 4
    1a8e:	84 e0       	ldi	r24, 0x04	; 4
    1a90:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1a94:	2d c1       	rjmp	.+602    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    1a96:	80 e9       	ldi	r24, 0x90	; 144
    1a98:	e8 16       	cp	r14, r24
    1a9a:	8a e0       	ldi	r24, 0x0A	; 10
    1a9c:	f8 06       	cpc	r15, r24
    1a9e:	29 f4       	brne	.+10     	; 0x1aaa <usart_init_spi+0x176>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    1aa0:	64 e0       	ldi	r22, 0x04	; 4
    1aa2:	85 e0       	ldi	r24, 0x05	; 5
    1aa4:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1aa8:	23 c1       	rjmp	.+582    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    1aaa:	e0 e9       	ldi	r30, 0x90	; 144
    1aac:	ee 16       	cp	r14, r30
    1aae:	eb e0       	ldi	r30, 0x0B	; 11
    1ab0:	fe 06       	cpc	r15, r30
    1ab2:	29 f4       	brne	.+10     	; 0x1abe <usart_init_spi+0x18a>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    1ab4:	64 e0       	ldi	r22, 0x04	; 4
    1ab6:	86 e0       	ldi	r24, 0x06	; 6
    1ab8:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1abc:	19 c1       	rjmp	.+562    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    1abe:	f0 ec       	ldi	r31, 0xC0	; 192
    1ac0:	ef 16       	cp	r14, r31
    1ac2:	f8 e0       	ldi	r31, 0x08	; 8
    1ac4:	ff 06       	cpc	r15, r31
    1ac6:	29 f4       	brne	.+10     	; 0x1ad2 <usart_init_spi+0x19e>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    1ac8:	68 e0       	ldi	r22, 0x08	; 8
    1aca:	83 e0       	ldi	r24, 0x03	; 3
    1acc:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1ad0:	0f c1       	rjmp	.+542    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    1ad2:	30 ec       	ldi	r19, 0xC0	; 192
    1ad4:	e3 16       	cp	r14, r19
    1ad6:	39 e0       	ldi	r19, 0x09	; 9
    1ad8:	f3 06       	cpc	r15, r19
    1ada:	29 f4       	brne	.+10     	; 0x1ae6 <usart_init_spi+0x1b2>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1adc:	68 e0       	ldi	r22, 0x08	; 8
    1ade:	84 e0       	ldi	r24, 0x04	; 4
    1ae0:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1ae4:	05 c1       	rjmp	.+522    	; 0x1cf0 <usart_init_spi+0x3bc>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    1ae6:	80 ea       	ldi	r24, 0xA0	; 160
    1ae8:	e8 16       	cp	r14, r24
    1aea:	88 e0       	ldi	r24, 0x08	; 8
    1aec:	f8 06       	cpc	r15, r24
    1aee:	69 f4       	brne	.+26     	; 0x1b0a <usart_init_spi+0x1d6>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1af0:	60 e1       	ldi	r22, 0x10	; 16
    1af2:	83 e0       	ldi	r24, 0x03	; 3
    1af4:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1af8:	e0 ea       	ldi	r30, 0xA0	; 160
    1afa:	f8 e0       	ldi	r31, 0x08	; 8
    1afc:	84 81       	ldd	r24, Z+4	; 0x04
    1afe:	8f 7e       	andi	r24, 0xEF	; 239
    1b00:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1b02:	f8 01       	movw	r30, r16
    1b04:	24 81       	ldd	r18, Z+4	; 0x04
    1b06:	22 50       	subi	r18, 0x02	; 2
    1b08:	53 c0       	rjmp	.+166    	; 0x1bb0 <usart_init_spi+0x27c>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    1b0a:	f0 ea       	ldi	r31, 0xA0	; 160
    1b0c:	ef 16       	cp	r14, r31
    1b0e:	f9 e0       	ldi	r31, 0x09	; 9
    1b10:	ff 06       	cpc	r15, r31
    1b12:	29 f4       	brne	.+10     	; 0x1b1e <usart_init_spi+0x1ea>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1b14:	60 e1       	ldi	r22, 0x10	; 16
    1b16:	84 e0       	ldi	r24, 0x04	; 4
    1b18:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1b1c:	e9 c0       	rjmp	.+466    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    1b1e:	30 ea       	ldi	r19, 0xA0	; 160
    1b20:	e3 16       	cp	r14, r19
    1b22:	3a e0       	ldi	r19, 0x0A	; 10
    1b24:	f3 06       	cpc	r15, r19
    1b26:	29 f4       	brne	.+10     	; 0x1b32 <usart_init_spi+0x1fe>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1b28:	60 e1       	ldi	r22, 0x10	; 16
    1b2a:	85 e0       	ldi	r24, 0x05	; 5
    1b2c:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1b30:	df c0       	rjmp	.+446    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    1b32:	80 ea       	ldi	r24, 0xA0	; 160
    1b34:	e8 16       	cp	r14, r24
    1b36:	8b e0       	ldi	r24, 0x0B	; 11
    1b38:	f8 06       	cpc	r15, r24
    1b3a:	29 f4       	brne	.+10     	; 0x1b46 <usart_init_spi+0x212>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1b3c:	60 e1       	ldi	r22, 0x10	; 16
    1b3e:	86 e0       	ldi	r24, 0x06	; 6
    1b40:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1b44:	d5 c0       	rjmp	.+426    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    1b46:	e0 eb       	ldi	r30, 0xB0	; 176
    1b48:	ee 16       	cp	r14, r30
    1b4a:	e8 e0       	ldi	r30, 0x08	; 8
    1b4c:	fe 06       	cpc	r15, r30
    1b4e:	29 f4       	brne	.+10     	; 0x1b5a <usart_init_spi+0x226>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1b50:	60 e2       	ldi	r22, 0x20	; 32
    1b52:	83 e0       	ldi	r24, 0x03	; 3
    1b54:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1b58:	cb c0       	rjmp	.+406    	; 0x1cf0 <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    1b5a:	f0 eb       	ldi	r31, 0xB0	; 176
    1b5c:	ef 16       	cp	r14, r31
    1b5e:	f9 e0       	ldi	r31, 0x09	; 9
    1b60:	ff 06       	cpc	r15, r31
    1b62:	29 f4       	brne	.+10     	; 0x1b6e <usart_init_spi+0x23a>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1b64:	60 e2       	ldi	r22, 0x20	; 32
    1b66:	84 e0       	ldi	r24, 0x04	; 4
    1b68:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1b6c:	c1 c0       	rjmp	.+386    	; 0x1cf0 <usart_init_spi+0x3bc>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    1b6e:	30 e8       	ldi	r19, 0x80	; 128
    1b70:	e3 16       	cp	r14, r19
    1b72:	34 e0       	ldi	r19, 0x04	; 4
    1b74:	f3 06       	cpc	r15, r19
    1b76:	29 f4       	brne	.+10     	; 0x1b82 <usart_init_spi+0x24e>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1b78:	60 e4       	ldi	r22, 0x40	; 64
    1b7a:	83 e0       	ldi	r24, 0x03	; 3
    1b7c:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1b80:	b7 c0       	rjmp	.+366    	; 0x1cf0 <usart_init_spi+0x3bc>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1b82:	80 ea       	ldi	r24, 0xA0	; 160
    1b84:	e8 16       	cp	r14, r24
    1b86:	84 e0       	ldi	r24, 0x04	; 4
    1b88:	f8 06       	cpc	r15, r24
    1b8a:	29 f4       	brne	.+10     	; 0x1b96 <usart_init_spi+0x262>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1b8c:	60 e4       	ldi	r22, 0x40	; 64
    1b8e:	85 e0       	ldi	r24, 0x05	; 5
    1b90:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <sysclk_enable_module>
    1b94:	ad c0       	rjmp	.+346    	; 0x1cf0 <usart_init_spi+0x3bc>
    1b96:	f7 01       	movw	r30, r14
    1b98:	84 81       	ldd	r24, Z+4	; 0x04
    1b9a:	8f 7e       	andi	r24, 0xEF	; 239
    1b9c:	84 83       	std	Z+4, r24	; 0x04
    1b9e:	fb 01       	movw	r30, r22
    1ba0:	24 81       	ldd	r18, Z+4	; 0x04
    1ba2:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1ba4:	c7 01       	movw	r24, r14
    1ba6:	f0 ea       	ldi	r31, 0xA0	; 160
    1ba8:	ef 16       	cp	r14, r31
    1baa:	f8 e0       	ldi	r31, 0x08	; 8
    1bac:	ff 06       	cpc	r15, r31
    1bae:	49 f4       	brne	.+18     	; 0x1bc2 <usart_init_spi+0x28e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    1bb0:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <__TEXT_REGION_LENGTH__+0x70064e>
    1bb4:	84 fd       	sbrc	r24, 4
    1bb6:	a5 c0       	rjmp	.+330    	; 0x1d02 <usart_init_spi+0x3ce>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    1bb8:	0f 2e       	mov	r0, r31
    1bba:	f1 e1       	ldi	r31, 0x11	; 17
    1bbc:	df 2e       	mov	r13, r31
    1bbe:	f0 2d       	mov	r31, r0
    1bc0:	a4 c0       	rjmp	.+328    	; 0x1d0a <usart_init_spi+0x3d6>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    1bc2:	80 3b       	cpi	r24, 0xB0	; 176
    1bc4:	38 e0       	ldi	r19, 0x08	; 8
    1bc6:	93 07       	cpc	r25, r19
    1bc8:	91 f0       	breq	.+36     	; 0x1bee <usart_init_spi+0x2ba>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    1bca:	80 3a       	cpi	r24, 0xA0	; 160
    1bcc:	e9 e0       	ldi	r30, 0x09	; 9
    1bce:	9e 07       	cpc	r25, r30
    1bd0:	49 f4       	brne	.+18     	; 0x1be4 <usart_init_spi+0x2b0>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    1bd2:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
    1bd6:	34 fd       	sbrc	r19, 4
    1bd8:	9b c0       	rjmp	.+310    	; 0x1d10 <usart_init_spi+0x3dc>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    1bda:	0f 2e       	mov	r0, r31
    1bdc:	f9 e1       	ldi	r31, 0x19	; 25
    1bde:	df 2e       	mov	r13, r31
    1be0:	f0 2d       	mov	r31, r0
    1be2:	16 c0       	rjmp	.+44     	; 0x1c10 <usart_init_spi+0x2dc>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    1be4:	80 3b       	cpi	r24, 0xB0	; 176
    1be6:	f9 e0       	ldi	r31, 0x09	; 9
    1be8:	9f 07       	cpc	r25, r31
    1bea:	f1 f0       	breq	.+60     	; 0x1c28 <usart_init_spi+0x2f4>
    1bec:	04 c0       	rjmp	.+8      	; 0x1bf6 <usart_init_spi+0x2c2>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1bee:	0f 2e       	mov	r0, r31
    1bf0:	f5 e1       	ldi	r31, 0x15	; 21
    1bf2:	df 2e       	mov	r13, r31
    1bf4:	f0 2d       	mov	r31, r0
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    1bf6:	80 3a       	cpi	r24, 0xA0	; 160
    1bf8:	3a e0       	ldi	r19, 0x0A	; 10
    1bfa:	93 07       	cpc	r25, r19
    1bfc:	49 f4       	brne	.+18     	; 0x1c10 <usart_init_spi+0x2dc>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    1bfe:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__TEXT_REGION_LENGTH__+0x70068e>
    1c02:	84 fd       	sbrc	r24, 4
    1c04:	8a c0       	rjmp	.+276    	; 0x1d1a <usart_init_spi+0x3e6>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    1c06:	0f 2e       	mov	r0, r31
    1c08:	f1 e2       	ldi	r31, 0x21	; 33
    1c0a:	df 2e       	mov	r13, r31
    1c0c:	f0 2d       	mov	r31, r0
    1c0e:	15 c0       	rjmp	.+42     	; 0x1c3a <usart_init_spi+0x306>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    1c10:	80 3a       	cpi	r24, 0xA0	; 160
    1c12:	9b 40       	sbci	r25, 0x0B	; 11
    1c14:	91 f4       	brne	.+36     	; 0x1c3a <usart_init_spi+0x306>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    1c16:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <__TEXT_REGION_LENGTH__+0x7006ae>
    1c1a:	84 fd       	sbrc	r24, 4
    1c1c:	0a c0       	rjmp	.+20     	; 0x1c32 <usart_init_spi+0x2fe>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    1c1e:	0f 2e       	mov	r0, r31
    1c20:	f9 e2       	ldi	r31, 0x29	; 41
    1c22:	df 2e       	mov	r13, r31
    1c24:	f0 2d       	mov	r31, r0
    1c26:	09 c0       	rjmp	.+18     	; 0x1c3a <usart_init_spi+0x306>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    1c28:	0f 2e       	mov	r0, r31
    1c2a:	fd e1       	ldi	r31, 0x1D	; 29
    1c2c:	df 2e       	mov	r13, r31
    1c2e:	f0 2d       	mov	r31, r0
    1c30:	04 c0       	rjmp	.+8      	; 0x1c3a <usart_init_spi+0x306>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    1c32:	0f 2e       	mov	r0, r31
    1c34:	fd e2       	ldi	r31, 0x2D	; 45
    1c36:	df 2e       	mov	r13, r31
    1c38:	f0 2d       	mov	r31, r0
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    1c3a:	ed 2d       	mov	r30, r13
    1c3c:	e6 95       	lsr	r30
    1c3e:	e6 95       	lsr	r30
    1c40:	e6 95       	lsr	r30
    1c42:	30 e2       	ldi	r19, 0x20	; 32
    1c44:	e3 9f       	mul	r30, r19
    1c46:	f0 01       	movw	r30, r0
    1c48:	11 24       	eor	r1, r1
    1c4a:	fa 5f       	subi	r31, 0xFA	; 250
    1c4c:	3d 2d       	mov	r19, r13
    1c4e:	37 70       	andi	r19, 0x07	; 7
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    1c50:	81 e0       	ldi	r24, 0x01	; 1
    1c52:	90 e0       	ldi	r25, 0x00	; 0
    1c54:	03 2e       	mov	r0, r19
    1c56:	02 c0       	rjmp	.+4      	; 0x1c5c <usart_init_spi+0x328>
    1c58:	88 0f       	add	r24, r24
    1c5a:	99 1f       	adc	r25, r25
    1c5c:	0a 94       	dec	r0
    1c5e:	e2 f7       	brpl	.-8      	; 0x1c58 <usart_init_spi+0x324>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    1c60:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    1c62:	22 30       	cpi	r18, 0x02	; 2
    1c64:	10 f0       	brcs	.+4      	; 0x1c6a <usart_init_spi+0x336>
    1c66:	40 e0       	ldi	r20, 0x00	; 0
    1c68:	01 c0       	rjmp	.+2      	; 0x1c6c <usart_init_spi+0x338>
    1c6a:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    1c6c:	df 01       	movw	r26, r30
    1c6e:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    1c70:	a3 0f       	add	r26, r19
    1c72:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    1c74:	9f b7       	in	r25, 0x3f	; 63
    1c76:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
    1c78:	f8 94       	cli
	return flags;
    1c7a:	39 81       	ldd	r19, Y+1	; 0x01
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    1c7c:	2c 91       	ld	r18, X
    1c7e:	27 70       	andi	r18, 0x07	; 7
    1c80:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    1c82:	9c 91       	ld	r25, X
    1c84:	94 2b       	or	r25, r20
    1c86:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1c88:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    1c8a:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    1c8c:	f7 01       	movw	r30, r14
    1c8e:	85 81       	ldd	r24, Z+5	; 0x05
    1c90:	80 6c       	ori	r24, 0xC0	; 192
    1c92:	85 83       	std	Z+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    1c94:	f8 01       	movw	r30, r16
    1c96:	84 81       	ldd	r24, Z+4	; 0x04
    1c98:	8d 7f       	andi	r24, 0xFD	; 253
    1c9a:	81 30       	cpi	r24, 0x01	; 1
    1c9c:	29 f4       	brne	.+10     	; 0x1ca8 <usart_init_spi+0x374>
		usart->CTRLC |= USART_UCPHA_bm;
    1c9e:	f7 01       	movw	r30, r14
    1ca0:	85 81       	ldd	r24, Z+5	; 0x05
    1ca2:	82 60       	ori	r24, 0x02	; 2
    1ca4:	85 83       	std	Z+5, r24	; 0x05
    1ca6:	04 c0       	rjmp	.+8      	; 0x1cb0 <usart_init_spi+0x37c>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    1ca8:	f7 01       	movw	r30, r14
    1caa:	85 81       	ldd	r24, Z+5	; 0x05
    1cac:	8d 7f       	andi	r24, 0xFD	; 253
    1cae:	85 83       	std	Z+5, r24	; 0x05
	}
	if (opt->data_order) {
    1cb0:	f8 01       	movw	r30, r16
    1cb2:	85 81       	ldd	r24, Z+5	; 0x05
    1cb4:	88 23       	and	r24, r24
    1cb6:	29 f0       	breq	.+10     	; 0x1cc2 <usart_init_spi+0x38e>
		(usart)->CTRLC |= USART_DORD_bm;
    1cb8:	f7 01       	movw	r30, r14
    1cba:	85 81       	ldd	r24, Z+5	; 0x05
    1cbc:	84 60       	ori	r24, 0x04	; 4
    1cbe:	85 83       	std	Z+5, r24	; 0x05
    1cc0:	04 c0       	rjmp	.+8      	; 0x1cca <usart_init_spi+0x396>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    1cc2:	f7 01       	movw	r30, r14
    1cc4:	85 81       	ldd	r24, Z+5	; 0x05
    1cc6:	8b 7f       	andi	r24, 0xFB	; 251
    1cc8:	85 83       	std	Z+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    1cca:	f8 01       	movw	r30, r16
    1ccc:	40 81       	ld	r20, Z
    1cce:	51 81       	ldd	r21, Z+1	; 0x01
    1cd0:	62 81       	ldd	r22, Z+2	; 0x02
    1cd2:	73 81       	ldd	r23, Z+3	; 0x03
    1cd4:	00 e8       	ldi	r16, 0x80	; 128
    1cd6:	14 e8       	ldi	r17, 0x84	; 132
    1cd8:	2e e1       	ldi	r18, 0x1E	; 30
    1cda:	30 e0       	ldi	r19, 0x00	; 0
    1cdc:	c7 01       	movw	r24, r14
    1cde:	f8 dd       	rcall	.-1040   	; 0x18d0 <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    1ce0:	f7 01       	movw	r30, r14
    1ce2:	84 81       	ldd	r24, Z+4	; 0x04
    1ce4:	88 60       	ori	r24, 0x08	; 8
    1ce6:	84 83       	std	Z+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    1ce8:	84 81       	ldd	r24, Z+4	; 0x04
    1cea:	80 61       	ori	r24, 0x10	; 16
    1cec:	84 83       	std	Z+4, r24	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    1cee:	1a c0       	rjmp	.+52     	; 0x1d24 <usart_init_spi+0x3f0>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1cf0:	f7 01       	movw	r30, r14
    1cf2:	84 81       	ldd	r24, Z+4	; 0x04
    1cf4:	8f 7e       	andi	r24, 0xEF	; 239
    1cf6:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1cf8:	f8 01       	movw	r30, r16
    1cfa:	24 81       	ldd	r18, Z+4	; 0x04
    1cfc:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1cfe:	c7 01       	movw	r24, r14
    1d00:	60 cf       	rjmp	.-320    	; 0x1bc2 <usart_init_spi+0x28e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1d02:	0f 2e       	mov	r0, r31
    1d04:	f5 e1       	ldi	r31, 0x15	; 21
    1d06:	df 2e       	mov	r13, r31
    1d08:	f0 2d       	mov	r31, r0
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1d0a:	80 ea       	ldi	r24, 0xA0	; 160
    1d0c:	98 e0       	ldi	r25, 0x08	; 8
    1d0e:	6a cf       	rjmp	.-300    	; 0x1be4 <usart_init_spi+0x2b0>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    1d10:	0f 2e       	mov	r0, r31
    1d12:	fd e1       	ldi	r31, 0x1D	; 29
    1d14:	df 2e       	mov	r13, r31
    1d16:	f0 2d       	mov	r31, r0
    1d18:	7b cf       	rjmp	.-266    	; 0x1c10 <usart_init_spi+0x2dc>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    1d1a:	0f 2e       	mov	r0, r31
    1d1c:	f5 e2       	ldi	r31, 0x25	; 37
    1d1e:	df 2e       	mov	r13, r31
    1d20:	f0 2d       	mov	r31, r0
    1d22:	8b cf       	rjmp	.-234    	; 0x1c3a <usart_init_spi+0x306>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    1d24:	0f 90       	pop	r0
    1d26:	df 91       	pop	r29
    1d28:	cf 91       	pop	r28
    1d2a:	1f 91       	pop	r17
    1d2c:	0f 91       	pop	r16
    1d2e:	ff 90       	pop	r15
    1d30:	ef 90       	pop	r14
    1d32:	df 90       	pop	r13
    1d34:	08 95       	ret

00001d36 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1d36:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1d38:	03 96       	adiw	r24, 0x03	; 3
    1d3a:	81 83       	std	Z+1, r24	; 0x01
    1d3c:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1d3e:	2f ef       	ldi	r18, 0xFF	; 255
    1d40:	3f ef       	ldi	r19, 0xFF	; 255
    1d42:	23 83       	std	Z+3, r18	; 0x03
    1d44:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1d46:	85 83       	std	Z+5, r24	; 0x05
    1d48:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1d4a:	87 83       	std	Z+7, r24	; 0x07
    1d4c:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1d4e:	10 82       	st	Z, r1
    1d50:	08 95       	ret

00001d52 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1d52:	fc 01       	movw	r30, r24
    1d54:	10 86       	std	Z+8, r1	; 0x08
    1d56:	11 86       	std	Z+9, r1	; 0x09
    1d58:	08 95       	ret

00001d5a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1d5a:	cf 93       	push	r28
    1d5c:	df 93       	push	r29
    1d5e:	9c 01       	movw	r18, r24
    1d60:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1d62:	dc 01       	movw	r26, r24
    1d64:	11 96       	adiw	r26, 0x01	; 1
    1d66:	cd 91       	ld	r28, X+
    1d68:	dc 91       	ld	r29, X
    1d6a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1d6c:	c2 83       	std	Z+2, r28	; 0x02
    1d6e:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1d70:	8c 81       	ldd	r24, Y+4	; 0x04
    1d72:	9d 81       	ldd	r25, Y+5	; 0x05
    1d74:	84 83       	std	Z+4, r24	; 0x04
    1d76:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1d78:	8c 81       	ldd	r24, Y+4	; 0x04
    1d7a:	9d 81       	ldd	r25, Y+5	; 0x05
    1d7c:	dc 01       	movw	r26, r24
    1d7e:	12 96       	adiw	r26, 0x02	; 2
    1d80:	6d 93       	st	X+, r22
    1d82:	7c 93       	st	X, r23
    1d84:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    1d86:	6c 83       	std	Y+4, r22	; 0x04
    1d88:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1d8a:	20 87       	std	Z+8, r18	; 0x08
    1d8c:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    1d8e:	f9 01       	movw	r30, r18
    1d90:	80 81       	ld	r24, Z
    1d92:	8f 5f       	subi	r24, 0xFF	; 255
    1d94:	80 83       	st	Z, r24
}
    1d96:	df 91       	pop	r29
    1d98:	cf 91       	pop	r28
    1d9a:	08 95       	ret

00001d9c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1d9c:	cf 93       	push	r28
    1d9e:	df 93       	push	r29
    1da0:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1da2:	48 81       	ld	r20, Y
    1da4:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1da6:	4f 3f       	cpi	r20, 0xFF	; 255
    1da8:	2f ef       	ldi	r18, 0xFF	; 255
    1daa:	52 07       	cpc	r21, r18
    1dac:	21 f4       	brne	.+8      	; 0x1db6 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1dae:	fc 01       	movw	r30, r24
    1db0:	a7 81       	ldd	r26, Z+7	; 0x07
    1db2:	b0 85       	ldd	r27, Z+8	; 0x08
    1db4:	0d c0       	rjmp	.+26     	; 0x1dd0 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1db6:	dc 01       	movw	r26, r24
    1db8:	13 96       	adiw	r26, 0x03	; 3
    1dba:	01 c0       	rjmp	.+2      	; 0x1dbe <vListInsert+0x22>
    1dbc:	df 01       	movw	r26, r30
    1dbe:	12 96       	adiw	r26, 0x02	; 2
    1dc0:	ed 91       	ld	r30, X+
    1dc2:	fc 91       	ld	r31, X
    1dc4:	13 97       	sbiw	r26, 0x03	; 3
    1dc6:	20 81       	ld	r18, Z
    1dc8:	31 81       	ldd	r19, Z+1	; 0x01
    1dca:	42 17       	cp	r20, r18
    1dcc:	53 07       	cpc	r21, r19
    1dce:	b0 f7       	brcc	.-20     	; 0x1dbc <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1dd0:	12 96       	adiw	r26, 0x02	; 2
    1dd2:	ed 91       	ld	r30, X+
    1dd4:	fc 91       	ld	r31, X
    1dd6:	13 97       	sbiw	r26, 0x03	; 3
    1dd8:	ea 83       	std	Y+2, r30	; 0x02
    1dda:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1ddc:	c4 83       	std	Z+4, r28	; 0x04
    1dde:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    1de0:	ac 83       	std	Y+4, r26	; 0x04
    1de2:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    1de4:	12 96       	adiw	r26, 0x02	; 2
    1de6:	cd 93       	st	X+, r28
    1de8:	dc 93       	st	X, r29
    1dea:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1dec:	88 87       	std	Y+8, r24	; 0x08
    1dee:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    1df0:	fc 01       	movw	r30, r24
    1df2:	20 81       	ld	r18, Z
    1df4:	2f 5f       	subi	r18, 0xFF	; 255
    1df6:	20 83       	st	Z, r18
}
    1df8:	df 91       	pop	r29
    1dfa:	cf 91       	pop	r28
    1dfc:	08 95       	ret

00001dfe <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1dfe:	cf 93       	push	r28
    1e00:	df 93       	push	r29
    1e02:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1e04:	a0 85       	ldd	r26, Z+8	; 0x08
    1e06:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1e08:	c2 81       	ldd	r28, Z+2	; 0x02
    1e0a:	d3 81       	ldd	r29, Z+3	; 0x03
    1e0c:	84 81       	ldd	r24, Z+4	; 0x04
    1e0e:	95 81       	ldd	r25, Z+5	; 0x05
    1e10:	8c 83       	std	Y+4, r24	; 0x04
    1e12:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1e14:	c4 81       	ldd	r28, Z+4	; 0x04
    1e16:	d5 81       	ldd	r29, Z+5	; 0x05
    1e18:	82 81       	ldd	r24, Z+2	; 0x02
    1e1a:	93 81       	ldd	r25, Z+3	; 0x03
    1e1c:	8a 83       	std	Y+2, r24	; 0x02
    1e1e:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1e20:	11 96       	adiw	r26, 0x01	; 1
    1e22:	8d 91       	ld	r24, X+
    1e24:	9c 91       	ld	r25, X
    1e26:	12 97       	sbiw	r26, 0x02	; 2
    1e28:	e8 17       	cp	r30, r24
    1e2a:	f9 07       	cpc	r31, r25
    1e2c:	31 f4       	brne	.+12     	; 0x1e3a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1e2e:	84 81       	ldd	r24, Z+4	; 0x04
    1e30:	95 81       	ldd	r25, Z+5	; 0x05
    1e32:	11 96       	adiw	r26, 0x01	; 1
    1e34:	8d 93       	st	X+, r24
    1e36:	9c 93       	st	X, r25
    1e38:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1e3a:	10 86       	std	Z+8, r1	; 0x08
    1e3c:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    1e3e:	8c 91       	ld	r24, X
    1e40:	81 50       	subi	r24, 0x01	; 1
    1e42:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1e44:	8c 91       	ld	r24, X
}
    1e46:	df 91       	pop	r29
    1e48:	cf 91       	pop	r28
    1e4a:	08 95       	ret

00001e4c <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1e4c:	0f 93       	push	r16
    1e4e:	1f 93       	push	r17
    1e50:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    1e52:	71 e1       	ldi	r23, 0x11	; 17
    1e54:	fc 01       	movw	r30, r24
    1e56:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    1e58:	31 97       	sbiw	r30, 0x01	; 1
    1e5a:	62 e2       	ldi	r22, 0x22	; 34
    1e5c:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    1e5e:	31 97       	sbiw	r30, 0x01	; 1
    1e60:	23 e3       	ldi	r18, 0x33	; 51
    1e62:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    1e64:	01 2e       	mov	r0, r17
    1e66:	00 0c       	add	r0, r0
    1e68:	22 0b       	sbc	r18, r18
    1e6a:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1e6c:	31 97       	sbiw	r30, 0x01	; 1
    1e6e:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1e70:	31 97       	sbiw	r30, 0x01	; 1
    1e72:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1e74:	31 97       	sbiw	r30, 0x01	; 1
    1e76:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    1e78:	31 97       	sbiw	r30, 0x01	; 1
    1e7a:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    1e7c:	31 97       	sbiw	r30, 0x01	; 1
    1e7e:	20 e8       	ldi	r18, 0x80	; 128
    1e80:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    1e82:	31 97       	sbiw	r30, 0x01	; 1
    1e84:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    1e86:	31 97       	sbiw	r30, 0x01	; 1
    1e88:	22 e0       	ldi	r18, 0x02	; 2
    1e8a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    1e8c:	31 97       	sbiw	r30, 0x01	; 1
    1e8e:	23 e0       	ldi	r18, 0x03	; 3
    1e90:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    1e92:	31 97       	sbiw	r30, 0x01	; 1
    1e94:	24 e0       	ldi	r18, 0x04	; 4
    1e96:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    1e98:	31 97       	sbiw	r30, 0x01	; 1
    1e9a:	25 e0       	ldi	r18, 0x05	; 5
    1e9c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    1e9e:	31 97       	sbiw	r30, 0x01	; 1
    1ea0:	26 e0       	ldi	r18, 0x06	; 6
    1ea2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    1ea4:	31 97       	sbiw	r30, 0x01	; 1
    1ea6:	27 e0       	ldi	r18, 0x07	; 7
    1ea8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    1eaa:	31 97       	sbiw	r30, 0x01	; 1
    1eac:	28 e0       	ldi	r18, 0x08	; 8
    1eae:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    1eb0:	31 97       	sbiw	r30, 0x01	; 1
    1eb2:	29 e0       	ldi	r18, 0x09	; 9
    1eb4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    1eb6:	31 97       	sbiw	r30, 0x01	; 1
    1eb8:	20 e1       	ldi	r18, 0x10	; 16
    1eba:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    1ebc:	31 97       	sbiw	r30, 0x01	; 1
    1ebe:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    1ec0:	31 97       	sbiw	r30, 0x01	; 1
    1ec2:	22 e1       	ldi	r18, 0x12	; 18
    1ec4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    1ec6:	31 97       	sbiw	r30, 0x01	; 1
    1ec8:	23 e1       	ldi	r18, 0x13	; 19
    1eca:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    1ecc:	31 97       	sbiw	r30, 0x01	; 1
    1ece:	24 e1       	ldi	r18, 0x14	; 20
    1ed0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    1ed2:	31 97       	sbiw	r30, 0x01	; 1
    1ed4:	25 e1       	ldi	r18, 0x15	; 21
    1ed6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    1ed8:	31 97       	sbiw	r30, 0x01	; 1
    1eda:	26 e1       	ldi	r18, 0x16	; 22
    1edc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    1ede:	31 97       	sbiw	r30, 0x01	; 1
    1ee0:	27 e1       	ldi	r18, 0x17	; 23
    1ee2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    1ee4:	31 97       	sbiw	r30, 0x01	; 1
    1ee6:	28 e1       	ldi	r18, 0x18	; 24
    1ee8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    1eea:	31 97       	sbiw	r30, 0x01	; 1
    1eec:	29 e1       	ldi	r18, 0x19	; 25
    1eee:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    1ef0:	31 97       	sbiw	r30, 0x01	; 1
    1ef2:	20 e2       	ldi	r18, 0x20	; 32
    1ef4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    1ef6:	31 97       	sbiw	r30, 0x01	; 1
    1ef8:	21 e2       	ldi	r18, 0x21	; 33
    1efa:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    1efc:	31 97       	sbiw	r30, 0x01	; 1
    1efe:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    1f00:	31 97       	sbiw	r30, 0x01	; 1
    1f02:	23 e2       	ldi	r18, 0x23	; 35
    1f04:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1f06:	31 97       	sbiw	r30, 0x01	; 1
    1f08:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1f0a:	31 97       	sbiw	r30, 0x01	; 1
    1f0c:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    1f0e:	31 97       	sbiw	r30, 0x01	; 1
    1f10:	26 e2       	ldi	r18, 0x26	; 38
    1f12:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    1f14:	31 97       	sbiw	r30, 0x01	; 1
    1f16:	27 e2       	ldi	r18, 0x27	; 39
    1f18:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    1f1a:	31 97       	sbiw	r30, 0x01	; 1
    1f1c:	28 e2       	ldi	r18, 0x28	; 40
    1f1e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    1f20:	31 97       	sbiw	r30, 0x01	; 1
    1f22:	29 e2       	ldi	r18, 0x29	; 41
    1f24:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    1f26:	31 97       	sbiw	r30, 0x01	; 1
    1f28:	20 e3       	ldi	r18, 0x30	; 48
    1f2a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    1f2c:	31 97       	sbiw	r30, 0x01	; 1
    1f2e:	21 e3       	ldi	r18, 0x31	; 49
    1f30:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    1f32:	87 97       	sbiw	r24, 0x27	; 39
    1f34:	1f 91       	pop	r17
    1f36:	0f 91       	pop	r16
    1f38:	08 95       	ret

00001f3a <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    1f3a:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    1f3c:	e0 e7       	ldi	r30, 0x70	; 112
    1f3e:	f0 e0       	ldi	r31, 0x00	; 0
    1f40:	83 81       	ldd	r24, Z+3	; 0x03
    1f42:	8a 7f       	andi	r24, 0xFA	; 250
    1f44:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    1f46:	e0 e0       	ldi	r30, 0x00	; 0
    1f48:	f8 e0       	ldi	r31, 0x08	; 8
    1f4a:	80 e0       	ldi	r24, 0x00	; 0
    1f4c:	9a ef       	ldi	r25, 0xFA	; 250
    1f4e:	86 a3       	std	Z+38, r24	; 0x26
    1f50:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    1f52:	91 e0       	ldi	r25, 0x01	; 1
    1f54:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1f56:	a0 ea       	ldi	r26, 0xA0	; 160
    1f58:	b0 e0       	ldi	r27, 0x00	; 0
    1f5a:	12 96       	adiw	r26, 0x02	; 2
    1f5c:	8c 91       	ld	r24, X
    1f5e:	12 97       	sbiw	r26, 0x02	; 2
    1f60:	81 60       	ori	r24, 0x01	; 1
    1f62:	12 96       	adiw	r26, 0x02	; 2
    1f64:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    1f66:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    1f68:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    1f6a:	a0 91 f3 22 	lds	r26, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    1f6e:	b0 91 f4 22 	lds	r27, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    1f72:	0d 90       	ld	r0, X+
    1f74:	0d be       	out	0x3d, r0	; 61
    1f76:	0d 90       	ld	r0, X+
    1f78:	0e be       	out	0x3e, r0	; 62
    1f7a:	ff 91       	pop	r31
    1f7c:	ef 91       	pop	r30
    1f7e:	df 91       	pop	r29
    1f80:	cf 91       	pop	r28
    1f82:	bf 91       	pop	r27
    1f84:	af 91       	pop	r26
    1f86:	9f 91       	pop	r25
    1f88:	8f 91       	pop	r24
    1f8a:	7f 91       	pop	r23
    1f8c:	6f 91       	pop	r22
    1f8e:	5f 91       	pop	r21
    1f90:	4f 91       	pop	r20
    1f92:	3f 91       	pop	r19
    1f94:	2f 91       	pop	r18
    1f96:	1f 91       	pop	r17
    1f98:	0f 91       	pop	r16
    1f9a:	ff 90       	pop	r15
    1f9c:	ef 90       	pop	r14
    1f9e:	df 90       	pop	r13
    1fa0:	cf 90       	pop	r12
    1fa2:	bf 90       	pop	r11
    1fa4:	af 90       	pop	r10
    1fa6:	9f 90       	pop	r9
    1fa8:	8f 90       	pop	r8
    1faa:	7f 90       	pop	r7
    1fac:	6f 90       	pop	r6
    1fae:	5f 90       	pop	r5
    1fb0:	4f 90       	pop	r4
    1fb2:	3f 90       	pop	r3
    1fb4:	2f 90       	pop	r2
    1fb6:	1f 90       	pop	r1
    1fb8:	0f 90       	pop	r0
    1fba:	0f be       	out	0x3f, r0	; 63
    1fbc:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    1fbe:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    1fc0:	81 e0       	ldi	r24, 0x01	; 1
    1fc2:	08 95       	ret

00001fc4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    1fc4:	0f 92       	push	r0
    1fc6:	0f b6       	in	r0, 0x3f	; 63
    1fc8:	f8 94       	cli
    1fca:	0f 92       	push	r0
    1fcc:	1f 92       	push	r1
    1fce:	11 24       	eor	r1, r1
    1fd0:	2f 92       	push	r2
    1fd2:	3f 92       	push	r3
    1fd4:	4f 92       	push	r4
    1fd6:	5f 92       	push	r5
    1fd8:	6f 92       	push	r6
    1fda:	7f 92       	push	r7
    1fdc:	8f 92       	push	r8
    1fde:	9f 92       	push	r9
    1fe0:	af 92       	push	r10
    1fe2:	bf 92       	push	r11
    1fe4:	cf 92       	push	r12
    1fe6:	df 92       	push	r13
    1fe8:	ef 92       	push	r14
    1fea:	ff 92       	push	r15
    1fec:	0f 93       	push	r16
    1fee:	1f 93       	push	r17
    1ff0:	2f 93       	push	r18
    1ff2:	3f 93       	push	r19
    1ff4:	4f 93       	push	r20
    1ff6:	5f 93       	push	r21
    1ff8:	6f 93       	push	r22
    1ffa:	7f 93       	push	r23
    1ffc:	8f 93       	push	r24
    1ffe:	9f 93       	push	r25
    2000:	af 93       	push	r26
    2002:	bf 93       	push	r27
    2004:	cf 93       	push	r28
    2006:	df 93       	push	r29
    2008:	ef 93       	push	r30
    200a:	ff 93       	push	r31
    200c:	a0 91 f3 22 	lds	r26, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    2010:	b0 91 f4 22 	lds	r27, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    2014:	0d b6       	in	r0, 0x3d	; 61
    2016:	0d 92       	st	X+, r0
    2018:	0e b6       	in	r0, 0x3e	; 62
    201a:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    201c:	7e d6       	rcall	.+3324   	; 0x2d1a <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    201e:	a0 91 f3 22 	lds	r26, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    2022:	b0 91 f4 22 	lds	r27, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    2026:	0d 90       	ld	r0, X+
    2028:	0d be       	out	0x3d, r0	; 61
    202a:	0d 90       	ld	r0, X+
    202c:	0e be       	out	0x3e, r0	; 62
    202e:	ff 91       	pop	r31
    2030:	ef 91       	pop	r30
    2032:	df 91       	pop	r29
    2034:	cf 91       	pop	r28
    2036:	bf 91       	pop	r27
    2038:	af 91       	pop	r26
    203a:	9f 91       	pop	r25
    203c:	8f 91       	pop	r24
    203e:	7f 91       	pop	r23
    2040:	6f 91       	pop	r22
    2042:	5f 91       	pop	r21
    2044:	4f 91       	pop	r20
    2046:	3f 91       	pop	r19
    2048:	2f 91       	pop	r18
    204a:	1f 91       	pop	r17
    204c:	0f 91       	pop	r16
    204e:	ff 90       	pop	r15
    2050:	ef 90       	pop	r14
    2052:	df 90       	pop	r13
    2054:	cf 90       	pop	r12
    2056:	bf 90       	pop	r11
    2058:	af 90       	pop	r10
    205a:	9f 90       	pop	r9
    205c:	8f 90       	pop	r8
    205e:	7f 90       	pop	r7
    2060:	6f 90       	pop	r6
    2062:	5f 90       	pop	r5
    2064:	4f 90       	pop	r4
    2066:	3f 90       	pop	r3
    2068:	2f 90       	pop	r2
    206a:	1f 90       	pop	r1
    206c:	0f 90       	pop	r0
    206e:	0f be       	out	0x3f, r0	; 63
    2070:	0f 90       	pop	r0

    asm volatile ( "ret" );
    2072:	08 95       	ret

00002074 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    2074:	0f 92       	push	r0
    2076:	0f b6       	in	r0, 0x3f	; 63
    2078:	f8 94       	cli
    207a:	0f 92       	push	r0
    207c:	1f 92       	push	r1
    207e:	11 24       	eor	r1, r1
    2080:	2f 92       	push	r2
    2082:	3f 92       	push	r3
    2084:	4f 92       	push	r4
    2086:	5f 92       	push	r5
    2088:	6f 92       	push	r6
    208a:	7f 92       	push	r7
    208c:	8f 92       	push	r8
    208e:	9f 92       	push	r9
    2090:	af 92       	push	r10
    2092:	bf 92       	push	r11
    2094:	cf 92       	push	r12
    2096:	df 92       	push	r13
    2098:	ef 92       	push	r14
    209a:	ff 92       	push	r15
    209c:	0f 93       	push	r16
    209e:	1f 93       	push	r17
    20a0:	2f 93       	push	r18
    20a2:	3f 93       	push	r19
    20a4:	4f 93       	push	r20
    20a6:	5f 93       	push	r21
    20a8:	6f 93       	push	r22
    20aa:	7f 93       	push	r23
    20ac:	8f 93       	push	r24
    20ae:	9f 93       	push	r25
    20b0:	af 93       	push	r26
    20b2:	bf 93       	push	r27
    20b4:	cf 93       	push	r28
    20b6:	df 93       	push	r29
    20b8:	ef 93       	push	r30
    20ba:	ff 93       	push	r31
    20bc:	a0 91 f3 22 	lds	r26, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    20c0:	b0 91 f4 22 	lds	r27, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    20c4:	0d b6       	in	r0, 0x3d	; 61
    20c6:	0d 92       	st	X+, r0
    20c8:	0e b6       	in	r0, 0x3e	; 62
    20ca:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    20cc:	e1 d4       	rcall	.+2498   	; 0x2a90 <xTaskIncrementTick>
    20ce:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    20d0:	24 d6       	rcall	.+3144   	; 0x2d1a <vTaskSwitchContext>
    20d2:	a0 91 f3 22 	lds	r26, 0x22F3	; 0x8022f3 <pxCurrentTCB>
        }
        portRESTORE_CONTEXT();
    20d6:	b0 91 f4 22 	lds	r27, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    20da:	0d 90       	ld	r0, X+
    20dc:	0d be       	out	0x3d, r0	; 61
    20de:	0d 90       	ld	r0, X+
    20e0:	0e be       	out	0x3e, r0	; 62
    20e2:	ff 91       	pop	r31
    20e4:	ef 91       	pop	r30
    20e6:	df 91       	pop	r29
    20e8:	cf 91       	pop	r28
    20ea:	bf 91       	pop	r27
    20ec:	af 91       	pop	r26
    20ee:	9f 91       	pop	r25
    20f0:	8f 91       	pop	r24
    20f2:	7f 91       	pop	r23
    20f4:	6f 91       	pop	r22
    20f6:	5f 91       	pop	r21
    20f8:	4f 91       	pop	r20
    20fa:	3f 91       	pop	r19
    20fc:	2f 91       	pop	r18
    20fe:	1f 91       	pop	r17
    2100:	0f 91       	pop	r16
    2102:	ff 90       	pop	r15
    2104:	ef 90       	pop	r14
    2106:	df 90       	pop	r13
    2108:	cf 90       	pop	r12
    210a:	bf 90       	pop	r11
    210c:	af 90       	pop	r10
    210e:	9f 90       	pop	r9
    2110:	8f 90       	pop	r8
    2112:	7f 90       	pop	r7
    2114:	6f 90       	pop	r6
    2116:	5f 90       	pop	r5
    2118:	4f 90       	pop	r4
    211a:	3f 90       	pop	r3
    211c:	2f 90       	pop	r2
    211e:	1f 90       	pop	r1
    2120:	0f 90       	pop	r0
    2122:	0f be       	out	0x3f, r0	; 63
    2124:	0f 90       	pop	r0
    2126:	18 95       	reti

00002128 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2128:	cf 93       	push	r28
    212a:	df 93       	push	r29
    212c:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    212e:	a0 d4       	rcall	.+2368   	; 0x2a70 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    2130:	ce 01       	movw	r24, r28
    2132:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <malloc>
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2136:	ec 01       	movw	r28, r24
    2138:	63 d5       	rcall	.+2758   	; 0x2c00 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    213a:	ce 01       	movw	r24, r28
    213c:	df 91       	pop	r29
    213e:	cf 91       	pop	r28
    2140:	08 95       	ret

00002142 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2142:	cf 93       	push	r28
    2144:	df 93       	push	r29
	if( pv )
    2146:	00 97       	sbiw	r24, 0x00	; 0
    2148:	31 f0       	breq	.+12     	; 0x2156 <vPortFree+0x14>
    214a:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    214c:	91 d4       	rcall	.+2338   	; 0x2a70 <vTaskSuspendAll>
		{
			free( pv );
    214e:	ce 01       	movw	r24, r28
    2150:	0e 94 2a 1f 	call	0x3e54	; 0x3e54 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    2154:	55 d5       	rcall	.+2730   	; 0x2c00 <xTaskResumeAll>
	}
}
    2156:	df 91       	pop	r29
    2158:	cf 91       	pop	r28
    215a:	08 95       	ret

0000215c <prvIsQueueEmpty>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    215c:	0f b6       	in	r0, 0x3f	; 63
    215e:	f8 94       	cli
    2160:	0f 92       	push	r0
    2162:	fc 01       	movw	r30, r24
    2164:	92 8d       	ldd	r25, Z+26	; 0x1a
    2166:	0f 90       	pop	r0
    2168:	0f be       	out	0x3f, r0	; 63
    216a:	81 e0       	ldi	r24, 0x01	; 1
    216c:	91 11       	cpse	r25, r1
    216e:	80 e0       	ldi	r24, 0x00	; 0
    2170:	08 95       	ret

00002172 <prvCopyDataToQueue>:
    2172:	0f 93       	push	r16
    2174:	1f 93       	push	r17
    2176:	cf 93       	push	r28
    2178:	df 93       	push	r29
    217a:	ec 01       	movw	r28, r24
    217c:	04 2f       	mov	r16, r20
    217e:	1a 8d       	ldd	r17, Y+26	; 0x1a
    2180:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2182:	44 23       	and	r20, r20
    2184:	b9 f1       	breq	.+110    	; 0x21f4 <prvCopyDataToQueue+0x82>
    2186:	01 11       	cpse	r16, r1
    2188:	16 c0       	rjmp	.+44     	; 0x21b6 <prvCopyDataToQueue+0x44>
    218a:	50 e0       	ldi	r21, 0x00	; 0
    218c:	8a 81       	ldd	r24, Y+2	; 0x02
    218e:	9b 81       	ldd	r25, Y+3	; 0x03
    2190:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <memcpy>
    2194:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2196:	8a 81       	ldd	r24, Y+2	; 0x02
    2198:	9b 81       	ldd	r25, Y+3	; 0x03
    219a:	82 0f       	add	r24, r18
    219c:	91 1d       	adc	r25, r1
    219e:	8a 83       	std	Y+2, r24	; 0x02
    21a0:	9b 83       	std	Y+3, r25	; 0x03
    21a2:	2c 81       	ldd	r18, Y+4	; 0x04
    21a4:	3d 81       	ldd	r19, Y+5	; 0x05
    21a6:	82 17       	cp	r24, r18
    21a8:	93 07       	cpc	r25, r19
    21aa:	20 f1       	brcs	.+72     	; 0x21f4 <prvCopyDataToQueue+0x82>
    21ac:	88 81       	ld	r24, Y
    21ae:	99 81       	ldd	r25, Y+1	; 0x01
    21b0:	8a 83       	std	Y+2, r24	; 0x02
    21b2:	9b 83       	std	Y+3, r25	; 0x03
    21b4:	1f c0       	rjmp	.+62     	; 0x21f4 <prvCopyDataToQueue+0x82>
    21b6:	50 e0       	ldi	r21, 0x00	; 0
    21b8:	8e 81       	ldd	r24, Y+6	; 0x06
    21ba:	9f 81       	ldd	r25, Y+7	; 0x07
    21bc:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <memcpy>
    21c0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    21c2:	90 e0       	ldi	r25, 0x00	; 0
    21c4:	91 95       	neg	r25
    21c6:	81 95       	neg	r24
    21c8:	91 09       	sbc	r25, r1
    21ca:	2e 81       	ldd	r18, Y+6	; 0x06
    21cc:	3f 81       	ldd	r19, Y+7	; 0x07
    21ce:	28 0f       	add	r18, r24
    21d0:	39 1f       	adc	r19, r25
    21d2:	2e 83       	std	Y+6, r18	; 0x06
    21d4:	3f 83       	std	Y+7, r19	; 0x07
    21d6:	48 81       	ld	r20, Y
    21d8:	59 81       	ldd	r21, Y+1	; 0x01
    21da:	24 17       	cp	r18, r20
    21dc:	35 07       	cpc	r19, r21
    21de:	30 f4       	brcc	.+12     	; 0x21ec <prvCopyDataToQueue+0x7a>
    21e0:	2c 81       	ldd	r18, Y+4	; 0x04
    21e2:	3d 81       	ldd	r19, Y+5	; 0x05
    21e4:	82 0f       	add	r24, r18
    21e6:	93 1f       	adc	r25, r19
    21e8:	8e 83       	std	Y+6, r24	; 0x06
    21ea:	9f 83       	std	Y+7, r25	; 0x07
    21ec:	02 30       	cpi	r16, 0x02	; 2
    21ee:	11 f4       	brne	.+4      	; 0x21f4 <prvCopyDataToQueue+0x82>
    21f0:	11 11       	cpse	r17, r1
    21f2:	11 50       	subi	r17, 0x01	; 1
    21f4:	1f 5f       	subi	r17, 0xFF	; 255
    21f6:	1a 8f       	std	Y+26, r17	; 0x1a
    21f8:	80 e0       	ldi	r24, 0x00	; 0
    21fa:	df 91       	pop	r29
    21fc:	cf 91       	pop	r28
    21fe:	1f 91       	pop	r17
    2200:	0f 91       	pop	r16
    2202:	08 95       	ret

00002204 <prvCopyDataFromQueue>:
    2204:	fc 01       	movw	r30, r24
    2206:	44 8d       	ldd	r20, Z+28	; 0x1c
    2208:	44 23       	and	r20, r20
    220a:	a9 f0       	breq	.+42     	; 0x2236 <prvCopyDataFromQueue+0x32>
    220c:	50 e0       	ldi	r21, 0x00	; 0
    220e:	26 81       	ldd	r18, Z+6	; 0x06
    2210:	37 81       	ldd	r19, Z+7	; 0x07
    2212:	24 0f       	add	r18, r20
    2214:	35 1f       	adc	r19, r21
    2216:	26 83       	std	Z+6, r18	; 0x06
    2218:	37 83       	std	Z+7, r19	; 0x07
    221a:	84 81       	ldd	r24, Z+4	; 0x04
    221c:	95 81       	ldd	r25, Z+5	; 0x05
    221e:	28 17       	cp	r18, r24
    2220:	39 07       	cpc	r19, r25
    2222:	20 f0       	brcs	.+8      	; 0x222c <prvCopyDataFromQueue+0x28>
    2224:	80 81       	ld	r24, Z
    2226:	91 81       	ldd	r25, Z+1	; 0x01
    2228:	86 83       	std	Z+6, r24	; 0x06
    222a:	97 83       	std	Z+7, r25	; 0x07
    222c:	cb 01       	movw	r24, r22
    222e:	66 81       	ldd	r22, Z+6	; 0x06
    2230:	77 81       	ldd	r23, Z+7	; 0x07
    2232:	0c 94 b3 1f 	jmp	0x3f66	; 0x3f66 <memcpy>
    2236:	08 95       	ret

00002238 <prvUnlockQueue>:
    2238:	ef 92       	push	r14
    223a:	ff 92       	push	r15
    223c:	0f 93       	push	r16
    223e:	1f 93       	push	r17
    2240:	cf 93       	push	r28
    2242:	8c 01       	movw	r16, r24
    2244:	0f b6       	in	r0, 0x3f	; 63
    2246:	f8 94       	cli
    2248:	0f 92       	push	r0
    224a:	fc 01       	movw	r30, r24
    224c:	c6 8d       	ldd	r28, Z+30	; 0x1e
    224e:	1c 16       	cp	r1, r28
    2250:	9c f4       	brge	.+38     	; 0x2278 <prvUnlockQueue+0x40>
    2252:	81 89       	ldd	r24, Z+17	; 0x11
    2254:	81 11       	cpse	r24, r1
    2256:	06 c0       	rjmp	.+12     	; 0x2264 <prvUnlockQueue+0x2c>
    2258:	0f c0       	rjmp	.+30     	; 0x2278 <prvUnlockQueue+0x40>
    225a:	f8 01       	movw	r30, r16
    225c:	81 89       	ldd	r24, Z+17	; 0x11
    225e:	81 11       	cpse	r24, r1
    2260:	05 c0       	rjmp	.+10     	; 0x226c <prvUnlockQueue+0x34>
    2262:	0a c0       	rjmp	.+20     	; 0x2278 <prvUnlockQueue+0x40>
    2264:	78 01       	movw	r14, r16
    2266:	f1 e1       	ldi	r31, 0x11	; 17
    2268:	ef 0e       	add	r14, r31
    226a:	f1 1c       	adc	r15, r1
    226c:	c7 01       	movw	r24, r14
    226e:	e4 d5       	rcall	.+3016   	; 0x2e38 <xTaskRemoveFromEventList>
    2270:	81 11       	cpse	r24, r1
    2272:	60 d6       	rcall	.+3264   	; 0x2f34 <vTaskMissedYield>
    2274:	c1 50       	subi	r28, 0x01	; 1
    2276:	89 f7       	brne	.-30     	; 0x225a <prvUnlockQueue+0x22>
    2278:	8f ef       	ldi	r24, 0xFF	; 255
    227a:	f8 01       	movw	r30, r16
    227c:	86 8f       	std	Z+30, r24	; 0x1e
    227e:	0f 90       	pop	r0
    2280:	0f be       	out	0x3f, r0	; 63
    2282:	0f b6       	in	r0, 0x3f	; 63
    2284:	f8 94       	cli
    2286:	0f 92       	push	r0
    2288:	c5 8d       	ldd	r28, Z+29	; 0x1d
    228a:	1c 16       	cp	r1, r28
    228c:	9c f4       	brge	.+38     	; 0x22b4 <prvUnlockQueue+0x7c>
    228e:	80 85       	ldd	r24, Z+8	; 0x08
    2290:	81 11       	cpse	r24, r1
    2292:	06 c0       	rjmp	.+12     	; 0x22a0 <prvUnlockQueue+0x68>
    2294:	0f c0       	rjmp	.+30     	; 0x22b4 <prvUnlockQueue+0x7c>
    2296:	f8 01       	movw	r30, r16
    2298:	80 85       	ldd	r24, Z+8	; 0x08
    229a:	81 11       	cpse	r24, r1
    229c:	05 c0       	rjmp	.+10     	; 0x22a8 <prvUnlockQueue+0x70>
    229e:	0a c0       	rjmp	.+20     	; 0x22b4 <prvUnlockQueue+0x7c>
    22a0:	78 01       	movw	r14, r16
    22a2:	f8 e0       	ldi	r31, 0x08	; 8
    22a4:	ef 0e       	add	r14, r31
    22a6:	f1 1c       	adc	r15, r1
    22a8:	c7 01       	movw	r24, r14
    22aa:	c6 d5       	rcall	.+2956   	; 0x2e38 <xTaskRemoveFromEventList>
    22ac:	81 11       	cpse	r24, r1
    22ae:	42 d6       	rcall	.+3204   	; 0x2f34 <vTaskMissedYield>
    22b0:	c1 50       	subi	r28, 0x01	; 1
    22b2:	89 f7       	brne	.-30     	; 0x2296 <prvUnlockQueue+0x5e>
    22b4:	8f ef       	ldi	r24, 0xFF	; 255
    22b6:	f8 01       	movw	r30, r16
    22b8:	85 8f       	std	Z+29, r24	; 0x1d
    22ba:	0f 90       	pop	r0
    22bc:	0f be       	out	0x3f, r0	; 63
    22be:	cf 91       	pop	r28
    22c0:	1f 91       	pop	r17
    22c2:	0f 91       	pop	r16
    22c4:	ff 90       	pop	r15
    22c6:	ef 90       	pop	r14
    22c8:	08 95       	ret

000022ca <xQueueGenericReset>:
    22ca:	cf 93       	push	r28
    22cc:	df 93       	push	r29
    22ce:	ec 01       	movw	r28, r24
    22d0:	0f b6       	in	r0, 0x3f	; 63
    22d2:	f8 94       	cli
    22d4:	0f 92       	push	r0
    22d6:	e8 81       	ld	r30, Y
    22d8:	f9 81       	ldd	r31, Y+1	; 0x01
    22da:	8b 8d       	ldd	r24, Y+27	; 0x1b
    22dc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    22de:	90 e0       	ldi	r25, 0x00	; 0
    22e0:	30 e0       	ldi	r19, 0x00	; 0
    22e2:	82 9f       	mul	r24, r18
    22e4:	a0 01       	movw	r20, r0
    22e6:	83 9f       	mul	r24, r19
    22e8:	50 0d       	add	r21, r0
    22ea:	92 9f       	mul	r25, r18
    22ec:	50 0d       	add	r21, r0
    22ee:	11 24       	eor	r1, r1
    22f0:	4e 0f       	add	r20, r30
    22f2:	5f 1f       	adc	r21, r31
    22f4:	4c 83       	std	Y+4, r20	; 0x04
    22f6:	5d 83       	std	Y+5, r21	; 0x05
    22f8:	1a 8e       	std	Y+26, r1	; 0x1a
    22fa:	ea 83       	std	Y+2, r30	; 0x02
    22fc:	fb 83       	std	Y+3, r31	; 0x03
    22fe:	01 97       	sbiw	r24, 0x01	; 1
    2300:	82 9f       	mul	r24, r18
    2302:	a0 01       	movw	r20, r0
    2304:	83 9f       	mul	r24, r19
    2306:	50 0d       	add	r21, r0
    2308:	92 9f       	mul	r25, r18
    230a:	50 0d       	add	r21, r0
    230c:	11 24       	eor	r1, r1
    230e:	cf 01       	movw	r24, r30
    2310:	84 0f       	add	r24, r20
    2312:	95 1f       	adc	r25, r21
    2314:	8e 83       	std	Y+6, r24	; 0x06
    2316:	9f 83       	std	Y+7, r25	; 0x07
    2318:	8f ef       	ldi	r24, 0xFF	; 255
    231a:	8d 8f       	std	Y+29, r24	; 0x1d
    231c:	8e 8f       	std	Y+30, r24	; 0x1e
    231e:	61 11       	cpse	r22, r1
    2320:	0a c0       	rjmp	.+20     	; 0x2336 <xQueueGenericReset+0x6c>
    2322:	88 85       	ldd	r24, Y+8	; 0x08
    2324:	88 23       	and	r24, r24
    2326:	69 f0       	breq	.+26     	; 0x2342 <xQueueGenericReset+0x78>
    2328:	ce 01       	movw	r24, r28
    232a:	08 96       	adiw	r24, 0x08	; 8
    232c:	85 d5       	rcall	.+2826   	; 0x2e38 <xTaskRemoveFromEventList>
    232e:	88 23       	and	r24, r24
    2330:	41 f0       	breq	.+16     	; 0x2342 <xQueueGenericReset+0x78>
    2332:	48 de       	rcall	.-880    	; 0x1fc4 <vPortYield>
    2334:	06 c0       	rjmp	.+12     	; 0x2342 <xQueueGenericReset+0x78>
    2336:	ce 01       	movw	r24, r28
    2338:	08 96       	adiw	r24, 0x08	; 8
    233a:	fd dc       	rcall	.-1542   	; 0x1d36 <vListInitialise>
    233c:	ce 01       	movw	r24, r28
    233e:	41 96       	adiw	r24, 0x11	; 17
    2340:	fa dc       	rcall	.-1548   	; 0x1d36 <vListInitialise>
    2342:	0f 90       	pop	r0
    2344:	0f be       	out	0x3f, r0	; 63
    2346:	81 e0       	ldi	r24, 0x01	; 1
    2348:	df 91       	pop	r29
    234a:	cf 91       	pop	r28
    234c:	08 95       	ret

0000234e <xQueueGenericCreate>:
    234e:	0f 93       	push	r16
    2350:	1f 93       	push	r17
    2352:	cf 93       	push	r28
    2354:	df 93       	push	r29
    2356:	08 2f       	mov	r16, r24
    2358:	16 2f       	mov	r17, r22
    235a:	86 9f       	mul	r24, r22
    235c:	c0 01       	movw	r24, r0
    235e:	11 24       	eor	r1, r1
    2360:	4f 96       	adiw	r24, 0x1f	; 31
    2362:	e2 de       	rcall	.-572    	; 0x2128 <pvPortMalloc>
    2364:	ec 01       	movw	r28, r24
    2366:	00 97       	sbiw	r24, 0x00	; 0
    2368:	69 f0       	breq	.+26     	; 0x2384 <xQueueGenericCreate+0x36>
    236a:	11 11       	cpse	r17, r1
    236c:	03 c0       	rjmp	.+6      	; 0x2374 <xQueueGenericCreate+0x26>
    236e:	88 83       	st	Y, r24
    2370:	99 83       	std	Y+1, r25	; 0x01
    2372:	03 c0       	rjmp	.+6      	; 0x237a <xQueueGenericCreate+0x2c>
    2374:	4f 96       	adiw	r24, 0x1f	; 31
    2376:	88 83       	st	Y, r24
    2378:	99 83       	std	Y+1, r25	; 0x01
    237a:	0b 8f       	std	Y+27, r16	; 0x1b
    237c:	1c 8f       	std	Y+28, r17	; 0x1c
    237e:	61 e0       	ldi	r22, 0x01	; 1
    2380:	ce 01       	movw	r24, r28
    2382:	a3 df       	rcall	.-186    	; 0x22ca <xQueueGenericReset>
    2384:	ce 01       	movw	r24, r28
    2386:	df 91       	pop	r29
    2388:	cf 91       	pop	r28
    238a:	1f 91       	pop	r17
    238c:	0f 91       	pop	r16
    238e:	08 95       	ret

00002390 <xQueueGenericSend>:
    2390:	af 92       	push	r10
    2392:	bf 92       	push	r11
    2394:	cf 92       	push	r12
    2396:	df 92       	push	r13
    2398:	ef 92       	push	r14
    239a:	ff 92       	push	r15
    239c:	0f 93       	push	r16
    239e:	1f 93       	push	r17
    23a0:	cf 93       	push	r28
    23a2:	df 93       	push	r29
    23a4:	cd b7       	in	r28, 0x3d	; 61
    23a6:	de b7       	in	r29, 0x3e	; 62
    23a8:	25 97       	sbiw	r28, 0x05	; 5
    23aa:	cd bf       	out	0x3d, r28	; 61
    23ac:	de bf       	out	0x3e, r29	; 62
    23ae:	8c 01       	movw	r16, r24
    23b0:	6b 01       	movw	r12, r22
    23b2:	4c 83       	std	Y+4, r20	; 0x04
    23b4:	5d 83       	std	Y+5, r21	; 0x05
    23b6:	a2 2e       	mov	r10, r18
    23b8:	b1 2c       	mov	r11, r1
    23ba:	7c 01       	movw	r14, r24
    23bc:	88 e0       	ldi	r24, 0x08	; 8
    23be:	e8 0e       	add	r14, r24
    23c0:	f1 1c       	adc	r15, r1
    23c2:	0f b6       	in	r0, 0x3f	; 63
    23c4:	f8 94       	cli
    23c6:	0f 92       	push	r0
    23c8:	f8 01       	movw	r30, r16
    23ca:	92 8d       	ldd	r25, Z+26	; 0x1a
    23cc:	83 8d       	ldd	r24, Z+27	; 0x1b
    23ce:	98 17       	cp	r25, r24
    23d0:	18 f0       	brcs	.+6      	; 0x23d8 <xQueueGenericSend+0x48>
    23d2:	f2 e0       	ldi	r31, 0x02	; 2
    23d4:	af 12       	cpse	r10, r31
    23d6:	15 c0       	rjmp	.+42     	; 0x2402 <xQueueGenericSend+0x72>
    23d8:	4a 2d       	mov	r20, r10
    23da:	b6 01       	movw	r22, r12
    23dc:	c8 01       	movw	r24, r16
    23de:	c9 de       	rcall	.-622    	; 0x2172 <prvCopyDataToQueue>
    23e0:	f8 01       	movw	r30, r16
    23e2:	91 89       	ldd	r25, Z+17	; 0x11
    23e4:	99 23       	and	r25, r25
    23e6:	39 f0       	breq	.+14     	; 0x23f6 <xQueueGenericSend+0x66>
    23e8:	c8 01       	movw	r24, r16
    23ea:	41 96       	adiw	r24, 0x11	; 17
    23ec:	25 d5       	rcall	.+2634   	; 0x2e38 <xTaskRemoveFromEventList>
    23ee:	88 23       	and	r24, r24
    23f0:	21 f0       	breq	.+8      	; 0x23fa <xQueueGenericSend+0x6a>
    23f2:	e8 dd       	rcall	.-1072   	; 0x1fc4 <vPortYield>
    23f4:	02 c0       	rjmp	.+4      	; 0x23fa <xQueueGenericSend+0x6a>
    23f6:	81 11       	cpse	r24, r1
    23f8:	e5 dd       	rcall	.-1078   	; 0x1fc4 <vPortYield>
    23fa:	0f 90       	pop	r0
    23fc:	0f be       	out	0x3f, r0	; 63
    23fe:	81 e0       	ldi	r24, 0x01	; 1
    2400:	46 c0       	rjmp	.+140    	; 0x248e <xQueueGenericSend+0xfe>
    2402:	8c 81       	ldd	r24, Y+4	; 0x04
    2404:	9d 81       	ldd	r25, Y+5	; 0x05
    2406:	89 2b       	or	r24, r25
    2408:	21 f4       	brne	.+8      	; 0x2412 <xQueueGenericSend+0x82>
    240a:	0f 90       	pop	r0
    240c:	0f be       	out	0x3f, r0	; 63
    240e:	80 e0       	ldi	r24, 0x00	; 0
    2410:	3e c0       	rjmp	.+124    	; 0x248e <xQueueGenericSend+0xfe>
    2412:	b1 10       	cpse	r11, r1
    2414:	05 c0       	rjmp	.+10     	; 0x2420 <xQueueGenericSend+0x90>
    2416:	ce 01       	movw	r24, r28
    2418:	01 96       	adiw	r24, 0x01	; 1
    241a:	56 d5       	rcall	.+2732   	; 0x2ec8 <vTaskInternalSetTimeOutState>
    241c:	bb 24       	eor	r11, r11
    241e:	b3 94       	inc	r11
    2420:	0f 90       	pop	r0
    2422:	0f be       	out	0x3f, r0	; 63
    2424:	25 d3       	rcall	.+1610   	; 0x2a70 <vTaskSuspendAll>
    2426:	0f b6       	in	r0, 0x3f	; 63
    2428:	f8 94       	cli
    242a:	0f 92       	push	r0
    242c:	f8 01       	movw	r30, r16
    242e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2430:	8f 3f       	cpi	r24, 0xFF	; 255
    2432:	09 f4       	brne	.+2      	; 0x2436 <xQueueGenericSend+0xa6>
    2434:	15 8e       	std	Z+29, r1	; 0x1d
    2436:	f8 01       	movw	r30, r16
    2438:	86 8d       	ldd	r24, Z+30	; 0x1e
    243a:	8f 3f       	cpi	r24, 0xFF	; 255
    243c:	09 f4       	brne	.+2      	; 0x2440 <xQueueGenericSend+0xb0>
    243e:	16 8e       	std	Z+30, r1	; 0x1e
    2440:	0f 90       	pop	r0
    2442:	0f be       	out	0x3f, r0	; 63
    2444:	be 01       	movw	r22, r28
    2446:	6c 5f       	subi	r22, 0xFC	; 252
    2448:	7f 4f       	sbci	r23, 0xFF	; 255
    244a:	ce 01       	movw	r24, r28
    244c:	01 96       	adiw	r24, 0x01	; 1
    244e:	47 d5       	rcall	.+2702   	; 0x2ede <xTaskCheckForTimeOut>
    2450:	81 11       	cpse	r24, r1
    2452:	19 c0       	rjmp	.+50     	; 0x2486 <xQueueGenericSend+0xf6>
    2454:	0f b6       	in	r0, 0x3f	; 63
    2456:	f8 94       	cli
    2458:	0f 92       	push	r0
    245a:	f8 01       	movw	r30, r16
    245c:	92 8d       	ldd	r25, Z+26	; 0x1a
    245e:	0f 90       	pop	r0
    2460:	0f be       	out	0x3f, r0	; 63
    2462:	83 8d       	ldd	r24, Z+27	; 0x1b
    2464:	98 13       	cpse	r25, r24
    2466:	0b c0       	rjmp	.+22     	; 0x247e <xQueueGenericSend+0xee>
    2468:	6c 81       	ldd	r22, Y+4	; 0x04
    246a:	7d 81       	ldd	r23, Y+5	; 0x05
    246c:	c7 01       	movw	r24, r14
    246e:	bb d4       	rcall	.+2422   	; 0x2de6 <vTaskPlaceOnEventList>
    2470:	c8 01       	movw	r24, r16
    2472:	e2 de       	rcall	.-572    	; 0x2238 <prvUnlockQueue>
    2474:	c5 d3       	rcall	.+1930   	; 0x2c00 <xTaskResumeAll>
    2476:	81 11       	cpse	r24, r1
    2478:	a4 cf       	rjmp	.-184    	; 0x23c2 <xQueueGenericSend+0x32>
    247a:	a4 dd       	rcall	.-1208   	; 0x1fc4 <vPortYield>
    247c:	a2 cf       	rjmp	.-188    	; 0x23c2 <xQueueGenericSend+0x32>
    247e:	c8 01       	movw	r24, r16
    2480:	db de       	rcall	.-586    	; 0x2238 <prvUnlockQueue>
    2482:	be d3       	rcall	.+1916   	; 0x2c00 <xTaskResumeAll>
    2484:	9e cf       	rjmp	.-196    	; 0x23c2 <xQueueGenericSend+0x32>
    2486:	c8 01       	movw	r24, r16
    2488:	d7 de       	rcall	.-594    	; 0x2238 <prvUnlockQueue>
    248a:	ba d3       	rcall	.+1908   	; 0x2c00 <xTaskResumeAll>
    248c:	80 e0       	ldi	r24, 0x00	; 0
    248e:	25 96       	adiw	r28, 0x05	; 5
    2490:	cd bf       	out	0x3d, r28	; 61
    2492:	de bf       	out	0x3e, r29	; 62
    2494:	df 91       	pop	r29
    2496:	cf 91       	pop	r28
    2498:	1f 91       	pop	r17
    249a:	0f 91       	pop	r16
    249c:	ff 90       	pop	r15
    249e:	ef 90       	pop	r14
    24a0:	df 90       	pop	r13
    24a2:	cf 90       	pop	r12
    24a4:	bf 90       	pop	r11
    24a6:	af 90       	pop	r10
    24a8:	08 95       	ret

000024aa <xQueueGenericSendFromISR>:
    24aa:	ef 92       	push	r14
    24ac:	ff 92       	push	r15
    24ae:	0f 93       	push	r16
    24b0:	1f 93       	push	r17
    24b2:	cf 93       	push	r28
    24b4:	df 93       	push	r29
    24b6:	8a 01       	movw	r16, r20
    24b8:	fc 01       	movw	r30, r24
    24ba:	52 8d       	ldd	r21, Z+26	; 0x1a
    24bc:	33 8d       	ldd	r19, Z+27	; 0x1b
    24be:	53 17       	cp	r21, r19
    24c0:	10 f0       	brcs	.+4      	; 0x24c6 <xQueueGenericSendFromISR+0x1c>
    24c2:	22 30       	cpi	r18, 0x02	; 2
    24c4:	f1 f4       	brne	.+60     	; 0x2502 <xQueueGenericSendFromISR+0x58>
    24c6:	42 2f       	mov	r20, r18
    24c8:	78 01       	movw	r14, r16
    24ca:	ec 01       	movw	r28, r24
    24cc:	1e 8d       	ldd	r17, Y+30	; 0x1e
    24ce:	8a 8d       	ldd	r24, Y+26	; 0x1a
    24d0:	ce 01       	movw	r24, r28
    24d2:	4f de       	rcall	.-866    	; 0x2172 <prvCopyDataToQueue>
    24d4:	1f 3f       	cpi	r17, 0xFF	; 255
    24d6:	79 f4       	brne	.+30     	; 0x24f6 <xQueueGenericSendFromISR+0x4c>
    24d8:	89 89       	ldd	r24, Y+17	; 0x11
    24da:	88 23       	and	r24, r24
    24dc:	a1 f0       	breq	.+40     	; 0x2506 <xQueueGenericSendFromISR+0x5c>
    24de:	ce 01       	movw	r24, r28
    24e0:	41 96       	adiw	r24, 0x11	; 17
    24e2:	aa d4       	rcall	.+2388   	; 0x2e38 <xTaskRemoveFromEventList>
    24e4:	88 23       	and	r24, r24
    24e6:	89 f0       	breq	.+34     	; 0x250a <xQueueGenericSendFromISR+0x60>
    24e8:	e1 14       	cp	r14, r1
    24ea:	f1 04       	cpc	r15, r1
    24ec:	81 f0       	breq	.+32     	; 0x250e <xQueueGenericSendFromISR+0x64>
    24ee:	81 e0       	ldi	r24, 0x01	; 1
    24f0:	f7 01       	movw	r30, r14
    24f2:	80 83       	st	Z, r24
    24f4:	0d c0       	rjmp	.+26     	; 0x2510 <xQueueGenericSendFromISR+0x66>
    24f6:	ff 24       	eor	r15, r15
    24f8:	f3 94       	inc	r15
    24fa:	f1 0e       	add	r15, r17
    24fc:	fe 8e       	std	Y+30, r15	; 0x1e
    24fe:	81 e0       	ldi	r24, 0x01	; 1
    2500:	07 c0       	rjmp	.+14     	; 0x2510 <xQueueGenericSendFromISR+0x66>
    2502:	80 e0       	ldi	r24, 0x00	; 0
    2504:	05 c0       	rjmp	.+10     	; 0x2510 <xQueueGenericSendFromISR+0x66>
    2506:	81 e0       	ldi	r24, 0x01	; 1
    2508:	03 c0       	rjmp	.+6      	; 0x2510 <xQueueGenericSendFromISR+0x66>
    250a:	81 e0       	ldi	r24, 0x01	; 1
    250c:	01 c0       	rjmp	.+2      	; 0x2510 <xQueueGenericSendFromISR+0x66>
    250e:	81 e0       	ldi	r24, 0x01	; 1
    2510:	df 91       	pop	r29
    2512:	cf 91       	pop	r28
    2514:	1f 91       	pop	r17
    2516:	0f 91       	pop	r16
    2518:	ff 90       	pop	r15
    251a:	ef 90       	pop	r14
    251c:	08 95       	ret

0000251e <xQueueReceive>:
    251e:	af 92       	push	r10
    2520:	bf 92       	push	r11
    2522:	cf 92       	push	r12
    2524:	df 92       	push	r13
    2526:	ef 92       	push	r14
    2528:	ff 92       	push	r15
    252a:	0f 93       	push	r16
    252c:	1f 93       	push	r17
    252e:	cf 93       	push	r28
    2530:	df 93       	push	r29
    2532:	cd b7       	in	r28, 0x3d	; 61
    2534:	de b7       	in	r29, 0x3e	; 62
    2536:	25 97       	sbiw	r28, 0x05	; 5
    2538:	cd bf       	out	0x3d, r28	; 61
    253a:	de bf       	out	0x3e, r29	; 62
    253c:	8c 01       	movw	r16, r24
    253e:	5b 01       	movw	r10, r22
    2540:	4c 83       	std	Y+4, r20	; 0x04
    2542:	5d 83       	std	Y+5, r21	; 0x05
    2544:	e1 2c       	mov	r14, r1
    2546:	6c 01       	movw	r12, r24
    2548:	81 e1       	ldi	r24, 0x11	; 17
    254a:	c8 0e       	add	r12, r24
    254c:	d1 1c       	adc	r13, r1
    254e:	0f b6       	in	r0, 0x3f	; 63
    2550:	f8 94       	cli
    2552:	0f 92       	push	r0
    2554:	f8 01       	movw	r30, r16
    2556:	f2 8c       	ldd	r15, Z+26	; 0x1a
    2558:	ff 20       	and	r15, r15
    255a:	91 f0       	breq	.+36     	; 0x2580 <xQueueReceive+0x62>
    255c:	b5 01       	movw	r22, r10
    255e:	c8 01       	movw	r24, r16
    2560:	51 de       	rcall	.-862    	; 0x2204 <prvCopyDataFromQueue>
    2562:	fa 94       	dec	r15
    2564:	f8 01       	movw	r30, r16
    2566:	f2 8e       	std	Z+26, r15	; 0x1a
    2568:	80 85       	ldd	r24, Z+8	; 0x08
    256a:	88 23       	and	r24, r24
    256c:	29 f0       	breq	.+10     	; 0x2578 <xQueueReceive+0x5a>
    256e:	c8 01       	movw	r24, r16
    2570:	08 96       	adiw	r24, 0x08	; 8
    2572:	62 d4       	rcall	.+2244   	; 0x2e38 <xTaskRemoveFromEventList>
    2574:	81 11       	cpse	r24, r1
    2576:	26 dd       	rcall	.-1460   	; 0x1fc4 <vPortYield>
    2578:	0f 90       	pop	r0
    257a:	0f be       	out	0x3f, r0	; 63
    257c:	81 e0       	ldi	r24, 0x01	; 1
    257e:	45 c0       	rjmp	.+138    	; 0x260a <xQueueReceive+0xec>
    2580:	8c 81       	ldd	r24, Y+4	; 0x04
    2582:	9d 81       	ldd	r25, Y+5	; 0x05
    2584:	89 2b       	or	r24, r25
    2586:	21 f4       	brne	.+8      	; 0x2590 <xQueueReceive+0x72>
    2588:	0f 90       	pop	r0
    258a:	0f be       	out	0x3f, r0	; 63
    258c:	80 e0       	ldi	r24, 0x00	; 0
    258e:	3d c0       	rjmp	.+122    	; 0x260a <xQueueReceive+0xec>
    2590:	e1 10       	cpse	r14, r1
    2592:	05 c0       	rjmp	.+10     	; 0x259e <xQueueReceive+0x80>
    2594:	ce 01       	movw	r24, r28
    2596:	01 96       	adiw	r24, 0x01	; 1
    2598:	97 d4       	rcall	.+2350   	; 0x2ec8 <vTaskInternalSetTimeOutState>
    259a:	ee 24       	eor	r14, r14
    259c:	e3 94       	inc	r14
    259e:	0f 90       	pop	r0
    25a0:	0f be       	out	0x3f, r0	; 63
    25a2:	66 d2       	rcall	.+1228   	; 0x2a70 <vTaskSuspendAll>
    25a4:	0f b6       	in	r0, 0x3f	; 63
    25a6:	f8 94       	cli
    25a8:	0f 92       	push	r0
    25aa:	f8 01       	movw	r30, r16
    25ac:	85 8d       	ldd	r24, Z+29	; 0x1d
    25ae:	8f 3f       	cpi	r24, 0xFF	; 255
    25b0:	09 f4       	brne	.+2      	; 0x25b4 <xQueueReceive+0x96>
    25b2:	15 8e       	std	Z+29, r1	; 0x1d
    25b4:	f8 01       	movw	r30, r16
    25b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    25b8:	8f 3f       	cpi	r24, 0xFF	; 255
    25ba:	09 f4       	brne	.+2      	; 0x25be <xQueueReceive+0xa0>
    25bc:	16 8e       	std	Z+30, r1	; 0x1e
    25be:	0f 90       	pop	r0
    25c0:	0f be       	out	0x3f, r0	; 63
    25c2:	be 01       	movw	r22, r28
    25c4:	6c 5f       	subi	r22, 0xFC	; 252
    25c6:	7f 4f       	sbci	r23, 0xFF	; 255
    25c8:	ce 01       	movw	r24, r28
    25ca:	01 96       	adiw	r24, 0x01	; 1
    25cc:	88 d4       	rcall	.+2320   	; 0x2ede <xTaskCheckForTimeOut>
    25ce:	81 11       	cpse	r24, r1
    25d0:	13 c0       	rjmp	.+38     	; 0x25f8 <xQueueReceive+0xda>
    25d2:	c8 01       	movw	r24, r16
    25d4:	c3 dd       	rcall	.-1146   	; 0x215c <prvIsQueueEmpty>
    25d6:	88 23       	and	r24, r24
    25d8:	59 f0       	breq	.+22     	; 0x25f0 <xQueueReceive+0xd2>
    25da:	6c 81       	ldd	r22, Y+4	; 0x04
    25dc:	7d 81       	ldd	r23, Y+5	; 0x05
    25de:	c6 01       	movw	r24, r12
    25e0:	02 d4       	rcall	.+2052   	; 0x2de6 <vTaskPlaceOnEventList>
    25e2:	c8 01       	movw	r24, r16
    25e4:	29 de       	rcall	.-942    	; 0x2238 <prvUnlockQueue>
    25e6:	0c d3       	rcall	.+1560   	; 0x2c00 <xTaskResumeAll>
    25e8:	81 11       	cpse	r24, r1
    25ea:	b1 cf       	rjmp	.-158    	; 0x254e <xQueueReceive+0x30>
    25ec:	eb dc       	rcall	.-1578   	; 0x1fc4 <vPortYield>
    25ee:	af cf       	rjmp	.-162    	; 0x254e <xQueueReceive+0x30>
    25f0:	c8 01       	movw	r24, r16
    25f2:	22 de       	rcall	.-956    	; 0x2238 <prvUnlockQueue>
    25f4:	05 d3       	rcall	.+1546   	; 0x2c00 <xTaskResumeAll>
    25f6:	ab cf       	rjmp	.-170    	; 0x254e <xQueueReceive+0x30>
    25f8:	c8 01       	movw	r24, r16
    25fa:	1e de       	rcall	.-964    	; 0x2238 <prvUnlockQueue>
    25fc:	01 d3       	rcall	.+1538   	; 0x2c00 <xTaskResumeAll>
    25fe:	c8 01       	movw	r24, r16
    2600:	ad dd       	rcall	.-1190   	; 0x215c <prvIsQueueEmpty>
    2602:	88 23       	and	r24, r24
    2604:	09 f4       	brne	.+2      	; 0x2608 <xQueueReceive+0xea>
    2606:	a3 cf       	rjmp	.-186    	; 0x254e <xQueueReceive+0x30>
    2608:	80 e0       	ldi	r24, 0x00	; 0
    260a:	25 96       	adiw	r28, 0x05	; 5
    260c:	cd bf       	out	0x3d, r28	; 61
    260e:	de bf       	out	0x3e, r29	; 62
    2610:	df 91       	pop	r29
    2612:	cf 91       	pop	r28
    2614:	1f 91       	pop	r17
    2616:	0f 91       	pop	r16
    2618:	ff 90       	pop	r15
    261a:	ef 90       	pop	r14
    261c:	df 90       	pop	r13
    261e:	cf 90       	pop	r12
    2620:	bf 90       	pop	r11
    2622:	af 90       	pop	r10
    2624:	08 95       	ret

00002626 <xQueueSemaphoreTake>:
    2626:	df 92       	push	r13
    2628:	ef 92       	push	r14
    262a:	ff 92       	push	r15
    262c:	0f 93       	push	r16
    262e:	1f 93       	push	r17
    2630:	cf 93       	push	r28
    2632:	df 93       	push	r29
    2634:	cd b7       	in	r28, 0x3d	; 61
    2636:	de b7       	in	r29, 0x3e	; 62
    2638:	25 97       	sbiw	r28, 0x05	; 5
    263a:	cd bf       	out	0x3d, r28	; 61
    263c:	de bf       	out	0x3e, r29	; 62
    263e:	8c 01       	movw	r16, r24
    2640:	6c 83       	std	Y+4, r22	; 0x04
    2642:	7d 83       	std	Y+5, r23	; 0x05
    2644:	d1 2c       	mov	r13, r1
    2646:	7c 01       	movw	r14, r24
    2648:	81 e1       	ldi	r24, 0x11	; 17
    264a:	e8 0e       	add	r14, r24
    264c:	f1 1c       	adc	r15, r1
    264e:	0f b6       	in	r0, 0x3f	; 63
    2650:	f8 94       	cli
    2652:	0f 92       	push	r0
    2654:	f8 01       	movw	r30, r16
    2656:	82 8d       	ldd	r24, Z+26	; 0x1a
    2658:	88 23       	and	r24, r24
    265a:	71 f0       	breq	.+28     	; 0x2678 <xQueueSemaphoreTake+0x52>
    265c:	81 50       	subi	r24, 0x01	; 1
    265e:	82 8f       	std	Z+26, r24	; 0x1a
    2660:	80 85       	ldd	r24, Z+8	; 0x08
    2662:	88 23       	and	r24, r24
    2664:	29 f0       	breq	.+10     	; 0x2670 <xQueueSemaphoreTake+0x4a>
    2666:	c8 01       	movw	r24, r16
    2668:	08 96       	adiw	r24, 0x08	; 8
    266a:	e6 d3       	rcall	.+1996   	; 0x2e38 <xTaskRemoveFromEventList>
    266c:	81 11       	cpse	r24, r1
    266e:	aa dc       	rcall	.-1708   	; 0x1fc4 <vPortYield>
    2670:	0f 90       	pop	r0
    2672:	0f be       	out	0x3f, r0	; 63
    2674:	81 e0       	ldi	r24, 0x01	; 1
    2676:	45 c0       	rjmp	.+138    	; 0x2702 <xQueueSemaphoreTake+0xdc>
    2678:	8c 81       	ldd	r24, Y+4	; 0x04
    267a:	9d 81       	ldd	r25, Y+5	; 0x05
    267c:	89 2b       	or	r24, r25
    267e:	21 f4       	brne	.+8      	; 0x2688 <xQueueSemaphoreTake+0x62>
    2680:	0f 90       	pop	r0
    2682:	0f be       	out	0x3f, r0	; 63
    2684:	80 e0       	ldi	r24, 0x00	; 0
    2686:	3d c0       	rjmp	.+122    	; 0x2702 <xQueueSemaphoreTake+0xdc>
    2688:	d1 10       	cpse	r13, r1
    268a:	05 c0       	rjmp	.+10     	; 0x2696 <xQueueSemaphoreTake+0x70>
    268c:	ce 01       	movw	r24, r28
    268e:	01 96       	adiw	r24, 0x01	; 1
    2690:	1b d4       	rcall	.+2102   	; 0x2ec8 <vTaskInternalSetTimeOutState>
    2692:	dd 24       	eor	r13, r13
    2694:	d3 94       	inc	r13
    2696:	0f 90       	pop	r0
    2698:	0f be       	out	0x3f, r0	; 63
    269a:	ea d1       	rcall	.+980    	; 0x2a70 <vTaskSuspendAll>
    269c:	0f b6       	in	r0, 0x3f	; 63
    269e:	f8 94       	cli
    26a0:	0f 92       	push	r0
    26a2:	f8 01       	movw	r30, r16
    26a4:	85 8d       	ldd	r24, Z+29	; 0x1d
    26a6:	8f 3f       	cpi	r24, 0xFF	; 255
    26a8:	09 f4       	brne	.+2      	; 0x26ac <xQueueSemaphoreTake+0x86>
    26aa:	15 8e       	std	Z+29, r1	; 0x1d
    26ac:	f8 01       	movw	r30, r16
    26ae:	86 8d       	ldd	r24, Z+30	; 0x1e
    26b0:	8f 3f       	cpi	r24, 0xFF	; 255
    26b2:	09 f4       	brne	.+2      	; 0x26b6 <xQueueSemaphoreTake+0x90>
    26b4:	16 8e       	std	Z+30, r1	; 0x1e
    26b6:	0f 90       	pop	r0
    26b8:	0f be       	out	0x3f, r0	; 63
    26ba:	be 01       	movw	r22, r28
    26bc:	6c 5f       	subi	r22, 0xFC	; 252
    26be:	7f 4f       	sbci	r23, 0xFF	; 255
    26c0:	ce 01       	movw	r24, r28
    26c2:	01 96       	adiw	r24, 0x01	; 1
    26c4:	0c d4       	rcall	.+2072   	; 0x2ede <xTaskCheckForTimeOut>
    26c6:	81 11       	cpse	r24, r1
    26c8:	13 c0       	rjmp	.+38     	; 0x26f0 <xQueueSemaphoreTake+0xca>
    26ca:	c8 01       	movw	r24, r16
    26cc:	47 dd       	rcall	.-1394   	; 0x215c <prvIsQueueEmpty>
    26ce:	88 23       	and	r24, r24
    26d0:	59 f0       	breq	.+22     	; 0x26e8 <xQueueSemaphoreTake+0xc2>
    26d2:	6c 81       	ldd	r22, Y+4	; 0x04
    26d4:	7d 81       	ldd	r23, Y+5	; 0x05
    26d6:	c7 01       	movw	r24, r14
    26d8:	86 d3       	rcall	.+1804   	; 0x2de6 <vTaskPlaceOnEventList>
    26da:	c8 01       	movw	r24, r16
    26dc:	ad dd       	rcall	.-1190   	; 0x2238 <prvUnlockQueue>
    26de:	90 d2       	rcall	.+1312   	; 0x2c00 <xTaskResumeAll>
    26e0:	81 11       	cpse	r24, r1
    26e2:	b5 cf       	rjmp	.-150    	; 0x264e <xQueueSemaphoreTake+0x28>
    26e4:	6f dc       	rcall	.-1826   	; 0x1fc4 <vPortYield>
    26e6:	b3 cf       	rjmp	.-154    	; 0x264e <xQueueSemaphoreTake+0x28>
    26e8:	c8 01       	movw	r24, r16
    26ea:	a6 dd       	rcall	.-1204   	; 0x2238 <prvUnlockQueue>
    26ec:	89 d2       	rcall	.+1298   	; 0x2c00 <xTaskResumeAll>
    26ee:	af cf       	rjmp	.-162    	; 0x264e <xQueueSemaphoreTake+0x28>
    26f0:	c8 01       	movw	r24, r16
    26f2:	a2 dd       	rcall	.-1212   	; 0x2238 <prvUnlockQueue>
    26f4:	85 d2       	rcall	.+1290   	; 0x2c00 <xTaskResumeAll>
    26f6:	c8 01       	movw	r24, r16
    26f8:	31 dd       	rcall	.-1438   	; 0x215c <prvIsQueueEmpty>
    26fa:	88 23       	and	r24, r24
    26fc:	09 f4       	brne	.+2      	; 0x2700 <xQueueSemaphoreTake+0xda>
    26fe:	a7 cf       	rjmp	.-178    	; 0x264e <xQueueSemaphoreTake+0x28>
    2700:	80 e0       	ldi	r24, 0x00	; 0
    2702:	25 96       	adiw	r28, 0x05	; 5
    2704:	cd bf       	out	0x3d, r28	; 61
    2706:	de bf       	out	0x3e, r29	; 62
    2708:	df 91       	pop	r29
    270a:	cf 91       	pop	r28
    270c:	1f 91       	pop	r17
    270e:	0f 91       	pop	r16
    2710:	ff 90       	pop	r15
    2712:	ef 90       	pop	r14
    2714:	df 90       	pop	r13
    2716:	08 95       	ret

00002718 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    2718:	cf 93       	push	r28
    271a:	df 93       	push	r29
    271c:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    271e:	0f b6       	in	r0, 0x3f	; 63
    2720:	f8 94       	cli
    2722:	0f 92       	push	r0
    2724:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2726:	8f 3f       	cpi	r24, 0xFF	; 255
    2728:	09 f4       	brne	.+2      	; 0x272c <vQueueWaitForMessageRestricted+0x14>
    272a:	1d 8e       	std	Y+29, r1	; 0x1d
    272c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    272e:	8f 3f       	cpi	r24, 0xFF	; 255
    2730:	09 f4       	brne	.+2      	; 0x2734 <vQueueWaitForMessageRestricted+0x1c>
    2732:	1e 8e       	std	Y+30, r1	; 0x1e
    2734:	0f 90       	pop	r0
    2736:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2738:	8a 8d       	ldd	r24, Y+26	; 0x1a
    273a:	81 11       	cpse	r24, r1
    273c:	03 c0       	rjmp	.+6      	; 0x2744 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    273e:	ce 01       	movw	r24, r28
    2740:	41 96       	adiw	r24, 0x11	; 17
    2742:	62 d3       	rcall	.+1732   	; 0x2e08 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    2744:	ce 01       	movw	r24, r28
    2746:	78 dd       	rcall	.-1296   	; 0x2238 <prvUnlockQueue>
	}
    2748:	df 91       	pop	r29
    274a:	cf 91       	pop	r28
    274c:	08 95       	ret

0000274e <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
    274e:	e0 91 b2 22 	lds	r30, 0x22B2	; 0x8022b2 <pxDelayedTaskList>
    2752:	f0 91 b3 22 	lds	r31, 0x22B3	; 0x8022b3 <pxDelayedTaskList+0x1>
    2756:	80 81       	ld	r24, Z
    2758:	81 11       	cpse	r24, r1
    275a:	07 c0       	rjmp	.+14     	; 0x276a <prvResetNextTaskUnblockTime+0x1c>
    275c:	8f ef       	ldi	r24, 0xFF	; 255
    275e:	9f ef       	ldi	r25, 0xFF	; 255
    2760:	80 93 9b 22 	sts	0x229B, r24	; 0x80229b <xNextTaskUnblockTime>
    2764:	90 93 9c 22 	sts	0x229C, r25	; 0x80229c <xNextTaskUnblockTime+0x1>
    2768:	08 95       	ret
    276a:	e0 91 b2 22 	lds	r30, 0x22B2	; 0x8022b2 <pxDelayedTaskList>
    276e:	f0 91 b3 22 	lds	r31, 0x22B3	; 0x8022b3 <pxDelayedTaskList+0x1>
    2772:	05 80       	ldd	r0, Z+5	; 0x05
    2774:	f6 81       	ldd	r31, Z+6	; 0x06
    2776:	e0 2d       	mov	r30, r0
    2778:	06 80       	ldd	r0, Z+6	; 0x06
    277a:	f7 81       	ldd	r31, Z+7	; 0x07
    277c:	e0 2d       	mov	r30, r0
    277e:	82 81       	ldd	r24, Z+2	; 0x02
    2780:	93 81       	ldd	r25, Z+3	; 0x03
    2782:	80 93 9b 22 	sts	0x229B, r24	; 0x80229b <xNextTaskUnblockTime>
    2786:	90 93 9c 22 	sts	0x229C, r25	; 0x80229c <xNextTaskUnblockTime+0x1>
    278a:	08 95       	ret

0000278c <prvIdleTask>:
    278c:	c6 ec       	ldi	r28, 0xC6	; 198
    278e:	d2 e2       	ldi	r29, 0x22	; 34
    2790:	88 81       	ld	r24, Y
    2792:	82 30       	cpi	r24, 0x02	; 2
    2794:	e8 f3       	brcs	.-6      	; 0x2790 <prvIdleTask+0x4>
    2796:	16 dc       	rcall	.-2004   	; 0x1fc4 <vPortYield>
    2798:	fb cf       	rjmp	.-10     	; 0x2790 <prvIdleTask+0x4>

0000279a <prvAddCurrentTaskToDelayedList>:
    279a:	0f 93       	push	r16
    279c:	1f 93       	push	r17
    279e:	cf 93       	push	r28
    27a0:	df 93       	push	r29
    27a2:	ec 01       	movw	r28, r24
    27a4:	00 91 a4 22 	lds	r16, 0x22A4	; 0x8022a4 <xTickCount>
    27a8:	10 91 a5 22 	lds	r17, 0x22A5	; 0x8022a5 <xTickCount+0x1>
    27ac:	80 91 f3 22 	lds	r24, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    27b0:	90 91 f4 22 	lds	r25, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    27b4:	02 96       	adiw	r24, 0x02	; 2
    27b6:	23 db       	rcall	.-2490   	; 0x1dfe <uxListRemove>
    27b8:	c0 0f       	add	r28, r16
    27ba:	d1 1f       	adc	r29, r17
    27bc:	e0 91 f3 22 	lds	r30, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    27c0:	f0 91 f4 22 	lds	r31, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    27c4:	c2 83       	std	Z+2, r28	; 0x02
    27c6:	d3 83       	std	Z+3, r29	; 0x03
    27c8:	c0 17       	cp	r28, r16
    27ca:	d1 07       	cpc	r29, r17
    27cc:	60 f4       	brcc	.+24     	; 0x27e6 <prvAddCurrentTaskToDelayedList+0x4c>
    27ce:	60 91 f3 22 	lds	r22, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    27d2:	70 91 f4 22 	lds	r23, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    27d6:	80 91 b0 22 	lds	r24, 0x22B0	; 0x8022b0 <pxOverflowDelayedTaskList>
    27da:	90 91 b1 22 	lds	r25, 0x22B1	; 0x8022b1 <pxOverflowDelayedTaskList+0x1>
    27de:	6e 5f       	subi	r22, 0xFE	; 254
    27e0:	7f 4f       	sbci	r23, 0xFF	; 255
    27e2:	dc da       	rcall	.-2632   	; 0x1d9c <vListInsert>
    27e4:	16 c0       	rjmp	.+44     	; 0x2812 <prvAddCurrentTaskToDelayedList+0x78>
    27e6:	60 91 f3 22 	lds	r22, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    27ea:	70 91 f4 22 	lds	r23, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    27ee:	80 91 b2 22 	lds	r24, 0x22B2	; 0x8022b2 <pxDelayedTaskList>
    27f2:	90 91 b3 22 	lds	r25, 0x22B3	; 0x8022b3 <pxDelayedTaskList+0x1>
    27f6:	6e 5f       	subi	r22, 0xFE	; 254
    27f8:	7f 4f       	sbci	r23, 0xFF	; 255
    27fa:	d0 da       	rcall	.-2656   	; 0x1d9c <vListInsert>
    27fc:	80 91 9b 22 	lds	r24, 0x229B	; 0x80229b <xNextTaskUnblockTime>
    2800:	90 91 9c 22 	lds	r25, 0x229C	; 0x80229c <xNextTaskUnblockTime+0x1>
    2804:	c8 17       	cp	r28, r24
    2806:	d9 07       	cpc	r29, r25
    2808:	20 f4       	brcc	.+8      	; 0x2812 <prvAddCurrentTaskToDelayedList+0x78>
    280a:	c0 93 9b 22 	sts	0x229B, r28	; 0x80229b <xNextTaskUnblockTime>
    280e:	d0 93 9c 22 	sts	0x229C, r29	; 0x80229c <xNextTaskUnblockTime+0x1>
    2812:	df 91       	pop	r29
    2814:	cf 91       	pop	r28
    2816:	1f 91       	pop	r17
    2818:	0f 91       	pop	r16
    281a:	08 95       	ret

0000281c <xTaskCreate>:
    281c:	4f 92       	push	r4
    281e:	5f 92       	push	r5
    2820:	6f 92       	push	r6
    2822:	7f 92       	push	r7
    2824:	8f 92       	push	r8
    2826:	9f 92       	push	r9
    2828:	af 92       	push	r10
    282a:	bf 92       	push	r11
    282c:	cf 92       	push	r12
    282e:	df 92       	push	r13
    2830:	ef 92       	push	r14
    2832:	ff 92       	push	r15
    2834:	0f 93       	push	r16
    2836:	1f 93       	push	r17
    2838:	cf 93       	push	r28
    283a:	df 93       	push	r29
    283c:	4c 01       	movw	r8, r24
    283e:	6b 01       	movw	r12, r22
    2840:	5a 01       	movw	r10, r20
    2842:	29 01       	movw	r4, r18
    2844:	ca 01       	movw	r24, r20
    2846:	70 dc       	rcall	.-1824   	; 0x2128 <pvPortMalloc>
    2848:	3c 01       	movw	r6, r24
    284a:	89 2b       	or	r24, r25
    284c:	09 f4       	brne	.+2      	; 0x2850 <xTaskCreate+0x34>
    284e:	d3 c0       	rjmp	.+422    	; 0x29f6 <xTaskCreate+0x1da>
    2850:	86 e2       	ldi	r24, 0x26	; 38
    2852:	90 e0       	ldi	r25, 0x00	; 0
    2854:	69 dc       	rcall	.-1838   	; 0x2128 <pvPortMalloc>
    2856:	ec 01       	movw	r28, r24
    2858:	89 2b       	or	r24, r25
    285a:	59 f0       	breq	.+22     	; 0x2872 <xTaskCreate+0x56>
    285c:	6f 8a       	std	Y+23, r6	; 0x17
    285e:	78 8e       	std	Y+24, r7	; 0x18
    2860:	81 e0       	ldi	r24, 0x01	; 1
    2862:	a8 1a       	sub	r10, r24
    2864:	b1 08       	sbc	r11, r1
    2866:	a6 0c       	add	r10, r6
    2868:	b7 1c       	adc	r11, r7
    286a:	c1 14       	cp	r12, r1
    286c:	d1 04       	cpc	r13, r1
    286e:	21 f4       	brne	.+8      	; 0x2878 <xTaskCreate+0x5c>
    2870:	1f c0       	rjmp	.+62     	; 0x28b0 <xTaskCreate+0x94>
    2872:	c3 01       	movw	r24, r6
    2874:	66 dc       	rcall	.-1844   	; 0x2142 <vPortFree>
    2876:	bf c0       	rjmp	.+382    	; 0x29f6 <xTaskCreate+0x1da>
    2878:	d6 01       	movw	r26, r12
    287a:	8c 91       	ld	r24, X
    287c:	89 8f       	std	Y+25, r24	; 0x19
    287e:	8c 91       	ld	r24, X
    2880:	88 23       	and	r24, r24
    2882:	a1 f0       	breq	.+40     	; 0x28ac <xTaskCreate+0x90>
    2884:	ae 01       	movw	r20, r28
    2886:	46 5e       	subi	r20, 0xE6	; 230
    2888:	5f 4f       	sbci	r21, 0xFF	; 255
    288a:	f6 01       	movw	r30, r12
    288c:	31 96       	adiw	r30, 0x01	; 1
    288e:	b8 e0       	ldi	r27, 0x08	; 8
    2890:	cb 0e       	add	r12, r27
    2892:	d1 1c       	adc	r13, r1
    2894:	cf 01       	movw	r24, r30
    2896:	21 91       	ld	r18, Z+
    2898:	da 01       	movw	r26, r20
    289a:	2d 93       	st	X+, r18
    289c:	ad 01       	movw	r20, r26
    289e:	dc 01       	movw	r26, r24
    28a0:	8c 91       	ld	r24, X
    28a2:	88 23       	and	r24, r24
    28a4:	19 f0       	breq	.+6      	; 0x28ac <xTaskCreate+0x90>
    28a6:	ce 16       	cp	r12, r30
    28a8:	df 06       	cpc	r13, r31
    28aa:	a1 f7       	brne	.-24     	; 0x2894 <xTaskCreate+0x78>
    28ac:	18 a2       	std	Y+32, r1	; 0x20
    28ae:	01 c0       	rjmp	.+2      	; 0x28b2 <xTaskCreate+0x96>
    28b0:	19 8e       	std	Y+25, r1	; 0x19
    28b2:	05 30       	cpi	r16, 0x05	; 5
    28b4:	08 f0       	brcs	.+2      	; 0x28b8 <xTaskCreate+0x9c>
    28b6:	04 e0       	ldi	r16, 0x04	; 4
    28b8:	0e 8b       	std	Y+22, r16	; 0x16
    28ba:	6e 01       	movw	r12, r28
    28bc:	b2 e0       	ldi	r27, 0x02	; 2
    28be:	cb 0e       	add	r12, r27
    28c0:	d1 1c       	adc	r13, r1
    28c2:	c6 01       	movw	r24, r12
    28c4:	46 da       	rcall	.-2932   	; 0x1d52 <vListInitialiseItem>
    28c6:	ce 01       	movw	r24, r28
    28c8:	0c 96       	adiw	r24, 0x0c	; 12
    28ca:	43 da       	rcall	.-2938   	; 0x1d52 <vListInitialiseItem>
    28cc:	c8 87       	std	Y+8, r28	; 0x08
    28ce:	d9 87       	std	Y+9, r29	; 0x09
    28d0:	85 e0       	ldi	r24, 0x05	; 5
    28d2:	90 e0       	ldi	r25, 0x00	; 0
    28d4:	80 1b       	sub	r24, r16
    28d6:	91 09       	sbc	r25, r1
    28d8:	8c 87       	std	Y+12, r24	; 0x0c
    28da:	9d 87       	std	Y+13, r25	; 0x0d
    28dc:	ca 8b       	std	Y+18, r28	; 0x12
    28de:	db 8b       	std	Y+19, r29	; 0x13
    28e0:	19 a2       	std	Y+33, r1	; 0x21
    28e2:	1a a2       	std	Y+34, r1	; 0x22
    28e4:	1b a2       	std	Y+35, r1	; 0x23
    28e6:	1c a2       	std	Y+36, r1	; 0x24
    28e8:	1d a2       	std	Y+37, r1	; 0x25
    28ea:	a2 01       	movw	r20, r4
    28ec:	b4 01       	movw	r22, r8
    28ee:	c5 01       	movw	r24, r10
    28f0:	ad da       	rcall	.-2726   	; 0x1e4c <pxPortInitialiseStack>
    28f2:	88 83       	st	Y, r24
    28f4:	99 83       	std	Y+1, r25	; 0x01
    28f6:	e1 14       	cp	r14, r1
    28f8:	f1 04       	cpc	r15, r1
    28fa:	19 f0       	breq	.+6      	; 0x2902 <xTaskCreate+0xe6>
    28fc:	f7 01       	movw	r30, r14
    28fe:	c0 83       	st	Z, r28
    2900:	d1 83       	std	Z+1, r29	; 0x01
    2902:	0f b6       	in	r0, 0x3f	; 63
    2904:	f8 94       	cli
    2906:	0f 92       	push	r0
    2908:	80 91 a6 22 	lds	r24, 0x22A6	; 0x8022a6 <uxCurrentNumberOfTasks>
    290c:	8f 5f       	subi	r24, 0xFF	; 255
    290e:	80 93 a6 22 	sts	0x22A6, r24	; 0x8022a6 <uxCurrentNumberOfTasks>
    2912:	80 91 f3 22 	lds	r24, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    2916:	90 91 f4 22 	lds	r25, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    291a:	89 2b       	or	r24, r25
    291c:	69 f5       	brne	.+90     	; 0x2978 <xTaskCreate+0x15c>
    291e:	c0 93 f3 22 	sts	0x22F3, r28	; 0x8022f3 <pxCurrentTCB>
    2922:	d0 93 f4 22 	sts	0x22F4, r29	; 0x8022f4 <pxCurrentTCB+0x1>
    2926:	80 91 a6 22 	lds	r24, 0x22A6	; 0x8022a6 <uxCurrentNumberOfTasks>
    292a:	81 30       	cpi	r24, 0x01	; 1
    292c:	a9 f5       	brne	.+106    	; 0x2998 <xTaskCreate+0x17c>
    292e:	06 ec       	ldi	r16, 0xC6	; 198
    2930:	12 e2       	ldi	r17, 0x22	; 34
    2932:	0f 2e       	mov	r0, r31
    2934:	f3 ef       	ldi	r31, 0xF3	; 243
    2936:	ef 2e       	mov	r14, r31
    2938:	f2 e2       	ldi	r31, 0x22	; 34
    293a:	ff 2e       	mov	r15, r31
    293c:	f0 2d       	mov	r31, r0
    293e:	c8 01       	movw	r24, r16
    2940:	fa d9       	rcall	.-3084   	; 0x1d36 <vListInitialise>
    2942:	07 5f       	subi	r16, 0xF7	; 247
    2944:	1f 4f       	sbci	r17, 0xFF	; 255
    2946:	0e 15       	cp	r16, r14
    2948:	1f 05       	cpc	r17, r15
    294a:	c9 f7       	brne	.-14     	; 0x293e <xTaskCreate+0x122>
    294c:	8d eb       	ldi	r24, 0xBD	; 189
    294e:	92 e2       	ldi	r25, 0x22	; 34
    2950:	f2 d9       	rcall	.-3100   	; 0x1d36 <vListInitialise>
    2952:	84 eb       	ldi	r24, 0xB4	; 180
    2954:	92 e2       	ldi	r25, 0x22	; 34
    2956:	ef d9       	rcall	.-3106   	; 0x1d36 <vListInitialise>
    2958:	87 ea       	ldi	r24, 0xA7	; 167
    295a:	92 e2       	ldi	r25, 0x22	; 34
    295c:	ec d9       	rcall	.-3112   	; 0x1d36 <vListInitialise>
    295e:	8d eb       	ldi	r24, 0xBD	; 189
    2960:	92 e2       	ldi	r25, 0x22	; 34
    2962:	80 93 b2 22 	sts	0x22B2, r24	; 0x8022b2 <pxDelayedTaskList>
    2966:	90 93 b3 22 	sts	0x22B3, r25	; 0x8022b3 <pxDelayedTaskList+0x1>
    296a:	84 eb       	ldi	r24, 0xB4	; 180
    296c:	92 e2       	ldi	r25, 0x22	; 34
    296e:	80 93 b0 22 	sts	0x22B0, r24	; 0x8022b0 <pxOverflowDelayedTaskList>
    2972:	90 93 b1 22 	sts	0x22B1, r25	; 0x8022b1 <pxOverflowDelayedTaskList+0x1>
    2976:	10 c0       	rjmp	.+32     	; 0x2998 <xTaskCreate+0x17c>
    2978:	80 91 a2 22 	lds	r24, 0x22A2	; 0x8022a2 <xSchedulerRunning>
    297c:	81 11       	cpse	r24, r1
    297e:	0c c0       	rjmp	.+24     	; 0x2998 <xTaskCreate+0x17c>
    2980:	e0 91 f3 22 	lds	r30, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    2984:	f0 91 f4 22 	lds	r31, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    2988:	96 89       	ldd	r25, Z+22	; 0x16
    298a:	8e 89       	ldd	r24, Y+22	; 0x16
    298c:	89 17       	cp	r24, r25
    298e:	20 f0       	brcs	.+8      	; 0x2998 <xTaskCreate+0x17c>
    2990:	c0 93 f3 22 	sts	0x22F3, r28	; 0x8022f3 <pxCurrentTCB>
    2994:	d0 93 f4 22 	sts	0x22F4, r29	; 0x8022f4 <pxCurrentTCB+0x1>
    2998:	80 91 9d 22 	lds	r24, 0x229D	; 0x80229d <uxTaskNumber>
    299c:	8f 5f       	subi	r24, 0xFF	; 255
    299e:	80 93 9d 22 	sts	0x229D, r24	; 0x80229d <uxTaskNumber>
    29a2:	8e 89       	ldd	r24, Y+22	; 0x16
    29a4:	90 91 a3 22 	lds	r25, 0x22A3	; 0x8022a3 <uxTopReadyPriority>
    29a8:	98 17       	cp	r25, r24
    29aa:	10 f4       	brcc	.+4      	; 0x29b0 <xTaskCreate+0x194>
    29ac:	80 93 a3 22 	sts	0x22A3, r24	; 0x8022a3 <uxTopReadyPriority>
    29b0:	90 e0       	ldi	r25, 0x00	; 0
    29b2:	9c 01       	movw	r18, r24
    29b4:	22 0f       	add	r18, r18
    29b6:	33 1f       	adc	r19, r19
    29b8:	22 0f       	add	r18, r18
    29ba:	33 1f       	adc	r19, r19
    29bc:	22 0f       	add	r18, r18
    29be:	33 1f       	adc	r19, r19
    29c0:	82 0f       	add	r24, r18
    29c2:	93 1f       	adc	r25, r19
    29c4:	b6 01       	movw	r22, r12
    29c6:	8a 53       	subi	r24, 0x3A	; 58
    29c8:	9d 4d       	sbci	r25, 0xDD	; 221
    29ca:	c7 d9       	rcall	.-3186   	; 0x1d5a <vListInsertEnd>
    29cc:	0f 90       	pop	r0
    29ce:	0f be       	out	0x3f, r0	; 63
    29d0:	80 91 a2 22 	lds	r24, 0x22A2	; 0x8022a2 <xSchedulerRunning>
    29d4:	88 23       	and	r24, r24
    29d6:	59 f0       	breq	.+22     	; 0x29ee <xTaskCreate+0x1d2>
    29d8:	e0 91 f3 22 	lds	r30, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    29dc:	f0 91 f4 22 	lds	r31, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    29e0:	96 89       	ldd	r25, Z+22	; 0x16
    29e2:	8e 89       	ldd	r24, Y+22	; 0x16
    29e4:	98 17       	cp	r25, r24
    29e6:	28 f4       	brcc	.+10     	; 0x29f2 <xTaskCreate+0x1d6>
    29e8:	ed da       	rcall	.-2598   	; 0x1fc4 <vPortYield>
    29ea:	81 e0       	ldi	r24, 0x01	; 1
    29ec:	05 c0       	rjmp	.+10     	; 0x29f8 <xTaskCreate+0x1dc>
    29ee:	81 e0       	ldi	r24, 0x01	; 1
    29f0:	03 c0       	rjmp	.+6      	; 0x29f8 <xTaskCreate+0x1dc>
    29f2:	81 e0       	ldi	r24, 0x01	; 1
    29f4:	01 c0       	rjmp	.+2      	; 0x29f8 <xTaskCreate+0x1dc>
    29f6:	8f ef       	ldi	r24, 0xFF	; 255
    29f8:	df 91       	pop	r29
    29fa:	cf 91       	pop	r28
    29fc:	1f 91       	pop	r17
    29fe:	0f 91       	pop	r16
    2a00:	ff 90       	pop	r15
    2a02:	ef 90       	pop	r14
    2a04:	df 90       	pop	r13
    2a06:	cf 90       	pop	r12
    2a08:	bf 90       	pop	r11
    2a0a:	af 90       	pop	r10
    2a0c:	9f 90       	pop	r9
    2a0e:	8f 90       	pop	r8
    2a10:	7f 90       	pop	r7
    2a12:	6f 90       	pop	r6
    2a14:	5f 90       	pop	r5
    2a16:	4f 90       	pop	r4
    2a18:	08 95       	ret

00002a1a <vTaskStartScheduler>:
    2a1a:	ef 92       	push	r14
    2a1c:	ff 92       	push	r15
    2a1e:	0f 93       	push	r16
    2a20:	0f 2e       	mov	r0, r31
    2a22:	f9 e9       	ldi	r31, 0x99	; 153
    2a24:	ef 2e       	mov	r14, r31
    2a26:	f2 e2       	ldi	r31, 0x22	; 34
    2a28:	ff 2e       	mov	r15, r31
    2a2a:	f0 2d       	mov	r31, r0
    2a2c:	00 e0       	ldi	r16, 0x00	; 0
    2a2e:	20 e0       	ldi	r18, 0x00	; 0
    2a30:	30 e0       	ldi	r19, 0x00	; 0
    2a32:	45 e5       	ldi	r20, 0x55	; 85
    2a34:	50 e0       	ldi	r21, 0x00	; 0
    2a36:	6d e0       	ldi	r22, 0x0D	; 13
    2a38:	70 e2       	ldi	r23, 0x20	; 32
    2a3a:	86 ec       	ldi	r24, 0xC6	; 198
    2a3c:	93 e1       	ldi	r25, 0x13	; 19
    2a3e:	ee de       	rcall	.-548    	; 0x281c <xTaskCreate>
    2a40:	81 30       	cpi	r24, 0x01	; 1
    2a42:	91 f4       	brne	.+36     	; 0x2a68 <vTaskStartScheduler+0x4e>
    2a44:	e0 d2       	rcall	.+1472   	; 0x3006 <xTimerCreateTimerTask>
    2a46:	81 30       	cpi	r24, 0x01	; 1
    2a48:	79 f4       	brne	.+30     	; 0x2a68 <vTaskStartScheduler+0x4e>
    2a4a:	f8 94       	cli
    2a4c:	8f ef       	ldi	r24, 0xFF	; 255
    2a4e:	9f ef       	ldi	r25, 0xFF	; 255
    2a50:	80 93 9b 22 	sts	0x229B, r24	; 0x80229b <xNextTaskUnblockTime>
    2a54:	90 93 9c 22 	sts	0x229C, r25	; 0x80229c <xNextTaskUnblockTime+0x1>
    2a58:	81 e0       	ldi	r24, 0x01	; 1
    2a5a:	80 93 a2 22 	sts	0x22A2, r24	; 0x8022a2 <xSchedulerRunning>
    2a5e:	10 92 a4 22 	sts	0x22A4, r1	; 0x8022a4 <xTickCount>
    2a62:	10 92 a5 22 	sts	0x22A5, r1	; 0x8022a5 <xTickCount+0x1>
    2a66:	69 da       	rcall	.-2862   	; 0x1f3a <xPortStartScheduler>
    2a68:	0f 91       	pop	r16
    2a6a:	ff 90       	pop	r15
    2a6c:	ef 90       	pop	r14
    2a6e:	08 95       	ret

00002a70 <vTaskSuspendAll>:
    2a70:	80 91 98 22 	lds	r24, 0x2298	; 0x802298 <uxSchedulerSuspended>
    2a74:	8f 5f       	subi	r24, 0xFF	; 255
    2a76:	80 93 98 22 	sts	0x2298, r24	; 0x802298 <uxSchedulerSuspended>
    2a7a:	08 95       	ret

00002a7c <xTaskGetTickCount>:
    2a7c:	0f b6       	in	r0, 0x3f	; 63
    2a7e:	f8 94       	cli
    2a80:	0f 92       	push	r0
    2a82:	80 91 a4 22 	lds	r24, 0x22A4	; 0x8022a4 <xTickCount>
    2a86:	90 91 a5 22 	lds	r25, 0x22A5	; 0x8022a5 <xTickCount+0x1>
    2a8a:	0f 90       	pop	r0
    2a8c:	0f be       	out	0x3f, r0	; 63
    2a8e:	08 95       	ret

00002a90 <xTaskIncrementTick>:
    2a90:	df 92       	push	r13
    2a92:	ef 92       	push	r14
    2a94:	ff 92       	push	r15
    2a96:	0f 93       	push	r16
    2a98:	1f 93       	push	r17
    2a9a:	cf 93       	push	r28
    2a9c:	df 93       	push	r29
    2a9e:	80 91 98 22 	lds	r24, 0x2298	; 0x802298 <uxSchedulerSuspended>
    2aa2:	81 11       	cpse	r24, r1
    2aa4:	9a c0       	rjmp	.+308    	; 0x2bda <xTaskIncrementTick+0x14a>
    2aa6:	e0 90 a4 22 	lds	r14, 0x22A4	; 0x8022a4 <xTickCount>
    2aaa:	f0 90 a5 22 	lds	r15, 0x22A5	; 0x8022a5 <xTickCount+0x1>
    2aae:	8f ef       	ldi	r24, 0xFF	; 255
    2ab0:	e8 1a       	sub	r14, r24
    2ab2:	f8 0a       	sbc	r15, r24
    2ab4:	e0 92 a4 22 	sts	0x22A4, r14	; 0x8022a4 <xTickCount>
    2ab8:	f0 92 a5 22 	sts	0x22A5, r15	; 0x8022a5 <xTickCount+0x1>
    2abc:	e1 14       	cp	r14, r1
    2abe:	f1 04       	cpc	r15, r1
    2ac0:	b1 f4       	brne	.+44     	; 0x2aee <xTaskIncrementTick+0x5e>
    2ac2:	80 91 b2 22 	lds	r24, 0x22B2	; 0x8022b2 <pxDelayedTaskList>
    2ac6:	90 91 b3 22 	lds	r25, 0x22B3	; 0x8022b3 <pxDelayedTaskList+0x1>
    2aca:	20 91 b0 22 	lds	r18, 0x22B0	; 0x8022b0 <pxOverflowDelayedTaskList>
    2ace:	30 91 b1 22 	lds	r19, 0x22B1	; 0x8022b1 <pxOverflowDelayedTaskList+0x1>
    2ad2:	20 93 b2 22 	sts	0x22B2, r18	; 0x8022b2 <pxDelayedTaskList>
    2ad6:	30 93 b3 22 	sts	0x22B3, r19	; 0x8022b3 <pxDelayedTaskList+0x1>
    2ada:	80 93 b0 22 	sts	0x22B0, r24	; 0x8022b0 <pxOverflowDelayedTaskList>
    2ade:	90 93 b1 22 	sts	0x22B1, r25	; 0x8022b1 <pxOverflowDelayedTaskList+0x1>
    2ae2:	80 91 9e 22 	lds	r24, 0x229E	; 0x80229e <xNumOfOverflows>
    2ae6:	8f 5f       	subi	r24, 0xFF	; 255
    2ae8:	80 93 9e 22 	sts	0x229E, r24	; 0x80229e <xNumOfOverflows>
    2aec:	30 de       	rcall	.-928    	; 0x274e <prvResetNextTaskUnblockTime>
    2aee:	80 91 9b 22 	lds	r24, 0x229B	; 0x80229b <xNextTaskUnblockTime>
    2af2:	90 91 9c 22 	lds	r25, 0x229C	; 0x80229c <xNextTaskUnblockTime+0x1>
    2af6:	e8 16       	cp	r14, r24
    2af8:	f9 06       	cpc	r15, r25
    2afa:	10 f4       	brcc	.+4      	; 0x2b00 <xTaskIncrementTick+0x70>
    2afc:	d1 2c       	mov	r13, r1
    2afe:	4f c0       	rjmp	.+158    	; 0x2b9e <xTaskIncrementTick+0x10e>
    2b00:	d1 2c       	mov	r13, r1
    2b02:	e0 91 b2 22 	lds	r30, 0x22B2	; 0x8022b2 <pxDelayedTaskList>
    2b06:	f0 91 b3 22 	lds	r31, 0x22B3	; 0x8022b3 <pxDelayedTaskList+0x1>
    2b0a:	80 81       	ld	r24, Z
    2b0c:	81 11       	cpse	r24, r1
    2b0e:	07 c0       	rjmp	.+14     	; 0x2b1e <xTaskIncrementTick+0x8e>
    2b10:	8f ef       	ldi	r24, 0xFF	; 255
    2b12:	9f ef       	ldi	r25, 0xFF	; 255
    2b14:	80 93 9b 22 	sts	0x229B, r24	; 0x80229b <xNextTaskUnblockTime>
    2b18:	90 93 9c 22 	sts	0x229C, r25	; 0x80229c <xNextTaskUnblockTime+0x1>
    2b1c:	40 c0       	rjmp	.+128    	; 0x2b9e <xTaskIncrementTick+0x10e>
    2b1e:	e0 91 b2 22 	lds	r30, 0x22B2	; 0x8022b2 <pxDelayedTaskList>
    2b22:	f0 91 b3 22 	lds	r31, 0x22B3	; 0x8022b3 <pxDelayedTaskList+0x1>
    2b26:	05 80       	ldd	r0, Z+5	; 0x05
    2b28:	f6 81       	ldd	r31, Z+6	; 0x06
    2b2a:	e0 2d       	mov	r30, r0
    2b2c:	c6 81       	ldd	r28, Z+6	; 0x06
    2b2e:	d7 81       	ldd	r29, Z+7	; 0x07
    2b30:	8a 81       	ldd	r24, Y+2	; 0x02
    2b32:	9b 81       	ldd	r25, Y+3	; 0x03
    2b34:	e8 16       	cp	r14, r24
    2b36:	f9 06       	cpc	r15, r25
    2b38:	28 f4       	brcc	.+10     	; 0x2b44 <xTaskIncrementTick+0xb4>
    2b3a:	80 93 9b 22 	sts	0x229B, r24	; 0x80229b <xNextTaskUnblockTime>
    2b3e:	90 93 9c 22 	sts	0x229C, r25	; 0x80229c <xNextTaskUnblockTime+0x1>
    2b42:	2d c0       	rjmp	.+90     	; 0x2b9e <xTaskIncrementTick+0x10e>
    2b44:	8e 01       	movw	r16, r28
    2b46:	0e 5f       	subi	r16, 0xFE	; 254
    2b48:	1f 4f       	sbci	r17, 0xFF	; 255
    2b4a:	c8 01       	movw	r24, r16
    2b4c:	58 d9       	rcall	.-3408   	; 0x1dfe <uxListRemove>
    2b4e:	8c 89       	ldd	r24, Y+20	; 0x14
    2b50:	9d 89       	ldd	r25, Y+21	; 0x15
    2b52:	89 2b       	or	r24, r25
    2b54:	19 f0       	breq	.+6      	; 0x2b5c <xTaskIncrementTick+0xcc>
    2b56:	ce 01       	movw	r24, r28
    2b58:	0c 96       	adiw	r24, 0x0c	; 12
    2b5a:	51 d9       	rcall	.-3422   	; 0x1dfe <uxListRemove>
    2b5c:	8e 89       	ldd	r24, Y+22	; 0x16
    2b5e:	90 91 a3 22 	lds	r25, 0x22A3	; 0x8022a3 <uxTopReadyPriority>
    2b62:	98 17       	cp	r25, r24
    2b64:	10 f4       	brcc	.+4      	; 0x2b6a <xTaskIncrementTick+0xda>
    2b66:	80 93 a3 22 	sts	0x22A3, r24	; 0x8022a3 <uxTopReadyPriority>
    2b6a:	90 e0       	ldi	r25, 0x00	; 0
    2b6c:	9c 01       	movw	r18, r24
    2b6e:	22 0f       	add	r18, r18
    2b70:	33 1f       	adc	r19, r19
    2b72:	22 0f       	add	r18, r18
    2b74:	33 1f       	adc	r19, r19
    2b76:	22 0f       	add	r18, r18
    2b78:	33 1f       	adc	r19, r19
    2b7a:	82 0f       	add	r24, r18
    2b7c:	93 1f       	adc	r25, r19
    2b7e:	b8 01       	movw	r22, r16
    2b80:	8a 53       	subi	r24, 0x3A	; 58
    2b82:	9d 4d       	sbci	r25, 0xDD	; 221
    2b84:	ea d8       	rcall	.-3628   	; 0x1d5a <vListInsertEnd>
    2b86:	e0 91 f3 22 	lds	r30, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    2b8a:	f0 91 f4 22 	lds	r31, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    2b8e:	9e 89       	ldd	r25, Y+22	; 0x16
    2b90:	86 89       	ldd	r24, Z+22	; 0x16
    2b92:	98 17       	cp	r25, r24
    2b94:	08 f4       	brcc	.+2      	; 0x2b98 <xTaskIncrementTick+0x108>
    2b96:	b5 cf       	rjmp	.-150    	; 0x2b02 <xTaskIncrementTick+0x72>
    2b98:	dd 24       	eor	r13, r13
    2b9a:	d3 94       	inc	r13
    2b9c:	b2 cf       	rjmp	.-156    	; 0x2b02 <xTaskIncrementTick+0x72>
    2b9e:	e0 91 f3 22 	lds	r30, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    2ba2:	f0 91 f4 22 	lds	r31, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    2ba6:	86 89       	ldd	r24, Z+22	; 0x16
    2ba8:	90 e0       	ldi	r25, 0x00	; 0
    2baa:	fc 01       	movw	r30, r24
    2bac:	ee 0f       	add	r30, r30
    2bae:	ff 1f       	adc	r31, r31
    2bb0:	ee 0f       	add	r30, r30
    2bb2:	ff 1f       	adc	r31, r31
    2bb4:	ee 0f       	add	r30, r30
    2bb6:	ff 1f       	adc	r31, r31
    2bb8:	8e 0f       	add	r24, r30
    2bba:	9f 1f       	adc	r25, r31
    2bbc:	fc 01       	movw	r30, r24
    2bbe:	ea 53       	subi	r30, 0x3A	; 58
    2bc0:	fd 4d       	sbci	r31, 0xDD	; 221
    2bc2:	80 81       	ld	r24, Z
    2bc4:	82 30       	cpi	r24, 0x02	; 2
    2bc6:	10 f0       	brcs	.+4      	; 0x2bcc <xTaskIncrementTick+0x13c>
    2bc8:	dd 24       	eor	r13, r13
    2bca:	d3 94       	inc	r13
    2bcc:	80 91 9f 22 	lds	r24, 0x229F	; 0x80229f <xYieldPending>
    2bd0:	88 23       	and	r24, r24
    2bd2:	69 f0       	breq	.+26     	; 0x2bee <xTaskIncrementTick+0x15e>
    2bd4:	dd 24       	eor	r13, r13
    2bd6:	d3 94       	inc	r13
    2bd8:	0a c0       	rjmp	.+20     	; 0x2bee <xTaskIncrementTick+0x15e>
    2bda:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <xPendedTicks>
    2bde:	90 91 a1 22 	lds	r25, 0x22A1	; 0x8022a1 <xPendedTicks+0x1>
    2be2:	01 96       	adiw	r24, 0x01	; 1
    2be4:	80 93 a0 22 	sts	0x22A0, r24	; 0x8022a0 <xPendedTicks>
    2be8:	90 93 a1 22 	sts	0x22A1, r25	; 0x8022a1 <xPendedTicks+0x1>
    2bec:	d1 2c       	mov	r13, r1
    2bee:	8d 2d       	mov	r24, r13
    2bf0:	df 91       	pop	r29
    2bf2:	cf 91       	pop	r28
    2bf4:	1f 91       	pop	r17
    2bf6:	0f 91       	pop	r16
    2bf8:	ff 90       	pop	r15
    2bfa:	ef 90       	pop	r14
    2bfc:	df 90       	pop	r13
    2bfe:	08 95       	ret

00002c00 <xTaskResumeAll>:
    2c00:	df 92       	push	r13
    2c02:	ef 92       	push	r14
    2c04:	ff 92       	push	r15
    2c06:	0f 93       	push	r16
    2c08:	1f 93       	push	r17
    2c0a:	cf 93       	push	r28
    2c0c:	df 93       	push	r29
    2c0e:	0f b6       	in	r0, 0x3f	; 63
    2c10:	f8 94       	cli
    2c12:	0f 92       	push	r0
    2c14:	80 91 98 22 	lds	r24, 0x2298	; 0x802298 <uxSchedulerSuspended>
    2c18:	81 50       	subi	r24, 0x01	; 1
    2c1a:	80 93 98 22 	sts	0x2298, r24	; 0x802298 <uxSchedulerSuspended>
    2c1e:	80 91 98 22 	lds	r24, 0x2298	; 0x802298 <uxSchedulerSuspended>
    2c22:	81 11       	cpse	r24, r1
    2c24:	5d c0       	rjmp	.+186    	; 0x2ce0 <xTaskResumeAll+0xe0>
    2c26:	80 91 a6 22 	lds	r24, 0x22A6	; 0x8022a6 <uxCurrentNumberOfTasks>
    2c2a:	81 11       	cpse	r24, r1
    2c2c:	30 c0       	rjmp	.+96     	; 0x2c8e <xTaskResumeAll+0x8e>
    2c2e:	5b c0       	rjmp	.+182    	; 0x2ce6 <xTaskResumeAll+0xe6>
    2c30:	d7 01       	movw	r26, r14
    2c32:	15 96       	adiw	r26, 0x05	; 5
    2c34:	ed 91       	ld	r30, X+
    2c36:	fc 91       	ld	r31, X
    2c38:	16 97       	sbiw	r26, 0x06	; 6
    2c3a:	c6 81       	ldd	r28, Z+6	; 0x06
    2c3c:	d7 81       	ldd	r29, Z+7	; 0x07
    2c3e:	ce 01       	movw	r24, r28
    2c40:	0c 96       	adiw	r24, 0x0c	; 12
    2c42:	dd d8       	rcall	.-3654   	; 0x1dfe <uxListRemove>
    2c44:	8e 01       	movw	r16, r28
    2c46:	0e 5f       	subi	r16, 0xFE	; 254
    2c48:	1f 4f       	sbci	r17, 0xFF	; 255
    2c4a:	c8 01       	movw	r24, r16
    2c4c:	d8 d8       	rcall	.-3664   	; 0x1dfe <uxListRemove>
    2c4e:	8e 89       	ldd	r24, Y+22	; 0x16
    2c50:	90 91 a3 22 	lds	r25, 0x22A3	; 0x8022a3 <uxTopReadyPriority>
    2c54:	98 17       	cp	r25, r24
    2c56:	10 f4       	brcc	.+4      	; 0x2c5c <xTaskResumeAll+0x5c>
    2c58:	80 93 a3 22 	sts	0x22A3, r24	; 0x8022a3 <uxTopReadyPriority>
    2c5c:	90 e0       	ldi	r25, 0x00	; 0
    2c5e:	9c 01       	movw	r18, r24
    2c60:	22 0f       	add	r18, r18
    2c62:	33 1f       	adc	r19, r19
    2c64:	22 0f       	add	r18, r18
    2c66:	33 1f       	adc	r19, r19
    2c68:	22 0f       	add	r18, r18
    2c6a:	33 1f       	adc	r19, r19
    2c6c:	82 0f       	add	r24, r18
    2c6e:	93 1f       	adc	r25, r19
    2c70:	b8 01       	movw	r22, r16
    2c72:	8a 53       	subi	r24, 0x3A	; 58
    2c74:	9d 4d       	sbci	r25, 0xDD	; 221
    2c76:	71 d8       	rcall	.-3870   	; 0x1d5a <vListInsertEnd>
    2c78:	e0 91 f3 22 	lds	r30, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    2c7c:	f0 91 f4 22 	lds	r31, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    2c80:	9e 89       	ldd	r25, Y+22	; 0x16
    2c82:	86 89       	ldd	r24, Z+22	; 0x16
    2c84:	98 17       	cp	r25, r24
    2c86:	68 f0       	brcs	.+26     	; 0x2ca2 <xTaskResumeAll+0xa2>
    2c88:	d0 92 9f 22 	sts	0x229F, r13	; 0x80229f <xYieldPending>
    2c8c:	0a c0       	rjmp	.+20     	; 0x2ca2 <xTaskResumeAll+0xa2>
    2c8e:	c0 e0       	ldi	r28, 0x00	; 0
    2c90:	d0 e0       	ldi	r29, 0x00	; 0
    2c92:	0f 2e       	mov	r0, r31
    2c94:	f7 ea       	ldi	r31, 0xA7	; 167
    2c96:	ef 2e       	mov	r14, r31
    2c98:	f2 e2       	ldi	r31, 0x22	; 34
    2c9a:	ff 2e       	mov	r15, r31
    2c9c:	f0 2d       	mov	r31, r0
    2c9e:	dd 24       	eor	r13, r13
    2ca0:	d3 94       	inc	r13
    2ca2:	f7 01       	movw	r30, r14
    2ca4:	80 81       	ld	r24, Z
    2ca6:	81 11       	cpse	r24, r1
    2ca8:	c3 cf       	rjmp	.-122    	; 0x2c30 <xTaskResumeAll+0x30>
    2caa:	cd 2b       	or	r28, r29
    2cac:	09 f0       	breq	.+2      	; 0x2cb0 <xTaskResumeAll+0xb0>
    2cae:	4f dd       	rcall	.-1378   	; 0x274e <prvResetNextTaskUnblockTime>
    2cb0:	c0 91 a0 22 	lds	r28, 0x22A0	; 0x8022a0 <xPendedTicks>
    2cb4:	d0 91 a1 22 	lds	r29, 0x22A1	; 0x8022a1 <xPendedTicks+0x1>
    2cb8:	20 97       	sbiw	r28, 0x00	; 0
    2cba:	59 f0       	breq	.+22     	; 0x2cd2 <xTaskResumeAll+0xd2>
    2cbc:	11 e0       	ldi	r17, 0x01	; 1
    2cbe:	e8 de       	rcall	.-560    	; 0x2a90 <xTaskIncrementTick>
    2cc0:	81 11       	cpse	r24, r1
    2cc2:	10 93 9f 22 	sts	0x229F, r17	; 0x80229f <xYieldPending>
    2cc6:	21 97       	sbiw	r28, 0x01	; 1
    2cc8:	d1 f7       	brne	.-12     	; 0x2cbe <xTaskResumeAll+0xbe>
    2cca:	10 92 a0 22 	sts	0x22A0, r1	; 0x8022a0 <xPendedTicks>
    2cce:	10 92 a1 22 	sts	0x22A1, r1	; 0x8022a1 <xPendedTicks+0x1>
    2cd2:	80 91 9f 22 	lds	r24, 0x229F	; 0x80229f <xYieldPending>
    2cd6:	88 23       	and	r24, r24
    2cd8:	29 f0       	breq	.+10     	; 0x2ce4 <xTaskResumeAll+0xe4>
    2cda:	74 d9       	rcall	.-3352   	; 0x1fc4 <vPortYield>
    2cdc:	81 e0       	ldi	r24, 0x01	; 1
    2cde:	03 c0       	rjmp	.+6      	; 0x2ce6 <xTaskResumeAll+0xe6>
    2ce0:	80 e0       	ldi	r24, 0x00	; 0
    2ce2:	01 c0       	rjmp	.+2      	; 0x2ce6 <xTaskResumeAll+0xe6>
    2ce4:	80 e0       	ldi	r24, 0x00	; 0
    2ce6:	0f 90       	pop	r0
    2ce8:	0f be       	out	0x3f, r0	; 63
    2cea:	df 91       	pop	r29
    2cec:	cf 91       	pop	r28
    2cee:	1f 91       	pop	r17
    2cf0:	0f 91       	pop	r16
    2cf2:	ff 90       	pop	r15
    2cf4:	ef 90       	pop	r14
    2cf6:	df 90       	pop	r13
    2cf8:	08 95       	ret

00002cfa <vTaskDelay>:
    2cfa:	cf 93       	push	r28
    2cfc:	df 93       	push	r29
    2cfe:	ec 01       	movw	r28, r24
    2d00:	89 2b       	or	r24, r25
    2d02:	39 f0       	breq	.+14     	; 0x2d12 <vTaskDelay+0x18>
    2d04:	b5 de       	rcall	.-662    	; 0x2a70 <vTaskSuspendAll>
    2d06:	60 e0       	ldi	r22, 0x00	; 0
    2d08:	ce 01       	movw	r24, r28
    2d0a:	47 dd       	rcall	.-1394   	; 0x279a <prvAddCurrentTaskToDelayedList>
    2d0c:	79 df       	rcall	.-270    	; 0x2c00 <xTaskResumeAll>
    2d0e:	81 11       	cpse	r24, r1
    2d10:	01 c0       	rjmp	.+2      	; 0x2d14 <vTaskDelay+0x1a>
    2d12:	58 d9       	rcall	.-3408   	; 0x1fc4 <vPortYield>
    2d14:	df 91       	pop	r29
    2d16:	cf 91       	pop	r28
    2d18:	08 95       	ret

00002d1a <vTaskSwitchContext>:
    2d1a:	80 91 98 22 	lds	r24, 0x2298	; 0x802298 <uxSchedulerSuspended>
    2d1e:	88 23       	and	r24, r24
    2d20:	21 f0       	breq	.+8      	; 0x2d2a <vTaskSwitchContext+0x10>
    2d22:	81 e0       	ldi	r24, 0x01	; 1
    2d24:	80 93 9f 22 	sts	0x229F, r24	; 0x80229f <xYieldPending>
    2d28:	08 95       	ret
    2d2a:	10 92 9f 22 	sts	0x229F, r1	; 0x80229f <xYieldPending>
    2d2e:	20 91 a3 22 	lds	r18, 0x22A3	; 0x8022a3 <uxTopReadyPriority>
    2d32:	82 2f       	mov	r24, r18
    2d34:	90 e0       	ldi	r25, 0x00	; 0
    2d36:	fc 01       	movw	r30, r24
    2d38:	ee 0f       	add	r30, r30
    2d3a:	ff 1f       	adc	r31, r31
    2d3c:	ee 0f       	add	r30, r30
    2d3e:	ff 1f       	adc	r31, r31
    2d40:	ee 0f       	add	r30, r30
    2d42:	ff 1f       	adc	r31, r31
    2d44:	e8 0f       	add	r30, r24
    2d46:	f9 1f       	adc	r31, r25
    2d48:	ea 53       	subi	r30, 0x3A	; 58
    2d4a:	fd 4d       	sbci	r31, 0xDD	; 221
    2d4c:	30 81       	ld	r19, Z
    2d4e:	31 11       	cpse	r19, r1
    2d50:	11 c0       	rjmp	.+34     	; 0x2d74 <vTaskSwitchContext+0x5a>
    2d52:	21 50       	subi	r18, 0x01	; 1
    2d54:	82 2f       	mov	r24, r18
    2d56:	90 e0       	ldi	r25, 0x00	; 0
    2d58:	fc 01       	movw	r30, r24
    2d5a:	ee 0f       	add	r30, r30
    2d5c:	ff 1f       	adc	r31, r31
    2d5e:	ee 0f       	add	r30, r30
    2d60:	ff 1f       	adc	r31, r31
    2d62:	ee 0f       	add	r30, r30
    2d64:	ff 1f       	adc	r31, r31
    2d66:	e8 0f       	add	r30, r24
    2d68:	f9 1f       	adc	r31, r25
    2d6a:	ea 53       	subi	r30, 0x3A	; 58
    2d6c:	fd 4d       	sbci	r31, 0xDD	; 221
    2d6e:	30 81       	ld	r19, Z
    2d70:	33 23       	and	r19, r19
    2d72:	79 f3       	breq	.-34     	; 0x2d52 <vTaskSwitchContext+0x38>
    2d74:	ac 01       	movw	r20, r24
    2d76:	44 0f       	add	r20, r20
    2d78:	55 1f       	adc	r21, r21
    2d7a:	44 0f       	add	r20, r20
    2d7c:	55 1f       	adc	r21, r21
    2d7e:	44 0f       	add	r20, r20
    2d80:	55 1f       	adc	r21, r21
    2d82:	48 0f       	add	r20, r24
    2d84:	59 1f       	adc	r21, r25
    2d86:	da 01       	movw	r26, r20
    2d88:	aa 53       	subi	r26, 0x3A	; 58
    2d8a:	bd 4d       	sbci	r27, 0xDD	; 221
    2d8c:	11 96       	adiw	r26, 0x01	; 1
    2d8e:	ed 91       	ld	r30, X+
    2d90:	fc 91       	ld	r31, X
    2d92:	12 97       	sbiw	r26, 0x02	; 2
    2d94:	02 80       	ldd	r0, Z+2	; 0x02
    2d96:	f3 81       	ldd	r31, Z+3	; 0x03
    2d98:	e0 2d       	mov	r30, r0
    2d9a:	11 96       	adiw	r26, 0x01	; 1
    2d9c:	ed 93       	st	X+, r30
    2d9e:	fc 93       	st	X, r31
    2da0:	12 97       	sbiw	r26, 0x02	; 2
    2da2:	47 53       	subi	r20, 0x37	; 55
    2da4:	5d 4d       	sbci	r21, 0xDD	; 221
    2da6:	e4 17       	cp	r30, r20
    2da8:	f5 07       	cpc	r31, r21
    2daa:	29 f4       	brne	.+10     	; 0x2db6 <vTaskSwitchContext+0x9c>
    2dac:	42 81       	ldd	r20, Z+2	; 0x02
    2dae:	53 81       	ldd	r21, Z+3	; 0x03
    2db0:	fd 01       	movw	r30, r26
    2db2:	41 83       	std	Z+1, r20	; 0x01
    2db4:	52 83       	std	Z+2, r21	; 0x02
    2db6:	fc 01       	movw	r30, r24
    2db8:	ee 0f       	add	r30, r30
    2dba:	ff 1f       	adc	r31, r31
    2dbc:	ee 0f       	add	r30, r30
    2dbe:	ff 1f       	adc	r31, r31
    2dc0:	ee 0f       	add	r30, r30
    2dc2:	ff 1f       	adc	r31, r31
    2dc4:	8e 0f       	add	r24, r30
    2dc6:	9f 1f       	adc	r25, r31
    2dc8:	fc 01       	movw	r30, r24
    2dca:	ea 53       	subi	r30, 0x3A	; 58
    2dcc:	fd 4d       	sbci	r31, 0xDD	; 221
    2dce:	01 80       	ldd	r0, Z+1	; 0x01
    2dd0:	f2 81       	ldd	r31, Z+2	; 0x02
    2dd2:	e0 2d       	mov	r30, r0
    2dd4:	86 81       	ldd	r24, Z+6	; 0x06
    2dd6:	97 81       	ldd	r25, Z+7	; 0x07
    2dd8:	80 93 f3 22 	sts	0x22F3, r24	; 0x8022f3 <pxCurrentTCB>
    2ddc:	90 93 f4 22 	sts	0x22F4, r25	; 0x8022f4 <pxCurrentTCB+0x1>
    2de0:	20 93 a3 22 	sts	0x22A3, r18	; 0x8022a3 <uxTopReadyPriority>
    2de4:	08 95       	ret

00002de6 <vTaskPlaceOnEventList>:
    2de6:	cf 93       	push	r28
    2de8:	df 93       	push	r29
    2dea:	eb 01       	movw	r28, r22
    2dec:	60 91 f3 22 	lds	r22, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    2df0:	70 91 f4 22 	lds	r23, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    2df4:	64 5f       	subi	r22, 0xF4	; 244
    2df6:	7f 4f       	sbci	r23, 0xFF	; 255
    2df8:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <vListInsert>
    2dfc:	61 e0       	ldi	r22, 0x01	; 1
    2dfe:	ce 01       	movw	r24, r28
    2e00:	cc dc       	rcall	.-1640   	; 0x279a <prvAddCurrentTaskToDelayedList>
    2e02:	df 91       	pop	r29
    2e04:	cf 91       	pop	r28
    2e06:	08 95       	ret

00002e08 <vTaskPlaceOnEventListRestricted>:
    2e08:	0f 93       	push	r16
    2e0a:	1f 93       	push	r17
    2e0c:	cf 93       	push	r28
    2e0e:	8b 01       	movw	r16, r22
    2e10:	c4 2f       	mov	r28, r20
    2e12:	60 91 f3 22 	lds	r22, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    2e16:	70 91 f4 22 	lds	r23, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    2e1a:	64 5f       	subi	r22, 0xF4	; 244
    2e1c:	7f 4f       	sbci	r23, 0xFF	; 255
    2e1e:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <vListInsertEnd>
    2e22:	cc 23       	and	r28, r28
    2e24:	11 f0       	breq	.+4      	; 0x2e2a <vTaskPlaceOnEventListRestricted+0x22>
    2e26:	0f ef       	ldi	r16, 0xFF	; 255
    2e28:	1f ef       	ldi	r17, 0xFF	; 255
    2e2a:	6c 2f       	mov	r22, r28
    2e2c:	c8 01       	movw	r24, r16
    2e2e:	b5 dc       	rcall	.-1686   	; 0x279a <prvAddCurrentTaskToDelayedList>
    2e30:	cf 91       	pop	r28
    2e32:	1f 91       	pop	r17
    2e34:	0f 91       	pop	r16
    2e36:	08 95       	ret

00002e38 <xTaskRemoveFromEventList>:
    2e38:	0f 93       	push	r16
    2e3a:	1f 93       	push	r17
    2e3c:	cf 93       	push	r28
    2e3e:	df 93       	push	r29
    2e40:	dc 01       	movw	r26, r24
    2e42:	15 96       	adiw	r26, 0x05	; 5
    2e44:	ed 91       	ld	r30, X+
    2e46:	fc 91       	ld	r31, X
    2e48:	16 97       	sbiw	r26, 0x06	; 6
    2e4a:	c6 81       	ldd	r28, Z+6	; 0x06
    2e4c:	d7 81       	ldd	r29, Z+7	; 0x07
    2e4e:	8e 01       	movw	r16, r28
    2e50:	04 5f       	subi	r16, 0xF4	; 244
    2e52:	1f 4f       	sbci	r17, 0xFF	; 255
    2e54:	c8 01       	movw	r24, r16
    2e56:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <uxListRemove>
    2e5a:	80 91 98 22 	lds	r24, 0x2298	; 0x802298 <uxSchedulerSuspended>
    2e5e:	81 11       	cpse	r24, r1
    2e60:	1c c0       	rjmp	.+56     	; 0x2e9a <xTaskRemoveFromEventList+0x62>
    2e62:	0a 50       	subi	r16, 0x0A	; 10
    2e64:	11 09       	sbc	r17, r1
    2e66:	c8 01       	movw	r24, r16
    2e68:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <uxListRemove>
    2e6c:	8e 89       	ldd	r24, Y+22	; 0x16
    2e6e:	90 91 a3 22 	lds	r25, 0x22A3	; 0x8022a3 <uxTopReadyPriority>
    2e72:	98 17       	cp	r25, r24
    2e74:	10 f4       	brcc	.+4      	; 0x2e7a <xTaskRemoveFromEventList+0x42>
    2e76:	80 93 a3 22 	sts	0x22A3, r24	; 0x8022a3 <uxTopReadyPriority>
    2e7a:	90 e0       	ldi	r25, 0x00	; 0
    2e7c:	9c 01       	movw	r18, r24
    2e7e:	22 0f       	add	r18, r18
    2e80:	33 1f       	adc	r19, r19
    2e82:	22 0f       	add	r18, r18
    2e84:	33 1f       	adc	r19, r19
    2e86:	22 0f       	add	r18, r18
    2e88:	33 1f       	adc	r19, r19
    2e8a:	82 0f       	add	r24, r18
    2e8c:	93 1f       	adc	r25, r19
    2e8e:	b8 01       	movw	r22, r16
    2e90:	8a 53       	subi	r24, 0x3A	; 58
    2e92:	9d 4d       	sbci	r25, 0xDD	; 221
    2e94:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <vListInsertEnd>
    2e98:	05 c0       	rjmp	.+10     	; 0x2ea4 <xTaskRemoveFromEventList+0x6c>
    2e9a:	b8 01       	movw	r22, r16
    2e9c:	87 ea       	ldi	r24, 0xA7	; 167
    2e9e:	92 e2       	ldi	r25, 0x22	; 34
    2ea0:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <vListInsertEnd>
    2ea4:	e0 91 f3 22 	lds	r30, 0x22F3	; 0x8022f3 <pxCurrentTCB>
    2ea8:	f0 91 f4 22 	lds	r31, 0x22F4	; 0x8022f4 <pxCurrentTCB+0x1>
    2eac:	9e 89       	ldd	r25, Y+22	; 0x16
    2eae:	86 89       	ldd	r24, Z+22	; 0x16
    2eb0:	89 17       	cp	r24, r25
    2eb2:	20 f4       	brcc	.+8      	; 0x2ebc <xTaskRemoveFromEventList+0x84>
    2eb4:	81 e0       	ldi	r24, 0x01	; 1
    2eb6:	80 93 9f 22 	sts	0x229F, r24	; 0x80229f <xYieldPending>
    2eba:	01 c0       	rjmp	.+2      	; 0x2ebe <xTaskRemoveFromEventList+0x86>
    2ebc:	80 e0       	ldi	r24, 0x00	; 0
    2ebe:	df 91       	pop	r29
    2ec0:	cf 91       	pop	r28
    2ec2:	1f 91       	pop	r17
    2ec4:	0f 91       	pop	r16
    2ec6:	08 95       	ret

00002ec8 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2ec8:	20 91 9e 22 	lds	r18, 0x229E	; 0x80229e <xNumOfOverflows>
    2ecc:	fc 01       	movw	r30, r24
    2ece:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2ed0:	20 91 a4 22 	lds	r18, 0x22A4	; 0x8022a4 <xTickCount>
    2ed4:	30 91 a5 22 	lds	r19, 0x22A5	; 0x8022a5 <xTickCount+0x1>
    2ed8:	21 83       	std	Z+1, r18	; 0x01
    2eda:	32 83       	std	Z+2, r19	; 0x02
    2edc:	08 95       	ret

00002ede <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2ede:	0f b6       	in	r0, 0x3f	; 63
    2ee0:	f8 94       	cli
    2ee2:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2ee4:	20 91 a4 22 	lds	r18, 0x22A4	; 0x8022a4 <xTickCount>
    2ee8:	30 91 a5 22 	lds	r19, 0x22A5	; 0x8022a5 <xTickCount+0x1>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    2eec:	dc 01       	movw	r26, r24
    2eee:	11 96       	adiw	r26, 0x01	; 1
    2ef0:	4d 91       	ld	r20, X+
    2ef2:	5c 91       	ld	r21, X
    2ef4:	12 97       	sbiw	r26, 0x02	; 2
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2ef6:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <xNumOfOverflows>
    2efa:	fc 91       	ld	r31, X
    2efc:	fe 17       	cp	r31, r30
    2efe:	19 f0       	breq	.+6      	; 0x2f06 <xTaskCheckForTimeOut+0x28>
    2f00:	24 17       	cp	r18, r20
    2f02:	35 07       	cpc	r19, r21
    2f04:	98 f4       	brcc	.+38     	; 0x2f2c <xTaskCheckForTimeOut+0x4e>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    2f06:	24 1b       	sub	r18, r20
    2f08:	35 0b       	sbc	r19, r21
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    2f0a:	fb 01       	movw	r30, r22
    2f0c:	40 81       	ld	r20, Z
    2f0e:	51 81       	ldd	r21, Z+1	; 0x01
    2f10:	24 17       	cp	r18, r20
    2f12:	35 07       	cpc	r19, r21
    2f14:	38 f4       	brcc	.+14     	; 0x2f24 <xTaskCheckForTimeOut+0x46>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    2f16:	42 1b       	sub	r20, r18
    2f18:	53 0b       	sbc	r21, r19
    2f1a:	40 83       	st	Z, r20
    2f1c:	51 83       	std	Z+1, r21	; 0x01
			vTaskInternalSetTimeOutState( pxTimeOut );
    2f1e:	d4 df       	rcall	.-88     	; 0x2ec8 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    2f20:	80 e0       	ldi	r24, 0x00	; 0
    2f22:	05 c0       	rjmp	.+10     	; 0x2f2e <xTaskCheckForTimeOut+0x50>
		}
		else
		{
			*pxTicksToWait = 0;
    2f24:	10 82       	st	Z, r1
    2f26:	11 82       	std	Z+1, r1	; 0x01
			xReturn = pdTRUE;
    2f28:	81 e0       	ldi	r24, 0x01	; 1
    2f2a:	01 c0       	rjmp	.+2      	; 0x2f2e <xTaskCheckForTimeOut+0x50>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    2f2c:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    2f2e:	0f 90       	pop	r0
    2f30:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2f32:	08 95       	ret

00002f34 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2f34:	81 e0       	ldi	r24, 0x01	; 1
    2f36:	80 93 9f 22 	sts	0x229F, r24	; 0x80229f <xYieldPending>
    2f3a:	08 95       	ret

00002f3c <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    2f3c:	80 91 a2 22 	lds	r24, 0x22A2	; 0x8022a2 <xSchedulerRunning>
    2f40:	88 23       	and	r24, r24
    2f42:	31 f0       	breq	.+12     	; 0x2f50 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2f44:	80 91 98 22 	lds	r24, 0x2298	; 0x802298 <uxSchedulerSuspended>
    2f48:	88 23       	and	r24, r24
    2f4a:	21 f0       	breq	.+8      	; 0x2f54 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    2f4c:	80 e0       	ldi	r24, 0x00	; 0
    2f4e:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    2f50:	81 e0       	ldi	r24, 0x01	; 1
    2f52:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    2f54:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    2f56:	08 95       	ret

00002f58 <prvInsertTimerInActiveList>:
			pxNewTimer->ucStatus = 0x00;
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
		}

		return pxNewTimer;
	}
    2f58:	fc 01       	movw	r30, r24
    2f5a:	62 83       	std	Z+2, r22	; 0x02
    2f5c:	73 83       	std	Z+3, r23	; 0x03
    2f5e:	80 87       	std	Z+8, r24	; 0x08
    2f60:	91 87       	std	Z+9, r25	; 0x09
    2f62:	46 17       	cp	r20, r22
    2f64:	57 07       	cpc	r21, r23
    2f66:	90 f0       	brcs	.+36     	; 0x2f8c <prvInsertTimerInActiveList+0x34>
    2f68:	42 1b       	sub	r20, r18
    2f6a:	53 0b       	sbc	r21, r19
    2f6c:	84 85       	ldd	r24, Z+12	; 0x0c
    2f6e:	95 85       	ldd	r25, Z+13	; 0x0d
    2f70:	48 17       	cp	r20, r24
    2f72:	59 07       	cpc	r21, r25
    2f74:	e0 f4       	brcc	.+56     	; 0x2fae <prvInsertTimerInActiveList+0x56>
    2f76:	bf 01       	movw	r22, r30
    2f78:	6e 5f       	subi	r22, 0xFE	; 254
    2f7a:	7f 4f       	sbci	r23, 0xFF	; 255
    2f7c:	80 91 fb 22 	lds	r24, 0x22FB	; 0x8022fb <pxOverflowTimerList>
    2f80:	90 91 fc 22 	lds	r25, 0x22FC	; 0x8022fc <pxOverflowTimerList+0x1>
    2f84:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <vListInsert>
    2f88:	80 e0       	ldi	r24, 0x00	; 0
    2f8a:	08 95       	ret
    2f8c:	42 17       	cp	r20, r18
    2f8e:	53 07       	cpc	r21, r19
    2f90:	18 f4       	brcc	.+6      	; 0x2f98 <prvInsertTimerInActiveList+0x40>
    2f92:	62 17       	cp	r22, r18
    2f94:	73 07       	cpc	r23, r19
    2f96:	68 f4       	brcc	.+26     	; 0x2fb2 <prvInsertTimerInActiveList+0x5a>
    2f98:	bf 01       	movw	r22, r30
    2f9a:	6e 5f       	subi	r22, 0xFE	; 254
    2f9c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f9e:	80 91 fd 22 	lds	r24, 0x22FD	; 0x8022fd <pxCurrentTimerList>
    2fa2:	90 91 fe 22 	lds	r25, 0x22FE	; 0x8022fe <pxCurrentTimerList+0x1>
    2fa6:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <vListInsert>
    2faa:	80 e0       	ldi	r24, 0x00	; 0
    2fac:	08 95       	ret
    2fae:	81 e0       	ldi	r24, 0x01	; 1
    2fb0:	08 95       	ret
    2fb2:	81 e0       	ldi	r24, 0x01	; 1
    2fb4:	08 95       	ret

00002fb6 <prvCheckForValidListAndQueue>:
    2fb6:	0f b6       	in	r0, 0x3f	; 63
    2fb8:	f8 94       	cli
    2fba:	0f 92       	push	r0
    2fbc:	80 91 f9 22 	lds	r24, 0x22F9	; 0x8022f9 <xTimerQueue>
    2fc0:	90 91 fa 22 	lds	r25, 0x22FA	; 0x8022fa <xTimerQueue+0x1>
    2fc4:	89 2b       	or	r24, r25
    2fc6:	e1 f4       	brne	.+56     	; 0x3000 <prvCheckForValidListAndQueue+0x4a>
    2fc8:	88 e0       	ldi	r24, 0x08	; 8
    2fca:	93 e2       	ldi	r25, 0x23	; 35
    2fcc:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <vListInitialise>
    2fd0:	8f ef       	ldi	r24, 0xFF	; 255
    2fd2:	92 e2       	ldi	r25, 0x22	; 34
    2fd4:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <vListInitialise>
    2fd8:	88 e0       	ldi	r24, 0x08	; 8
    2fda:	93 e2       	ldi	r25, 0x23	; 35
    2fdc:	80 93 fd 22 	sts	0x22FD, r24	; 0x8022fd <pxCurrentTimerList>
    2fe0:	90 93 fe 22 	sts	0x22FE, r25	; 0x8022fe <pxCurrentTimerList+0x1>
    2fe4:	8f ef       	ldi	r24, 0xFF	; 255
    2fe6:	92 e2       	ldi	r25, 0x22	; 34
    2fe8:	80 93 fb 22 	sts	0x22FB, r24	; 0x8022fb <pxOverflowTimerList>
    2fec:	90 93 fc 22 	sts	0x22FC, r25	; 0x8022fc <pxOverflowTimerList+0x1>
    2ff0:	40 e0       	ldi	r20, 0x00	; 0
    2ff2:	65 e0       	ldi	r22, 0x05	; 5
    2ff4:	8a e0       	ldi	r24, 0x0A	; 10
    2ff6:	ab d9       	rcall	.-3242   	; 0x234e <xQueueGenericCreate>
    2ff8:	80 93 f9 22 	sts	0x22F9, r24	; 0x8022f9 <xTimerQueue>
    2ffc:	90 93 fa 22 	sts	0x22FA, r25	; 0x8022fa <xTimerQueue+0x1>
    3000:	0f 90       	pop	r0
    3002:	0f be       	out	0x3f, r0	; 63
    3004:	08 95       	ret

00003006 <xTimerCreateTimerTask>:
    3006:	ef 92       	push	r14
    3008:	ff 92       	push	r15
    300a:	0f 93       	push	r16
    300c:	d4 df       	rcall	.-88     	; 0x2fb6 <prvCheckForValidListAndQueue>
    300e:	80 91 f9 22 	lds	r24, 0x22F9	; 0x8022f9 <xTimerQueue>
    3012:	90 91 fa 22 	lds	r25, 0x22FA	; 0x8022fa <xTimerQueue+0x1>
    3016:	89 2b       	or	r24, r25
    3018:	89 f0       	breq	.+34     	; 0x303c <xTimerCreateTimerTask+0x36>
    301a:	0f 2e       	mov	r0, r31
    301c:	f7 ef       	ldi	r31, 0xF7	; 247
    301e:	ef 2e       	mov	r14, r31
    3020:	f2 e2       	ldi	r31, 0x22	; 34
    3022:	ff 2e       	mov	r15, r31
    3024:	f0 2d       	mov	r31, r0
    3026:	03 e0       	ldi	r16, 0x03	; 3
    3028:	20 e0       	ldi	r18, 0x00	; 0
    302a:	30 e0       	ldi	r19, 0x00	; 0
    302c:	45 e5       	ldi	r20, 0x55	; 85
    302e:	50 e0       	ldi	r21, 0x00	; 0
    3030:	62 e1       	ldi	r22, 0x12	; 18
    3032:	70 e2       	ldi	r23, 0x20	; 32
    3034:	83 ed       	ldi	r24, 0xD3	; 211
    3036:	98 e1       	ldi	r25, 0x18	; 24
    3038:	f1 db       	rcall	.-2078   	; 0x281c <xTaskCreate>
    303a:	01 c0       	rjmp	.+2      	; 0x303e <xTimerCreateTimerTask+0x38>
    303c:	80 e0       	ldi	r24, 0x00	; 0
    303e:	0f 91       	pop	r16
    3040:	ff 90       	pop	r15
    3042:	ef 90       	pop	r14
    3044:	08 95       	ret

00003046 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    3046:	0f 93       	push	r16
    3048:	1f 93       	push	r17
    304a:	cf 93       	push	r28
    304c:	df 93       	push	r29
    304e:	cd b7       	in	r28, 0x3d	; 61
    3050:	de b7       	in	r29, 0x3e	; 62
    3052:	25 97       	sbiw	r28, 0x05	; 5
    3054:	cd bf       	out	0x3d, r28	; 61
    3056:	de bf       	out	0x3e, r29	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    3058:	e0 91 f9 22 	lds	r30, 0x22F9	; 0x8022f9 <xTimerQueue>
    305c:	f0 91 fa 22 	lds	r31, 0x22FA	; 0x8022fa <xTimerQueue+0x1>
    3060:	30 97       	sbiw	r30, 0x00	; 0
    3062:	51 f1       	breq	.+84     	; 0x30b8 <xTimerGenericCommand+0x72>
    3064:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    3066:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    3068:	4a 83       	std	Y+2, r20	; 0x02
    306a:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    306c:	8c 83       	std	Y+4, r24	; 0x04
    306e:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    3070:	66 30       	cpi	r22, 0x06	; 6
    3072:	d4 f4       	brge	.+52     	; 0x30a8 <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    3074:	63 df       	rcall	.-314    	; 0x2f3c <xTaskGetSchedulerState>
    3076:	82 30       	cpi	r24, 0x02	; 2
    3078:	59 f4       	brne	.+22     	; 0x3090 <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    307a:	20 e0       	ldi	r18, 0x00	; 0
    307c:	a8 01       	movw	r20, r16
    307e:	be 01       	movw	r22, r28
    3080:	6f 5f       	subi	r22, 0xFF	; 255
    3082:	7f 4f       	sbci	r23, 0xFF	; 255
    3084:	80 91 f9 22 	lds	r24, 0x22F9	; 0x8022f9 <xTimerQueue>
    3088:	90 91 fa 22 	lds	r25, 0x22FA	; 0x8022fa <xTimerQueue+0x1>
    308c:	81 d9       	rcall	.-3326   	; 0x2390 <xQueueGenericSend>
    308e:	15 c0       	rjmp	.+42     	; 0x30ba <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    3090:	20 e0       	ldi	r18, 0x00	; 0
    3092:	40 e0       	ldi	r20, 0x00	; 0
    3094:	50 e0       	ldi	r21, 0x00	; 0
    3096:	be 01       	movw	r22, r28
    3098:	6f 5f       	subi	r22, 0xFF	; 255
    309a:	7f 4f       	sbci	r23, 0xFF	; 255
    309c:	80 91 f9 22 	lds	r24, 0x22F9	; 0x8022f9 <xTimerQueue>
    30a0:	90 91 fa 22 	lds	r25, 0x22FA	; 0x8022fa <xTimerQueue+0x1>
    30a4:	75 d9       	rcall	.-3350   	; 0x2390 <xQueueGenericSend>
    30a6:	09 c0       	rjmp	.+18     	; 0x30ba <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    30a8:	20 e0       	ldi	r18, 0x00	; 0
    30aa:	ad 01       	movw	r20, r26
    30ac:	be 01       	movw	r22, r28
    30ae:	6f 5f       	subi	r22, 0xFF	; 255
    30b0:	7f 4f       	sbci	r23, 0xFF	; 255
    30b2:	cf 01       	movw	r24, r30
    30b4:	fa d9       	rcall	.-3084   	; 0x24aa <xQueueGenericSendFromISR>
    30b6:	01 c0       	rjmp	.+2      	; 0x30ba <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    30b8:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    30ba:	25 96       	adiw	r28, 0x05	; 5
    30bc:	cd bf       	out	0x3d, r28	; 61
    30be:	de bf       	out	0x3e, r29	; 62
    30c0:	df 91       	pop	r29
    30c2:	cf 91       	pop	r28
    30c4:	1f 91       	pop	r17
    30c6:	0f 91       	pop	r16
    30c8:	08 95       	ret

000030ca <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    30ca:	af 92       	push	r10
    30cc:	bf 92       	push	r11
    30ce:	cf 92       	push	r12
    30d0:	df 92       	push	r13
    30d2:	ef 92       	push	r14
    30d4:	ff 92       	push	r15
    30d6:	0f 93       	push	r16
    30d8:	1f 93       	push	r17
    30da:	cf 93       	push	r28
    30dc:	df 93       	push	r29
    30de:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    30e0:	cd dc       	rcall	.-1638   	; 0x2a7c <xTaskGetTickCount>
    30e2:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    30e4:	80 91 f5 22 	lds	r24, 0x22F5	; 0x8022f5 <xLastTime.4598>
    30e8:	90 91 f6 22 	lds	r25, 0x22F6	; 0x8022f6 <xLastTime.4598+0x1>
    30ec:	e8 16       	cp	r14, r24
    30ee:	f9 06       	cpc	r15, r25
    30f0:	08 f0       	brcs	.+2      	; 0x30f4 <prvSampleTimeNow+0x2a>
    30f2:	47 c0       	rjmp	.+142    	; 0x3182 <prvSampleTimeNow+0xb8>
    30f4:	2f c0       	rjmp	.+94     	; 0x3154 <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    30f6:	05 80       	ldd	r0, Z+5	; 0x05
    30f8:	f6 81       	ldd	r31, Z+6	; 0x06
    30fa:	e0 2d       	mov	r30, r0
    30fc:	a0 80       	ld	r10, Z
    30fe:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3100:	c6 81       	ldd	r28, Z+6	; 0x06
    3102:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3104:	8e 01       	movw	r16, r28
    3106:	0e 5f       	subi	r16, 0xFE	; 254
    3108:	1f 4f       	sbci	r17, 0xFF	; 255
    310a:	c8 01       	movw	r24, r16
    310c:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3110:	e8 89       	ldd	r30, Y+16	; 0x10
    3112:	f9 89       	ldd	r31, Y+17	; 0x11
    3114:	ce 01       	movw	r24, r28
    3116:	19 95       	eicall

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    3118:	8a 89       	ldd	r24, Y+18	; 0x12
    311a:	82 ff       	sbrs	r24, 2
    311c:	1b c0       	rjmp	.+54     	; 0x3154 <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    311e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3120:	9d 85       	ldd	r25, Y+13	; 0x0d
    3122:	8a 0d       	add	r24, r10
    3124:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    3126:	a8 16       	cp	r10, r24
    3128:	b9 06       	cpc	r11, r25
    312a:	60 f4       	brcc	.+24     	; 0x3144 <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    312c:	8a 83       	std	Y+2, r24	; 0x02
    312e:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3130:	c8 87       	std	Y+8, r28	; 0x08
    3132:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3134:	b8 01       	movw	r22, r16
    3136:	80 91 fd 22 	lds	r24, 0x22FD	; 0x8022fd <pxCurrentTimerList>
    313a:	90 91 fe 22 	lds	r25, 0x22FE	; 0x8022fe <pxCurrentTimerList+0x1>
    313e:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <vListInsert>
    3142:	08 c0       	rjmp	.+16     	; 0x3154 <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3144:	00 e0       	ldi	r16, 0x00	; 0
    3146:	10 e0       	ldi	r17, 0x00	; 0
    3148:	20 e0       	ldi	r18, 0x00	; 0
    314a:	30 e0       	ldi	r19, 0x00	; 0
    314c:	a5 01       	movw	r20, r10
    314e:	60 e0       	ldi	r22, 0x00	; 0
    3150:	ce 01       	movw	r24, r28
    3152:	79 df       	rcall	.-270    	; 0x3046 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3154:	e0 91 fd 22 	lds	r30, 0x22FD	; 0x8022fd <pxCurrentTimerList>
    3158:	f0 91 fe 22 	lds	r31, 0x22FE	; 0x8022fe <pxCurrentTimerList+0x1>
    315c:	80 81       	ld	r24, Z
    315e:	81 11       	cpse	r24, r1
    3160:	ca cf       	rjmp	.-108    	; 0x30f6 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    3162:	80 91 fb 22 	lds	r24, 0x22FB	; 0x8022fb <pxOverflowTimerList>
    3166:	90 91 fc 22 	lds	r25, 0x22FC	; 0x8022fc <pxOverflowTimerList+0x1>
    316a:	80 93 fd 22 	sts	0x22FD, r24	; 0x8022fd <pxCurrentTimerList>
    316e:	90 93 fe 22 	sts	0x22FE, r25	; 0x8022fe <pxCurrentTimerList+0x1>
	pxOverflowTimerList = pxTemp;
    3172:	e0 93 fb 22 	sts	0x22FB, r30	; 0x8022fb <pxOverflowTimerList>
    3176:	f0 93 fc 22 	sts	0x22FC, r31	; 0x8022fc <pxOverflowTimerList+0x1>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    317a:	81 e0       	ldi	r24, 0x01	; 1
    317c:	f6 01       	movw	r30, r12
    317e:	80 83       	st	Z, r24
    3180:	02 c0       	rjmp	.+4      	; 0x3186 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    3182:	f6 01       	movw	r30, r12
    3184:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    3186:	e0 92 f5 22 	sts	0x22F5, r14	; 0x8022f5 <xLastTime.4598>
    318a:	f0 92 f6 22 	sts	0x22F6, r15	; 0x8022f6 <xLastTime.4598+0x1>

	return xTimeNow;
}
    318e:	c7 01       	movw	r24, r14
    3190:	df 91       	pop	r29
    3192:	cf 91       	pop	r28
    3194:	1f 91       	pop	r17
    3196:	0f 91       	pop	r16
    3198:	ff 90       	pop	r15
    319a:	ef 90       	pop	r14
    319c:	df 90       	pop	r13
    319e:	cf 90       	pop	r12
    31a0:	bf 90       	pop	r11
    31a2:	af 90       	pop	r10
    31a4:	08 95       	ret

000031a6 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    31a6:	cf 93       	push	r28
    31a8:	df 93       	push	r29
    31aa:	00 d0       	rcall	.+0      	; 0x31ac <prvTimerTask+0x6>
    31ac:	00 d0       	rcall	.+0      	; 0x31ae <prvTimerTask+0x8>
    31ae:	cd b7       	in	r28, 0x3d	; 61
    31b0:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    31b2:	ce 01       	movw	r24, r28
    31b4:	01 96       	adiw	r24, 0x01	; 1
    31b6:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    31b8:	e8 2e       	mov	r14, r24
    31ba:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    31bc:	e0 91 fd 22 	lds	r30, 0x22FD	; 0x8022fd <pxCurrentTimerList>
    31c0:	f0 91 fe 22 	lds	r31, 0x22FE	; 0x8022fe <pxCurrentTimerList+0x1>
    31c4:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    31c6:	88 23       	and	r24, r24
    31c8:	09 f4       	brne	.+2      	; 0x31cc <prvTimerTask+0x26>
    31ca:	cf c0       	rjmp	.+414    	; 0x336a <prvTimerTask+0x1c4>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    31cc:	05 80       	ldd	r0, Z+5	; 0x05
    31ce:	f6 81       	ldd	r31, Z+6	; 0x06
    31d0:	e0 2d       	mov	r30, r0
    31d2:	c0 80       	ld	r12, Z
    31d4:	d1 80       	ldd	r13, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    31d6:	4c dc       	rcall	.-1896   	; 0x2a70 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    31d8:	c5 01       	movw	r24, r10
    31da:	77 df       	rcall	.-274    	; 0x30ca <prvSampleTimeNow>
    31dc:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    31de:	89 81       	ldd	r24, Y+1	; 0x01
    31e0:	81 11       	cpse	r24, r1
    31e2:	46 c0       	rjmp	.+140    	; 0x3270 <prvTimerTask+0xca>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    31e4:	0c 15       	cp	r16, r12
    31e6:	1d 05       	cpc	r17, r13
			{
				( void ) xTaskResumeAll();
    31e8:	a0 f1       	brcs	.+104    	; 0x3252 <prvTimerTask+0xac>
    31ea:	0a dd       	rcall	.-1516   	; 0x2c00 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    31ec:	e0 91 fd 22 	lds	r30, 0x22FD	; 0x8022fd <pxCurrentTimerList>
    31f0:	f0 91 fe 22 	lds	r31, 0x22FE	; 0x8022fe <pxCurrentTimerList+0x1>
    31f4:	05 80       	ldd	r0, Z+5	; 0x05
    31f6:	f6 81       	ldd	r31, Z+6	; 0x06
    31f8:	e0 2d       	mov	r30, r0
    31fa:	86 80       	ldd	r8, Z+6	; 0x06
    31fc:	97 80       	ldd	r9, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    31fe:	c4 01       	movw	r24, r8
    3200:	02 96       	adiw	r24, 0x02	; 2
    3202:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto-reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    3206:	d4 01       	movw	r26, r8
    3208:	52 96       	adiw	r26, 0x12	; 18
    320a:	8c 91       	ld	r24, X
    320c:	52 97       	sbiw	r26, 0x12	; 18
    320e:	82 ff       	sbrs	r24, 2
    3210:	15 c0       	rjmp	.+42     	; 0x323c <prvTimerTask+0x96>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    3212:	1c 96       	adiw	r26, 0x0c	; 12
    3214:	6d 91       	ld	r22, X+
    3216:	7c 91       	ld	r23, X
    3218:	1d 97       	sbiw	r26, 0x0d	; 13
    321a:	6c 0d       	add	r22, r12
    321c:	7d 1d       	adc	r23, r13
    321e:	96 01       	movw	r18, r12
    3220:	a8 01       	movw	r20, r16
    3222:	c4 01       	movw	r24, r8
    3224:	99 de       	rcall	.-718    	; 0x2f58 <prvInsertTimerInActiveList>
    3226:	88 23       	and	r24, r24
    3228:	61 f0       	breq	.+24     	; 0x3242 <prvTimerTask+0x9c>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    322a:	00 e0       	ldi	r16, 0x00	; 0
    322c:	10 e0       	ldi	r17, 0x00	; 0
    322e:	20 e0       	ldi	r18, 0x00	; 0
    3230:	30 e0       	ldi	r19, 0x00	; 0
    3232:	a6 01       	movw	r20, r12
    3234:	60 e0       	ldi	r22, 0x00	; 0
    3236:	c4 01       	movw	r24, r8
    3238:	06 df       	rcall	.-500    	; 0x3046 <xTimerGenericCommand>
    323a:	03 c0       	rjmp	.+6      	; 0x3242 <prvTimerTask+0x9c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    323c:	8e 7f       	andi	r24, 0xFE	; 254
    323e:	f4 01       	movw	r30, r8
    3240:	82 8b       	std	Z+18, r24	; 0x12
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3242:	d4 01       	movw	r26, r8
    3244:	50 96       	adiw	r26, 0x10	; 16
    3246:	ed 91       	ld	r30, X+
    3248:	fc 91       	ld	r31, X
    324a:	51 97       	sbiw	r26, 0x11	; 17
    324c:	c4 01       	movw	r24, r8
    324e:	19 95       	eicall
    3250:	80 c0       	rjmp	.+256    	; 0x3352 <prvTimerTask+0x1ac>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3252:	40 e0       	ldi	r20, 0x00	; 0
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    3254:	b6 01       	movw	r22, r12
    3256:	60 1b       	sub	r22, r16
    3258:	71 0b       	sbc	r23, r17
    325a:	80 91 f9 22 	lds	r24, 0x22F9	; 0x8022f9 <xTimerQueue>
    325e:	90 91 fa 22 	lds	r25, 0x22FA	; 0x8022fa <xTimerQueue+0x1>

				if( xTaskResumeAll() == pdFALSE )
    3262:	5a da       	rcall	.-2892   	; 0x2718 <vQueueWaitForMessageRestricted>
    3264:	cd dc       	rcall	.-1638   	; 0x2c00 <xTaskResumeAll>
    3266:	81 11       	cpse	r24, r1
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    3268:	74 c0       	rjmp	.+232    	; 0x3352 <prvTimerTask+0x1ac>
    326a:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <vPortYield>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    326e:	71 c0       	rjmp	.+226    	; 0x3352 <prvTimerTask+0x1ac>
    3270:	c7 dc       	rcall	.-1650   	; 0x2c00 <xTaskResumeAll>
    3272:	6f c0       	rjmp	.+222    	; 0x3352 <prvTimerTask+0x1ac>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3274:	89 81       	ldd	r24, Y+1	; 0x01
    3276:	88 23       	and	r24, r24
    3278:	0c f4       	brge	.+2      	; 0x327c <prvTimerTask+0xd6>
    327a:	6b c0       	rjmp	.+214    	; 0x3352 <prvTimerTask+0x1ac>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    327c:	cc 80       	ldd	r12, Y+4	; 0x04
    327e:	dd 80       	ldd	r13, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    3280:	f6 01       	movw	r30, r12
    3282:	82 85       	ldd	r24, Z+10	; 0x0a
    3284:	93 85       	ldd	r25, Z+11	; 0x0b
    3286:	89 2b       	or	r24, r25
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3288:	21 f0       	breq	.+8      	; 0x3292 <prvTimerTask+0xec>
    328a:	c6 01       	movw	r24, r12
    328c:	02 96       	adiw	r24, 0x02	; 2
    328e:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3292:	ce 01       	movw	r24, r28
    3294:	06 96       	adiw	r24, 0x06	; 6
    3296:	19 df       	rcall	.-462    	; 0x30ca <prvSampleTimeNow>
    3298:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    329a:	e9 81       	ldd	r30, Y+1	; 0x01
    329c:	0e 2e       	mov	r0, r30
    329e:	00 0c       	add	r0, r0
    32a0:	ff 0b       	sbc	r31, r31
    32a2:	ea 30       	cpi	r30, 0x0A	; 10
    32a4:	f1 05       	cpc	r31, r1
    32a6:	08 f0       	brcs	.+2      	; 0x32aa <prvTimerTask+0x104>
    32a8:	54 c0       	rjmp	.+168    	; 0x3352 <prvTimerTask+0x1ac>
    32aa:	88 27       	eor	r24, r24
    32ac:	e2 50       	subi	r30, 0x02	; 2
    32ae:	ff 4f       	sbci	r31, 0xFF	; 255
    32b0:	8f 4f       	sbci	r24, 0xFF	; 255
    32b2:	30 c5       	rjmp	.+2656   	; 0x3d14 <__tablejump2__>
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    32b4:	d6 01       	movw	r26, r12
    32b6:	52 96       	adiw	r26, 0x12	; 18
    32b8:	8c 91       	ld	r24, X
    32ba:	52 97       	sbiw	r26, 0x12	; 18
    32bc:	81 60       	ori	r24, 0x01	; 1
    32be:	52 96       	adiw	r26, 0x12	; 18
    32c0:	8c 93       	st	X, r24
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    32c2:	52 97       	sbiw	r26, 0x12	; 18
    32c4:	2a 81       	ldd	r18, Y+2	; 0x02
    32c6:	3b 81       	ldd	r19, Y+3	; 0x03
    32c8:	1c 96       	adiw	r26, 0x0c	; 12
    32ca:	6d 91       	ld	r22, X+
    32cc:	7c 91       	ld	r23, X
    32ce:	1d 97       	sbiw	r26, 0x0d	; 13
    32d0:	62 0f       	add	r22, r18
    32d2:	73 1f       	adc	r23, r19
    32d4:	c6 01       	movw	r24, r12
    32d6:	40 de       	rcall	.-896    	; 0x2f58 <prvInsertTimerInActiveList>
    32d8:	88 23       	and	r24, r24
    32da:	d9 f1       	breq	.+118    	; 0x3352 <prvTimerTask+0x1ac>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    32dc:	d6 01       	movw	r26, r12
    32de:	50 96       	adiw	r26, 0x10	; 16
    32e0:	ed 91       	ld	r30, X+
    32e2:	fc 91       	ld	r31, X
    32e4:	51 97       	sbiw	r26, 0x11	; 17
    32e6:	c6 01       	movw	r24, r12
    32e8:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    32ea:	f6 01       	movw	r30, r12
    32ec:	82 89       	ldd	r24, Z+18	; 0x12
    32ee:	82 ff       	sbrs	r24, 2
    32f0:	30 c0       	rjmp	.+96     	; 0x3352 <prvTimerTask+0x1ac>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    32f2:	4a 81       	ldd	r20, Y+2	; 0x02
    32f4:	5b 81       	ldd	r21, Y+3	; 0x03
    32f6:	84 85       	ldd	r24, Z+12	; 0x0c
    32f8:	95 85       	ldd	r25, Z+13	; 0x0d
    32fa:	48 0f       	add	r20, r24
    32fc:	59 1f       	adc	r21, r25
    32fe:	00 e0       	ldi	r16, 0x00	; 0
    3300:	10 e0       	ldi	r17, 0x00	; 0
    3302:	20 e0       	ldi	r18, 0x00	; 0
    3304:	30 e0       	ldi	r19, 0x00	; 0
    3306:	60 e0       	ldi	r22, 0x00	; 0
    3308:	c6 01       	movw	r24, r12
    330a:	9d de       	rcall	.-710    	; 0x3046 <xTimerGenericCommand>
    330c:	22 c0       	rjmp	.+68     	; 0x3352 <prvTimerTask+0x1ac>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    330e:	d6 01       	movw	r26, r12
    3310:	52 96       	adiw	r26, 0x12	; 18
    3312:	8c 91       	ld	r24, X
    3314:	52 97       	sbiw	r26, 0x12	; 18
    3316:	8e 7f       	andi	r24, 0xFE	; 254
    3318:	52 96       	adiw	r26, 0x12	; 18
    331a:	8c 93       	st	X, r24
    331c:	1a c0       	rjmp	.+52     	; 0x3352 <prvTimerTask+0x1ac>
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    331e:	f6 01       	movw	r30, r12
    3320:	82 89       	ldd	r24, Z+18	; 0x12
    3322:	81 60       	ori	r24, 0x01	; 1
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    3324:	82 8b       	std	Z+18, r24	; 0x12
    3326:	6a 81       	ldd	r22, Y+2	; 0x02
    3328:	7b 81       	ldd	r23, Y+3	; 0x03
    332a:	64 87       	std	Z+12, r22	; 0x0c
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    332c:	75 87       	std	Z+13, r23	; 0x0d
    332e:	64 0f       	add	r22, r20
    3330:	75 1f       	adc	r23, r21
    3332:	9a 01       	movw	r18, r20
    3334:	c6 01       	movw	r24, r12
    3336:	10 de       	rcall	.-992    	; 0x2f58 <prvInsertTimerInActiveList>
    3338:	0c c0       	rjmp	.+24     	; 0x3352 <prvTimerTask+0x1ac>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    333a:	d6 01       	movw	r26, r12
    333c:	52 96       	adiw	r26, 0x12	; 18
    333e:	8c 91       	ld	r24, X
    3340:	81 fd       	sbrc	r24, 1
    3342:	04 c0       	rjmp	.+8      	; 0x334c <prvTimerTask+0x1a6>
						{
							vPortFree( pxTimer );
    3344:	c6 01       	movw	r24, r12
    3346:	0e 94 a1 10 	call	0x2142	; 0x2142 <vPortFree>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    334a:	03 c0       	rjmp	.+6      	; 0x3352 <prvTimerTask+0x1ac>
    334c:	8e 7f       	andi	r24, 0xFE	; 254
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    334e:	f6 01       	movw	r30, r12
    3350:	82 8b       	std	Z+18, r24	; 0x12
    3352:	40 e0       	ldi	r20, 0x00	; 0
    3354:	50 e0       	ldi	r21, 0x00	; 0
    3356:	6e 2d       	mov	r22, r14
    3358:	7f 2d       	mov	r23, r15
    335a:	80 91 f9 22 	lds	r24, 0x22F9	; 0x8022f9 <xTimerQueue>
    335e:	90 91 fa 22 	lds	r25, 0x22FA	; 0x8022fa <xTimerQueue+0x1>
    3362:	dd d8       	rcall	.-3654   	; 0x251e <xQueueReceive>
    3364:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    3366:	86 cf       	rjmp	.-244    	; 0x3274 <prvTimerTask+0xce>
    3368:	29 cf       	rjmp	.-430    	; 0x31bc <prvTimerTask+0x16>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    336a:	82 db       	rcall	.-2300   	; 0x2a70 <vTaskSuspendAll>
    336c:	c5 01       	movw	r24, r10
    336e:	ad de       	rcall	.-678    	; 0x30ca <prvSampleTimeNow>
    3370:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    3372:	89 81       	ldd	r24, Y+1	; 0x01
    3374:	81 11       	cpse	r24, r1
    3376:	7c cf       	rjmp	.-264    	; 0x3270 <prvTimerTask+0xca>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3378:	e0 91 fb 22 	lds	r30, 0x22FB	; 0x8022fb <pxOverflowTimerList>
    337c:	f0 91 fc 22 	lds	r31, 0x22FC	; 0x8022fc <pxOverflowTimerList+0x1>
    3380:	80 81       	ld	r24, Z
    3382:	41 e0       	ldi	r20, 0x01	; 1
    3384:	81 11       	cpse	r24, r1
    3386:	40 e0       	ldi	r20, 0x00	; 0
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    3388:	c1 2c       	mov	r12, r1
    338a:	d1 2c       	mov	r13, r1
    338c:	63 cf       	rjmp	.-314    	; 0x3254 <prvTimerTask+0xae>

0000338e <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
    338e:	80 3a       	cpi	r24, 0xA0	; 160
    3390:	28 e0       	ldi	r18, 0x08	; 8
    3392:	92 07       	cpc	r25, r18
    3394:	21 f4       	brne	.+8      	; 0x339e <usart_spi_init+0x10>
    3396:	60 e1       	ldi	r22, 0x10	; 16
    3398:	83 e0       	ldi	r24, 0x03	; 3
    339a:	12 c1       	rjmp	.+548    	; 0x35c0 <sysclk_enable_module>
    339c:	08 95       	ret
    339e:	80 3b       	cpi	r24, 0xB0	; 176
    33a0:	28 e0       	ldi	r18, 0x08	; 8
    33a2:	92 07       	cpc	r25, r18
    33a4:	21 f4       	brne	.+8      	; 0x33ae <usart_spi_init+0x20>
    33a6:	60 e2       	ldi	r22, 0x20	; 32
    33a8:	83 e0       	ldi	r24, 0x03	; 3
    33aa:	0a c1       	rjmp	.+532    	; 0x35c0 <sysclk_enable_module>
    33ac:	08 95       	ret
    33ae:	80 3a       	cpi	r24, 0xA0	; 160
    33b0:	29 e0       	ldi	r18, 0x09	; 9
    33b2:	92 07       	cpc	r25, r18
    33b4:	21 f4       	brne	.+8      	; 0x33be <usart_spi_init+0x30>
    33b6:	60 e1       	ldi	r22, 0x10	; 16
    33b8:	84 e0       	ldi	r24, 0x04	; 4
    33ba:	02 c1       	rjmp	.+516    	; 0x35c0 <sysclk_enable_module>
    33bc:	08 95       	ret
    33be:	80 3b       	cpi	r24, 0xB0	; 176
    33c0:	29 e0       	ldi	r18, 0x09	; 9
    33c2:	92 07       	cpc	r25, r18
    33c4:	21 f4       	brne	.+8      	; 0x33ce <usart_spi_init+0x40>
    33c6:	60 e2       	ldi	r22, 0x20	; 32
    33c8:	84 e0       	ldi	r24, 0x04	; 4
    33ca:	fa c0       	rjmp	.+500    	; 0x35c0 <sysclk_enable_module>
    33cc:	08 95       	ret
    33ce:	80 3a       	cpi	r24, 0xA0	; 160
    33d0:	2a e0       	ldi	r18, 0x0A	; 10
    33d2:	92 07       	cpc	r25, r18
    33d4:	21 f4       	brne	.+8      	; 0x33de <usart_spi_init+0x50>
    33d6:	60 e1       	ldi	r22, 0x10	; 16
    33d8:	85 e0       	ldi	r24, 0x05	; 5
    33da:	f2 c0       	rjmp	.+484    	; 0x35c0 <sysclk_enable_module>
    33dc:	08 95       	ret
    33de:	80 3a       	cpi	r24, 0xA0	; 160
    33e0:	9b 40       	sbci	r25, 0x0B	; 11
    33e2:	19 f4       	brne	.+6      	; 0x33ea <usart_spi_init+0x5c>
    33e4:	60 e1       	ldi	r22, 0x10	; 16
    33e6:	86 e0       	ldi	r24, 0x06	; 6
    33e8:	eb c0       	rjmp	.+470    	; 0x35c0 <sysclk_enable_module>
    33ea:	08 95       	ret

000033ec <usart_spi_setup_device>:
    33ec:	0f 93       	push	r16
    33ee:	1f 93       	push	r17
    33f0:	cf 93       	push	r28
    33f2:	df 93       	push	r29
    33f4:	00 d0       	rcall	.+0      	; 0x33f6 <usart_spi_setup_device+0xa>
    33f6:	00 d0       	rcall	.+0      	; 0x33f8 <usart_spi_setup_device+0xc>
    33f8:	cd b7       	in	r28, 0x3d	; 61
    33fa:	de b7       	in	r29, 0x3e	; 62
    33fc:	09 83       	std	Y+1, r16	; 0x01
    33fe:	1a 83       	std	Y+2, r17	; 0x02
    3400:	2b 83       	std	Y+3, r18	; 0x03
    3402:	3c 83       	std	Y+4, r19	; 0x04
    3404:	4d 83       	std	Y+5, r20	; 0x05
    3406:	1e 82       	std	Y+6, r1	; 0x06
    3408:	be 01       	movw	r22, r28
    340a:	6f 5f       	subi	r22, 0xFF	; 255
    340c:	7f 4f       	sbci	r23, 0xFF	; 255
    340e:	0e 94 9a 0c 	call	0x1934	; 0x1934 <usart_init_spi>
    3412:	26 96       	adiw	r28, 0x06	; 6
    3414:	cd bf       	out	0x3d, r28	; 61
    3416:	de bf       	out	0x3e, r29	; 62
    3418:	df 91       	pop	r29
    341a:	cf 91       	pop	r28
    341c:	1f 91       	pop	r17
    341e:	0f 91       	pop	r16
    3420:	08 95       	ret

00003422 <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
    3422:	fb 01       	movw	r30, r22
    3424:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    3426:	e8 2f       	mov	r30, r24
    3428:	e6 95       	lsr	r30
    342a:	e6 95       	lsr	r30
    342c:	e6 95       	lsr	r30
    342e:	40 e2       	ldi	r20, 0x20	; 32
    3430:	e4 9f       	mul	r30, r20
    3432:	f0 01       	movw	r30, r0
    3434:	11 24       	eor	r1, r1
    3436:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    3438:	87 70       	andi	r24, 0x07	; 7
    343a:	21 e0       	ldi	r18, 0x01	; 1
    343c:	30 e0       	ldi	r19, 0x00	; 0
    343e:	a9 01       	movw	r20, r18
    3440:	02 c0       	rjmp	.+4      	; 0x3446 <usart_spi_select_device+0x24>
    3442:	44 0f       	add	r20, r20
    3444:	55 1f       	adc	r21, r21
    3446:	8a 95       	dec	r24
    3448:	e2 f7       	brpl	.-8      	; 0x3442 <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    344a:	46 83       	std	Z+6, r20	; 0x06
    344c:	08 95       	ret

0000344e <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
    344e:	fb 01       	movw	r30, r22
    3450:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    3452:	e8 2f       	mov	r30, r24
    3454:	e6 95       	lsr	r30
    3456:	e6 95       	lsr	r30
    3458:	e6 95       	lsr	r30
    345a:	40 e2       	ldi	r20, 0x20	; 32
    345c:	e4 9f       	mul	r30, r20
    345e:	f0 01       	movw	r30, r0
    3460:	11 24       	eor	r1, r1
    3462:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    3464:	87 70       	andi	r24, 0x07	; 7
    3466:	21 e0       	ldi	r18, 0x01	; 1
    3468:	30 e0       	ldi	r19, 0x00	; 0
    346a:	a9 01       	movw	r20, r18
    346c:	02 c0       	rjmp	.+4      	; 0x3472 <usart_spi_deselect_device+0x24>
    346e:	44 0f       	add	r20, r20
    3470:	55 1f       	adc	r21, r21
    3472:	8a 95       	dec	r24
    3474:	e2 f7       	brpl	.-8      	; 0x346e <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3476:	45 83       	std	Z+5, r20	; 0x05
    3478:	08 95       	ret

0000347a <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
    347a:	80 93 11 23 	sts	0x2311, r24	; 0x802311 <fbpointer>
    347e:	90 93 12 23 	sts	0x2312, r25	; 0x802312 <fbpointer+0x1>
    3482:	08 95       	ret

00003484 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
    3484:	20 91 11 23 	lds	r18, 0x2311	; 0x802311 <fbpointer>
    3488:	30 91 12 23 	lds	r19, 0x2312	; 0x802312 <fbpointer+0x1>
    348c:	90 e8       	ldi	r25, 0x80	; 128
    348e:	89 9f       	mul	r24, r25
    3490:	20 0d       	add	r18, r0
    3492:	31 1d       	adc	r19, r1
    3494:	11 24       	eor	r1, r1
    3496:	f9 01       	movw	r30, r18
    3498:	e6 0f       	add	r30, r22
    349a:	f1 1d       	adc	r31, r1
    349c:	40 83       	st	Z, r20
    349e:	08 95       	ret

000034a0 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
    34a0:	20 91 11 23 	lds	r18, 0x2311	; 0x802311 <fbpointer>
    34a4:	30 91 12 23 	lds	r19, 0x2312	; 0x802312 <fbpointer+0x1>
    34a8:	90 e8       	ldi	r25, 0x80	; 128
    34aa:	89 9f       	mul	r24, r25
    34ac:	20 0d       	add	r18, r0
    34ae:	31 1d       	adc	r19, r1
    34b0:	11 24       	eor	r1, r1
    34b2:	f9 01       	movw	r30, r18
    34b4:	e6 0f       	add	r30, r22
    34b6:	f1 1d       	adc	r31, r1
}
    34b8:	80 81       	ld	r24, Z
    34ba:	08 95       	ret

000034bc <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
    34bc:	ff 92       	push	r15
    34be:	0f 93       	push	r16
    34c0:	1f 93       	push	r17
    34c2:	cf 93       	push	r28
    34c4:	df 93       	push	r29
    34c6:	e4 2f       	mov	r30, r20
    34c8:	f0 e0       	ldi	r31, 0x00	; 0
    34ca:	e8 0f       	add	r30, r24
    34cc:	f1 1d       	adc	r31, r1
    34ce:	e1 38       	cpi	r30, 0x81	; 129
    34d0:	f1 05       	cpc	r31, r1
    34d2:	1c f0       	brlt	.+6      	; 0x34da <gfx_mono_generic_draw_horizontal_line+0x1e>
    34d4:	c0 e8       	ldi	r28, 0x80	; 128
    34d6:	4c 2f       	mov	r20, r28
    34d8:	48 1b       	sub	r20, r24
    34da:	44 23       	and	r20, r20
    34dc:	09 f4       	brne	.+2      	; 0x34e0 <gfx_mono_generic_draw_horizontal_line+0x24>
    34de:	50 c0       	rjmp	.+160    	; 0x3580 <gfx_mono_generic_draw_horizontal_line+0xc4>
    34e0:	d6 2f       	mov	r29, r22
    34e2:	d6 95       	lsr	r29
    34e4:	d6 95       	lsr	r29
    34e6:	d6 95       	lsr	r29
    34e8:	70 e0       	ldi	r23, 0x00	; 0
    34ea:	98 e0       	ldi	r25, 0x08	; 8
    34ec:	d9 9f       	mul	r29, r25
    34ee:	60 19       	sub	r22, r0
    34f0:	71 09       	sbc	r23, r1
    34f2:	11 24       	eor	r1, r1
    34f4:	e1 e0       	ldi	r30, 0x01	; 1
    34f6:	f0 e0       	ldi	r31, 0x00	; 0
    34f8:	df 01       	movw	r26, r30
    34fa:	02 c0       	rjmp	.+4      	; 0x3500 <gfx_mono_generic_draw_horizontal_line+0x44>
    34fc:	aa 0f       	add	r26, r26
    34fe:	bb 1f       	adc	r27, r27
    3500:	6a 95       	dec	r22
    3502:	e2 f7       	brpl	.-8      	; 0x34fc <gfx_mono_generic_draw_horizontal_line+0x40>
    3504:	fa 2e       	mov	r15, r26
    3506:	21 30       	cpi	r18, 0x01	; 1
    3508:	21 f0       	breq	.+8      	; 0x3512 <gfx_mono_generic_draw_horizontal_line+0x56>
    350a:	a8 f0       	brcs	.+42     	; 0x3536 <gfx_mono_generic_draw_horizontal_line+0x7a>
    350c:	22 30       	cpi	r18, 0x02	; 2
    350e:	39 f1       	breq	.+78     	; 0x355e <gfx_mono_generic_draw_horizontal_line+0xa2>
    3510:	37 c0       	rjmp	.+110    	; 0x3580 <gfx_mono_generic_draw_horizontal_line+0xc4>
    3512:	c4 2f       	mov	r28, r20
    3514:	1f ef       	ldi	r17, 0xFF	; 255
    3516:	18 0f       	add	r17, r24
    3518:	01 2f       	mov	r16, r17
    351a:	0c 0f       	add	r16, r28
    351c:	60 2f       	mov	r22, r16
    351e:	8d 2f       	mov	r24, r29
    3520:	0e 94 86 05 	call	0xb0c	; 0xb0c <gfx_mono_st7565r_get_byte>
    3524:	4f 2d       	mov	r20, r15
    3526:	48 2b       	or	r20, r24
    3528:	60 2f       	mov	r22, r16
    352a:	8d 2f       	mov	r24, r29
    352c:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <gfx_mono_st7565r_put_byte>
    3530:	c1 50       	subi	r28, 0x01	; 1
    3532:	91 f7       	brne	.-28     	; 0x3518 <gfx_mono_generic_draw_horizontal_line+0x5c>
    3534:	25 c0       	rjmp	.+74     	; 0x3580 <gfx_mono_generic_draw_horizontal_line+0xc4>
    3536:	c4 2f       	mov	r28, r20
    3538:	1f ef       	ldi	r17, 0xFF	; 255
    353a:	18 0f       	add	r17, r24
    353c:	fa 2e       	mov	r15, r26
    353e:	f0 94       	com	r15
    3540:	01 2f       	mov	r16, r17
    3542:	0c 0f       	add	r16, r28
    3544:	60 2f       	mov	r22, r16
    3546:	8d 2f       	mov	r24, r29
    3548:	0e 94 86 05 	call	0xb0c	; 0xb0c <gfx_mono_st7565r_get_byte>
    354c:	4f 2d       	mov	r20, r15
    354e:	48 23       	and	r20, r24
    3550:	60 2f       	mov	r22, r16
    3552:	8d 2f       	mov	r24, r29
    3554:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <gfx_mono_st7565r_put_byte>
    3558:	c1 50       	subi	r28, 0x01	; 1
    355a:	91 f7       	brne	.-28     	; 0x3540 <gfx_mono_generic_draw_horizontal_line+0x84>
    355c:	11 c0       	rjmp	.+34     	; 0x3580 <gfx_mono_generic_draw_horizontal_line+0xc4>
    355e:	c4 2f       	mov	r28, r20
    3560:	1f ef       	ldi	r17, 0xFF	; 255
    3562:	18 0f       	add	r17, r24
    3564:	01 2f       	mov	r16, r17
    3566:	0c 0f       	add	r16, r28
    3568:	60 2f       	mov	r22, r16
    356a:	8d 2f       	mov	r24, r29
    356c:	0e 94 86 05 	call	0xb0c	; 0xb0c <gfx_mono_st7565r_get_byte>
    3570:	4f 2d       	mov	r20, r15
    3572:	48 27       	eor	r20, r24
    3574:	60 2f       	mov	r22, r16
    3576:	8d 2f       	mov	r24, r29
    3578:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <gfx_mono_st7565r_put_byte>
    357c:	c1 50       	subi	r28, 0x01	; 1
    357e:	91 f7       	brne	.-28     	; 0x3564 <gfx_mono_generic_draw_horizontal_line+0xa8>
    3580:	df 91       	pop	r29
    3582:	cf 91       	pop	r28
    3584:	1f 91       	pop	r17
    3586:	0f 91       	pop	r16
    3588:	ff 90       	pop	r15
    358a:	08 95       	ret

0000358c <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
    358c:	ff 92       	push	r15
    358e:	0f 93       	push	r16
    3590:	1f 93       	push	r17
    3592:	cf 93       	push	r28
    3594:	df 93       	push	r29
	if (height == 0) {
    3596:	22 23       	and	r18, r18
    3598:	69 f0       	breq	.+26     	; 0x35b4 <gfx_mono_generic_draw_filled_rect+0x28>
    359a:	f4 2e       	mov	r15, r20
    359c:	18 2f       	mov	r17, r24
    359e:	c2 2f       	mov	r28, r18
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
    35a0:	df ef       	ldi	r29, 0xFF	; 255
    35a2:	d6 0f       	add	r29, r22
    35a4:	6d 2f       	mov	r22, r29
    35a6:	6c 0f       	add	r22, r28
    35a8:	20 2f       	mov	r18, r16
    35aa:	4f 2d       	mov	r20, r15
    35ac:	81 2f       	mov	r24, r17
    35ae:	86 df       	rcall	.-244    	; 0x34bc <gfx_mono_generic_draw_horizontal_line>
    35b0:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
    35b2:	c1 f7       	brne	.-16     	; 0x35a4 <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
    35b4:	df 91       	pop	r29
    35b6:	cf 91       	pop	r28
    35b8:	1f 91       	pop	r17
    35ba:	0f 91       	pop	r16
    35bc:	ff 90       	pop	r15
    35be:	08 95       	ret

000035c0 <sysclk_enable_module>:
	sysclk_rtcsrc_enable(CONFIG_RTC_SOURCE);
#endif
}

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
    35c0:	cf 93       	push	r28
    35c2:	df 93       	push	r29
    35c4:	1f 92       	push	r1
    35c6:	cd b7       	in	r28, 0x3d	; 61
    35c8:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    35ca:	9f b7       	in	r25, 0x3f	; 63
    35cc:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
    35ce:	f8 94       	cli
	return flags;
    35d0:	99 81       	ldd	r25, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
    35d2:	e8 2f       	mov	r30, r24
    35d4:	f0 e0       	ldi	r31, 0x00	; 0
    35d6:	e0 59       	subi	r30, 0x90	; 144
    35d8:	ff 4f       	sbci	r31, 0xFF	; 255
    35da:	60 95       	com	r22
    35dc:	80 81       	ld	r24, Z
    35de:	68 23       	and	r22, r24
    35e0:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    35e2:	9f bf       	out	0x3f, r25	; 63

	cpu_irq_restore(flags);
}
    35e4:	0f 90       	pop	r0
    35e6:	df 91       	pop	r29
    35e8:	cf 91       	pop	r28
    35ea:	08 95       	ret

000035ec <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
    35ec:	af 92       	push	r10
    35ee:	bf 92       	push	r11
    35f0:	cf 92       	push	r12
    35f2:	df 92       	push	r13
    35f4:	ef 92       	push	r14
    35f6:	ff 92       	push	r15
    35f8:	0f 93       	push	r16
    35fa:	1f 93       	push	r17
    35fc:	cf 93       	push	r28
    35fe:	df 93       	push	r29
    3600:	c8 2f       	mov	r28, r24
    3602:	e6 2e       	mov	r14, r22
    3604:	b4 2e       	mov	r11, r20
    3606:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
    3608:	00 e0       	ldi	r16, 0x00	; 0
    360a:	f9 01       	movw	r30, r18
    360c:	24 81       	ldd	r18, Z+4	; 0x04
    360e:	43 81       	ldd	r20, Z+3	; 0x03
    3610:	6b 2d       	mov	r22, r11
    3612:	8e 2d       	mov	r24, r14
    3614:	bb df       	rcall	.-138    	; 0x358c <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
    3616:	f6 01       	movw	r30, r12
    3618:	80 81       	ld	r24, Z
    361a:	81 11       	cpse	r24, r1
    361c:	3a c0       	rjmp	.+116    	; 0x3692 <gfx_mono_draw_char+0xa6>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
    361e:	83 81       	ldd	r24, Z+3	; 0x03
    3620:	28 2f       	mov	r18, r24
    3622:	26 95       	lsr	r18
    3624:	26 95       	lsr	r18
    3626:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
    3628:	87 70       	andi	r24, 0x07	; 7
    362a:	09 f0       	breq	.+2      	; 0x362e <gfx_mono_draw_char+0x42>
		char_row_size++;
    362c:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
    362e:	f6 01       	movw	r30, r12
    3630:	a4 80       	ldd	r10, Z+4	; 0x04
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
    3632:	8c 2f       	mov	r24, r28
    3634:	90 e0       	ldi	r25, 0x00	; 0
    3636:	35 81       	ldd	r19, Z+5	; 0x05
    3638:	83 1b       	sub	r24, r19
    363a:	91 09       	sbc	r25, r1
    363c:	2a 9d       	mul	r18, r10
    363e:	90 01       	movw	r18, r0
    3640:	11 24       	eor	r1, r1
    3642:	82 9f       	mul	r24, r18
    3644:	a0 01       	movw	r20, r0
    3646:	83 9f       	mul	r24, r19
    3648:	50 0d       	add	r21, r0
    364a:	92 9f       	mul	r25, r18
    364c:	50 0d       	add	r21, r0
    364e:	11 24       	eor	r1, r1
    3650:	01 81       	ldd	r16, Z+1	; 0x01
    3652:	12 81       	ldd	r17, Z+2	; 0x02
    3654:	04 0f       	add	r16, r20
    3656:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
    3658:	f6 01       	movw	r30, r12
    365a:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
    365c:	ff 20       	and	r15, r15
    365e:	a9 f0       	breq	.+42     	; 0x368a <gfx_mono_draw_char+0x9e>
    3660:	d0 e0       	ldi	r29, 0x00	; 0
    3662:	c0 e0       	ldi	r28, 0x00	; 0
    3664:	8e 2d       	mov	r24, r14
    3666:	8c 0f       	add	r24, r28
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
    3668:	9c 2f       	mov	r25, r28
    366a:	97 70       	andi	r25, 0x07	; 7
    366c:	21 f4       	brne	.+8      	; 0x3676 <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
    366e:	f8 01       	movw	r30, r16
    3670:	d4 91       	lpm	r29, Z
				glyph_data++;
    3672:	0f 5f       	subi	r16, 0xFF	; 255
    3674:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
    3676:	dd 23       	and	r29, r29
    3678:	24 f4       	brge	.+8      	; 0x3682 <gfx_mono_draw_char+0x96>
				gfx_mono_draw_pixel(inc_x, inc_y,
    367a:	41 e0       	ldi	r20, 0x01	; 1
    367c:	6b 2d       	mov	r22, r11
    367e:	0e 94 4f 05 	call	0xa9e	; 0xa9e <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
    3682:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
    3684:	cf 5f       	subi	r28, 0xFF	; 255
    3686:	fc 12       	cpse	r15, r28
    3688:	ed cf       	rjmp	.-38     	; 0x3664 <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
    368a:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
    368c:	aa 94       	dec	r10
	} while (rows_left > 0);
    368e:	a1 10       	cpse	r10, r1
    3690:	e3 cf       	rjmp	.-58     	; 0x3658 <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
    3692:	df 91       	pop	r29
    3694:	cf 91       	pop	r28
    3696:	1f 91       	pop	r17
    3698:	0f 91       	pop	r16
    369a:	ff 90       	pop	r15
    369c:	ef 90       	pop	r14
    369e:	df 90       	pop	r13
    36a0:	cf 90       	pop	r12
    36a2:	bf 90       	pop	r11
    36a4:	af 90       	pop	r10
    36a6:	08 95       	ret

000036a8 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
    36a8:	df 92       	push	r13
    36aa:	ef 92       	push	r14
    36ac:	ff 92       	push	r15
    36ae:	0f 93       	push	r16
    36b0:	1f 93       	push	r17
    36b2:	cf 93       	push	r28
    36b4:	df 93       	push	r29
    36b6:	d6 2e       	mov	r13, r22
    36b8:	04 2f       	mov	r16, r20
    36ba:	79 01       	movw	r14, r18
    36bc:	ec 01       	movw	r28, r24
    36be:	16 2f       	mov	r17, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
    36c0:	89 91       	ld	r24, Y+
    36c2:	8a 30       	cpi	r24, 0x0A	; 10
    36c4:	31 f4       	brne	.+12     	; 0x36d2 <gfx_mono_draw_string+0x2a>
			x = start_of_string_position_x;
			y += font->height + 1;
    36c6:	f7 01       	movw	r30, r14
    36c8:	84 81       	ldd	r24, Z+4	; 0x04
    36ca:	8f 5f       	subi	r24, 0xFF	; 255
    36cc:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
    36ce:	1d 2d       	mov	r17, r13
    36d0:	09 c0       	rjmp	.+18     	; 0x36e4 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
    36d2:	8d 30       	cpi	r24, 0x0D	; 13
    36d4:	39 f0       	breq	.+14     	; 0x36e4 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
    36d6:	97 01       	movw	r18, r14
    36d8:	40 2f       	mov	r20, r16
    36da:	61 2f       	mov	r22, r17
    36dc:	87 df       	rcall	.-242    	; 0x35ec <gfx_mono_draw_char>
			x += font->width;
    36de:	f7 01       	movw	r30, r14
    36e0:	83 81       	ldd	r24, Z+3	; 0x03
    36e2:	18 0f       	add	r17, r24
		}
	} while (*(++str));
    36e4:	88 81       	ld	r24, Y
    36e6:	81 11       	cpse	r24, r1
    36e8:	eb cf       	rjmp	.-42     	; 0x36c0 <gfx_mono_draw_string+0x18>
}
    36ea:	df 91       	pop	r29
    36ec:	cf 91       	pop	r28
    36ee:	1f 91       	pop	r17
    36f0:	0f 91       	pop	r16
    36f2:	ff 90       	pop	r15
    36f4:	ef 90       	pop	r14
    36f6:	df 90       	pop	r13
    36f8:	08 95       	ret

000036fa <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    36fa:	cf 93       	push	r28
    36fc:	df 93       	push	r29
    36fe:	fc 01       	movw	r30, r24
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3700:	20 e0       	ldi	r18, 0x00	; 0
    3702:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    3704:	c6 2f       	mov	r28, r22
    3706:	d0 e0       	ldi	r29, 0x00	; 0
    3708:	de 01       	movw	r26, r28
    370a:	02 2e       	mov	r0, r18
    370c:	02 c0       	rjmp	.+4      	; 0x3712 <ioport_configure_port_pin+0x18>
    370e:	b5 95       	asr	r27
    3710:	a7 95       	ror	r26
    3712:	0a 94       	dec	r0
    3714:	e2 f7       	brpl	.-8      	; 0x370e <ioport_configure_port_pin+0x14>
    3716:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3718:	50 8b       	std	Z+16, r21	; 0x10
    371a:	2f 5f       	subi	r18, 0xFF	; 255
    371c:	3f 4f       	sbci	r19, 0xFF	; 255
    371e:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    3720:	28 30       	cpi	r18, 0x08	; 8
    3722:	31 05       	cpc	r19, r1
    3724:	89 f7       	brne	.-30     	; 0x3708 <ioport_configure_port_pin+0xe>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    3726:	40 ff       	sbrs	r20, 0
    3728:	0a c0       	rjmp	.+20     	; 0x373e <ioport_configure_port_pin+0x44>
		if (flags & IOPORT_INIT_HIGH) {
    372a:	41 ff       	sbrs	r20, 1
    372c:	03 c0       	rjmp	.+6      	; 0x3734 <ioport_configure_port_pin+0x3a>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    372e:	fc 01       	movw	r30, r24
    3730:	65 83       	std	Z+5, r22	; 0x05
    3732:	02 c0       	rjmp	.+4      	; 0x3738 <ioport_configure_port_pin+0x3e>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    3734:	fc 01       	movw	r30, r24
    3736:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    3738:	fc 01       	movw	r30, r24
    373a:	61 83       	std	Z+1, r22	; 0x01
    373c:	02 c0       	rjmp	.+4      	; 0x3742 <ioport_configure_port_pin+0x48>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    373e:	fc 01       	movw	r30, r24
    3740:	62 83       	std	Z+2, r22	; 0x02
	}
}
    3742:	df 91       	pop	r29
    3744:	cf 91       	pop	r28
    3746:	08 95       	ret

00003748 <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    3748:	43 e0       	ldi	r20, 0x03	; 3
    374a:	50 e0       	ldi	r21, 0x00	; 0
    374c:	61 e0       	ldi	r22, 0x01	; 1
    374e:	80 ee       	ldi	r24, 0xE0	; 224
    3750:	97 e0       	ldi	r25, 0x07	; 7
    3752:	d3 df       	rcall	.-90     	; 0x36fa <ioport_configure_port_pin>
    3754:	43 e0       	ldi	r20, 0x03	; 3
    3756:	50 e0       	ldi	r21, 0x00	; 0
    3758:	62 e0       	ldi	r22, 0x02	; 2
    375a:	80 ee       	ldi	r24, 0xE0	; 224
    375c:	97 e0       	ldi	r25, 0x07	; 7
    375e:	cd df       	rcall	.-102    	; 0x36fa <ioport_configure_port_pin>
    3760:	43 e0       	ldi	r20, 0x03	; 3
    3762:	50 e0       	ldi	r21, 0x00	; 0
    3764:	60 e1       	ldi	r22, 0x10	; 16
    3766:	80 e6       	ldi	r24, 0x60	; 96
    3768:	96 e0       	ldi	r25, 0x06	; 6
    376a:	c7 df       	rcall	.-114    	; 0x36fa <ioport_configure_port_pin>
    376c:	41 e0       	ldi	r20, 0x01	; 1
    376e:	50 e4       	ldi	r21, 0x40	; 64
    3770:	60 e2       	ldi	r22, 0x20	; 32
    3772:	80 e6       	ldi	r24, 0x60	; 96
    3774:	96 e0       	ldi	r25, 0x06	; 6
    3776:	c1 df       	rcall	.-126    	; 0x36fa <ioport_configure_port_pin>
    3778:	40 e0       	ldi	r20, 0x00	; 0
    377a:	5b e1       	ldi	r21, 0x1B	; 27
    377c:	60 e2       	ldi	r22, 0x20	; 32
    377e:	80 e8       	ldi	r24, 0x80	; 128
    3780:	96 e0       	ldi	r25, 0x06	; 6
    3782:	bb df       	rcall	.-138    	; 0x36fa <ioport_configure_port_pin>
    3784:	40 e0       	ldi	r20, 0x00	; 0
    3786:	5b e1       	ldi	r21, 0x1B	; 27
    3788:	62 e0       	ldi	r22, 0x02	; 2
    378a:	80 ea       	ldi	r24, 0xA0	; 160
    378c:	96 e0       	ldi	r25, 0x06	; 6
    378e:	b5 df       	rcall	.-150    	; 0x36fa <ioport_configure_port_pin>
    3790:	40 e0       	ldi	r20, 0x00	; 0
    3792:	5b e1       	ldi	r21, 0x1B	; 27
    3794:	64 e0       	ldi	r22, 0x04	; 4
    3796:	80 ea       	ldi	r24, 0xA0	; 160
    3798:	96 e0       	ldi	r25, 0x06	; 6
    379a:	af df       	rcall	.-162    	; 0x36fa <ioport_configure_port_pin>
    379c:	43 e0       	ldi	r20, 0x03	; 3
    379e:	50 e0       	ldi	r21, 0x00	; 0
    37a0:	62 e0       	ldi	r22, 0x02	; 2
    37a2:	80 e6       	ldi	r24, 0x60	; 96
    37a4:	96 e0       	ldi	r25, 0x06	; 6
    37a6:	a9 df       	rcall	.-174    	; 0x36fa <ioport_configure_port_pin>
    37a8:	43 e0       	ldi	r20, 0x03	; 3
    37aa:	50 e0       	ldi	r21, 0x00	; 0
    37ac:	68 e0       	ldi	r22, 0x08	; 8
    37ae:	80 e6       	ldi	r24, 0x60	; 96
    37b0:	96 e0       	ldi	r25, 0x06	; 6
    37b2:	a3 df       	rcall	.-186    	; 0x36fa <ioport_configure_port_pin>
    37b4:	43 e0       	ldi	r20, 0x03	; 3
    37b6:	50 e0       	ldi	r21, 0x00	; 0
    37b8:	68 e0       	ldi	r22, 0x08	; 8
    37ba:	80 ea       	ldi	r24, 0xA0	; 160
    37bc:	96 e0       	ldi	r25, 0x06	; 6
    37be:	9d df       	rcall	.-198    	; 0x36fa <ioport_configure_port_pin>
    37c0:	43 e0       	ldi	r20, 0x03	; 3
    37c2:	50 e0       	ldi	r21, 0x00	; 0
    37c4:	61 e0       	ldi	r22, 0x01	; 1
    37c6:	80 e6       	ldi	r24, 0x60	; 96
    37c8:	96 e0       	ldi	r25, 0x06	; 6
    37ca:	97 df       	rcall	.-210    	; 0x36fa <ioport_configure_port_pin>
    37cc:	43 e0       	ldi	r20, 0x03	; 3
    37ce:	50 e0       	ldi	r21, 0x00	; 0
    37d0:	68 e0       	ldi	r22, 0x08	; 8
    37d2:	80 e0       	ldi	r24, 0x00	; 0
    37d4:	96 e0       	ldi	r25, 0x06	; 6
    37d6:	91 df       	rcall	.-222    	; 0x36fa <ioport_configure_port_pin>
    37d8:	41 e0       	ldi	r20, 0x01	; 1
    37da:	50 e0       	ldi	r21, 0x00	; 0
    37dc:	60 e1       	ldi	r22, 0x10	; 16
    37de:	80 e8       	ldi	r24, 0x80	; 128
    37e0:	96 e0       	ldi	r25, 0x06	; 6
    37e2:	8b df       	rcall	.-234    	; 0x36fa <ioport_configure_port_pin>
    37e4:	43 e0       	ldi	r20, 0x03	; 3
    37e6:	50 e0       	ldi	r21, 0x00	; 0
    37e8:	62 e0       	ldi	r22, 0x02	; 2
    37ea:	80 e6       	ldi	r24, 0x60	; 96
    37ec:	96 e0       	ldi	r25, 0x06	; 6
    37ee:	85 df       	rcall	.-246    	; 0x36fa <ioport_configure_port_pin>
    37f0:	43 e0       	ldi	r20, 0x03	; 3
    37f2:	50 e0       	ldi	r21, 0x00	; 0
    37f4:	68 e0       	ldi	r22, 0x08	; 8
    37f6:	80 e6       	ldi	r24, 0x60	; 96
    37f8:	96 e0       	ldi	r25, 0x06	; 6
    37fa:	7f df       	rcall	.-258    	; 0x36fa <ioport_configure_port_pin>
    37fc:	40 e0       	ldi	r20, 0x00	; 0
    37fe:	50 e0       	ldi	r21, 0x00	; 0
    3800:	64 e0       	ldi	r22, 0x04	; 4
    3802:	80 e6       	ldi	r24, 0x60	; 96
    3804:	96 e0       	ldi	r25, 0x06	; 6
    3806:	79 df       	rcall	.-270    	; 0x36fa <ioport_configure_port_pin>
    3808:	43 e0       	ldi	r20, 0x03	; 3
    380a:	50 e0       	ldi	r21, 0x00	; 0
    380c:	60 e1       	ldi	r22, 0x10	; 16
    380e:	80 ea       	ldi	r24, 0xA0	; 160
    3810:	96 e0       	ldi	r25, 0x06	; 6
    3812:	73 df       	rcall	.-282    	; 0x36fa <ioport_configure_port_pin>
    3814:	40 e0       	ldi	r20, 0x00	; 0
    3816:	50 e0       	ldi	r21, 0x00	; 0
    3818:	61 e0       	ldi	r22, 0x01	; 1
    381a:	80 e0       	ldi	r24, 0x00	; 0
    381c:	96 e0       	ldi	r25, 0x06	; 6
    381e:	6d df       	rcall	.-294    	; 0x36fa <ioport_configure_port_pin>
    3820:	40 e0       	ldi	r20, 0x00	; 0
    3822:	50 e0       	ldi	r21, 0x00	; 0
    3824:	64 e0       	ldi	r22, 0x04	; 4
    3826:	80 e0       	ldi	r24, 0x00	; 0
    3828:	96 e0       	ldi	r25, 0x06	; 6
    382a:	67 df       	rcall	.-306    	; 0x36fa <ioport_configure_port_pin>
    382c:	40 e0       	ldi	r20, 0x00	; 0
    382e:	50 e0       	ldi	r21, 0x00	; 0
    3830:	62 e0       	ldi	r22, 0x02	; 2
    3832:	80 e2       	ldi	r24, 0x20	; 32
    3834:	96 e0       	ldi	r25, 0x06	; 6
    3836:	61 df       	rcall	.-318    	; 0x36fa <ioport_configure_port_pin>
    3838:	43 e0       	ldi	r20, 0x03	; 3
    383a:	50 e0       	ldi	r21, 0x00	; 0
    383c:	68 e0       	ldi	r22, 0x08	; 8
    383e:	80 e4       	ldi	r24, 0x40	; 64
    3840:	96 e0       	ldi	r25, 0x06	; 6
    3842:	5b df       	rcall	.-330    	; 0x36fa <ioport_configure_port_pin>
    3844:	40 e0       	ldi	r20, 0x00	; 0
    3846:	50 e0       	ldi	r21, 0x00	; 0
    3848:	64 e0       	ldi	r22, 0x04	; 4
    384a:	80 e4       	ldi	r24, 0x40	; 64
    384c:	96 e0       	ldi	r25, 0x06	; 6
    384e:	55 df       	rcall	.-342    	; 0x36fa <ioport_configure_port_pin>
    3850:	43 e0       	ldi	r20, 0x03	; 3
    3852:	50 e0       	ldi	r21, 0x00	; 0
    3854:	68 e0       	ldi	r22, 0x08	; 8
    3856:	80 e6       	ldi	r24, 0x60	; 96
    3858:	96 e0       	ldi	r25, 0x06	; 6
    385a:	4f df       	rcall	.-354    	; 0x36fa <ioport_configure_port_pin>
    385c:	40 e0       	ldi	r20, 0x00	; 0
    385e:	50 e0       	ldi	r21, 0x00	; 0
    3860:	64 e0       	ldi	r22, 0x04	; 4
    3862:	80 e6       	ldi	r24, 0x60	; 96
    3864:	96 e0       	ldi	r25, 0x06	; 6
    3866:	49 df       	rcall	.-366    	; 0x36fa <ioport_configure_port_pin>
    3868:	43 e0       	ldi	r20, 0x03	; 3
    386a:	50 e0       	ldi	r21, 0x00	; 0
    386c:	68 e0       	ldi	r22, 0x08	; 8
    386e:	80 e8       	ldi	r24, 0x80	; 128
    3870:	96 e0       	ldi	r25, 0x06	; 6
    3872:	43 df       	rcall	.-378    	; 0x36fa <ioport_configure_port_pin>
    3874:	40 e0       	ldi	r20, 0x00	; 0
    3876:	50 e0       	ldi	r21, 0x00	; 0
    3878:	64 e0       	ldi	r22, 0x04	; 4
    387a:	80 e8       	ldi	r24, 0x80	; 128
    387c:	96 e0       	ldi	r25, 0x06	; 6
    387e:	3d cf       	rjmp	.-390    	; 0x36fa <ioport_configure_port_pin>
    3880:	08 95       	ret

00003882 <__portable_avr_delay_cycles>:
 *
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
    3882:	04 c0       	rjmp	.+8      	; 0x388c <__portable_avr_delay_cycles+0xa>
	while (n) {
		barrier();
		n--;
    3884:	61 50       	subi	r22, 0x01	; 1
    3886:	71 09       	sbc	r23, r1
    3888:	81 09       	sbc	r24, r1
    388a:	91 09       	sbc	r25, r1
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	while (n) {
    388c:	61 15       	cp	r22, r1
    388e:	71 05       	cpc	r23, r1
    3890:	81 05       	cpc	r24, r1
    3892:	91 05       	cpc	r25, r1
    3894:	b9 f7       	brne	.-18     	; 0x3884 <__portable_avr_delay_cycles+0x2>
    3896:	08 95       	ret

00003898 <print_message>:
	 * KARENA GABAKAL BISA DIAMBIL KAN MASIH DIPAKE TASK YG MANGGIL CALLBACK FUNCTION INI (si task ultrasonic)
	 * ENDINGNYA MALAH STUCK NGELOOP 1000 TAHUN NUNGGUIN SEMAPHORENYA BISA DIAMBIL
	 */
	
	//if (xSemaphoreTake(xSemaphore, (TickType_t)10) == pdTRUE) {		
		incremental = incremental + 1;
    3898:	80 91 15 23 	lds	r24, 0x2315	; 0x802315 <incremental>
    389c:	90 91 16 23 	lds	r25, 0x2316	; 0x802316 <incremental+0x1>
    38a0:	01 96       	adiw	r24, 0x01	; 1
    38a2:	80 93 15 23 	sts	0x2315, r24	; 0x802315 <incremental>
    38a6:	90 93 16 23 	sts	0x2316, r25	; 0x802316 <incremental+0x1>
    38aa:	08 95       	ret

000038ac <vCounter>:
		
		vTaskDelay(10/portTICK_PERIOD_MS);
	}
}

static portTASK_FUNCTION(vCounter, r_) {
    38ac:	cf 93       	push	r28
    38ae:	df 93       	push	r29
    38b0:	cd b7       	in	r28, 0x3d	; 61
    38b2:	de b7       	in	r29, 0x3e	; 62
    38b4:	c0 58       	subi	r28, 0x80	; 128
    38b6:	d1 09       	sbc	r29, r1
    38b8:	cd bf       	out	0x3d, r28	; 61
    38ba:	de bf       	out	0x3e, r29	; 62
	
	while(1) {
		
		if(xSemaphoreTake(xSemaphore, (TickType_t) 10) == pdTRUE) {
			counter++;
			snprintf(strbuf, sizeof(strbuf), "Counter : %d", counter);
    38bc:	0f 2e       	mov	r0, r31
    38be:	fa e1       	ldi	r31, 0x1A	; 26
    38c0:	ef 2e       	mov	r14, r31
    38c2:	f0 e2       	ldi	r31, 0x20	; 32
    38c4:	ff 2e       	mov	r15, r31
    38c6:	f0 2d       	mov	r31, r0
    38c8:	68 94       	set
    38ca:	dd 24       	eor	r13, r13
    38cc:	d7 f8       	bld	r13, 7
    38ce:	8e 01       	movw	r16, r28
    38d0:	0f 5f       	subi	r16, 0xFF	; 255
    38d2:	1f 4f       	sbci	r17, 0xFF	; 255
static portTASK_FUNCTION(vCounter, r_) {
	char strbuf[128];
	
	while(1) {
		
		if(xSemaphoreTake(xSemaphore, (TickType_t) 10) == pdTRUE) {
    38d4:	6a e0       	ldi	r22, 0x0A	; 10
    38d6:	70 e0       	ldi	r23, 0x00	; 0
    38d8:	80 91 1f 23 	lds	r24, 0x231F	; 0x80231f <xSemaphore>
    38dc:	90 91 20 23 	lds	r25, 0x2320	; 0x802320 <xSemaphore+0x1>
    38e0:	0e 94 13 13 	call	0x2626	; 0x2626 <xQueueSemaphoreTake>
    38e4:	81 30       	cpi	r24, 0x01	; 1
    38e6:	29 f5       	brne	.+74     	; 0x3932 <vCounter+0x86>
			counter++;
    38e8:	80 91 17 23 	lds	r24, 0x2317	; 0x802317 <counter>
    38ec:	90 91 18 23 	lds	r25, 0x2318	; 0x802318 <counter+0x1>
    38f0:	01 96       	adiw	r24, 0x01	; 1
    38f2:	80 93 17 23 	sts	0x2317, r24	; 0x802317 <counter>
    38f6:	90 93 18 23 	sts	0x2318, r25	; 0x802318 <counter+0x1>
			snprintf(strbuf, sizeof(strbuf), "Counter : %d", counter);
    38fa:	9f 93       	push	r25
    38fc:	8f 93       	push	r24
    38fe:	ff 92       	push	r15
    3900:	ef 92       	push	r14
    3902:	1f 92       	push	r1
    3904:	df 92       	push	r13
    3906:	1f 93       	push	r17
    3908:	0f 93       	push	r16
    390a:	36 d3       	rcall	.+1644   	; 0x3f78 <snprintf>
			gfx_mono_draw_string(strbuf,0, 8, &sysfont);
    390c:	26 e0       	ldi	r18, 0x06	; 6
    390e:	30 e2       	ldi	r19, 0x20	; 32
    3910:	48 e0       	ldi	r20, 0x08	; 8
    3912:	60 e0       	ldi	r22, 0x00	; 0
    3914:	c8 01       	movw	r24, r16
    3916:	c8 de       	rcall	.-624    	; 0x36a8 <gfx_mono_draw_string>
			xSemaphoreGive(xSemaphore);	
    3918:	20 e0       	ldi	r18, 0x00	; 0
    391a:	40 e0       	ldi	r20, 0x00	; 0
    391c:	50 e0       	ldi	r21, 0x00	; 0
    391e:	60 e0       	ldi	r22, 0x00	; 0
    3920:	70 e0       	ldi	r23, 0x00	; 0
    3922:	80 91 1f 23 	lds	r24, 0x231F	; 0x80231f <xSemaphore>
    3926:	90 91 20 23 	lds	r25, 0x2320	; 0x802320 <xSemaphore+0x1>
    392a:	0e 94 c8 11 	call	0x2390	; 0x2390 <xQueueGenericSend>
    392e:	cd bf       	out	0x3d, r28	; 61
    3930:	de bf       	out	0x3e, r29	; 62
		}
		
		vTaskDelay(100/portTICK_PERIOD_MS);
    3932:	82 e3       	ldi	r24, 0x32	; 50
    3934:	90 e0       	ldi	r25, 0x00	; 0
    3936:	e1 d9       	rcall	.-3134   	; 0x2cfa <vTaskDelay>
	}	
    3938:	cd cf       	rjmp	.-102    	; 0x38d4 <vCounter+0x28>

0000393a <vPushButton1>:
		gfx_mono_draw_string(strbuf,0, 24, &sysfont);
		vTaskDelay(375/portTICK_PERIOD_MS);
	}
}

static portTASK_FUNCTION(vPushButton1, s_) {
    393a:	cf 93       	push	r28
    393c:	df 93       	push	r29
    393e:	cd b7       	in	r28, 0x3d	; 61
    3940:	de b7       	in	r29, 0x3e	; 62
    3942:	c0 58       	subi	r28, 0x80	; 128
    3944:	d1 09       	sbc	r29, r1
    3946:	cd bf       	out	0x3d, r28	; 61
    3948:	de bf       	out	0x3e, r29	; 62

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	return base->IN & arch_ioport_pin_to_mask(pin);
    394a:	00 ea       	ldi	r16, 0xA0	; 160
    394c:	16 e0       	ldi	r17, 0x06	; 6
	while(1) {
		
		if(ioport_get_pin_level(GPIO_PUSH_BUTTON_1)==0){
			if(xSemaphoreTake(xSemaphore, (TickType_t) 10) == pdTRUE) {
				counter++;
				snprintf(strbuf, sizeof(strbuf), "Counter : %d", counter);
    394e:	0f 2e       	mov	r0, r31
    3950:	fa e1       	ldi	r31, 0x1A	; 26
    3952:	cf 2e       	mov	r12, r31
    3954:	f0 e2       	ldi	r31, 0x20	; 32
    3956:	df 2e       	mov	r13, r31
    3958:	f0 2d       	mov	r31, r0
    395a:	68 94       	set
    395c:	bb 24       	eor	r11, r11
    395e:	b7 f8       	bld	r11, 7
    3960:	ce 01       	movw	r24, r28
    3962:	01 96       	adiw	r24, 0x01	; 1
    3964:	7c 01       	movw	r14, r24
    3966:	f8 01       	movw	r30, r16
    3968:	80 85       	ldd	r24, Z+8	; 0x08
static portTASK_FUNCTION(vPushButton1, s_) {
	char strbuf[128];
	
	while(1) {
		
		if(ioport_get_pin_level(GPIO_PUSH_BUTTON_1)==0){
    396a:	81 fd       	sbrc	r24, 1
    396c:	2f c0       	rjmp	.+94     	; 0x39cc <vPushButton1+0x92>
			if(xSemaphoreTake(xSemaphore, (TickType_t) 10) == pdTRUE) {
    396e:	6a e0       	ldi	r22, 0x0A	; 10
    3970:	70 e0       	ldi	r23, 0x00	; 0
    3972:	80 91 1f 23 	lds	r24, 0x231F	; 0x80231f <xSemaphore>
    3976:	90 91 20 23 	lds	r25, 0x2320	; 0x802320 <xSemaphore+0x1>
    397a:	0e 94 13 13 	call	0x2626	; 0x2626 <xQueueSemaphoreTake>
    397e:	81 30       	cpi	r24, 0x01	; 1
    3980:	29 f5       	brne	.+74     	; 0x39cc <vPushButton1+0x92>
				counter++;
    3982:	80 91 17 23 	lds	r24, 0x2317	; 0x802317 <counter>
    3986:	90 91 18 23 	lds	r25, 0x2318	; 0x802318 <counter+0x1>
    398a:	01 96       	adiw	r24, 0x01	; 1
    398c:	80 93 17 23 	sts	0x2317, r24	; 0x802317 <counter>
    3990:	90 93 18 23 	sts	0x2318, r25	; 0x802318 <counter+0x1>
				snprintf(strbuf, sizeof(strbuf), "Counter : %d", counter);
    3994:	9f 93       	push	r25
    3996:	8f 93       	push	r24
    3998:	df 92       	push	r13
    399a:	cf 92       	push	r12
    399c:	1f 92       	push	r1
    399e:	bf 92       	push	r11
    39a0:	ff 92       	push	r15
    39a2:	ef 92       	push	r14
    39a4:	e9 d2       	rcall	.+1490   	; 0x3f78 <snprintf>
				gfx_mono_draw_string(strbuf,0, 8, &sysfont);
    39a6:	26 e0       	ldi	r18, 0x06	; 6
    39a8:	30 e2       	ldi	r19, 0x20	; 32
    39aa:	48 e0       	ldi	r20, 0x08	; 8
    39ac:	60 e0       	ldi	r22, 0x00	; 0
    39ae:	c7 01       	movw	r24, r14
    39b0:	7b de       	rcall	.-778    	; 0x36a8 <gfx_mono_draw_string>
				xSemaphoreGive(xSemaphore);
    39b2:	20 e0       	ldi	r18, 0x00	; 0
    39b4:	40 e0       	ldi	r20, 0x00	; 0
    39b6:	50 e0       	ldi	r21, 0x00	; 0
    39b8:	60 e0       	ldi	r22, 0x00	; 0
    39ba:	70 e0       	ldi	r23, 0x00	; 0
    39bc:	80 91 1f 23 	lds	r24, 0x231F	; 0x80231f <xSemaphore>
    39c0:	90 91 20 23 	lds	r25, 0x2320	; 0x802320 <xSemaphore+0x1>
    39c4:	0e 94 c8 11 	call	0x2390	; 0x2390 <xQueueGenericSend>
    39c8:	cd bf       	out	0x3d, r28	; 61
    39ca:	de bf       	out	0x3e, r29	; 62
			}
		}
		
		vTaskDelay(10/portTICK_PERIOD_MS);
    39cc:	85 e0       	ldi	r24, 0x05	; 5
    39ce:	90 e0       	ldi	r25, 0x00	; 0
    39d0:	94 d9       	rcall	.-3288   	; 0x2cfa <vTaskDelay>
	}
    39d2:	c9 cf       	rjmp	.-110    	; 0x3966 <vPushButton1+0x2c>

000039d4 <vBlinkLed1>:
		}
		vTaskDelay(150 / portTICK_PERIOD_MS);
	}
}

static portTASK_FUNCTION(vBlinkLed1, q_) {	
    39d4:	cf 93       	push	r28
    39d6:	df 93       	push	r29
    39d8:	cd b7       	in	r28, 0x3d	; 61
    39da:	de b7       	in	r29, 0x3e	; 62
    39dc:	c0 58       	subi	r28, 0x80	; 128
    39de:	d1 09       	sbc	r29, r1
    39e0:	cd bf       	out	0x3d, r28	; 61
    39e2:	de bf       	out	0x3e, r29	; 62
	char strbuf[128];
	int flagLed1 = 0;
    39e4:	80 e0       	ldi	r24, 0x00	; 0
    39e6:	90 e0       	ldi	r25, 0x00	; 0
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    39e8:	0f 2e       	mov	r0, r31
    39ea:	f0 ee       	ldi	r31, 0xE0	; 224
    39ec:	af 2e       	mov	r10, r31
    39ee:	f7 e0       	ldi	r31, 0x07	; 7
    39f0:	bf 2e       	mov	r11, r31
    39f2:	f0 2d       	mov	r31, r0
    39f4:	68 94       	set
    39f6:	88 24       	eor	r8, r8
    39f8:	81 f8       	bld	r8, 1
	
	while(1) {
		flagLed1 = !flagLed1;
		ioport_set_pin_level(LED1_GPIO, flagLed1);
		snprintf(strbuf, sizeof(strbuf), "LED 1 : %d", !flagLed1);
    39fa:	0f 2e       	mov	r0, r31
    39fc:	f7 e2       	ldi	r31, 0x27	; 39
    39fe:	cf 2e       	mov	r12, r31
    3a00:	f0 e2       	ldi	r31, 0x20	; 32
    3a02:	df 2e       	mov	r13, r31
    3a04:	f0 2d       	mov	r31, r0
    3a06:	68 94       	set
    3a08:	99 24       	eor	r9, r9
    3a0a:	97 f8       	bld	r9, 7
    3a0c:	9e 01       	movw	r18, r28
    3a0e:	2f 5f       	subi	r18, 0xFF	; 255
    3a10:	3f 4f       	sbci	r19, 0xFF	; 255
    3a12:	79 01       	movw	r14, r18
static portTASK_FUNCTION(vBlinkLed1, q_) {	
	char strbuf[128];
	int flagLed1 = 0;
	
	while(1) {
		flagLed1 = !flagLed1;
    3a14:	01 e0       	ldi	r16, 0x01	; 1
    3a16:	00 97       	sbiw	r24, 0x00	; 0
    3a18:	09 f0       	breq	.+2      	; 0x3a1c <vBlinkLed1+0x48>
    3a1a:	00 e0       	ldi	r16, 0x00	; 0
    3a1c:	10 e0       	ldi	r17, 0x00	; 0
__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
    3a1e:	00 97       	sbiw	r24, 0x00	; 0
    3a20:	19 f4       	brne	.+6      	; 0x3a28 <vBlinkLed1+0x54>
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3a22:	f5 01       	movw	r30, r10
    3a24:	85 82       	std	Z+5, r8	; 0x05
    3a26:	02 c0       	rjmp	.+4      	; 0x3a2c <vBlinkLed1+0x58>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    3a28:	f5 01       	movw	r30, r10
    3a2a:	86 82       	std	Z+6, r8	; 0x06
		ioport_set_pin_level(LED1_GPIO, flagLed1);
		snprintf(strbuf, sizeof(strbuf), "LED 1 : %d", !flagLed1);
    3a2c:	21 e0       	ldi	r18, 0x01	; 1
    3a2e:	30 e0       	ldi	r19, 0x00	; 0
    3a30:	89 2b       	or	r24, r25
    3a32:	09 f4       	brne	.+2      	; 0x3a36 <vBlinkLed1+0x62>
    3a34:	20 e0       	ldi	r18, 0x00	; 0
    3a36:	3f 93       	push	r19
    3a38:	2f 93       	push	r18
    3a3a:	df 92       	push	r13
    3a3c:	cf 92       	push	r12
    3a3e:	1f 92       	push	r1
    3a40:	9f 92       	push	r9
    3a42:	ff 92       	push	r15
    3a44:	ef 92       	push	r14
    3a46:	98 d2       	rcall	.+1328   	; 0x3f78 <snprintf>
		gfx_mono_draw_string(strbuf,0, 24, &sysfont);
    3a48:	26 e0       	ldi	r18, 0x06	; 6
    3a4a:	30 e2       	ldi	r19, 0x20	; 32
    3a4c:	48 e1       	ldi	r20, 0x18	; 24
    3a4e:	60 e0       	ldi	r22, 0x00	; 0
    3a50:	c7 01       	movw	r24, r14
    3a52:	2a de       	rcall	.-940    	; 0x36a8 <gfx_mono_draw_string>
		vTaskDelay(375/portTICK_PERIOD_MS);
    3a54:	8b eb       	ldi	r24, 0xBB	; 187
    3a56:	90 e0       	ldi	r25, 0x00	; 0
    3a58:	50 d9       	rcall	.-3424   	; 0x2cfa <vTaskDelay>
	}
    3a5a:	cd bf       	out	0x3d, r28	; 61
    3a5c:	de bf       	out	0x3e, r29	; 62
static portTASK_FUNCTION(vBlinkLed1, q_) {	
	char strbuf[128];
	int flagLed1 = 0;
	
	while(1) {
		flagLed1 = !flagLed1;
    3a5e:	c8 01       	movw	r24, r16
		ioport_set_pin_level(LED1_GPIO, flagLed1);
		snprintf(strbuf, sizeof(strbuf), "LED 1 : %d", !flagLed1);
		gfx_mono_draw_string(strbuf,0, 24, &sysfont);
		vTaskDelay(375/portTICK_PERIOD_MS);
	}
    3a60:	d9 cf       	rjmp	.-78     	; 0x3a14 <vBlinkLed1+0x40>

00003a62 <vUltrasonicSensor>:
	/* Start the task */
	vTaskStartScheduler();
}


static portTASK_FUNCTION(vUltrasonicSensor, p_) {
    3a62:	cf 93       	push	r28
    3a64:	df 93       	push	r29
    3a66:	cd b7       	in	r28, 0x3d	; 61
    3a68:	de b7       	in	r29, 0x3e	; 62
    3a6a:	c0 58       	subi	r28, 0x80	; 128
    3a6c:	d1 09       	sbc	r29, r1
    3a6e:	cd bf       	out	0x3d, r28	; 61
    3a70:	de bf       	out	0x3e, r29	; 62
 */
static inline void tc_write_clock_source(volatile void *tc,
		TC_CLKSEL_t TC_CLKSEL_enum)
{
	((TC0_t *)tc)->CTRLA =
			(((TC0_t *)tc)->CTRLA & ~TC0_CLKSEL_gm) |
    3a72:	0f 2e       	mov	r0, r31
    3a74:	f0 e4       	ldi	r31, 0x40	; 64
    3a76:	ef 2e       	mov	r14, r31
    3a78:	fa e0       	ldi	r31, 0x0A	; 10
    3a7a:	ff 2e       	mov	r15, r31
    3a7c:	f0 2d       	mov	r31, r0
		if (xSemaphoreTake(xSemaphore, (TickType_t)10) == pdTRUE) {
			//xTimerStart(xIncrementTimer, 0);		// Start the timer (doesnt work bruh)
			//tc_enable(&TCE1);		// Start the timer (doesnt work bruh)
			tc_write_clock_source(&TCE1, TC_CLKSEL_DIV1_gc);	// Start the timer
			
			PORTB.DIR = 0b11111111; //Set output
    3a7e:	00 e2       	ldi	r16, 0x20	; 32
    3a80:	16 e0       	ldi	r17, 0x06	; 6
    3a82:	55 24       	eor	r5, r5
    3a84:	5a 94       	dec	r5
				gfx_mono_draw_string(strbuf, 0, 0, &sysfont);
				incremental = 0;
			} else {
				int inc = newinc - oldinc;
				distance = inc/2; //Dibagi 2 seperti rumus sonar
				snprintf(strbuf, sizeof(strbuf), "Panjang: %d cm   ", distance);
    3a86:	0f 2e       	mov	r0, r31
    3a88:	f2 e3       	ldi	r31, 0x32	; 50
    3a8a:	af 2e       	mov	r10, r31
    3a8c:	f0 e2       	ldi	r31, 0x20	; 32
    3a8e:	bf 2e       	mov	r11, r31
    3a90:	f0 2d       	mov	r31, r0
    3a92:	68 94       	set
    3a94:	44 24       	eor	r4, r4
    3a96:	47 f8       	bld	r4, 7
    3a98:	ce 01       	movw	r24, r28
    3a9a:	01 96       	adiw	r24, 0x01	; 1
    3a9c:	6c 01       	movw	r12, r24

			//taskEXIT_CRITICAL();		// freertos substitute for cpu_irq_disable (fails)
			cpu_irq_disable(); //Interrupt dimatikan
			
			if (incremental > 300){ //Jika hasil lebih dari 300 cm, dibulatkan menjadi 300 cm
				distance = 300;
    3a9e:	0f 2e       	mov	r0, r31
    3aa0:	fc e2       	ldi	r31, 0x2C	; 44
    3aa2:	6f 2e       	mov	r6, r31
    3aa4:	77 24       	eor	r7, r7
    3aa6:	73 94       	inc	r7
    3aa8:	f0 2d       	mov	r31, r0
				snprintf(strbuf, sizeof(strbuf), "Panjang: %d cm   ", distance);
    3aaa:	22 24       	eor	r2, r2
    3aac:	23 94       	inc	r2
    3aae:	0f 2e       	mov	r0, r31
    3ab0:	fc e2       	ldi	r31, 0x2C	; 44
    3ab2:	3f 2e       	mov	r3, r31
    3ab4:	f0 2d       	mov	r31, r0

static portTASK_FUNCTION(vUltrasonicSensor, p_) {
	char strbuf[128];	
	//setup_timer();
	while(1) {
		if (xSemaphoreTake(xSemaphore, (TickType_t)10) == pdTRUE) {
    3ab6:	6a e0       	ldi	r22, 0x0A	; 10
    3ab8:	70 e0       	ldi	r23, 0x00	; 0
    3aba:	80 91 1f 23 	lds	r24, 0x231F	; 0x80231f <xSemaphore>
    3abe:	90 91 20 23 	lds	r25, 0x2320	; 0x802320 <xSemaphore+0x1>
    3ac2:	0e 94 13 13 	call	0x2626	; 0x2626 <xQueueSemaphoreTake>
    3ac6:	81 30       	cpi	r24, 0x01	; 1
    3ac8:	09 f0       	breq	.+2      	; 0x3acc <vUltrasonicSensor+0x6a>
    3aca:	7a c0       	rjmp	.+244    	; 0x3bc0 <vUltrasonicSensor+0x15e>
    3acc:	f7 01       	movw	r30, r14
    3ace:	80 81       	ld	r24, Z
 * \note Configuring the clock also starts the timer
 */
static inline void tc_write_clock_source(volatile void *tc,
		TC_CLKSEL_t TC_CLKSEL_enum)
{
	((TC0_t *)tc)->CTRLA =
    3ad0:	80 7f       	andi	r24, 0xF0	; 240
    3ad2:	81 60       	ori	r24, 0x01	; 1
    3ad4:	80 83       	st	Z, r24
			//xTimerStart(xIncrementTimer, 0);		// Start the timer (doesnt work bruh)
			//tc_enable(&TCE1);		// Start the timer (doesnt work bruh)
			tc_write_clock_source(&TCE1, TC_CLKSEL_DIV1_gc);	// Start the timer
			
			PORTB.DIR = 0b11111111; //Set output
    3ad6:	f8 01       	movw	r30, r16
    3ad8:	50 82       	st	Z, r5
			PORTB.OUT = 0b00000000; //Set low
    3ada:	14 82       	std	Z+4, r1	; 0x04
			PORTB.OUT = 0b11111111; //Set high selama 5us
    3adc:	54 82       	std	Z+4, r5	; 0x04
			delay_us(5);
    3ade:	62 e0       	ldi	r22, 0x02	; 2
    3ae0:	70 e0       	ldi	r23, 0x00	; 0
    3ae2:	80 e0       	ldi	r24, 0x00	; 0
    3ae4:	90 e0       	ldi	r25, 0x00	; 0
    3ae6:	cd de       	rcall	.-614    	; 0x3882 <__portable_avr_delay_cycles>
			PORTB.OUT = 0b00000000; //Kembali menjadi low
    3ae8:	f8 01       	movw	r30, r16
    3aea:	14 82       	std	Z+4, r1	; 0x04
			PORTB.DIR = 0b00000000; //Set menjadi input
    3aec:	10 82       	st	Z, r1
			delay_us(400); //Delay holdoff selama 750us
    3aee:	66 e8       	ldi	r22, 0x86	; 134
    3af0:	70 e0       	ldi	r23, 0x00	; 0
    3af2:	80 e0       	ldi	r24, 0x00	; 0
    3af4:	90 e0       	ldi	r25, 0x00	; 0
    3af6:	c5 de       	rcall	.-630    	; 0x3882 <__portable_avr_delay_cycles>
			int oldinc = incremental;
    3af8:	80 90 15 23 	lds	r8, 0x2315	; 0x802315 <incremental>
    3afc:	90 90 16 23 	lds	r9, 0x2316	; 0x802316 <incremental+0x1>
			delay_us(115); //Delay lagi, kali ini seharusnya pin menjadi high
    3b00:	67 e2       	ldi	r22, 0x27	; 39
    3b02:	70 e0       	ldi	r23, 0x00	; 0
    3b04:	80 e0       	ldi	r24, 0x00	; 0
    3b06:	90 e0       	ldi	r25, 0x00	; 0
    3b08:	bc de       	rcall	.-648    	; 0x3882 <__portable_avr_delay_cycles>
			
			// taskENTER_CRITICAL();	// freertos substitute for cpu_irq_enable (fails)
			cpu_irq_enable(); //Mulai interrupt
    3b0a:	78 94       	sei
			
			while(PORTB.IN & PIN0_bm){
    3b0c:	f8 01       	movw	r30, r16
    3b0e:	80 85       	ldd	r24, Z+8	; 0x08
    3b10:	80 fd       	sbrc	r24, 0
    3b12:	fc cf       	rjmp	.-8      	; 0x3b0c <vUltrasonicSensor+0xaa>
				//Tidak ada apa-apa di sini. Loop ini berfungsi untuk mendeteksi pin 0 PORT B yang berubah menjadi low
			}
			int newinc = incremental; //Catat selisih waktu antara suara dikirim hingga diterima
    3b14:	20 91 15 23 	lds	r18, 0x2315	; 0x802315 <incremental>
    3b18:	30 91 16 23 	lds	r19, 0x2316	; 0x802316 <incremental+0x1>
			(((TC0_t *)tc)->CTRLA & ~TC0_CLKSEL_gm) |
    3b1c:	f7 01       	movw	r30, r14
    3b1e:	80 81       	ld	r24, Z
 * \note Configuring the clock also starts the timer
 */
static inline void tc_write_clock_source(volatile void *tc,
		TC_CLKSEL_t TC_CLKSEL_enum)
{
	((TC0_t *)tc)->CTRLA =
    3b20:	80 7f       	andi	r24, 0xF0	; 240
    3b22:	80 83       	st	Z, r24
			// xTimerStop(xIncrementTimer, 0);		// Stop the timer  (doesnt work bruh)
			// tc_disable(&TCE1);		// Stop the timer  (doesnt work bruh)
			tc_write_clock_source(&TCE1, TC_CLKSEL_OFF_gc); // Stop the timer

			//taskEXIT_CRITICAL();		// freertos substitute for cpu_irq_disable (fails)
			cpu_irq_disable(); //Interrupt dimatikan
    3b24:	f8 94       	cli
			
			if (incremental > 300){ //Jika hasil lebih dari 300 cm, dibulatkan menjadi 300 cm
    3b26:	80 91 15 23 	lds	r24, 0x2315	; 0x802315 <incremental>
    3b2a:	90 91 16 23 	lds	r25, 0x2316	; 0x802316 <incremental+0x1>
    3b2e:	8d 32       	cpi	r24, 0x2D	; 45
    3b30:	91 40       	sbci	r25, 0x01	; 1
    3b32:	d0 f0       	brcs	.+52     	; 0x3b68 <vUltrasonicSensor+0x106>
				distance = 300;
    3b34:	60 92 13 23 	sts	0x2313, r6	; 0x802313 <distance>
    3b38:	70 92 14 23 	sts	0x2314, r7	; 0x802314 <distance+0x1>
				snprintf(strbuf, sizeof(strbuf), "Panjang: %d cm   ", distance);
    3b3c:	2f 92       	push	r2
    3b3e:	3f 92       	push	r3
    3b40:	bf 92       	push	r11
    3b42:	af 92       	push	r10
    3b44:	1f 92       	push	r1
    3b46:	4f 92       	push	r4
    3b48:	df 92       	push	r13
    3b4a:	cf 92       	push	r12
    3b4c:	15 d2       	rcall	.+1066   	; 0x3f78 <snprintf>
				gfx_mono_draw_string(strbuf, 0, 0, &sysfont);
    3b4e:	26 e0       	ldi	r18, 0x06	; 6
    3b50:	30 e2       	ldi	r19, 0x20	; 32
    3b52:	40 e0       	ldi	r20, 0x00	; 0
    3b54:	60 e0       	ldi	r22, 0x00	; 0
    3b56:	c6 01       	movw	r24, r12
    3b58:	a7 dd       	rcall	.-1202   	; 0x36a8 <gfx_mono_draw_string>
				incremental = 0;
    3b5a:	10 92 15 23 	sts	0x2315, r1	; 0x802315 <incremental>
    3b5e:	10 92 16 23 	sts	0x2316, r1	; 0x802316 <incremental+0x1>
    3b62:	cd bf       	out	0x3d, r28	; 61
    3b64:	de bf       	out	0x3e, r29	; 62
    3b66:	21 c0       	rjmp	.+66     	; 0x3baa <vUltrasonicSensor+0x148>
			} else {
				int inc = newinc - oldinc;
				distance = inc/2; //Dibagi 2 seperti rumus sonar
    3b68:	28 19       	sub	r18, r8
    3b6a:	39 09       	sbc	r19, r9
    3b6c:	c9 01       	movw	r24, r18
    3b6e:	99 23       	and	r25, r25
    3b70:	0c f4       	brge	.+2      	; 0x3b74 <vUltrasonicSensor+0x112>
    3b72:	01 96       	adiw	r24, 0x01	; 1
    3b74:	95 95       	asr	r25
    3b76:	87 95       	ror	r24
    3b78:	80 93 13 23 	sts	0x2313, r24	; 0x802313 <distance>
    3b7c:	90 93 14 23 	sts	0x2314, r25	; 0x802314 <distance+0x1>
				snprintf(strbuf, sizeof(strbuf), "Panjang: %d cm   ", distance);
    3b80:	9f 93       	push	r25
    3b82:	8f 93       	push	r24
    3b84:	bf 92       	push	r11
    3b86:	af 92       	push	r10
    3b88:	1f 92       	push	r1
    3b8a:	4f 92       	push	r4
    3b8c:	df 92       	push	r13
    3b8e:	cf 92       	push	r12
    3b90:	f3 d1       	rcall	.+998    	; 0x3f78 <snprintf>
				gfx_mono_draw_string(strbuf, 0, 0, &sysfont);
    3b92:	26 e0       	ldi	r18, 0x06	; 6
    3b94:	30 e2       	ldi	r19, 0x20	; 32
    3b96:	40 e0       	ldi	r20, 0x00	; 0
    3b98:	60 e0       	ldi	r22, 0x00	; 0
    3b9a:	c6 01       	movw	r24, r12
    3b9c:	85 dd       	rcall	.-1270   	; 0x36a8 <gfx_mono_draw_string>
    3b9e:	10 92 15 23 	sts	0x2315, r1	; 0x802315 <incremental>
				incremental = 0; //reset nilai variable incremental
    3ba2:	10 92 16 23 	sts	0x2316, r1	; 0x802316 <incremental+0x1>
    3ba6:	cd bf       	out	0x3d, r28	; 61
    3ba8:	de bf       	out	0x3e, r29	; 62
    3baa:	20 e0       	ldi	r18, 0x00	; 0
			}
			xSemaphoreGive(xSemaphore);
    3bac:	40 e0       	ldi	r20, 0x00	; 0
    3bae:	50 e0       	ldi	r21, 0x00	; 0
    3bb0:	60 e0       	ldi	r22, 0x00	; 0
    3bb2:	70 e0       	ldi	r23, 0x00	; 0
    3bb4:	80 91 1f 23 	lds	r24, 0x231F	; 0x80231f <xSemaphore>
    3bb8:	90 91 20 23 	lds	r25, 0x2320	; 0x802320 <xSemaphore+0x1>
    3bbc:	0e 94 c8 11 	call	0x2390	; 0x2390 <xQueueGenericSend>
		}
		vTaskDelay(150 / portTICK_PERIOD_MS);
    3bc0:	8b e4       	ldi	r24, 0x4B	; 75
    3bc2:	90 e0       	ldi	r25, 0x00	; 0
    3bc4:	9a d8       	rcall	.-3788   	; 0x2cfa <vTaskDelay>
    3bc6:	77 cf       	rjmp	.-274    	; 0x3ab6 <vUltrasonicSensor+0x54>

00003bc8 <setup_timer>:
	}
    3bc8:	80 e4       	ldi	r24, 0x40	; 64
*/

// OPTION 2: THIS IS THE TIMER USING TC LIBRARY FROM ATMEL STUDIO
//Fungsi setup timer
void setup_timer(void){
	tc_enable(&TCE1);
    3bca:	9a e0       	ldi	r25, 0x0A	; 10
    3bcc:	0e 94 b0 0b 	call	0x1760	; 0x1760 <tc_enable>
	tc_set_overflow_interrupt_callback(&TCE1,print_message);
    3bd0:	6c e4       	ldi	r22, 0x4C	; 76
    3bd2:	7c e1       	ldi	r23, 0x1C	; 28
    3bd4:	80 e4       	ldi	r24, 0x40	; 64
    3bd6:	9a e0       	ldi	r25, 0x0A	; 10
    3bd8:	0e 94 2f 0c 	call	0x185e	; 0x185e <tc_set_overflow_interrupt_callback>
 * \param tc Pointer to TC module.
 * \param wgm : waveform generator
 */
static inline void tc_set_wgm(volatile void *tc, enum tc_wg_mode_t wgm)
{
	((TC0_t *)tc)->CTRLB = (((TC0_t *)tc)->CTRLB & ~TC0_WGMODE_gm) | wgm;
    3bdc:	e0 e4       	ldi	r30, 0x40	; 64
    3bde:	fa e0       	ldi	r31, 0x0A	; 10
    3be0:	81 81       	ldd	r24, Z+1	; 0x01
    3be2:	88 7f       	andi	r24, 0xF8	; 248
    3be4:	81 83       	std	Z+1, r24	; 0x01
 * \param tc Pointer to TC module.
 * \param per_value Period value : PER
 */
static inline void tc_write_period(volatile void *tc, uint16_t per_value)
{
	((TC0_t *)tc)->PER = per_value;
    3be6:	8a e3       	ldi	r24, 0x3A	; 58
    3be8:	90 e0       	ldi	r25, 0x00	; 0
    3bea:	86 a3       	std	Z+38, r24	; 0x26
    3bec:	97 a3       	std	Z+39, r25	; 0x27
 * \note  Configures OVFINTLVL in INTCTRLA
 */
static inline void tc_set_overflow_interrupt_level(volatile void *tc,
		enum TC_INT_LEVEL_t level)
{
	((TC0_t *)tc)->INTCTRLA = ((TC0_t *)tc)->INTCTRLA & ~TC0_OVFINTLVL_gm;
    3bee:	86 81       	ldd	r24, Z+6	; 0x06
    3bf0:	8c 7f       	andi	r24, 0xFC	; 252
    3bf2:	86 83       	std	Z+6, r24	; 0x06
	((TC0_t *)tc)->INTCTRLA =
			((TC0_t *)tc)->INTCTRLA | (level << TC0_OVFINTLVL_gp);
    3bf4:	86 81       	ldd	r24, Z+6	; 0x06
 */
static inline void tc_set_overflow_interrupt_level(volatile void *tc,
		enum TC_INT_LEVEL_t level)
{
	((TC0_t *)tc)->INTCTRLA = ((TC0_t *)tc)->INTCTRLA & ~TC0_OVFINTLVL_gm;
	((TC0_t *)tc)->INTCTRLA =
    3bf6:	83 60       	ori	r24, 0x03	; 3
    3bf8:	86 83       	std	Z+6, r24	; 0x06
 */
static inline void tc_write_clock_source(volatile void *tc,
		TC_CLKSEL_t TC_CLKSEL_enum)
{
	((TC0_t *)tc)->CTRLA =
			(((TC0_t *)tc)->CTRLA & ~TC0_CLKSEL_gm) |
    3bfa:	80 81       	ld	r24, Z
 * \note Configuring the clock also starts the timer
 */
static inline void tc_write_clock_source(volatile void *tc,
		TC_CLKSEL_t TC_CLKSEL_enum)
{
	((TC0_t *)tc)->CTRLA =
    3bfc:	80 7f       	andi	r24, 0xF0	; 240
    3bfe:	80 83       	st	Z, r24
    3c00:	08 95       	ret

00003c02 <main>:
	//}
}


int main (void)
{
    3c02:	ef 92       	push	r14
    3c04:	ff 92       	push	r15
    3c06:	0f 93       	push	r16
	/* Insert system clock initialization code here (sysclk_init()). */
	// sysclk_init();
	board_init();
    3c08:	9f dd       	rcall	.-1218   	; 0x3748 <board_init>
 * Enables all interrupt levels, with vectors located in the application section
 * and fixed priority scheduling.
 */
static inline void pmic_init(void)
{
	PMIC.CTRL = PMIC_LVL_LOW | PMIC_LVL_MEDIUM |
    3c0a:	87 e0       	ldi	r24, 0x07	; 7
    3c0c:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	pmic_init();
	gfx_mono_init();
    3c10:	0e 94 0a 05 	call	0xa14	; 0xa14 <gfx_mono_st7565r_init>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3c14:	80 e1       	ldi	r24, 0x10	; 16
    3c16:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
	
	gpio_set_pin_high(LCD_BACKLIGHT_ENABLE_PIN);
	gfx_mono_draw_string("RTOS v10.2.1", 0, 0, &sysfont);
    3c1a:	26 e0       	ldi	r18, 0x06	; 6
    3c1c:	30 e2       	ldi	r19, 0x20	; 32
    3c1e:	40 e0       	ldi	r20, 0x00	; 0
    3c20:	60 e0       	ldi	r22, 0x00	; 0
    3c22:	84 e4       	ldi	r24, 0x44	; 68
    3c24:	90 e2       	ldi	r25, 0x20	; 32
    3c26:	40 dd       	rcall	.-1408   	; 0x36a8 <gfx_mono_draw_string>
	
	// Workaround for known issue: Enable RTC32 sysclk
	sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
    3c28:	64 e0       	ldi	r22, 0x04	; 4
    3c2a:	80 e0       	ldi	r24, 0x00	; 0
    3c2c:	c9 dc       	rcall	.-1646   	; 0x35c0 <sysclk_enable_module>
	while (RTC32.SYNCCTRL & RTC32_SYNCBUSY_bm) {
    3c2e:	e0 e2       	ldi	r30, 0x20	; 32
    3c30:	f4 e0       	ldi	r31, 0x04	; 4
    3c32:	81 81       	ldd	r24, Z+1	; 0x01
    3c34:	80 fd       	sbrc	r24, 0
    3c36:	fd cf       	rjmp	.-6      	; 0x3c32 <main+0x30>
		// Wait for RTC32 sysclk to become stable
	}
	
	delay_ms(1000);
    3c38:	66 e1       	ldi	r22, 0x16	; 22
    3c3a:	76 e1       	ldi	r23, 0x16	; 22
    3c3c:	85 e0       	ldi	r24, 0x05	; 5
    3c3e:	90 e0       	ldi	r25, 0x00	; 0

	setup_timer();		// used when using timer from freertos, because should run before vtaskstartscheduler
    3c40:	20 de       	rcall	.-960    	; 0x3882 <__portable_avr_delay_cycles>
    3c42:	c2 df       	rcall	.-124    	; 0x3bc8 <setup_timer>
	/* Create the task */
	
	xTaskCreate(vUltrasonicSensor, "", 1000, NULL, tskIDLE_PRIORITY + 0, NULL);	// higher priority
    3c44:	e1 2c       	mov	r14, r1
    3c46:	f1 2c       	mov	r15, r1
    3c48:	00 e0       	ldi	r16, 0x00	; 0
    3c4a:	20 e0       	ldi	r18, 0x00	; 0
    3c4c:	30 e0       	ldi	r19, 0x00	; 0
    3c4e:	48 ee       	ldi	r20, 0xE8	; 232
    3c50:	53 e0       	ldi	r21, 0x03	; 3
    3c52:	63 e4       	ldi	r22, 0x43	; 67
    3c54:	70 e2       	ldi	r23, 0x20	; 32
    3c56:	81 e3       	ldi	r24, 0x31	; 49
    3c58:	9d e1       	ldi	r25, 0x1D	; 29
    3c5a:	0e 94 0e 14 	call	0x281c	; 0x281c <xTaskCreate>
	xTaskCreate(vBlinkLed1, "", 1000, NULL, tskIDLE_PRIORITY + 2, NULL);	// higher priority
    3c5e:	02 e0       	ldi	r16, 0x02	; 2
    3c60:	20 e0       	ldi	r18, 0x00	; 0
    3c62:	30 e0       	ldi	r19, 0x00	; 0
    3c64:	48 ee       	ldi	r20, 0xE8	; 232
    3c66:	53 e0       	ldi	r21, 0x03	; 3
    3c68:	63 e4       	ldi	r22, 0x43	; 67
    3c6a:	70 e2       	ldi	r23, 0x20	; 32
    3c6c:	8a ee       	ldi	r24, 0xEA	; 234
    3c6e:	9c e1       	ldi	r25, 0x1C	; 28
    3c70:	0e 94 0e 14 	call	0x281c	; 0x281c <xTaskCreate>
	xTaskCreate(vPushButton1, "", 1000, NULL, tskIDLE_PRIORITY + 3, NULL);	// higher priority
    3c74:	03 e0       	ldi	r16, 0x03	; 3
    3c76:	20 e0       	ldi	r18, 0x00	; 0
    3c78:	30 e0       	ldi	r19, 0x00	; 0
    3c7a:	48 ee       	ldi	r20, 0xE8	; 232
    3c7c:	53 e0       	ldi	r21, 0x03	; 3
    3c7e:	63 e4       	ldi	r22, 0x43	; 67
    3c80:	70 e2       	ldi	r23, 0x20	; 32
    3c82:	8d e9       	ldi	r24, 0x9D	; 157
    3c84:	9c e1       	ldi	r25, 0x1C	; 28
    3c86:	0e 94 0e 14 	call	0x281c	; 0x281c <xTaskCreate>
	xTaskCreate(vCounter, "", 1000, NULL, tskIDLE_PRIORITY + 1, NULL);			// low priority
    3c8a:	01 e0       	ldi	r16, 0x01	; 1
    3c8c:	20 e0       	ldi	r18, 0x00	; 0
    3c8e:	30 e0       	ldi	r19, 0x00	; 0
    3c90:	48 ee       	ldi	r20, 0xE8	; 232
    3c92:	53 e0       	ldi	r21, 0x03	; 3
    3c94:	63 e4       	ldi	r22, 0x43	; 67
    3c96:	70 e2       	ldi	r23, 0x20	; 32
    3c98:	86 e5       	ldi	r24, 0x56	; 86
    3c9a:	9c e1       	ldi	r25, 0x1C	; 28
    3c9c:	0e 94 0e 14 	call	0x281c	; 0x281c <xTaskCreate>
	
	/* Semaphore */
	xSemaphore = xSemaphoreCreateBinary();
    3ca0:	43 e0       	ldi	r20, 0x03	; 3
    3ca2:	60 e0       	ldi	r22, 0x00	; 0
    3ca4:	81 e0       	ldi	r24, 0x01	; 1
    3ca6:	0e 94 a7 11 	call	0x234e	; 0x234e <xQueueGenericCreate>
    3caa:	80 93 1f 23 	sts	0x231F, r24	; 0x80231f <xSemaphore>
    3cae:	90 93 20 23 	sts	0x2320, r25	; 0x802320 <xSemaphore+0x1>
	xSemaphoreGive(xSemaphore);
    3cb2:	20 e0       	ldi	r18, 0x00	; 0
    3cb4:	40 e0       	ldi	r20, 0x00	; 0
    3cb6:	50 e0       	ldi	r21, 0x00	; 0
    3cb8:	60 e0       	ldi	r22, 0x00	; 0
    3cba:	70 e0       	ldi	r23, 0x00	; 0
    3cbc:	0e 94 c8 11 	call	0x2390	; 0x2390 <xQueueGenericSend>
	
	/* Start the task */
	vTaskStartScheduler();
    3cc0:	0e 94 0d 15 	call	0x2a1a	; 0x2a1a <vTaskStartScheduler>
}
    3cc4:	80 e0       	ldi	r24, 0x00	; 0
    3cc6:	90 e0       	ldi	r25, 0x00	; 0
    3cc8:	0f 91       	pop	r16
    3cca:	ff 90       	pop	r15
    3ccc:	ef 90       	pop	r14
    3cce:	08 95       	ret

00003cd0 <__udivmodsi4>:
    3cd0:	a1 e2       	ldi	r26, 0x21	; 33
    3cd2:	1a 2e       	mov	r1, r26
    3cd4:	aa 1b       	sub	r26, r26
    3cd6:	bb 1b       	sub	r27, r27
    3cd8:	fd 01       	movw	r30, r26
    3cda:	0d c0       	rjmp	.+26     	; 0x3cf6 <__udivmodsi4_ep>

00003cdc <__udivmodsi4_loop>:
    3cdc:	aa 1f       	adc	r26, r26
    3cde:	bb 1f       	adc	r27, r27
    3ce0:	ee 1f       	adc	r30, r30
    3ce2:	ff 1f       	adc	r31, r31
    3ce4:	a2 17       	cp	r26, r18
    3ce6:	b3 07       	cpc	r27, r19
    3ce8:	e4 07       	cpc	r30, r20
    3cea:	f5 07       	cpc	r31, r21
    3cec:	20 f0       	brcs	.+8      	; 0x3cf6 <__udivmodsi4_ep>
    3cee:	a2 1b       	sub	r26, r18
    3cf0:	b3 0b       	sbc	r27, r19
    3cf2:	e4 0b       	sbc	r30, r20
    3cf4:	f5 0b       	sbc	r31, r21

00003cf6 <__udivmodsi4_ep>:
    3cf6:	66 1f       	adc	r22, r22
    3cf8:	77 1f       	adc	r23, r23
    3cfa:	88 1f       	adc	r24, r24
    3cfc:	99 1f       	adc	r25, r25
    3cfe:	1a 94       	dec	r1
    3d00:	69 f7       	brne	.-38     	; 0x3cdc <__udivmodsi4_loop>
    3d02:	60 95       	com	r22
    3d04:	70 95       	com	r23
    3d06:	80 95       	com	r24
    3d08:	90 95       	com	r25
    3d0a:	9b 01       	movw	r18, r22
    3d0c:	ac 01       	movw	r20, r24
    3d0e:	bd 01       	movw	r22, r26
    3d10:	cf 01       	movw	r24, r30
    3d12:	08 95       	ret

00003d14 <__tablejump2__>:
    3d14:	ee 0f       	add	r30, r30
    3d16:	ff 1f       	adc	r31, r31
    3d18:	88 1f       	adc	r24, r24
    3d1a:	8b bf       	out	0x3b, r24	; 59
    3d1c:	07 90       	elpm	r0, Z+
    3d1e:	f6 91       	elpm	r31, Z
    3d20:	e0 2d       	mov	r30, r0
    3d22:	19 94       	eijmp

00003d24 <malloc>:
    3d24:	0f 93       	push	r16
    3d26:	1f 93       	push	r17
    3d28:	cf 93       	push	r28
    3d2a:	df 93       	push	r29
    3d2c:	82 30       	cpi	r24, 0x02	; 2
    3d2e:	91 05       	cpc	r25, r1
    3d30:	10 f4       	brcc	.+4      	; 0x3d36 <malloc+0x12>
    3d32:	82 e0       	ldi	r24, 0x02	; 2
    3d34:	90 e0       	ldi	r25, 0x00	; 0
    3d36:	e0 91 23 23 	lds	r30, 0x2323	; 0x802323 <__flp>
    3d3a:	f0 91 24 23 	lds	r31, 0x2324	; 0x802324 <__flp+0x1>
    3d3e:	20 e0       	ldi	r18, 0x00	; 0
    3d40:	30 e0       	ldi	r19, 0x00	; 0
    3d42:	a0 e0       	ldi	r26, 0x00	; 0
    3d44:	b0 e0       	ldi	r27, 0x00	; 0
    3d46:	30 97       	sbiw	r30, 0x00	; 0
    3d48:	19 f1       	breq	.+70     	; 0x3d90 <malloc+0x6c>
    3d4a:	40 81       	ld	r20, Z
    3d4c:	51 81       	ldd	r21, Z+1	; 0x01
    3d4e:	02 81       	ldd	r16, Z+2	; 0x02
    3d50:	13 81       	ldd	r17, Z+3	; 0x03
    3d52:	48 17       	cp	r20, r24
    3d54:	59 07       	cpc	r21, r25
    3d56:	c8 f0       	brcs	.+50     	; 0x3d8a <malloc+0x66>
    3d58:	84 17       	cp	r24, r20
    3d5a:	95 07       	cpc	r25, r21
    3d5c:	69 f4       	brne	.+26     	; 0x3d78 <malloc+0x54>
    3d5e:	10 97       	sbiw	r26, 0x00	; 0
    3d60:	31 f0       	breq	.+12     	; 0x3d6e <malloc+0x4a>
    3d62:	12 96       	adiw	r26, 0x02	; 2
    3d64:	0c 93       	st	X, r16
    3d66:	12 97       	sbiw	r26, 0x02	; 2
    3d68:	13 96       	adiw	r26, 0x03	; 3
    3d6a:	1c 93       	st	X, r17
    3d6c:	27 c0       	rjmp	.+78     	; 0x3dbc <malloc+0x98>
    3d6e:	00 93 23 23 	sts	0x2323, r16	; 0x802323 <__flp>
    3d72:	10 93 24 23 	sts	0x2324, r17	; 0x802324 <__flp+0x1>
    3d76:	22 c0       	rjmp	.+68     	; 0x3dbc <malloc+0x98>
    3d78:	21 15       	cp	r18, r1
    3d7a:	31 05       	cpc	r19, r1
    3d7c:	19 f0       	breq	.+6      	; 0x3d84 <malloc+0x60>
    3d7e:	42 17       	cp	r20, r18
    3d80:	53 07       	cpc	r21, r19
    3d82:	18 f4       	brcc	.+6      	; 0x3d8a <malloc+0x66>
    3d84:	9a 01       	movw	r18, r20
    3d86:	bd 01       	movw	r22, r26
    3d88:	ef 01       	movw	r28, r30
    3d8a:	df 01       	movw	r26, r30
    3d8c:	f8 01       	movw	r30, r16
    3d8e:	db cf       	rjmp	.-74     	; 0x3d46 <malloc+0x22>
    3d90:	21 15       	cp	r18, r1
    3d92:	31 05       	cpc	r19, r1
    3d94:	f9 f0       	breq	.+62     	; 0x3dd4 <malloc+0xb0>
    3d96:	28 1b       	sub	r18, r24
    3d98:	39 0b       	sbc	r19, r25
    3d9a:	24 30       	cpi	r18, 0x04	; 4
    3d9c:	31 05       	cpc	r19, r1
    3d9e:	80 f4       	brcc	.+32     	; 0x3dc0 <malloc+0x9c>
    3da0:	8a 81       	ldd	r24, Y+2	; 0x02
    3da2:	9b 81       	ldd	r25, Y+3	; 0x03
    3da4:	61 15       	cp	r22, r1
    3da6:	71 05       	cpc	r23, r1
    3da8:	21 f0       	breq	.+8      	; 0x3db2 <malloc+0x8e>
    3daa:	fb 01       	movw	r30, r22
    3dac:	82 83       	std	Z+2, r24	; 0x02
    3dae:	93 83       	std	Z+3, r25	; 0x03
    3db0:	04 c0       	rjmp	.+8      	; 0x3dba <malloc+0x96>
    3db2:	80 93 23 23 	sts	0x2323, r24	; 0x802323 <__flp>
    3db6:	90 93 24 23 	sts	0x2324, r25	; 0x802324 <__flp+0x1>
    3dba:	fe 01       	movw	r30, r28
    3dbc:	32 96       	adiw	r30, 0x02	; 2
    3dbe:	44 c0       	rjmp	.+136    	; 0x3e48 <malloc+0x124>
    3dc0:	fe 01       	movw	r30, r28
    3dc2:	e2 0f       	add	r30, r18
    3dc4:	f3 1f       	adc	r31, r19
    3dc6:	81 93       	st	Z+, r24
    3dc8:	91 93       	st	Z+, r25
    3dca:	22 50       	subi	r18, 0x02	; 2
    3dcc:	31 09       	sbc	r19, r1
    3dce:	28 83       	st	Y, r18
    3dd0:	39 83       	std	Y+1, r19	; 0x01
    3dd2:	3a c0       	rjmp	.+116    	; 0x3e48 <malloc+0x124>
    3dd4:	20 91 21 23 	lds	r18, 0x2321	; 0x802321 <__brkval>
    3dd8:	30 91 22 23 	lds	r19, 0x2322	; 0x802322 <__brkval+0x1>
    3ddc:	23 2b       	or	r18, r19
    3dde:	41 f4       	brne	.+16     	; 0x3df0 <malloc+0xcc>
    3de0:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    3de4:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    3de8:	20 93 21 23 	sts	0x2321, r18	; 0x802321 <__brkval>
    3dec:	30 93 22 23 	sts	0x2322, r19	; 0x802322 <__brkval+0x1>
    3df0:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
    3df4:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
    3df8:	21 15       	cp	r18, r1
    3dfa:	31 05       	cpc	r19, r1
    3dfc:	41 f4       	brne	.+16     	; 0x3e0e <malloc+0xea>
    3dfe:	2d b7       	in	r18, 0x3d	; 61
    3e00:	3e b7       	in	r19, 0x3e	; 62
    3e02:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    3e06:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    3e0a:	24 1b       	sub	r18, r20
    3e0c:	35 0b       	sbc	r19, r21
    3e0e:	e0 91 21 23 	lds	r30, 0x2321	; 0x802321 <__brkval>
    3e12:	f0 91 22 23 	lds	r31, 0x2322	; 0x802322 <__brkval+0x1>
    3e16:	e2 17       	cp	r30, r18
    3e18:	f3 07       	cpc	r31, r19
    3e1a:	a0 f4       	brcc	.+40     	; 0x3e44 <malloc+0x120>
    3e1c:	2e 1b       	sub	r18, r30
    3e1e:	3f 0b       	sbc	r19, r31
    3e20:	28 17       	cp	r18, r24
    3e22:	39 07       	cpc	r19, r25
    3e24:	78 f0       	brcs	.+30     	; 0x3e44 <malloc+0x120>
    3e26:	ac 01       	movw	r20, r24
    3e28:	4e 5f       	subi	r20, 0xFE	; 254
    3e2a:	5f 4f       	sbci	r21, 0xFF	; 255
    3e2c:	24 17       	cp	r18, r20
    3e2e:	35 07       	cpc	r19, r21
    3e30:	48 f0       	brcs	.+18     	; 0x3e44 <malloc+0x120>
    3e32:	4e 0f       	add	r20, r30
    3e34:	5f 1f       	adc	r21, r31
    3e36:	40 93 21 23 	sts	0x2321, r20	; 0x802321 <__brkval>
    3e3a:	50 93 22 23 	sts	0x2322, r21	; 0x802322 <__brkval+0x1>
    3e3e:	81 93       	st	Z+, r24
    3e40:	91 93       	st	Z+, r25
    3e42:	02 c0       	rjmp	.+4      	; 0x3e48 <malloc+0x124>
    3e44:	e0 e0       	ldi	r30, 0x00	; 0
    3e46:	f0 e0       	ldi	r31, 0x00	; 0
    3e48:	cf 01       	movw	r24, r30
    3e4a:	df 91       	pop	r29
    3e4c:	cf 91       	pop	r28
    3e4e:	1f 91       	pop	r17
    3e50:	0f 91       	pop	r16
    3e52:	08 95       	ret

00003e54 <free>:
    3e54:	cf 93       	push	r28
    3e56:	df 93       	push	r29
    3e58:	00 97       	sbiw	r24, 0x00	; 0
    3e5a:	09 f4       	brne	.+2      	; 0x3e5e <free+0xa>
    3e5c:	81 c0       	rjmp	.+258    	; 0x3f60 <free+0x10c>
    3e5e:	fc 01       	movw	r30, r24
    3e60:	32 97       	sbiw	r30, 0x02	; 2
    3e62:	12 82       	std	Z+2, r1	; 0x02
    3e64:	13 82       	std	Z+3, r1	; 0x03
    3e66:	a0 91 23 23 	lds	r26, 0x2323	; 0x802323 <__flp>
    3e6a:	b0 91 24 23 	lds	r27, 0x2324	; 0x802324 <__flp+0x1>
    3e6e:	10 97       	sbiw	r26, 0x00	; 0
    3e70:	81 f4       	brne	.+32     	; 0x3e92 <free+0x3e>
    3e72:	20 81       	ld	r18, Z
    3e74:	31 81       	ldd	r19, Z+1	; 0x01
    3e76:	82 0f       	add	r24, r18
    3e78:	93 1f       	adc	r25, r19
    3e7a:	20 91 21 23 	lds	r18, 0x2321	; 0x802321 <__brkval>
    3e7e:	30 91 22 23 	lds	r19, 0x2322	; 0x802322 <__brkval+0x1>
    3e82:	28 17       	cp	r18, r24
    3e84:	39 07       	cpc	r19, r25
    3e86:	51 f5       	brne	.+84     	; 0x3edc <free+0x88>
    3e88:	e0 93 21 23 	sts	0x2321, r30	; 0x802321 <__brkval>
    3e8c:	f0 93 22 23 	sts	0x2322, r31	; 0x802322 <__brkval+0x1>
    3e90:	67 c0       	rjmp	.+206    	; 0x3f60 <free+0x10c>
    3e92:	ed 01       	movw	r28, r26
    3e94:	20 e0       	ldi	r18, 0x00	; 0
    3e96:	30 e0       	ldi	r19, 0x00	; 0
    3e98:	ce 17       	cp	r28, r30
    3e9a:	df 07       	cpc	r29, r31
    3e9c:	40 f4       	brcc	.+16     	; 0x3eae <free+0x5a>
    3e9e:	4a 81       	ldd	r20, Y+2	; 0x02
    3ea0:	5b 81       	ldd	r21, Y+3	; 0x03
    3ea2:	9e 01       	movw	r18, r28
    3ea4:	41 15       	cp	r20, r1
    3ea6:	51 05       	cpc	r21, r1
    3ea8:	f1 f0       	breq	.+60     	; 0x3ee6 <free+0x92>
    3eaa:	ea 01       	movw	r28, r20
    3eac:	f5 cf       	rjmp	.-22     	; 0x3e98 <free+0x44>
    3eae:	c2 83       	std	Z+2, r28	; 0x02
    3eb0:	d3 83       	std	Z+3, r29	; 0x03
    3eb2:	40 81       	ld	r20, Z
    3eb4:	51 81       	ldd	r21, Z+1	; 0x01
    3eb6:	84 0f       	add	r24, r20
    3eb8:	95 1f       	adc	r25, r21
    3eba:	c8 17       	cp	r28, r24
    3ebc:	d9 07       	cpc	r29, r25
    3ebe:	59 f4       	brne	.+22     	; 0x3ed6 <free+0x82>
    3ec0:	88 81       	ld	r24, Y
    3ec2:	99 81       	ldd	r25, Y+1	; 0x01
    3ec4:	84 0f       	add	r24, r20
    3ec6:	95 1f       	adc	r25, r21
    3ec8:	02 96       	adiw	r24, 0x02	; 2
    3eca:	80 83       	st	Z, r24
    3ecc:	91 83       	std	Z+1, r25	; 0x01
    3ece:	8a 81       	ldd	r24, Y+2	; 0x02
    3ed0:	9b 81       	ldd	r25, Y+3	; 0x03
    3ed2:	82 83       	std	Z+2, r24	; 0x02
    3ed4:	93 83       	std	Z+3, r25	; 0x03
    3ed6:	21 15       	cp	r18, r1
    3ed8:	31 05       	cpc	r19, r1
    3eda:	29 f4       	brne	.+10     	; 0x3ee6 <free+0x92>
    3edc:	e0 93 23 23 	sts	0x2323, r30	; 0x802323 <__flp>
    3ee0:	f0 93 24 23 	sts	0x2324, r31	; 0x802324 <__flp+0x1>
    3ee4:	3d c0       	rjmp	.+122    	; 0x3f60 <free+0x10c>
    3ee6:	e9 01       	movw	r28, r18
    3ee8:	ea 83       	std	Y+2, r30	; 0x02
    3eea:	fb 83       	std	Y+3, r31	; 0x03
    3eec:	49 91       	ld	r20, Y+
    3eee:	59 91       	ld	r21, Y+
    3ef0:	c4 0f       	add	r28, r20
    3ef2:	d5 1f       	adc	r29, r21
    3ef4:	ec 17       	cp	r30, r28
    3ef6:	fd 07       	cpc	r31, r29
    3ef8:	61 f4       	brne	.+24     	; 0x3f12 <free+0xbe>
    3efa:	80 81       	ld	r24, Z
    3efc:	91 81       	ldd	r25, Z+1	; 0x01
    3efe:	84 0f       	add	r24, r20
    3f00:	95 1f       	adc	r25, r21
    3f02:	02 96       	adiw	r24, 0x02	; 2
    3f04:	e9 01       	movw	r28, r18
    3f06:	88 83       	st	Y, r24
    3f08:	99 83       	std	Y+1, r25	; 0x01
    3f0a:	82 81       	ldd	r24, Z+2	; 0x02
    3f0c:	93 81       	ldd	r25, Z+3	; 0x03
    3f0e:	8a 83       	std	Y+2, r24	; 0x02
    3f10:	9b 83       	std	Y+3, r25	; 0x03
    3f12:	e0 e0       	ldi	r30, 0x00	; 0
    3f14:	f0 e0       	ldi	r31, 0x00	; 0
    3f16:	12 96       	adiw	r26, 0x02	; 2
    3f18:	8d 91       	ld	r24, X+
    3f1a:	9c 91       	ld	r25, X
    3f1c:	13 97       	sbiw	r26, 0x03	; 3
    3f1e:	00 97       	sbiw	r24, 0x00	; 0
    3f20:	19 f0       	breq	.+6      	; 0x3f28 <free+0xd4>
    3f22:	fd 01       	movw	r30, r26
    3f24:	dc 01       	movw	r26, r24
    3f26:	f7 cf       	rjmp	.-18     	; 0x3f16 <free+0xc2>
    3f28:	8d 91       	ld	r24, X+
    3f2a:	9c 91       	ld	r25, X
    3f2c:	11 97       	sbiw	r26, 0x01	; 1
    3f2e:	9d 01       	movw	r18, r26
    3f30:	2e 5f       	subi	r18, 0xFE	; 254
    3f32:	3f 4f       	sbci	r19, 0xFF	; 255
    3f34:	82 0f       	add	r24, r18
    3f36:	93 1f       	adc	r25, r19
    3f38:	20 91 21 23 	lds	r18, 0x2321	; 0x802321 <__brkval>
    3f3c:	30 91 22 23 	lds	r19, 0x2322	; 0x802322 <__brkval+0x1>
    3f40:	28 17       	cp	r18, r24
    3f42:	39 07       	cpc	r19, r25
    3f44:	69 f4       	brne	.+26     	; 0x3f60 <free+0x10c>
    3f46:	30 97       	sbiw	r30, 0x00	; 0
    3f48:	29 f4       	brne	.+10     	; 0x3f54 <free+0x100>
    3f4a:	10 92 23 23 	sts	0x2323, r1	; 0x802323 <__flp>
    3f4e:	10 92 24 23 	sts	0x2324, r1	; 0x802324 <__flp+0x1>
    3f52:	02 c0       	rjmp	.+4      	; 0x3f58 <free+0x104>
    3f54:	12 82       	std	Z+2, r1	; 0x02
    3f56:	13 82       	std	Z+3, r1	; 0x03
    3f58:	a0 93 21 23 	sts	0x2321, r26	; 0x802321 <__brkval>
    3f5c:	b0 93 22 23 	sts	0x2322, r27	; 0x802322 <__brkval+0x1>
    3f60:	df 91       	pop	r29
    3f62:	cf 91       	pop	r28
    3f64:	08 95       	ret

00003f66 <memcpy>:
    3f66:	fb 01       	movw	r30, r22
    3f68:	dc 01       	movw	r26, r24
    3f6a:	02 c0       	rjmp	.+4      	; 0x3f70 <memcpy+0xa>
    3f6c:	01 90       	ld	r0, Z+
    3f6e:	0d 92       	st	X+, r0
    3f70:	41 50       	subi	r20, 0x01	; 1
    3f72:	50 40       	sbci	r21, 0x00	; 0
    3f74:	d8 f7       	brcc	.-10     	; 0x3f6c <memcpy+0x6>
    3f76:	08 95       	ret

00003f78 <snprintf>:
    3f78:	0f 93       	push	r16
    3f7a:	1f 93       	push	r17
    3f7c:	cf 93       	push	r28
    3f7e:	df 93       	push	r29
    3f80:	cd b7       	in	r28, 0x3d	; 61
    3f82:	de b7       	in	r29, 0x3e	; 62
    3f84:	2e 97       	sbiw	r28, 0x0e	; 14
    3f86:	cd bf       	out	0x3d, r28	; 61
    3f88:	de bf       	out	0x3e, r29	; 62
    3f8a:	0e 89       	ldd	r16, Y+22	; 0x16
    3f8c:	1f 89       	ldd	r17, Y+23	; 0x17
    3f8e:	88 8d       	ldd	r24, Y+24	; 0x18
    3f90:	99 8d       	ldd	r25, Y+25	; 0x19
    3f92:	26 e0       	ldi	r18, 0x06	; 6
    3f94:	2c 83       	std	Y+4, r18	; 0x04
    3f96:	09 83       	std	Y+1, r16	; 0x01
    3f98:	1a 83       	std	Y+2, r17	; 0x02
    3f9a:	97 ff       	sbrs	r25, 7
    3f9c:	02 c0       	rjmp	.+4      	; 0x3fa2 <snprintf+0x2a>
    3f9e:	80 e0       	ldi	r24, 0x00	; 0
    3fa0:	90 e8       	ldi	r25, 0x80	; 128
    3fa2:	01 97       	sbiw	r24, 0x01	; 1
    3fa4:	8d 83       	std	Y+5, r24	; 0x05
    3fa6:	9e 83       	std	Y+6, r25	; 0x06
    3fa8:	ae 01       	movw	r20, r28
    3faa:	44 5e       	subi	r20, 0xE4	; 228
    3fac:	5f 4f       	sbci	r21, 0xFF	; 255
    3fae:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3fb0:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3fb2:	ce 01       	movw	r24, r28
    3fb4:	01 96       	adiw	r24, 0x01	; 1
    3fb6:	16 d0       	rcall	.+44     	; 0x3fe4 <vfprintf>
    3fb8:	4d 81       	ldd	r20, Y+5	; 0x05
    3fba:	5e 81       	ldd	r21, Y+6	; 0x06
    3fbc:	57 fd       	sbrc	r21, 7
    3fbe:	0a c0       	rjmp	.+20     	; 0x3fd4 <snprintf+0x5c>
    3fc0:	2f 81       	ldd	r18, Y+7	; 0x07
    3fc2:	38 85       	ldd	r19, Y+8	; 0x08
    3fc4:	42 17       	cp	r20, r18
    3fc6:	53 07       	cpc	r21, r19
    3fc8:	0c f4       	brge	.+2      	; 0x3fcc <snprintf+0x54>
    3fca:	9a 01       	movw	r18, r20
    3fcc:	f8 01       	movw	r30, r16
    3fce:	e2 0f       	add	r30, r18
    3fd0:	f3 1f       	adc	r31, r19
    3fd2:	10 82       	st	Z, r1
    3fd4:	2e 96       	adiw	r28, 0x0e	; 14
    3fd6:	cd bf       	out	0x3d, r28	; 61
    3fd8:	de bf       	out	0x3e, r29	; 62
    3fda:	df 91       	pop	r29
    3fdc:	cf 91       	pop	r28
    3fde:	1f 91       	pop	r17
    3fe0:	0f 91       	pop	r16
    3fe2:	08 95       	ret

00003fe4 <vfprintf>:
    3fe4:	2f 92       	push	r2
    3fe6:	3f 92       	push	r3
    3fe8:	4f 92       	push	r4
    3fea:	5f 92       	push	r5
    3fec:	6f 92       	push	r6
    3fee:	7f 92       	push	r7
    3ff0:	8f 92       	push	r8
    3ff2:	9f 92       	push	r9
    3ff4:	af 92       	push	r10
    3ff6:	bf 92       	push	r11
    3ff8:	cf 92       	push	r12
    3ffa:	df 92       	push	r13
    3ffc:	ef 92       	push	r14
    3ffe:	ff 92       	push	r15
    4000:	0f 93       	push	r16
    4002:	1f 93       	push	r17
    4004:	cf 93       	push	r28
    4006:	df 93       	push	r29
    4008:	cd b7       	in	r28, 0x3d	; 61
    400a:	de b7       	in	r29, 0x3e	; 62
    400c:	2b 97       	sbiw	r28, 0x0b	; 11
    400e:	cd bf       	out	0x3d, r28	; 61
    4010:	de bf       	out	0x3e, r29	; 62
    4012:	6c 01       	movw	r12, r24
    4014:	7b 01       	movw	r14, r22
    4016:	8a 01       	movw	r16, r20
    4018:	fc 01       	movw	r30, r24
    401a:	16 82       	std	Z+6, r1	; 0x06
    401c:	17 82       	std	Z+7, r1	; 0x07
    401e:	83 81       	ldd	r24, Z+3	; 0x03
    4020:	81 ff       	sbrs	r24, 1
    4022:	bf c1       	rjmp	.+894    	; 0x43a2 <vfprintf+0x3be>
    4024:	ce 01       	movw	r24, r28
    4026:	01 96       	adiw	r24, 0x01	; 1
    4028:	3c 01       	movw	r6, r24
    402a:	f6 01       	movw	r30, r12
    402c:	93 81       	ldd	r25, Z+3	; 0x03
    402e:	f7 01       	movw	r30, r14
    4030:	93 fd       	sbrc	r25, 3
    4032:	85 91       	lpm	r24, Z+
    4034:	93 ff       	sbrs	r25, 3
    4036:	81 91       	ld	r24, Z+
    4038:	7f 01       	movw	r14, r30
    403a:	88 23       	and	r24, r24
    403c:	09 f4       	brne	.+2      	; 0x4040 <vfprintf+0x5c>
    403e:	ad c1       	rjmp	.+858    	; 0x439a <vfprintf+0x3b6>
    4040:	85 32       	cpi	r24, 0x25	; 37
    4042:	39 f4       	brne	.+14     	; 0x4052 <vfprintf+0x6e>
    4044:	93 fd       	sbrc	r25, 3
    4046:	85 91       	lpm	r24, Z+
    4048:	93 ff       	sbrs	r25, 3
    404a:	81 91       	ld	r24, Z+
    404c:	7f 01       	movw	r14, r30
    404e:	85 32       	cpi	r24, 0x25	; 37
    4050:	21 f4       	brne	.+8      	; 0x405a <vfprintf+0x76>
    4052:	b6 01       	movw	r22, r12
    4054:	90 e0       	ldi	r25, 0x00	; 0
    4056:	d3 d1       	rcall	.+934    	; 0x43fe <fputc>
    4058:	e8 cf       	rjmp	.-48     	; 0x402a <vfprintf+0x46>
    405a:	91 2c       	mov	r9, r1
    405c:	21 2c       	mov	r2, r1
    405e:	31 2c       	mov	r3, r1
    4060:	ff e1       	ldi	r31, 0x1F	; 31
    4062:	f3 15       	cp	r31, r3
    4064:	d8 f0       	brcs	.+54     	; 0x409c <vfprintf+0xb8>
    4066:	8b 32       	cpi	r24, 0x2B	; 43
    4068:	79 f0       	breq	.+30     	; 0x4088 <vfprintf+0xa4>
    406a:	38 f4       	brcc	.+14     	; 0x407a <vfprintf+0x96>
    406c:	80 32       	cpi	r24, 0x20	; 32
    406e:	79 f0       	breq	.+30     	; 0x408e <vfprintf+0xaa>
    4070:	83 32       	cpi	r24, 0x23	; 35
    4072:	a1 f4       	brne	.+40     	; 0x409c <vfprintf+0xb8>
    4074:	23 2d       	mov	r18, r3
    4076:	20 61       	ori	r18, 0x10	; 16
    4078:	1d c0       	rjmp	.+58     	; 0x40b4 <vfprintf+0xd0>
    407a:	8d 32       	cpi	r24, 0x2D	; 45
    407c:	61 f0       	breq	.+24     	; 0x4096 <vfprintf+0xb2>
    407e:	80 33       	cpi	r24, 0x30	; 48
    4080:	69 f4       	brne	.+26     	; 0x409c <vfprintf+0xb8>
    4082:	23 2d       	mov	r18, r3
    4084:	21 60       	ori	r18, 0x01	; 1
    4086:	16 c0       	rjmp	.+44     	; 0x40b4 <vfprintf+0xd0>
    4088:	83 2d       	mov	r24, r3
    408a:	82 60       	ori	r24, 0x02	; 2
    408c:	38 2e       	mov	r3, r24
    408e:	e3 2d       	mov	r30, r3
    4090:	e4 60       	ori	r30, 0x04	; 4
    4092:	3e 2e       	mov	r3, r30
    4094:	2a c0       	rjmp	.+84     	; 0x40ea <vfprintf+0x106>
    4096:	f3 2d       	mov	r31, r3
    4098:	f8 60       	ori	r31, 0x08	; 8
    409a:	1d c0       	rjmp	.+58     	; 0x40d6 <vfprintf+0xf2>
    409c:	37 fc       	sbrc	r3, 7
    409e:	2d c0       	rjmp	.+90     	; 0x40fa <vfprintf+0x116>
    40a0:	20 ed       	ldi	r18, 0xD0	; 208
    40a2:	28 0f       	add	r18, r24
    40a4:	2a 30       	cpi	r18, 0x0A	; 10
    40a6:	40 f0       	brcs	.+16     	; 0x40b8 <vfprintf+0xd4>
    40a8:	8e 32       	cpi	r24, 0x2E	; 46
    40aa:	b9 f4       	brne	.+46     	; 0x40da <vfprintf+0xf6>
    40ac:	36 fc       	sbrc	r3, 6
    40ae:	75 c1       	rjmp	.+746    	; 0x439a <vfprintf+0x3b6>
    40b0:	23 2d       	mov	r18, r3
    40b2:	20 64       	ori	r18, 0x40	; 64
    40b4:	32 2e       	mov	r3, r18
    40b6:	19 c0       	rjmp	.+50     	; 0x40ea <vfprintf+0x106>
    40b8:	36 fe       	sbrs	r3, 6
    40ba:	06 c0       	rjmp	.+12     	; 0x40c8 <vfprintf+0xe4>
    40bc:	8a e0       	ldi	r24, 0x0A	; 10
    40be:	98 9e       	mul	r9, r24
    40c0:	20 0d       	add	r18, r0
    40c2:	11 24       	eor	r1, r1
    40c4:	92 2e       	mov	r9, r18
    40c6:	11 c0       	rjmp	.+34     	; 0x40ea <vfprintf+0x106>
    40c8:	ea e0       	ldi	r30, 0x0A	; 10
    40ca:	2e 9e       	mul	r2, r30
    40cc:	20 0d       	add	r18, r0
    40ce:	11 24       	eor	r1, r1
    40d0:	22 2e       	mov	r2, r18
    40d2:	f3 2d       	mov	r31, r3
    40d4:	f0 62       	ori	r31, 0x20	; 32
    40d6:	3f 2e       	mov	r3, r31
    40d8:	08 c0       	rjmp	.+16     	; 0x40ea <vfprintf+0x106>
    40da:	8c 36       	cpi	r24, 0x6C	; 108
    40dc:	21 f4       	brne	.+8      	; 0x40e6 <vfprintf+0x102>
    40de:	83 2d       	mov	r24, r3
    40e0:	80 68       	ori	r24, 0x80	; 128
    40e2:	38 2e       	mov	r3, r24
    40e4:	02 c0       	rjmp	.+4      	; 0x40ea <vfprintf+0x106>
    40e6:	88 36       	cpi	r24, 0x68	; 104
    40e8:	41 f4       	brne	.+16     	; 0x40fa <vfprintf+0x116>
    40ea:	f7 01       	movw	r30, r14
    40ec:	93 fd       	sbrc	r25, 3
    40ee:	85 91       	lpm	r24, Z+
    40f0:	93 ff       	sbrs	r25, 3
    40f2:	81 91       	ld	r24, Z+
    40f4:	7f 01       	movw	r14, r30
    40f6:	81 11       	cpse	r24, r1
    40f8:	b3 cf       	rjmp	.-154    	; 0x4060 <vfprintf+0x7c>
    40fa:	98 2f       	mov	r25, r24
    40fc:	9f 7d       	andi	r25, 0xDF	; 223
    40fe:	95 54       	subi	r25, 0x45	; 69
    4100:	93 30       	cpi	r25, 0x03	; 3
    4102:	28 f4       	brcc	.+10     	; 0x410e <vfprintf+0x12a>
    4104:	0c 5f       	subi	r16, 0xFC	; 252
    4106:	1f 4f       	sbci	r17, 0xFF	; 255
    4108:	9f e3       	ldi	r25, 0x3F	; 63
    410a:	99 83       	std	Y+1, r25	; 0x01
    410c:	0d c0       	rjmp	.+26     	; 0x4128 <vfprintf+0x144>
    410e:	83 36       	cpi	r24, 0x63	; 99
    4110:	31 f0       	breq	.+12     	; 0x411e <vfprintf+0x13a>
    4112:	83 37       	cpi	r24, 0x73	; 115
    4114:	71 f0       	breq	.+28     	; 0x4132 <vfprintf+0x14e>
    4116:	83 35       	cpi	r24, 0x53	; 83
    4118:	09 f0       	breq	.+2      	; 0x411c <vfprintf+0x138>
    411a:	55 c0       	rjmp	.+170    	; 0x41c6 <vfprintf+0x1e2>
    411c:	20 c0       	rjmp	.+64     	; 0x415e <vfprintf+0x17a>
    411e:	f8 01       	movw	r30, r16
    4120:	80 81       	ld	r24, Z
    4122:	89 83       	std	Y+1, r24	; 0x01
    4124:	0e 5f       	subi	r16, 0xFE	; 254
    4126:	1f 4f       	sbci	r17, 0xFF	; 255
    4128:	88 24       	eor	r8, r8
    412a:	83 94       	inc	r8
    412c:	91 2c       	mov	r9, r1
    412e:	53 01       	movw	r10, r6
    4130:	12 c0       	rjmp	.+36     	; 0x4156 <vfprintf+0x172>
    4132:	28 01       	movw	r4, r16
    4134:	f2 e0       	ldi	r31, 0x02	; 2
    4136:	4f 0e       	add	r4, r31
    4138:	51 1c       	adc	r5, r1
    413a:	f8 01       	movw	r30, r16
    413c:	a0 80       	ld	r10, Z
    413e:	b1 80       	ldd	r11, Z+1	; 0x01
    4140:	36 fe       	sbrs	r3, 6
    4142:	03 c0       	rjmp	.+6      	; 0x414a <vfprintf+0x166>
    4144:	69 2d       	mov	r22, r9
    4146:	70 e0       	ldi	r23, 0x00	; 0
    4148:	02 c0       	rjmp	.+4      	; 0x414e <vfprintf+0x16a>
    414a:	6f ef       	ldi	r22, 0xFF	; 255
    414c:	7f ef       	ldi	r23, 0xFF	; 255
    414e:	c5 01       	movw	r24, r10
    4150:	4b d1       	rcall	.+662    	; 0x43e8 <strnlen>
    4152:	4c 01       	movw	r8, r24
    4154:	82 01       	movw	r16, r4
    4156:	f3 2d       	mov	r31, r3
    4158:	ff 77       	andi	r31, 0x7F	; 127
    415a:	3f 2e       	mov	r3, r31
    415c:	15 c0       	rjmp	.+42     	; 0x4188 <vfprintf+0x1a4>
    415e:	28 01       	movw	r4, r16
    4160:	22 e0       	ldi	r18, 0x02	; 2
    4162:	42 0e       	add	r4, r18
    4164:	51 1c       	adc	r5, r1
    4166:	f8 01       	movw	r30, r16
    4168:	a0 80       	ld	r10, Z
    416a:	b1 80       	ldd	r11, Z+1	; 0x01
    416c:	36 fe       	sbrs	r3, 6
    416e:	03 c0       	rjmp	.+6      	; 0x4176 <vfprintf+0x192>
    4170:	69 2d       	mov	r22, r9
    4172:	70 e0       	ldi	r23, 0x00	; 0
    4174:	02 c0       	rjmp	.+4      	; 0x417a <vfprintf+0x196>
    4176:	6f ef       	ldi	r22, 0xFF	; 255
    4178:	7f ef       	ldi	r23, 0xFF	; 255
    417a:	c5 01       	movw	r24, r10
    417c:	2a d1       	rcall	.+596    	; 0x43d2 <strnlen_P>
    417e:	4c 01       	movw	r8, r24
    4180:	f3 2d       	mov	r31, r3
    4182:	f0 68       	ori	r31, 0x80	; 128
    4184:	3f 2e       	mov	r3, r31
    4186:	82 01       	movw	r16, r4
    4188:	33 fc       	sbrc	r3, 3
    418a:	19 c0       	rjmp	.+50     	; 0x41be <vfprintf+0x1da>
    418c:	82 2d       	mov	r24, r2
    418e:	90 e0       	ldi	r25, 0x00	; 0
    4190:	88 16       	cp	r8, r24
    4192:	99 06       	cpc	r9, r25
    4194:	a0 f4       	brcc	.+40     	; 0x41be <vfprintf+0x1da>
    4196:	b6 01       	movw	r22, r12
    4198:	80 e2       	ldi	r24, 0x20	; 32
    419a:	90 e0       	ldi	r25, 0x00	; 0
    419c:	30 d1       	rcall	.+608    	; 0x43fe <fputc>
    419e:	2a 94       	dec	r2
    41a0:	f5 cf       	rjmp	.-22     	; 0x418c <vfprintf+0x1a8>
    41a2:	f5 01       	movw	r30, r10
    41a4:	37 fc       	sbrc	r3, 7
    41a6:	85 91       	lpm	r24, Z+
    41a8:	37 fe       	sbrs	r3, 7
    41aa:	81 91       	ld	r24, Z+
    41ac:	5f 01       	movw	r10, r30
    41ae:	b6 01       	movw	r22, r12
    41b0:	90 e0       	ldi	r25, 0x00	; 0
    41b2:	25 d1       	rcall	.+586    	; 0x43fe <fputc>
    41b4:	21 10       	cpse	r2, r1
    41b6:	2a 94       	dec	r2
    41b8:	21 e0       	ldi	r18, 0x01	; 1
    41ba:	82 1a       	sub	r8, r18
    41bc:	91 08       	sbc	r9, r1
    41be:	81 14       	cp	r8, r1
    41c0:	91 04       	cpc	r9, r1
    41c2:	79 f7       	brne	.-34     	; 0x41a2 <vfprintf+0x1be>
    41c4:	e1 c0       	rjmp	.+450    	; 0x4388 <vfprintf+0x3a4>
    41c6:	84 36       	cpi	r24, 0x64	; 100
    41c8:	11 f0       	breq	.+4      	; 0x41ce <vfprintf+0x1ea>
    41ca:	89 36       	cpi	r24, 0x69	; 105
    41cc:	39 f5       	brne	.+78     	; 0x421c <vfprintf+0x238>
    41ce:	f8 01       	movw	r30, r16
    41d0:	37 fe       	sbrs	r3, 7
    41d2:	07 c0       	rjmp	.+14     	; 0x41e2 <vfprintf+0x1fe>
    41d4:	60 81       	ld	r22, Z
    41d6:	71 81       	ldd	r23, Z+1	; 0x01
    41d8:	82 81       	ldd	r24, Z+2	; 0x02
    41da:	93 81       	ldd	r25, Z+3	; 0x03
    41dc:	0c 5f       	subi	r16, 0xFC	; 252
    41de:	1f 4f       	sbci	r17, 0xFF	; 255
    41e0:	08 c0       	rjmp	.+16     	; 0x41f2 <vfprintf+0x20e>
    41e2:	60 81       	ld	r22, Z
    41e4:	71 81       	ldd	r23, Z+1	; 0x01
    41e6:	07 2e       	mov	r0, r23
    41e8:	00 0c       	add	r0, r0
    41ea:	88 0b       	sbc	r24, r24
    41ec:	99 0b       	sbc	r25, r25
    41ee:	0e 5f       	subi	r16, 0xFE	; 254
    41f0:	1f 4f       	sbci	r17, 0xFF	; 255
    41f2:	f3 2d       	mov	r31, r3
    41f4:	ff 76       	andi	r31, 0x6F	; 111
    41f6:	3f 2e       	mov	r3, r31
    41f8:	97 ff       	sbrs	r25, 7
    41fa:	09 c0       	rjmp	.+18     	; 0x420e <vfprintf+0x22a>
    41fc:	90 95       	com	r25
    41fe:	80 95       	com	r24
    4200:	70 95       	com	r23
    4202:	61 95       	neg	r22
    4204:	7f 4f       	sbci	r23, 0xFF	; 255
    4206:	8f 4f       	sbci	r24, 0xFF	; 255
    4208:	9f 4f       	sbci	r25, 0xFF	; 255
    420a:	f0 68       	ori	r31, 0x80	; 128
    420c:	3f 2e       	mov	r3, r31
    420e:	2a e0       	ldi	r18, 0x0A	; 10
    4210:	30 e0       	ldi	r19, 0x00	; 0
    4212:	a3 01       	movw	r20, r6
    4214:	30 d1       	rcall	.+608    	; 0x4476 <__ultoa_invert>
    4216:	88 2e       	mov	r8, r24
    4218:	86 18       	sub	r8, r6
    421a:	44 c0       	rjmp	.+136    	; 0x42a4 <vfprintf+0x2c0>
    421c:	85 37       	cpi	r24, 0x75	; 117
    421e:	31 f4       	brne	.+12     	; 0x422c <vfprintf+0x248>
    4220:	23 2d       	mov	r18, r3
    4222:	2f 7e       	andi	r18, 0xEF	; 239
    4224:	b2 2e       	mov	r11, r18
    4226:	2a e0       	ldi	r18, 0x0A	; 10
    4228:	30 e0       	ldi	r19, 0x00	; 0
    422a:	25 c0       	rjmp	.+74     	; 0x4276 <vfprintf+0x292>
    422c:	93 2d       	mov	r25, r3
    422e:	99 7f       	andi	r25, 0xF9	; 249
    4230:	b9 2e       	mov	r11, r25
    4232:	8f 36       	cpi	r24, 0x6F	; 111
    4234:	c1 f0       	breq	.+48     	; 0x4266 <vfprintf+0x282>
    4236:	18 f4       	brcc	.+6      	; 0x423e <vfprintf+0x25a>
    4238:	88 35       	cpi	r24, 0x58	; 88
    423a:	79 f0       	breq	.+30     	; 0x425a <vfprintf+0x276>
    423c:	ae c0       	rjmp	.+348    	; 0x439a <vfprintf+0x3b6>
    423e:	80 37       	cpi	r24, 0x70	; 112
    4240:	19 f0       	breq	.+6      	; 0x4248 <vfprintf+0x264>
    4242:	88 37       	cpi	r24, 0x78	; 120
    4244:	21 f0       	breq	.+8      	; 0x424e <vfprintf+0x26a>
    4246:	a9 c0       	rjmp	.+338    	; 0x439a <vfprintf+0x3b6>
    4248:	e9 2f       	mov	r30, r25
    424a:	e0 61       	ori	r30, 0x10	; 16
    424c:	be 2e       	mov	r11, r30
    424e:	b4 fe       	sbrs	r11, 4
    4250:	0d c0       	rjmp	.+26     	; 0x426c <vfprintf+0x288>
    4252:	fb 2d       	mov	r31, r11
    4254:	f4 60       	ori	r31, 0x04	; 4
    4256:	bf 2e       	mov	r11, r31
    4258:	09 c0       	rjmp	.+18     	; 0x426c <vfprintf+0x288>
    425a:	34 fe       	sbrs	r3, 4
    425c:	0a c0       	rjmp	.+20     	; 0x4272 <vfprintf+0x28e>
    425e:	29 2f       	mov	r18, r25
    4260:	26 60       	ori	r18, 0x06	; 6
    4262:	b2 2e       	mov	r11, r18
    4264:	06 c0       	rjmp	.+12     	; 0x4272 <vfprintf+0x28e>
    4266:	28 e0       	ldi	r18, 0x08	; 8
    4268:	30 e0       	ldi	r19, 0x00	; 0
    426a:	05 c0       	rjmp	.+10     	; 0x4276 <vfprintf+0x292>
    426c:	20 e1       	ldi	r18, 0x10	; 16
    426e:	30 e0       	ldi	r19, 0x00	; 0
    4270:	02 c0       	rjmp	.+4      	; 0x4276 <vfprintf+0x292>
    4272:	20 e1       	ldi	r18, 0x10	; 16
    4274:	32 e0       	ldi	r19, 0x02	; 2
    4276:	f8 01       	movw	r30, r16
    4278:	b7 fe       	sbrs	r11, 7
    427a:	07 c0       	rjmp	.+14     	; 0x428a <vfprintf+0x2a6>
    427c:	60 81       	ld	r22, Z
    427e:	71 81       	ldd	r23, Z+1	; 0x01
    4280:	82 81       	ldd	r24, Z+2	; 0x02
    4282:	93 81       	ldd	r25, Z+3	; 0x03
    4284:	0c 5f       	subi	r16, 0xFC	; 252
    4286:	1f 4f       	sbci	r17, 0xFF	; 255
    4288:	06 c0       	rjmp	.+12     	; 0x4296 <vfprintf+0x2b2>
    428a:	60 81       	ld	r22, Z
    428c:	71 81       	ldd	r23, Z+1	; 0x01
    428e:	80 e0       	ldi	r24, 0x00	; 0
    4290:	90 e0       	ldi	r25, 0x00	; 0
    4292:	0e 5f       	subi	r16, 0xFE	; 254
    4294:	1f 4f       	sbci	r17, 0xFF	; 255
    4296:	a3 01       	movw	r20, r6
    4298:	ee d0       	rcall	.+476    	; 0x4476 <__ultoa_invert>
    429a:	88 2e       	mov	r8, r24
    429c:	86 18       	sub	r8, r6
    429e:	fb 2d       	mov	r31, r11
    42a0:	ff 77       	andi	r31, 0x7F	; 127
    42a2:	3f 2e       	mov	r3, r31
    42a4:	36 fe       	sbrs	r3, 6
    42a6:	0d c0       	rjmp	.+26     	; 0x42c2 <vfprintf+0x2de>
    42a8:	23 2d       	mov	r18, r3
    42aa:	2e 7f       	andi	r18, 0xFE	; 254
    42ac:	a2 2e       	mov	r10, r18
    42ae:	89 14       	cp	r8, r9
    42b0:	58 f4       	brcc	.+22     	; 0x42c8 <vfprintf+0x2e4>
    42b2:	34 fe       	sbrs	r3, 4
    42b4:	0b c0       	rjmp	.+22     	; 0x42cc <vfprintf+0x2e8>
    42b6:	32 fc       	sbrc	r3, 2
    42b8:	09 c0       	rjmp	.+18     	; 0x42cc <vfprintf+0x2e8>
    42ba:	83 2d       	mov	r24, r3
    42bc:	8e 7e       	andi	r24, 0xEE	; 238
    42be:	a8 2e       	mov	r10, r24
    42c0:	05 c0       	rjmp	.+10     	; 0x42cc <vfprintf+0x2e8>
    42c2:	b8 2c       	mov	r11, r8
    42c4:	a3 2c       	mov	r10, r3
    42c6:	03 c0       	rjmp	.+6      	; 0x42ce <vfprintf+0x2ea>
    42c8:	b8 2c       	mov	r11, r8
    42ca:	01 c0       	rjmp	.+2      	; 0x42ce <vfprintf+0x2ea>
    42cc:	b9 2c       	mov	r11, r9
    42ce:	a4 fe       	sbrs	r10, 4
    42d0:	0f c0       	rjmp	.+30     	; 0x42f0 <vfprintf+0x30c>
    42d2:	fe 01       	movw	r30, r28
    42d4:	e8 0d       	add	r30, r8
    42d6:	f1 1d       	adc	r31, r1
    42d8:	80 81       	ld	r24, Z
    42da:	80 33       	cpi	r24, 0x30	; 48
    42dc:	21 f4       	brne	.+8      	; 0x42e6 <vfprintf+0x302>
    42de:	9a 2d       	mov	r25, r10
    42e0:	99 7e       	andi	r25, 0xE9	; 233
    42e2:	a9 2e       	mov	r10, r25
    42e4:	09 c0       	rjmp	.+18     	; 0x42f8 <vfprintf+0x314>
    42e6:	a2 fe       	sbrs	r10, 2
    42e8:	06 c0       	rjmp	.+12     	; 0x42f6 <vfprintf+0x312>
    42ea:	b3 94       	inc	r11
    42ec:	b3 94       	inc	r11
    42ee:	04 c0       	rjmp	.+8      	; 0x42f8 <vfprintf+0x314>
    42f0:	8a 2d       	mov	r24, r10
    42f2:	86 78       	andi	r24, 0x86	; 134
    42f4:	09 f0       	breq	.+2      	; 0x42f8 <vfprintf+0x314>
    42f6:	b3 94       	inc	r11
    42f8:	a3 fc       	sbrc	r10, 3
    42fa:	10 c0       	rjmp	.+32     	; 0x431c <vfprintf+0x338>
    42fc:	a0 fe       	sbrs	r10, 0
    42fe:	06 c0       	rjmp	.+12     	; 0x430c <vfprintf+0x328>
    4300:	b2 14       	cp	r11, r2
    4302:	80 f4       	brcc	.+32     	; 0x4324 <vfprintf+0x340>
    4304:	28 0c       	add	r2, r8
    4306:	92 2c       	mov	r9, r2
    4308:	9b 18       	sub	r9, r11
    430a:	0d c0       	rjmp	.+26     	; 0x4326 <vfprintf+0x342>
    430c:	b2 14       	cp	r11, r2
    430e:	58 f4       	brcc	.+22     	; 0x4326 <vfprintf+0x342>
    4310:	b6 01       	movw	r22, r12
    4312:	80 e2       	ldi	r24, 0x20	; 32
    4314:	90 e0       	ldi	r25, 0x00	; 0
    4316:	73 d0       	rcall	.+230    	; 0x43fe <fputc>
    4318:	b3 94       	inc	r11
    431a:	f8 cf       	rjmp	.-16     	; 0x430c <vfprintf+0x328>
    431c:	b2 14       	cp	r11, r2
    431e:	18 f4       	brcc	.+6      	; 0x4326 <vfprintf+0x342>
    4320:	2b 18       	sub	r2, r11
    4322:	02 c0       	rjmp	.+4      	; 0x4328 <vfprintf+0x344>
    4324:	98 2c       	mov	r9, r8
    4326:	21 2c       	mov	r2, r1
    4328:	a4 fe       	sbrs	r10, 4
    432a:	0f c0       	rjmp	.+30     	; 0x434a <vfprintf+0x366>
    432c:	b6 01       	movw	r22, r12
    432e:	80 e3       	ldi	r24, 0x30	; 48
    4330:	90 e0       	ldi	r25, 0x00	; 0
    4332:	65 d0       	rcall	.+202    	; 0x43fe <fputc>
    4334:	a2 fe       	sbrs	r10, 2
    4336:	16 c0       	rjmp	.+44     	; 0x4364 <vfprintf+0x380>
    4338:	a1 fc       	sbrc	r10, 1
    433a:	03 c0       	rjmp	.+6      	; 0x4342 <vfprintf+0x35e>
    433c:	88 e7       	ldi	r24, 0x78	; 120
    433e:	90 e0       	ldi	r25, 0x00	; 0
    4340:	02 c0       	rjmp	.+4      	; 0x4346 <vfprintf+0x362>
    4342:	88 e5       	ldi	r24, 0x58	; 88
    4344:	90 e0       	ldi	r25, 0x00	; 0
    4346:	b6 01       	movw	r22, r12
    4348:	0c c0       	rjmp	.+24     	; 0x4362 <vfprintf+0x37e>
    434a:	8a 2d       	mov	r24, r10
    434c:	86 78       	andi	r24, 0x86	; 134
    434e:	51 f0       	breq	.+20     	; 0x4364 <vfprintf+0x380>
    4350:	a1 fe       	sbrs	r10, 1
    4352:	02 c0       	rjmp	.+4      	; 0x4358 <vfprintf+0x374>
    4354:	8b e2       	ldi	r24, 0x2B	; 43
    4356:	01 c0       	rjmp	.+2      	; 0x435a <vfprintf+0x376>
    4358:	80 e2       	ldi	r24, 0x20	; 32
    435a:	a7 fc       	sbrc	r10, 7
    435c:	8d e2       	ldi	r24, 0x2D	; 45
    435e:	b6 01       	movw	r22, r12
    4360:	90 e0       	ldi	r25, 0x00	; 0
    4362:	4d d0       	rcall	.+154    	; 0x43fe <fputc>
    4364:	89 14       	cp	r8, r9
    4366:	30 f4       	brcc	.+12     	; 0x4374 <vfprintf+0x390>
    4368:	b6 01       	movw	r22, r12
    436a:	80 e3       	ldi	r24, 0x30	; 48
    436c:	90 e0       	ldi	r25, 0x00	; 0
    436e:	47 d0       	rcall	.+142    	; 0x43fe <fputc>
    4370:	9a 94       	dec	r9
    4372:	f8 cf       	rjmp	.-16     	; 0x4364 <vfprintf+0x380>
    4374:	8a 94       	dec	r8
    4376:	f3 01       	movw	r30, r6
    4378:	e8 0d       	add	r30, r8
    437a:	f1 1d       	adc	r31, r1
    437c:	80 81       	ld	r24, Z
    437e:	b6 01       	movw	r22, r12
    4380:	90 e0       	ldi	r25, 0x00	; 0
    4382:	3d d0       	rcall	.+122    	; 0x43fe <fputc>
    4384:	81 10       	cpse	r8, r1
    4386:	f6 cf       	rjmp	.-20     	; 0x4374 <vfprintf+0x390>
    4388:	22 20       	and	r2, r2
    438a:	09 f4       	brne	.+2      	; 0x438e <vfprintf+0x3aa>
    438c:	4e ce       	rjmp	.-868    	; 0x402a <vfprintf+0x46>
    438e:	b6 01       	movw	r22, r12
    4390:	80 e2       	ldi	r24, 0x20	; 32
    4392:	90 e0       	ldi	r25, 0x00	; 0
    4394:	34 d0       	rcall	.+104    	; 0x43fe <fputc>
    4396:	2a 94       	dec	r2
    4398:	f7 cf       	rjmp	.-18     	; 0x4388 <vfprintf+0x3a4>
    439a:	f6 01       	movw	r30, r12
    439c:	86 81       	ldd	r24, Z+6	; 0x06
    439e:	97 81       	ldd	r25, Z+7	; 0x07
    43a0:	02 c0       	rjmp	.+4      	; 0x43a6 <vfprintf+0x3c2>
    43a2:	8f ef       	ldi	r24, 0xFF	; 255
    43a4:	9f ef       	ldi	r25, 0xFF	; 255
    43a6:	2b 96       	adiw	r28, 0x0b	; 11
    43a8:	cd bf       	out	0x3d, r28	; 61
    43aa:	de bf       	out	0x3e, r29	; 62
    43ac:	df 91       	pop	r29
    43ae:	cf 91       	pop	r28
    43b0:	1f 91       	pop	r17
    43b2:	0f 91       	pop	r16
    43b4:	ff 90       	pop	r15
    43b6:	ef 90       	pop	r14
    43b8:	df 90       	pop	r13
    43ba:	cf 90       	pop	r12
    43bc:	bf 90       	pop	r11
    43be:	af 90       	pop	r10
    43c0:	9f 90       	pop	r9
    43c2:	8f 90       	pop	r8
    43c4:	7f 90       	pop	r7
    43c6:	6f 90       	pop	r6
    43c8:	5f 90       	pop	r5
    43ca:	4f 90       	pop	r4
    43cc:	3f 90       	pop	r3
    43ce:	2f 90       	pop	r2
    43d0:	08 95       	ret

000043d2 <strnlen_P>:
    43d2:	fc 01       	movw	r30, r24
    43d4:	05 90       	lpm	r0, Z+
    43d6:	61 50       	subi	r22, 0x01	; 1
    43d8:	70 40       	sbci	r23, 0x00	; 0
    43da:	01 10       	cpse	r0, r1
    43dc:	d8 f7       	brcc	.-10     	; 0x43d4 <strnlen_P+0x2>
    43de:	80 95       	com	r24
    43e0:	90 95       	com	r25
    43e2:	8e 0f       	add	r24, r30
    43e4:	9f 1f       	adc	r25, r31
    43e6:	08 95       	ret

000043e8 <strnlen>:
    43e8:	fc 01       	movw	r30, r24
    43ea:	61 50       	subi	r22, 0x01	; 1
    43ec:	70 40       	sbci	r23, 0x00	; 0
    43ee:	01 90       	ld	r0, Z+
    43f0:	01 10       	cpse	r0, r1
    43f2:	d8 f7       	brcc	.-10     	; 0x43ea <strnlen+0x2>
    43f4:	80 95       	com	r24
    43f6:	90 95       	com	r25
    43f8:	8e 0f       	add	r24, r30
    43fa:	9f 1f       	adc	r25, r31
    43fc:	08 95       	ret

000043fe <fputc>:
    43fe:	0f 93       	push	r16
    4400:	1f 93       	push	r17
    4402:	cf 93       	push	r28
    4404:	df 93       	push	r29
    4406:	fb 01       	movw	r30, r22
    4408:	23 81       	ldd	r18, Z+3	; 0x03
    440a:	21 fd       	sbrc	r18, 1
    440c:	03 c0       	rjmp	.+6      	; 0x4414 <fputc+0x16>
    440e:	8f ef       	ldi	r24, 0xFF	; 255
    4410:	9f ef       	ldi	r25, 0xFF	; 255
    4412:	2c c0       	rjmp	.+88     	; 0x446c <fputc+0x6e>
    4414:	22 ff       	sbrs	r18, 2
    4416:	16 c0       	rjmp	.+44     	; 0x4444 <fputc+0x46>
    4418:	46 81       	ldd	r20, Z+6	; 0x06
    441a:	57 81       	ldd	r21, Z+7	; 0x07
    441c:	24 81       	ldd	r18, Z+4	; 0x04
    441e:	35 81       	ldd	r19, Z+5	; 0x05
    4420:	42 17       	cp	r20, r18
    4422:	53 07       	cpc	r21, r19
    4424:	44 f4       	brge	.+16     	; 0x4436 <fputc+0x38>
    4426:	a0 81       	ld	r26, Z
    4428:	b1 81       	ldd	r27, Z+1	; 0x01
    442a:	9d 01       	movw	r18, r26
    442c:	2f 5f       	subi	r18, 0xFF	; 255
    442e:	3f 4f       	sbci	r19, 0xFF	; 255
    4430:	20 83       	st	Z, r18
    4432:	31 83       	std	Z+1, r19	; 0x01
    4434:	8c 93       	st	X, r24
    4436:	26 81       	ldd	r18, Z+6	; 0x06
    4438:	37 81       	ldd	r19, Z+7	; 0x07
    443a:	2f 5f       	subi	r18, 0xFF	; 255
    443c:	3f 4f       	sbci	r19, 0xFF	; 255
    443e:	26 83       	std	Z+6, r18	; 0x06
    4440:	37 83       	std	Z+7, r19	; 0x07
    4442:	14 c0       	rjmp	.+40     	; 0x446c <fputc+0x6e>
    4444:	8b 01       	movw	r16, r22
    4446:	ec 01       	movw	r28, r24
    4448:	fb 01       	movw	r30, r22
    444a:	00 84       	ldd	r0, Z+8	; 0x08
    444c:	f1 85       	ldd	r31, Z+9	; 0x09
    444e:	e0 2d       	mov	r30, r0
    4450:	19 95       	eicall
    4452:	89 2b       	or	r24, r25
    4454:	e1 f6       	brne	.-72     	; 0x440e <fputc+0x10>
    4456:	d8 01       	movw	r26, r16
    4458:	16 96       	adiw	r26, 0x06	; 6
    445a:	8d 91       	ld	r24, X+
    445c:	9c 91       	ld	r25, X
    445e:	17 97       	sbiw	r26, 0x07	; 7
    4460:	01 96       	adiw	r24, 0x01	; 1
    4462:	16 96       	adiw	r26, 0x06	; 6
    4464:	8d 93       	st	X+, r24
    4466:	9c 93       	st	X, r25
    4468:	17 97       	sbiw	r26, 0x07	; 7
    446a:	ce 01       	movw	r24, r28
    446c:	df 91       	pop	r29
    446e:	cf 91       	pop	r28
    4470:	1f 91       	pop	r17
    4472:	0f 91       	pop	r16
    4474:	08 95       	ret

00004476 <__ultoa_invert>:
    4476:	fa 01       	movw	r30, r20
    4478:	aa 27       	eor	r26, r26
    447a:	28 30       	cpi	r18, 0x08	; 8
    447c:	51 f1       	breq	.+84     	; 0x44d2 <__ultoa_invert+0x5c>
    447e:	20 31       	cpi	r18, 0x10	; 16
    4480:	81 f1       	breq	.+96     	; 0x44e2 <__ultoa_invert+0x6c>
    4482:	e8 94       	clt
    4484:	6f 93       	push	r22
    4486:	6e 7f       	andi	r22, 0xFE	; 254
    4488:	6e 5f       	subi	r22, 0xFE	; 254
    448a:	7f 4f       	sbci	r23, 0xFF	; 255
    448c:	8f 4f       	sbci	r24, 0xFF	; 255
    448e:	9f 4f       	sbci	r25, 0xFF	; 255
    4490:	af 4f       	sbci	r26, 0xFF	; 255
    4492:	b1 e0       	ldi	r27, 0x01	; 1
    4494:	3e d0       	rcall	.+124    	; 0x4512 <__ultoa_invert+0x9c>
    4496:	b4 e0       	ldi	r27, 0x04	; 4
    4498:	3c d0       	rcall	.+120    	; 0x4512 <__ultoa_invert+0x9c>
    449a:	67 0f       	add	r22, r23
    449c:	78 1f       	adc	r23, r24
    449e:	89 1f       	adc	r24, r25
    44a0:	9a 1f       	adc	r25, r26
    44a2:	a1 1d       	adc	r26, r1
    44a4:	68 0f       	add	r22, r24
    44a6:	79 1f       	adc	r23, r25
    44a8:	8a 1f       	adc	r24, r26
    44aa:	91 1d       	adc	r25, r1
    44ac:	a1 1d       	adc	r26, r1
    44ae:	6a 0f       	add	r22, r26
    44b0:	71 1d       	adc	r23, r1
    44b2:	81 1d       	adc	r24, r1
    44b4:	91 1d       	adc	r25, r1
    44b6:	a1 1d       	adc	r26, r1
    44b8:	20 d0       	rcall	.+64     	; 0x44fa <__ultoa_invert+0x84>
    44ba:	09 f4       	brne	.+2      	; 0x44be <__ultoa_invert+0x48>
    44bc:	68 94       	set
    44be:	3f 91       	pop	r19
    44c0:	2a e0       	ldi	r18, 0x0A	; 10
    44c2:	26 9f       	mul	r18, r22
    44c4:	11 24       	eor	r1, r1
    44c6:	30 19       	sub	r19, r0
    44c8:	30 5d       	subi	r19, 0xD0	; 208
    44ca:	31 93       	st	Z+, r19
    44cc:	de f6       	brtc	.-74     	; 0x4484 <__ultoa_invert+0xe>
    44ce:	cf 01       	movw	r24, r30
    44d0:	08 95       	ret
    44d2:	46 2f       	mov	r20, r22
    44d4:	47 70       	andi	r20, 0x07	; 7
    44d6:	40 5d       	subi	r20, 0xD0	; 208
    44d8:	41 93       	st	Z+, r20
    44da:	b3 e0       	ldi	r27, 0x03	; 3
    44dc:	0f d0       	rcall	.+30     	; 0x44fc <__ultoa_invert+0x86>
    44de:	c9 f7       	brne	.-14     	; 0x44d2 <__ultoa_invert+0x5c>
    44e0:	f6 cf       	rjmp	.-20     	; 0x44ce <__ultoa_invert+0x58>
    44e2:	46 2f       	mov	r20, r22
    44e4:	4f 70       	andi	r20, 0x0F	; 15
    44e6:	40 5d       	subi	r20, 0xD0	; 208
    44e8:	4a 33       	cpi	r20, 0x3A	; 58
    44ea:	18 f0       	brcs	.+6      	; 0x44f2 <__ultoa_invert+0x7c>
    44ec:	49 5d       	subi	r20, 0xD9	; 217
    44ee:	31 fd       	sbrc	r19, 1
    44f0:	40 52       	subi	r20, 0x20	; 32
    44f2:	41 93       	st	Z+, r20
    44f4:	02 d0       	rcall	.+4      	; 0x44fa <__ultoa_invert+0x84>
    44f6:	a9 f7       	brne	.-22     	; 0x44e2 <__ultoa_invert+0x6c>
    44f8:	ea cf       	rjmp	.-44     	; 0x44ce <__ultoa_invert+0x58>
    44fa:	b4 e0       	ldi	r27, 0x04	; 4
    44fc:	a6 95       	lsr	r26
    44fe:	97 95       	ror	r25
    4500:	87 95       	ror	r24
    4502:	77 95       	ror	r23
    4504:	67 95       	ror	r22
    4506:	ba 95       	dec	r27
    4508:	c9 f7       	brne	.-14     	; 0x44fc <__ultoa_invert+0x86>
    450a:	00 97       	sbiw	r24, 0x00	; 0
    450c:	61 05       	cpc	r22, r1
    450e:	71 05       	cpc	r23, r1
    4510:	08 95       	ret
    4512:	9b 01       	movw	r18, r22
    4514:	ac 01       	movw	r20, r24
    4516:	0a 2e       	mov	r0, r26
    4518:	06 94       	lsr	r0
    451a:	57 95       	ror	r21
    451c:	47 95       	ror	r20
    451e:	37 95       	ror	r19
    4520:	27 95       	ror	r18
    4522:	ba 95       	dec	r27
    4524:	c9 f7       	brne	.-14     	; 0x4518 <__ultoa_invert+0xa2>
    4526:	62 0f       	add	r22, r18
    4528:	73 1f       	adc	r23, r19
    452a:	84 1f       	adc	r24, r20
    452c:	95 1f       	adc	r25, r21
    452e:	a0 1d       	adc	r26, r0
    4530:	08 95       	ret

00004532 <_exit>:
    4532:	f8 94       	cli

00004534 <__stop_program>:
    4534:	ff cf       	rjmp	.-2      	; 0x4534 <__stop_program>
